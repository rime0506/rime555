// ==================== ğŸ“± ç§»åŠ¨ç«¯å®æ—¶æ§åˆ¶å° (MobileConsole) ====================
// æ‹¦æˆª console è¾“å‡ºï¼Œåœ¨é¡µé¢ä¸Šæ˜¾ç¤ºæµ®åŠ¨æ§åˆ¶å°ï¼Œæ–¹ä¾¿æ‰‹æœºç«¯è°ƒè¯•
(function() {
    const MC_MAX_LOGS = 500;
    const mcLogs = [];
    let mcVisible = false;
    let mcFilter = 'all'; // all | log | warn | error | info
    let mcSearchText = '';
    let mcPaused = false;
    let mcPanel = null;
    let mcFab = null;
    let mcUnread = 0;

    // ä¿å­˜åŸå§‹ console æ–¹æ³•
    const _origLog = console.log.bind(console);
    const _origWarn = console.warn.bind(console);
    const _origError = console.error.bind(console);
    const _origInfo = console.info.bind(console);
    const _origDebug = console.debug.bind(console);

    function formatArg(arg) {
        if (arg === null) return 'null';
        if (arg === undefined) return 'undefined';
        if (typeof arg === 'string') return arg;
        if (arg instanceof Error) return `${arg.name}: ${arg.message}\n${arg.stack || ''}`;
        if (typeof arg === 'object') {
            try { return JSON.stringify(arg, null, 2); }
            catch (e) { return String(arg); }
        }
        return String(arg);
    }

    function addMcLog(level, args) {
        const entry = {
            id: Date.now() + '_' + Math.random().toString(36).slice(2, 6),
            time: new Date(),
            level: level,
            text: Array.from(args).map(formatArg).join(' ')
        };
        mcLogs.push(entry);
        if (mcLogs.length > MC_MAX_LOGS) mcLogs.splice(0, mcLogs.length - MC_MAX_LOGS);

        if (!mcVisible) {
            mcUnread++;
            updateFabBadge();
        }
        if (mcVisible && !mcPaused) {
            appendLogEntry(entry);
            autoScrollLogs();
        }
    }

    // æ‹¦æˆª console
    console.log = function() { _origLog.apply(console, arguments); addMcLog('log', arguments); };
    console.warn = function() { _origWarn.apply(console, arguments); addMcLog('warn', arguments); };
    console.error = function() { _origError.apply(console, arguments); addMcLog('error', arguments); };
    console.info = function() { _origInfo.apply(console, arguments); addMcLog('info', arguments); };
    console.debug = function() { _origDebug.apply(console, arguments); addMcLog('debug', arguments); };

    // æ•è·å…¨å±€é”™è¯¯
    window.addEventListener('error', function(e) {
        addMcLog('error', [`[GlobalError] ${e.message}`, `at ${e.filename}:${e.lineno}:${e.colno}`]);
    });
    window.addEventListener('unhandledrejection', function(e) {
        addMcLog('error', [`[UnhandledPromise] ${e.reason}`]);
    });

    const MC_COLORS = {
        log: { bg: 'transparent', color: '#333', border: 'transparent' },
        info: { bg: '#e8f4fd', color: '#0d6efd', border: '#b6d4fe' },
        warn: { bg: '#fff8e1', color: '#b8860b', border: '#ffe082' },
        error: { bg: '#fdecea', color: '#d32f2f', border: '#f5c6cb' },
        debug: { bg: '#f3e5f5', color: '#7b1fa2', border: '#ce93d8' }
    };

    function getTimeStr(d) {
        return d.toTimeString().split(' ')[0] + '.' + String(d.getMilliseconds()).padStart(3, '0');
    }

    function escHtml(s) {
        return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    function createLogEntryHtml(entry) {
        const c = MC_COLORS[entry.level] || MC_COLORS.log;
        const levelIcon = { log: 'ğŸ“', info: 'â„¹ï¸', warn: 'âš ï¸', error: 'âŒ', debug: 'ğŸ”' }[entry.level] || 'ğŸ“';
        const textEsc = escHtml(entry.text);
        // å¦‚æœæ–‡æœ¬è¶…è¿‡200å­—ç¬¦ï¼Œæˆªæ–­å¹¶æ”¯æŒå±•å¼€
        const isLong = entry.text.length > 200;
        const shortText = isLong ? escHtml(entry.text.substring(0, 200)) + '...' : textEsc;

        return `<div class="mc-log-entry" data-level="${entry.level}" data-id="${entry.id}" style="padding:6px 10px;border-bottom:1px solid #f0f0f0;font-size:12px;line-height:1.5;background:${c.bg};border-left:3px solid ${c.border};word-break:break-all;">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:2px;">
                <span style="color:${c.color};font-weight:600;font-size:11px;">${levelIcon} ${entry.level.toUpperCase()}</span>
                <span style="color:#aaa;font-size:10px;font-family:monospace;">${getTimeStr(entry.time)}</span>
            </div>
            <div class="mc-log-text" style="color:${c.color};font-family:'SF Mono',Menlo,Consolas,monospace;font-size:11.5px;white-space:pre-wrap;${isLong ? 'cursor:pointer;' : ''}" ${isLong ? `onclick="this.textContent=this.getAttribute('data-full')" data-full="${textEsc.replace(/"/g, '&quot;')}"` : ''}>${shortText}</div>
        </div>`;
    }

    function appendLogEntry(entry) {
        if (!mcPanel) return;
        const container = mcPanel.querySelector('#mc-log-container');
        if (!container) return;
        // è¿‡æ»¤æ£€æŸ¥
        if (mcFilter !== 'all' && entry.level !== mcFilter) return;
        if (mcSearchText && !entry.text.toLowerCase().includes(mcSearchText.toLowerCase())) return;
        container.insertAdjacentHTML('beforeend', createLogEntryHtml(entry));
    }

    function autoScrollLogs() {
        if (!mcPanel) return;
        const container = mcPanel.querySelector('#mc-log-container');
        if (container) {
            requestAnimationFrame(() => { container.scrollTop = container.scrollHeight; });
        }
    }

    function renderAllLogs() {
        if (!mcPanel) return;
        const container = mcPanel.querySelector('#mc-log-container');
        if (!container) return;
        const filtered = mcLogs.filter(e => {
            if (mcFilter !== 'all' && e.level !== mcFilter) return false;
            if (mcSearchText && !e.text.toLowerCase().includes(mcSearchText.toLowerCase())) return false;
            return true;
        });
        container.innerHTML = filtered.map(createLogEntryHtml).join('');
        autoScrollLogs();
    }

    function updateFilterBtns() {
        if (!mcPanel) return;
        mcPanel.querySelectorAll('.mc-filter-btn').forEach(btn => {
            const f = btn.getAttribute('data-filter');
            btn.style.background = f === mcFilter ? '#ffb3d1' : '#f5f5f5';
            btn.style.color = f === mcFilter ? '#fff' : '#666';
            btn.style.fontWeight = f === mcFilter ? '600' : '400';
        });
    }

    function updateFabBadge() {
        if (!mcFab) return;
        const badge = mcFab.querySelector('.mc-badge');
        if (badge) {
            if (mcUnread > 0) {
                badge.textContent = mcUnread > 99 ? '99+' : mcUnread;
                badge.style.display = 'flex';
            } else {
                badge.style.display = 'none';
            }
        }
    }

    function getLogCounts() {
        const counts = { all: mcLogs.length, log: 0, info: 0, warn: 0, error: 0 };
        mcLogs.forEach(e => { if (counts[e.level] !== undefined) counts[e.level]++; });
        return counts;
    }

    function updateCountBadges() {
        if (!mcPanel) return;
        const counts = getLogCounts();
        mcPanel.querySelectorAll('.mc-filter-btn').forEach(btn => {
            const f = btn.getAttribute('data-filter');
            const countSpan = btn.querySelector('.mc-count');
            if (countSpan && counts[f] !== undefined) {
                countSpan.textContent = counts[f];
            }
        });
    }

    function createPanel() {
        if (mcPanel) { mcPanel.remove(); mcPanel = null; }

        mcPanel = document.createElement('div');
        mcPanel.id = 'mc-console-panel';
        mcPanel.style.cssText = `position:fixed;bottom:0;left:0;right:0;height:55vh;background:#fff;z-index:99999;display:flex;flex-direction:column;box-shadow:0 -4px 20px rgba(0,0,0,0.15);border-top-left-radius:16px;border-top-right-radius:16px;transition:transform 0.3s cubic-bezier(0.4,0,0.2,1);font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;`;

        // å¤´éƒ¨æ‹–æ‹½æ¡ + å·¥å…·æ 
        mcPanel.innerHTML = `
            <div style="display:flex;align-items:center;justify-content:center;padding:8px 0 4px;cursor:grab;" id="mc-drag-handle">
                <div style="width:40px;height:4px;background:#ddd;border-radius:2px;"></div>
            </div>
            <div style="display:flex;align-items:center;justify-content:space-between;padding:4px 12px 8px;">
                <div style="font-size:14px;font-weight:600;color:#333;">ğŸ“± æ§åˆ¶å°</div>
                <div style="display:flex;gap:8px;align-items:center;">
                    <button id="mc-btn-pause" onclick="window._mcTogglePause()" style="padding:4px 10px;background:#f5f5f5;border:1px solid #e0e0e0;border-radius:6px;font-size:11px;cursor:pointer;color:#666;">â¸ æš‚åœ</button>
                    <button onclick="window._mcClearLogs()" style="padding:4px 10px;background:#fff0f0;border:1px solid #fcc;border-radius:6px;font-size:11px;cursor:pointer;color:#d32f2f;">ğŸ—‘ æ¸…ç©º</button>
                    <button onclick="window._mcExportLogs()" style="padding:4px 10px;background:#f0f4ff;border:1px solid #d8e2f8;border-radius:6px;font-size:11px;cursor:pointer;color:#5b7ddb;">ğŸ“¤ å¯¼å‡º</button>
                    <button onclick="window._mcHideConsole()" style="width:28px;height:28px;background:#f5f5f5;border:1px solid #e0e0e0;border-radius:50%;font-size:14px;cursor:pointer;display:flex;align-items:center;justify-content:center;padding:0;line-height:1;">âœ•</button>
                </div>
            </div>
            <div style="display:flex;gap:4px;padding:0 12px 8px;flex-wrap:wrap;align-items:center;">
                <button class="mc-filter-btn" data-filter="all" onclick="window._mcSetFilter('all')" style="padding:3px 8px;border-radius:12px;border:none;font-size:11px;cursor:pointer;">å…¨éƒ¨ <span class="mc-count">0</span></button>
                <button class="mc-filter-btn" data-filter="log" onclick="window._mcSetFilter('log')" style="padding:3px 8px;border-radius:12px;border:none;font-size:11px;cursor:pointer;">Log <span class="mc-count">0</span></button>
                <button class="mc-filter-btn" data-filter="info" onclick="window._mcSetFilter('info')" style="padding:3px 8px;border-radius:12px;border:none;font-size:11px;cursor:pointer;">Info <span class="mc-count">0</span></button>
                <button class="mc-filter-btn" data-filter="warn" onclick="window._mcSetFilter('warn')" style="padding:3px 8px;border-radius:12px;border:none;font-size:11px;cursor:pointer;">Warn <span class="mc-count">0</span></button>
                <button class="mc-filter-btn" data-filter="error" onclick="window._mcSetFilter('error')" style="padding:3px 8px;border-radius:12px;border:none;font-size:11px;cursor:pointer;">Error <span class="mc-count">0</span></button>
                <div style="flex:1;min-width:80px;margin-left:4px;">
                    <input type="text" id="mc-search-input" placeholder="ğŸ” æœç´¢æ—¥å¿—..." oninput="window._mcOnSearch(this.value)" style="width:100%;padding:4px 8px;border:1px solid #e0e0e0;border-radius:8px;font-size:11px;outline:none;box-sizing:border-box;" />
                </div>
            </div>
            <div id="mc-log-container" style="flex:1;overflow-y:auto;overflow-x:hidden;-webkit-overflow-scrolling:touch;background:#fafafa;"></div>
            <div id="mc-status-bar" style="padding:4px 12px;font-size:10px;color:#aaa;border-top:1px solid #f0f0f0;display:flex;justify-content:space-between;background:#fff;">
                <span id="mc-status-count">å…± 0 æ¡</span>
                <span id="mc-status-mem"></span>
            </div>
        `;

        document.body.appendChild(mcPanel);
        updateFilterBtns();
        updateCountBadges();
        renderAllLogs();
        updateStatusBar();

        // æ‹–æ‹½è°ƒæ•´é«˜åº¦
        let startY = 0, startH = 0, isDragging = false;
        const handle = mcPanel.querySelector('#mc-drag-handle');
        handle.addEventListener('touchstart', (e) => {
            isDragging = true;
            startY = e.touches[0].clientY;
            startH = mcPanel.offsetHeight;
            e.preventDefault();
        }, { passive: false });
        document.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            const dy = startY - e.touches[0].clientY;
            const newH = Math.max(150, Math.min(window.innerHeight * 0.9, startH + dy));
            mcPanel.style.height = newH + 'px';
        }, { passive: true });
        document.addEventListener('touchend', () => { isDragging = false; });
    }

    function updateStatusBar() {
        if (!mcPanel) return;
        const countEl = mcPanel.querySelector('#mc-status-count');
        const memEl = mcPanel.querySelector('#mc-status-mem');
        if (countEl) countEl.textContent = `å…± ${mcLogs.length} æ¡`;
        if (memEl && performance && performance.memory) {
            const used = (performance.memory.usedJSHeapSize / 1048576).toFixed(1);
            const total = (performance.memory.totalJSHeapSize / 1048576).toFixed(1);
            memEl.textContent = `å†…å­˜: ${used}/${total}MB`;
        }
    }

    function createFab() {
        if (mcFab) return;
        mcFab = document.createElement('div');
        mcFab.id = 'mc-fab';
        mcFab.style.cssText = `position:fixed;bottom:80px;right:12px;width:44px;height:44px;background:linear-gradient(135deg,#ffb3d1,#ff8fbc);border-radius:50%;z-index:99998;display:none;align-items:center;justify-content:center;cursor:pointer;box-shadow:0 3px 12px rgba(255,143,188,0.4);font-size:20px;user-select:none;-webkit-user-select:none;touch-action:none;transition:transform 0.2s;`;
        mcFab.innerHTML = `<span style="pointer-events:none;">ğŸ–¥</span><span class="mc-badge" style="display:none;position:absolute;top:-4px;right:-4px;min-width:18px;height:18px;background:#ff3b30;color:#fff;border-radius:9px;font-size:10px;font-weight:600;align-items:center;justify-content:center;padding:0 4px;pointer-events:none;"></span>`;
        mcFab.onclick = () => { window._mcShowConsole(); };
        document.body.appendChild(mcFab);

        // æ‹–æ‹½ç§»åŠ¨FAB
        let fabDragging = false, fabStartX = 0, fabStartY = 0, fabOrigX = 0, fabOrigY = 0, fabMoved = false;
        mcFab.addEventListener('touchstart', (e) => {
            fabDragging = true; fabMoved = false;
            fabStartX = e.touches[0].clientX; fabStartY = e.touches[0].clientY;
            const rect = mcFab.getBoundingClientRect();
            fabOrigX = rect.left; fabOrigY = rect.top;
            mcFab.style.transition = 'none';
            e.preventDefault();
        }, { passive: false });
        document.addEventListener('touchmove', (e) => {
            if (!fabDragging) return;
            const dx = e.touches[0].clientX - fabStartX;
            const dy = e.touches[0].clientY - fabStartY;
            if (Math.abs(dx) > 5 || Math.abs(dy) > 5) fabMoved = true;
            const nx = Math.max(0, Math.min(window.innerWidth - 44, fabOrigX + dx));
            const ny = Math.max(0, Math.min(window.innerHeight - 44, fabOrigY + dy));
            mcFab.style.left = nx + 'px'; mcFab.style.top = ny + 'px';
            mcFab.style.right = 'auto'; mcFab.style.bottom = 'auto';
        }, { passive: true });
        document.addEventListener('touchend', () => {
            if (!fabDragging) return;
            fabDragging = false;
            mcFab.style.transition = 'transform 0.2s';
            if (fabMoved) {
                // å¸é™„åˆ°æœ€è¿‘çš„è¾¹
                const rect = mcFab.getBoundingClientRect();
                const centerX = rect.left + 22;
                if (centerX < window.innerWidth / 2) {
                    mcFab.style.left = '12px'; mcFab.style.right = 'auto';
                } else {
                    mcFab.style.left = 'auto'; mcFab.style.right = '12px';
                }
            } else {
                // æ²¡æœ‰æ‹–æ‹½ç§»åŠ¨ â†’ è§†ä¸ºç‚¹å‡»ï¼Œæ‰“å¼€æ§åˆ¶å°
                window._mcShowConsole();
            }
        });
    }

    // å…¨å±€æ–¹æ³•æš´éœ²
    window._mcShowConsole = function() {
        mcVisible = true; mcUnread = 0; updateFabBadge();
        if (mcFab) mcFab.style.display = 'none';
        createPanel();
    };
    window._mcHideConsole = function() {
        mcVisible = false;
        if (mcPanel) { mcPanel.remove(); mcPanel = null; }
        if (mcFab && localStorage.getItem('mc_console_enabled') === 'true') {
            mcFab.style.display = 'flex';
        }
    };
    window._mcTogglePause = function() {
        mcPaused = !mcPaused;
        const btn = mcPanel && mcPanel.querySelector('#mc-btn-pause');
        if (btn) {
            btn.textContent = mcPaused ? 'â–¶ ç»§ç»­' : 'â¸ æš‚åœ';
            btn.style.background = mcPaused ? '#e8f5e9' : '#f5f5f5';
            btn.style.color = mcPaused ? '#2e7d32' : '#666';
        }
    };
    window._mcSetFilter = function(f) {
        mcFilter = f;
        updateFilterBtns();
        renderAllLogs();
    };
    window._mcOnSearch = function(val) {
        mcSearchText = val;
        renderAllLogs();
    };
    window._mcClearLogs = function() {
        mcLogs.length = 0;
        renderAllLogs();
        updateCountBadges();
        updateStatusBar();
    };
    window._mcExportLogs = function() {
        const text = mcLogs.map(e => `[${getTimeStr(e.time)}] [${e.level.toUpperCase()}] ${e.text}`).join('\n');
        const blob = new Blob([text], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = `console_logs_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.txt`;
        a.click();
        URL.revokeObjectURL(url);
    };

    // å¯ç”¨/ç¦ç”¨æ§åˆ¶å°
    window._mcEnableConsole = function(enabled) {
        localStorage.setItem('mc_console_enabled', enabled ? 'true' : 'false');
        if (enabled) {
            createFab();
            if (mcFab) mcFab.style.display = 'flex';
        } else {
            if (mcFab) mcFab.style.display = 'none';
            if (mcPanel) { mcPanel.remove(); mcPanel = null; }
            mcVisible = false;
        }
    };

    // é¡µé¢åŠ è½½åæ£€æŸ¥æ˜¯å¦å·²å¯ç”¨
    function mcInit() {
        createFab();
        if (localStorage.getItem('mc_console_enabled') === 'true') {
            if (mcFab) mcFab.style.display = 'flex';
        }
    }
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', mcInit);
    } else {
        mcInit();
    }

    // å®šæ—¶æ›´æ–°çŠ¶æ€æ å’Œè®¡æ•°
    setInterval(() => {
        if (mcVisible) { updateCountBadges(); updateStatusBar(); }
    }, 3000);

})();
// ==================== END ç§»åŠ¨ç«¯å®æ—¶æ§åˆ¶å° ====================

// å…¨å±€å¼‚å¸¸å…œåº•ï¼šé˜²æ­¢æœªæ•è·çš„é”™è¯¯å¯¼è‡´é¡µé¢å‡æ­»
window.addEventListener('error', function(e) {
    console.error('[GlobalError]', e.message, e.filename, e.lineno);
});
window.addEventListener('unhandledrejection', function(e) {
    console.error('[UnhandledPromise]', e.reason);
    e.preventDefault(); // é˜»æ­¢æµè§ˆå™¨é»˜è®¤å¤„ç†ï¼Œé¿å…é¡µé¢å¡ä½
});

// åŠ¨æ€ç”Ÿæˆ Manifest ä»¥æ”¯æŒå•æ–‡ä»¶ PWA
const manifest = {
    "name": "èŠ½èŠ½æœº",
    "short_name": "èŠ½èŠ½æœº",
    "start_url": ".",
    "display": "fullscreen",
    "background_color": "#ffffff",
    "theme_color": "#ffffff",
    "orientation": "portrait",
    "icons": [
        {
            "src": "https://img.heliar.top/file/1770541813634_æ— æ ‡é¢˜434_20260208170943.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "https://img.heliar.top/file/1770541813634_æ— æ ‡é¢˜434_20260208170943.png",
            "sizes": "512x512",
            "type": "image/png"
        }
    ]
};
const stringManifest = JSON.stringify(manifest);
const blob = new Blob([stringManifest], {type: 'application/manifest+json'});
const manifestURL = URL.createObjectURL(blob);
// ç­‰å¾… DOM åŠ è½½å®Œæˆåå†è®¾ç½® manifest
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {
        const manifestLink = document.querySelector('#manifest-link');
        if (manifestLink) {
            manifestLink.setAttribute('href', manifestURL);
        }
    });
} else {
    const manifestLink = document.querySelector('#manifest-link');
    if (manifestLink) {
        manifestLink.setAttribute('href', manifestURL);
    }
}

// ========== PWA æ¨¡å¼æ£€æµ‹ ==========
const _isPWAStandalone = window.matchMedia('(display-mode: standalone)').matches
    || window.navigator.standalone === true;

// åœ¨ PWA æ¨¡å¼ä¸‹ç»™ body æ·»åŠ  classï¼Œè®© CSS ç”¨ fixed + inset å®Œå…¨æ’‘æ»¡
if (_isPWAStandalone) {
    document.body.classList.add('standalone-mode');
}

// ç§»åŠ¨ç«¯è™šæ‹Ÿé”®ç›˜é€‚é…
// åŸç†ï¼šé”®ç›˜å¼¹èµ·æ—¶ visualViewport.height ç¼©å°
// ç›´æ¥æŠŠ chat-window é«˜åº¦è®¾ä¸ºå¯è§†è§†å£é«˜åº¦ï¼Œè®©æ•´ä¸ªåº•æ ï¼ˆè¾“å…¥æ¡†+æŒ‰é’®ï¼‰éƒ½åœ¨é”®ç›˜ä¸Šæ–¹
// PWAå…¨å±æ¨¡å¼ç‰¹åˆ«å¤„ç†ï¼šå»æ‰å®‰å…¨åŒºåŸŸpadding + å¯¹é½visualViewportåç§»
// ğŸ”§ å…¼å®¹æ€§ï¼šéƒ¨åˆ† Android æ‰‹æœºé”®ç›˜å¼¹å‡ºæ—¶ window.innerHeight ä¹Ÿä¼šç¼©å°ï¼Œ
//    å¯¼è‡´ kbHeight è®¡ç®—ä¸º 0ï¼Œéœ€è¦ç”¨åˆå§‹é«˜åº¦åšå¤‡ç”¨æ£€æµ‹
let _kbLastHeight = 0;
let _kbLastTop = 0;
let _kbRecalibrateTimer = null;
const _kbInitialInnerHeight = window.innerHeight; // ğŸ”§ è®°å½•åˆå§‹å±å¹•é«˜åº¦ï¼Œç”¨äºå…¼å®¹ Android

function applyKeyboardLayout() {
    const vp = window.visualViewport;
    if (!vp) return;
    
    // ğŸ”§ ä¸»æ£€æµ‹ï¼švisualViewport é«˜åº¦ vs window.innerHeight
    let kbHeight = Math.max(0, Math.round(window.innerHeight - vp.height));
    const vpTop = Math.round(vp.offsetTop || 0);
    
    // ğŸ”§ å¤‡ç”¨æ£€æµ‹ï¼šéƒ¨åˆ† Android æ‰‹æœº window.innerHeight ä¹Ÿè·Ÿç€é”®ç›˜ç¼©å°
    // æ­¤æ—¶ç”¨åˆå§‹è®°å½•çš„é«˜åº¦æ¥æ£€æµ‹
    if (kbHeight < 50) {
        const fallbackKb = Math.max(0, Math.round(_kbInitialInnerHeight - vp.height));
        if (fallbackKb > 50) {
            kbHeight = fallbackKb;
        }
    }
    
    // é«˜åº¦å’Œåç§»éƒ½æ²¡å˜æ—¶è·³è¿‡
    if (kbHeight === _kbLastHeight && vpTop === _kbLastTop) return;
    _kbLastHeight = kbHeight;
    _kbLastTop = vpTop;
    
    const isKeyboardUp = kbHeight > 50;
    
    // ğŸ”§ é˜²æ­¢æµè§ˆå™¨å› è¾“å…¥æ¡†èšç„¦è€Œæ»šåŠ¨æ•´ä¸ªé¡µé¢ï¼ˆéƒ¨åˆ† Android ä¼šå‡ºç°ï¼‰
    if (isKeyboardUp) {
        window.scrollTo(0, 0);
        document.documentElement.scrollTop = 0;
        document.body.scrollTop = 0;
    }
    
    // é”®ç›˜å¼¹èµ·æ—¶ï¼šæŠŠèŠå¤©çª—å£é«˜åº¦ç¼©åˆ°å¯è§†è§†å£é«˜åº¦ï¼Œæ•´ä¸ªåº•æ éƒ½åœ¨é”®ç›˜ä¸Šæ–¹
    // é”®ç›˜æ”¶èµ·æ—¶ï¼šæ¢å¤åŸå§‹çŠ¶æ€ï¼ˆCSS bottom:0 è‡ªåŠ¨æ’‘æ»¡ï¼‰
    // ğŸ”§ ä¿®å¤ï¼šstandalone æ¨¡å¼ CSS æœ‰ height:auto!importantï¼Œæ™®é€šå†…è”æ ·å¼ä¼šè¢«è¦†ç›–
    //    å¿…é¡»ç”¨ setProperty(..., 'important') æ‰èƒ½æ­£ç¡®è®¾ç½®é«˜åº¦
    const targets = document.querySelectorAll('.chat-window');
    targets.forEach(el => {
        if (el.style.display !== 'none' && el.style.display !== '') {
            if (isKeyboardUp) {
                // å¯¹é½å¯è§†è§†å£ï¼ˆPWAå…¨å±æ¨¡å¼ä¸‹å¯èƒ½æœ‰åç§»ï¼‰
                el.style.top = vpTop + 'px';
                el.style.setProperty('height', vp.height + 'px', 'important'); // ğŸ”§ ç”¨ !important è¦†ç›– standalone çš„ height:auto!important
                el.style.bottom = 'auto'; // é”®ç›˜å¼¹èµ·æ—¶ç”¨ height æ§åˆ¶ï¼Œç¦ç”¨ bottom
                // æ ‡è®°é”®ç›˜çŠ¶æ€ï¼ŒCSS ä¼šå»æ‰å®‰å…¨åŒºåŸŸ padding
                el.classList.add('keyboard-up');
            } else {
                // ğŸ”§ æ¢å¤åŸå§‹çŠ¶æ€ï¼šæ¸…é™¤æ‰€æœ‰å†…è”æ ·å¼ï¼Œè®© CSS çš„ top:0+bottom:0 è‡ªåŠ¨æ’‘æ»¡
                el.style.top = '';
                el.style.removeProperty('height'); // ğŸ”§ ç”¨ removeProperty ç¡®ä¿æ¸…é™¤ !important å£°æ˜
                el.style.bottom = '';
                el.classList.remove('keyboard-up');
            }
        }
    });
    
    // é”®ç›˜å¼¹èµ·æ—¶è‡ªåŠ¨æ»šåŠ¨èŠå¤©åˆ°åº•éƒ¨
    if (isKeyboardUp) {
        requestAnimationFrame(() => {
            // çº¿ä¸ŠèŠå¤©
            const chatBody = document.getElementById('chat-body');
            if (chatBody && chatBody.offsetParent !== null) {
                chatBody.scrollTop = chatBody.scrollHeight;
            }
            // çº¿ä¸‹èŠå¤©
            const offlineBody = document.getElementById('offline-chat-body');
            if (offlineBody && offlineBody.offsetParent !== null) {
                offlineBody.scrollTop = offlineBody.scrollHeight;
            }
        });
    }
}

function handleKeyboardResize() {
    // ğŸ”§ é˜²æ­¢é¡µé¢å› é”®ç›˜å¼¹å‡ºäº§ç”Ÿæ»šåŠ¨åç§»
    window.scrollTo(0, 0);
    
    // ç«‹å³æ‰§è¡Œä¸€æ¬¡
    applyKeyboardLayout();
    
    // iOS é”®ç›˜å¼¹èµ·æœ‰ ~300ms åŠ¨ç”»ï¼Œresize äº‹ä»¶å¯èƒ½åœ¨åŠ¨ç”»å¼€å§‹æ—¶å°±è§¦å‘
    // æ­¤æ—¶ vp.height è¿˜ä¸æ˜¯æœ€ç»ˆå€¼ï¼Œéœ€è¦å»¶è¿Ÿå†æ ¡å‡†
    clearTimeout(_kbRecalibrateTimer);
    _kbRecalibrateTimer = setTimeout(() => {
        _kbLastHeight = -1; // å¼ºåˆ¶é‡æ–°è®¡ç®—
        applyKeyboardLayout();
    }, 350);
}

// ç›‘å¬ visualViewport resize + scrollï¼ˆé”®ç›˜å¼¹èµ·/æ”¶èµ·/è§†å£æ»šåŠ¨éƒ½ä¼šè§¦å‘ï¼‰
if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', handleKeyboardResize);
    window.visualViewport.addEventListener('scroll', applyKeyboardLayout);
}

// ğŸ”§ ç›‘å¬ window resize äº‹ä»¶ä½œä¸ºå¤‡ç”¨ï¼ˆéƒ¨åˆ† Android æµè§ˆå™¨ä¸è§¦å‘ visualViewport äº‹ä»¶ï¼‰
window.addEventListener('resize', function() {
    // åªåœ¨æœ‰èŠå¤©çª—å£æ˜¾ç¤ºæ—¶å¤„ç†
    const anyVisible = document.querySelector('.chat-window[style*="display: flex"], .chat-window[style*="display:flex"]');
    if (anyVisible) {
        handleKeyboardResize();
    }
});

// åˆå§‹åŒ–DEXieæ•°æ®åº“
const db = new Dexie('DesktopDB');
// ç‰ˆæœ¬å‡çº§ï¼šå¢åŠ  lorebooks è¡¨
db.version(1).stores({
    dexiData: 'key, value'
});
db.version(2).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name' // æ–°å¢ä¸–ç•Œä¹¦è¡¨ï¼šidè‡ªå¢ï¼Œnameç´¢å¼•
});
db.version(3).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type' // æ–°å¢è§’è‰²è¡¨ï¼štype ç”¨äºåŒºåˆ† Char/NPC/User
});
db.version(4).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name'
});
db.version(5).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId' // æ–°å¢æœ‹å‹åœˆè¡¨ (ownerUserId ç”¨äºè´¦å·éš”ç¦»)
});
db.version(6).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId',
    friend_requests: '++id, fromCharId, toAccountId, status, time' // æ–°å¢å¥½å‹ç”³è¯·è¡¨
});
// ç‰ˆæœ¬71ï¼šå…¼å®¹å·²å­˜åœ¨çš„é«˜ç‰ˆæœ¬æ•°æ®åº“
db.version(71).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId',
    friend_requests: '++id, fromCharId, toAccountId, status, time'
});
// ç‰ˆæœ¬72ï¼šæ·»åŠ ç¾¤èŠè¡¨
db.version(72).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId',
    friend_requests: '++id, fromCharId, toAccountId, status, time',
    group_chats: '++id, name, ownerAccountId, created_at' // ç¾¤èŠè¡¨ï¼šidè‡ªå¢ï¼Œåç§°ï¼Œåˆ›å»ºè€…è´¦å·IDï¼Œåˆ›å»ºæ—¶é—´
});
// ç‰ˆæœ¬73ï¼šæ·»åŠ ç”µè¯è®°å½•å’ŒçŸ­ä¿¡è®°å½•è¡¨ï¼ˆä»localStorageè¿ç§»åˆ°IndexedDBï¼‰
db.version(73).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId',
    friend_requests: '++id, fromCharId, toAccountId, status, time',
    group_chats: '++id, name, ownerAccountId, created_at',
    phone_recents: '++id, accountId, charId, time, type', // ç”µè¯è®°å½•ï¼šaccountIdè´¦å·éš”ç¦»ï¼ŒcharIdè§’è‰²IDï¼Œtimeæ—¶é—´ï¼Œtypeç±»å‹(missed/incoming/outgoing)
    sms_messages: '++id, accountId, charId, time, read'   // çŸ­ä¿¡è®°å½•ï¼šaccountIdè´¦å·éš”ç¦»ï¼ŒcharIdè§’è‰²IDï¼Œtimeæ—¶é—´ï¼Œreadæ˜¯å¦å·²è¯»
});
// ç‰ˆæœ¬74ï¼šæ·»åŠ èŠå¤©æ€»ç»“è¡¨ï¼ˆç”¨äºAIè‡ªåŠ¨æ€»ç»“åŠŸèƒ½ï¼‰
db.version(74).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId',
    friend_requests: '++id, fromCharId, toAccountId, status, time',
    group_chats: '++id, name, ownerAccountId, created_at',
    phone_recents: '++id, accountId, charId, time, type',
    sms_messages: '++id, accountId, charId, time, read',
    chat_summaries: '++id, accountId, chatType, chatId, time' // èŠå¤©æ€»ç»“è¡¨ï¼šaccountIdè´¦å·éš”ç¦»ï¼ŒchatType(private/group)ï¼ŒchatIdè§’è‰²/ç¾¤èŠIDï¼Œtimeæ€»ç»“æ—¶é—´
});

// ç‰ˆæœ¬75ï¼šæ·»åŠ å¤´åƒåº“è¡¨
db.version(75).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId',
    friend_requests: '++id, fromCharId, toAccountId, status, time',
    group_chats: '++id, name, ownerAccountId, created_at',
    phone_recents: '++id, accountId, charId, time, type',
    sms_messages: '++id, accountId, charId, time, read',
    chat_summaries: '++id, accountId, chatType, chatId, time',
    avatar_library: '++id, category, time' // å¤´åƒåº“è¡¨ï¼šcategoryä¸ºåˆ†ç±»åï¼Œtimeæ·»åŠ æ—¶é—´
});

// ç‰ˆæœ¬76ï¼šæ·»åŠ å¤´åƒåˆ†ç±»è¡¨
db.version(76).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId',
    friend_requests: '++id, fromCharId, toAccountId, status, time',
    group_chats: '++id, name, ownerAccountId, created_at',
    phone_recents: '++id, accountId, charId, time, type',
    sms_messages: '++id, accountId, charId, time, read',
    chat_summaries: '++id, accountId, chatType, chatId, time',
    avatar_library: '++id, category, time',
    avatar_categories: '++id, name, order, time'
});

// ç‰ˆæœ¬77ï¼šå¤´åƒåº“å¢åŠ tagå­—æ®µï¼Œå­åˆ†ç±»å¢åŠ parentCategoryå­—æ®µ
db.version(77).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId',
    friend_requests: '++id, fromCharId, toAccountId, status, time',
    group_chats: '++id, name, ownerAccountId, created_at',
    phone_recents: '++id, accountId, charId, time, type',
    sms_messages: '++id, accountId, charId, time, read',
    chat_summaries: '++id, accountId, chatType, chatId, time',
    avatar_library: '++id, category, tag, time', // category=single/couple, tag=å­åˆ†ç±»å
    avatar_categories: '++id, name, parentCategory, order, time' // å­åˆ†ç±»æ ‡ç­¾ï¼šparentCategory=single/couple
});

// ç‰ˆæœ¬78ï¼šä¿®å¤chat_summariesè¡¨çš„å¤åˆç´¢å¼•
db.version(78).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId',
    friend_requests: '++id, fromCharId, toAccountId, status, time',
    group_chats: '++id, name, ownerAccountId, created_at',
    phone_recents: '++id, accountId, charId, time, type',
    sms_messages: '++id, accountId, charId, time, read',
    chat_summaries: '++id, [accountId+chatType+chatId], accountId, chatType, chatId, time', // æ·»åŠ å¤åˆç´¢å¼•ç”¨äºå¿«é€ŸæŸ¥è¯¢
    avatar_library: '++id, category, tag, time',
    avatar_categories: '++id, name, parentCategory, order, time'
});

// ç‰ˆæœ¬79ï¼šæ·»åŠ èŠå¤©ä¸»é¢˜è¡¨
db.version(79).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId',
    friend_requests: '++id, fromCharId, toAccountId, status, time',
    group_chats: '++id, name, ownerAccountId, created_at',
    phone_recents: '++id, accountId, charId, time, type',
    sms_messages: '++id, accountId, charId, time, read',
    chat_summaries: '++id, [accountId+chatType+chatId], accountId, chatType, chatId, time',
    avatar_library: '++id, category, tag, time',
    avatar_categories: '++id, name, parentCategory, order, time',
    chat_themes: '++id, name, accountId, time' // èŠå¤©ä¸»é¢˜è¡¨ï¼šaccountIdç”¨äºè´¦å·éš”ç¦»
});

// ç‰ˆæœ¬80ï¼šæ·»åŠ äº²å¯†ç©ºé—´è¡¨
db.version(80).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId',
    friend_requests: '++id, fromCharId, toAccountId, status, time',
    group_chats: '++id, name, ownerAccountId, created_at',
    phone_recents: '++id, accountId, charId, time, type',
    sms_messages: '++id, accountId, charId, time, read',
    chat_summaries: '++id, [accountId+chatType+chatId], accountId, chatType, chatId, time',
    avatar_library: '++id, category, tag, time',
    avatar_categories: '++id, name, parentCategory, order, time',
    chat_themes: '++id, name, accountId, time',
    intimate_relations: '++id, accountId, myCharId, partnerCharId, relationType, status, createdAt', // äº²å¯†å…³ç³»è¡¨
    intimate_requests: '++id, accountId, fromCharId, toCharId, relationType, status, time' // äº²å¯†å…³ç³»ç”³è¯·è¡¨
});

// ç‰ˆæœ¬81ï¼šæ·»åŠ ç¦»çº¿èŠå¤©è®°å½•è¡¨ + è´¢åŠ¡æ•°æ®è¡¨ï¼ˆä»localStorageè¿ç§»åˆ°IndexedDBï¼Œé˜²æ­¢æ•°æ®ä¸¢å¤±ï¼‰
db.version(81).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId',
    friend_requests: '++id, fromCharId, toAccountId, status, time',
    group_chats: '++id, name, ownerAccountId, created_at',
    phone_recents: '++id, accountId, charId, time, type',
    sms_messages: '++id, accountId, charId, time, read',
    chat_summaries: '++id, [accountId+chatType+chatId], accountId, chatType, chatId, time',
    avatar_library: '++id, category, tag, time',
    avatar_categories: '++id, name, parentCategory, order, time',
    chat_themes: '++id, name, accountId, time',
    intimate_relations: '++id, accountId, myCharId, partnerCharId, relationType, status, createdAt',
    intimate_requests: '++id, accountId, fromCharId, toCharId, relationType, status, time',
    offline_chats: '&key, accountId, charId, updatedAt', // ç¦»çº¿èŠå¤©è®°å½•ï¼šä»localStorageè¿ç§»
    finance_data: '&key, updatedAt' // è´¢åŠ¡æ•°æ®ï¼šphone_balance, loanHistory, scratchHistoryç­‰
});

// ===== è§’è‰²å†…å­˜ç¼“å­˜ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼šæ¶ˆé™¤é¢‘ç¹ IndexedDB è¯»å–ï¼‰=====
// åŸç†ï¼šå¯åŠ¨æ—¶å°† characters è¡¨åŠ è½½åˆ°å†…å­˜ Mapï¼Œä»£ç†è¯»å†™æ–¹æ³•
// è¯»å–èµ°ç¼“å­˜ï¼ˆåŒæ­¥çº§é€Ÿåº¦ï¼‰ï¼Œå†™å…¥åŒæ—¶æ›´æ–° DB + ç¼“å­˜
// æ•ˆæœï¼šæ¶ˆé™¤æ¯æ¬¡æ“ä½œ ~180 æ¬¡ DB è¯»å–ï¼Œå¤§å¹…æå‡æµç•…åº¦
const _charCache = new Map();
let _charCacheReady = false;

// ä¿å­˜ Dexie åŸå§‹æ–¹æ³•ï¼ˆä»£ç†å®ç°ä¸­ä½¿ç”¨è¿™äº›ç›´æ¥æ“ä½œ DBï¼‰
const _dbChar = {
    get: db.characters.get.bind(db.characters),
    toArray: db.characters.toArray.bind(db.characters),
    put: db.characters.put.bind(db.characters),
    add: db.characters.add.bind(db.characters),
    update: db.characters.update.bind(db.characters),
    delete: db.characters.delete.bind(db.characters),
    bulkPut: db.characters.bulkPut.bind(db.characters),
    filter: db.characters.filter.bind(db.characters),
    where: db.characters.where.bind(db.characters),
};

// å¯åŠ¨æ—¶åŠ è½½å…¨éƒ¨è§’è‰²åˆ°ç¼“å­˜
async function _initCharCache() {
    try {
        const all = await _dbChar.toArray();
        all.forEach(c => _charCache.set(c.id, c));
        _charCacheReady = true;
        console.log(`[CharCache] âœ… ç¼“å­˜å°±ç»ªï¼Œå…± ${_charCache.size} ä¸ªè§’è‰²`);
    } catch (e) {
        console.error('[CharCache] âŒ åˆå§‹åŒ–å¤±è´¥ï¼Œé€€åŒ–ä¸ºç›´æ¥è¯»DB:', e);
    }
}
_initCharCache(); // ç«‹å³å¯åŠ¨ï¼ˆä¸ä¾èµ–DOMï¼‰

// --- ä»£ç†è¯»å–æ–¹æ³•ï¼šç¼“å­˜å°±ç»ªæ—¶ä»å†…å­˜è¯»ï¼Œå¦åˆ™å›é€€DB ---
db.characters.get = async function(id) {
    if (_charCacheReady && id != null) {
        return _charCache.get(typeof id === 'number' ? id : parseInt(id)) || null;
    }
    return _dbChar.get(id);
};

db.characters.toArray = async function() {
    if (_charCacheReady) return Array.from(_charCache.values());
    return _dbChar.toArray();
};

db.characters.filter = function(fn) {
    if (_charCacheReady) {
        const result = Array.from(_charCache.values()).filter(fn);
        return { toArray: async () => result };
    }
    return _dbChar.filter(fn);
};

db.characters.where = function(field) {
    // ":id" æ˜¯ Dexie å†…éƒ¨ä½¿ç”¨çš„ä¸»é”®æŸ¥è¯¢ï¼ˆå¦‚ update/modifyï¼‰ï¼Œå¿…é¡»èµ°åŸå§‹æ–¹æ³•
    if (_charCacheReady && field !== ':id') {
        return {
            equals: (val) => ({
                toArray: async () => Array.from(_charCache.values()).filter(c => c[field] === val)
            })
        };
    }
    return _dbChar.where(field);
};

// --- ä»£ç†å†™å…¥æ–¹æ³•ï¼šå†™DB + åŒæ­¥æ›´æ–°ç¼“å­˜ ---
db.characters.put = async function(data) {
    const key = await _dbChar.put(data);
    if (data) {
        const id = data.id || key;
        if (id) { data.id = id; _charCache.set(id, data); }
    }
    return key;
};

db.characters.add = async function(data) {
    const id = await _dbChar.add(data);
    if (id) { data.id = id; _charCache.set(id, data); }
    return id;
};

db.characters.update = async function(id, changes) {
    const result = await _dbChar.update(id, changes);
    if (_charCacheReady && result) {
        const cached = _charCache.get(id);
        if (cached) {
            for (const [key, value] of Object.entries(changes)) {
                const parts = key.split('.');
                if (parts.length === 1) {
                    cached[key] = value;
                } else {
                    let obj = cached;
                    for (let i = 0; i < parts.length - 1; i++) {
                        if (obj[parts[i]] == null || typeof obj[parts[i]] !== 'object') obj[parts[i]] = {};
                        obj = obj[parts[i]];
                    }
                    obj[parts[parts.length - 1]] = value;
                }
            }
        }
    }
    return result;
};

db.characters.delete = async function(id) {
    const result = await _dbChar.delete(id);
    _charCache.delete(typeof id === 'number' ? id : parseInt(id));
    return result;
};

db.characters.bulkPut = async function(items) {
    const result = await _dbChar.bulkPut(items);
    // æ‰¹é‡å¯¼å…¥ååˆ·æ–°æ•´ä¸ªç¼“å­˜
    _charCache.clear();
    const all = await _dbChar.toArray();
    all.forEach(c => _charCache.set(c.id, c));
    return result;
};

// ğŸ“¦ æ•°æ®è¿ç§»ï¼šå°† localStorage ä¸­çš„ç”µè¯å’ŒçŸ­ä¿¡è®°å½•è¿ç§»åˆ° IndexedDB
async function migratePhoneAndSmsToIndexedDB() {
    const migrationKey = 'phone_sms_migrated_to_indexeddb';
    if (localStorage.getItem(migrationKey) === 'true') {
        return; // å·²ç»è¿ç§»è¿‡
    }
    
    console.log('[Migration] å¼€å§‹è¿ç§»ç”µè¯å’ŒçŸ­ä¿¡è®°å½•åˆ° IndexedDB...');
    
    // è·å–é»˜è®¤è´¦å·ID
    const currentAccountId = localStorage.getItem('current_my_char_id') || '1';
    
    // è¿ç§»ç”µè¯è®°å½•
    try {
        const phoneRecents = JSON.parse(localStorage.getItem('phone_recents') || '[]');
        if (phoneRecents.length > 0) {
            console.log(`[Migration] è¿ç§» ${phoneRecents.length} æ¡ç”µè¯è®°å½•...`);
            for (const record of phoneRecents) {
                await db.phone_recents.put({
                    accountId: currentAccountId,
                    charId: null, // æ—§æ•°æ®æ²¡æœ‰ charId
                    name: record.name,
                    number: record.number,
                    time: record.time || Date.now(),
                    type: record.type || 'missed',
                    isBlocked: record.isBlocked || false
                });
            }
            // ç¡®è®¤å†™å…¥æˆåŠŸåå†æ¸…ç†æ—§æ•°æ®
            localStorage.removeItem('phone_recents');
            console.log('[Migration] âœ… ç”µè¯è®°å½•è¿ç§»å®Œæˆ');
        }
    } catch (e) {
        console.error('[Migration] âŒ ç”µè¯è®°å½•è¿ç§»å¤±è´¥:', e);
    }
    
    // è¿ç§»çŸ­ä¿¡è®°å½•
    try {
        const smsMessages = JSON.parse(localStorage.getItem('sms_messages') || '[]');
        if (smsMessages.length > 0) {
            console.log(`[Migration] è¿ç§» ${smsMessages.length} æ¡çŸ­ä¿¡è®°å½•...`);
            for (const msg of smsMessages) {
                await db.sms_messages.put({
                    accountId: currentAccountId,
                    charId: null, // æ—§æ•°æ®æ²¡æœ‰ charId
                    sender: msg.sender,
                    number: msg.number,
                    content: msg.content || msg.message,
                    time: msg.time || msg.timestamp || Date.now(),
                    read: msg.read !== false,
                    type: msg.type || 'received',
                    isBlocked: msg.isBlocked || false,
                    receiverName: msg.receiverName,
                    receiverId: msg.receiverId
                });
            }
            // ç¡®è®¤å†™å…¥æˆåŠŸåå†æ¸…ç†æ—§æ•°æ®
            localStorage.removeItem('sms_messages');
            console.log('[Migration] âœ… çŸ­ä¿¡è®°å½•è¿ç§»å®Œæˆ');
        }
    } catch (e) {
        console.error('[Migration] âŒ çŸ­ä¿¡è®°å½•è¿ç§»å¤±è´¥:', e);
    }
    
    // æ ‡è®°è¿ç§»å®Œæˆ
    localStorage.setItem(migrationKey, 'true');
    console.log('[Migration] ğŸ‰ ç”µè¯å’ŒçŸ­ä¿¡æ•°æ®è¿ç§»å®Œæˆ');
}

// ğŸ“¦ æ•°æ®è¿ç§»v3ï¼šå°† localStorage ä¸­çš„ç¦»çº¿èŠå¤©è®°å½•å’Œè´¢åŠ¡æ•°æ®è¿ç§»åˆ° IndexedDB
async function migrateOfflineAndFinanceToIndexedDB() {
    const migrationKey = 'offline_finance_migrated_to_indexeddb_v1';
    if (localStorage.getItem(migrationKey) === 'true') {
        return; // å·²ç»è¿ç§»è¿‡
    }
    
    console.log('[Migration-v3] å¼€å§‹è¿ç§»ç¦»çº¿èŠå¤©å’Œè´¢åŠ¡æ•°æ®åˆ° IndexedDB...');
    
    try {
        // 1. è¿ç§»ç¦»çº¿èŠå¤©è®°å½• (æ ¼å¼: offline_chat_{accountId}_{charId})
        const offlineChatKeys = [];
        for (let i = 0; i < localStorage.length; i++) {
            const k = localStorage.key(i);
            if (k && k.startsWith('offline_chat_')) {
                offlineChatKeys.push(k);
            }
        }
        
        for (const lsKey of offlineChatKeys) {
            try {
                const rawData = localStorage.getItem(lsKey);
                if (!rawData) continue;
                const chatData = JSON.parse(rawData);
                // è§£æ key: offline_chat_{accountId}_{charId}
                const parts = lsKey.replace('offline_chat_', '').split('_');
                const accountId = parts[0] || '';
                const charId = parts.slice(1).join('_') || '';
                
                await db.offline_chats.put({
                    key: lsKey,
                    accountId: accountId,
                    charId: charId,
                    messages: chatData,
                    updatedAt: Date.now()
                });
                console.log(`[Migration-v3] âœ… ç¦»çº¿èŠå¤©å·²è¿ç§»: ${lsKey} (${chatData.length}æ¡æ¶ˆæ¯)`);
                // æ³¨æ„ï¼šä¸åˆ é™¤ localStorage ä¸­çš„æ—§æ•°æ®ï¼Œä¿ç•™ä½œä¸ºå¤‡ä»½
                // åç»­ä»£ç ä¼šä¼˜å…ˆä» IndexedDB è¯»å–
            } catch (e) {
                console.error(`[Migration-v3] âŒ ç¦»çº¿èŠå¤©è¿ç§»å¤±è´¥: ${lsKey}`, e);
            }
        }
        
        // 2. è¿ç§»è´¢åŠ¡æ•°æ®
        const financeKeys = ['phone_balance', 'phone_recharge_history', 'loanHistory', 'scratchHistory'];
        for (const fKey of financeKeys) {
            try {
                const rawVal = localStorage.getItem(fKey);
                if (rawVal === null) continue;
                let parsedVal;
                try { parsedVal = JSON.parse(rawVal); } catch { parsedVal = rawVal; }
                
                await db.finance_data.put({
                    key: fKey,
                    value: parsedVal,
                    updatedAt: Date.now()
                });
                console.log(`[Migration-v3] âœ… è´¢åŠ¡æ•°æ®å·²è¿ç§»: ${fKey}`);
                // ä¸åˆ é™¤ localStorage æ—§æ•°æ®ï¼Œä¿ç•™å…¼å®¹
            } catch (e) {
                console.error(`[Migration-v3] âŒ è´¢åŠ¡æ•°æ®è¿ç§»å¤±è´¥: ${fKey}`, e);
            }
        }
        
        localStorage.setItem(migrationKey, 'true');
        console.log('[Migration-v3] ğŸ‰ ç¦»çº¿èŠå¤©å’Œè´¢åŠ¡æ•°æ®è¿ç§»å®Œæˆ');
    } catch (e) {
        console.error('[Migration-v3] âŒ è¿ç§»è¿‡ç¨‹å‡ºé”™:', e);
    }
}

// ==================== ğŸ›¡ï¸ æ•°æ®å®‰å…¨å±‚ï¼šé˜²ä¸¢æ•°æ®æ ¸å¿ƒå·¥å…· ====================

// ğŸ›¡ï¸ è¿ç»­å†™å…¥å¤±è´¥è®¡æ•°å™¨ï¼ˆç”¨äºå‡çº§è­¦å‘Šï¼‰
let _dbWriteFailCount = 0;
const _DB_FAIL_ESCALATE_THRESHOLD = 3; // è¿ç»­å¤±è´¥Næ¬¡åæ˜¾ç¤ºæŒä¹…çº¢è‰²æ¨ªå¹…

// ğŸ›¡ï¸ æ˜¾ç¤ºæŒä¹…æ€§æ•°æ®ä¸¢å¤±é£é™©æ¨ªå¹…ï¼ˆä¸ä¼šè‡ªåŠ¨æ¶ˆå¤±ï¼Œç”¨æˆ·å¿…é¡»æ‰‹åŠ¨å…³é—­ï¼‰
function showDataLossBanner(message) {
    // é˜²æ­¢é‡å¤åˆ›å»º
    if (document.getElementById('data-loss-banner')) return;
    const banner = document.createElement('div');
    banner.id = 'data-loss-banner';
    banner.style.cssText = 'position:fixed;top:0;left:0;width:100%;z-index:999999;background:#d32f2f;color:#fff;padding:12px 40px 12px 16px;font-size:14px;line-height:1.4;box-shadow:0 2px 8px rgba(0,0,0,0.3);';
    banner.innerHTML = `âš ï¸ <b>æ•°æ®ä¿å­˜å¼‚å¸¸</b>ï¼š${message}<br><small>è¯·ç«‹å³å‰å¾€è®¾ç½® â†’ å¯¼å‡ºå¤‡ä»½ï¼Œé˜²æ­¢æ•°æ®ä¸¢å¤±ï¼</small>`;
    const closeBtn = document.createElement('div');
    closeBtn.textContent = 'Ã—';
    closeBtn.style.cssText = 'position:absolute;top:8px;right:12px;cursor:pointer;font-size:22px;font-weight:bold;';
    closeBtn.onclick = () => banner.remove();
    banner.appendChild(closeBtn);
    document.body.appendChild(banner);
}

// ğŸ›¡ï¸ ç´§æ€¥å¤‡ä»½åˆ° localStorageï¼ˆå½“ IndexedDB å†™å…¥å¤±è´¥æ—¶çš„æœ€åæ‰‹æ®µï¼‰
function emergencyLocalStorageBackup(label, data) {
    try {
        const backupKey = '_emergency_backup_' + Date.now();
        const backupPayload = {
            label: label,
            time: new Date().toISOString(),
            data: data
        };
        localStorage.setItem(backupKey, JSON.stringify(backupPayload));
        console.warn(`[SafeDB] ğŸ†˜ ç´§æ€¥å¤‡ä»½åˆ° localStorage: ${backupKey}`);
        return true;
    } catch (e) {
        console.error('[SafeDB] ğŸ†˜ ç´§æ€¥å¤‡ä»½ä¹Ÿå¤±è´¥äº†:', e);
        return false;
    }
}

// ğŸ›¡ï¸ å®‰å…¨å†™å…¥ localStorageï¼ˆè‡ªå¸¦ try/catch + quota æ£€æµ‹ + æç¤ºï¼‰
function safeLocalStorageSet(key, value) {
    try {
        localStorage.setItem(key, typeof value === 'string' ? value : JSON.stringify(value));
        return true;
    } catch (e) {
        console.error(`[SafeLS] âŒ localStorageå†™å…¥å¤±è´¥ key=${key}:`, e.message);
        if (e.name === 'QuotaExceededError' || e.code === 22 || e.code === 1014) {
            showDataLossBanner('localStorage å­˜å‚¨ç©ºé—´å·²æ»¡ï¼Œæ•°æ®æ— æ³•ä¿å­˜ï¼');
        }
        try { if (typeof showToast === 'function') showToast('âš ï¸ æœ¬åœ°å­˜å‚¨å†™å…¥å¤±è´¥: ' + key); } catch(_) {}
        return false;
    }
}

// ğŸ”§ å®‰å…¨å†™å…¥ IndexedDBï¼Œå¸¦é‡è¯• + ç”¨æˆ·æé†’ + ç´§æ€¥å…œåº•
// maxRetries: æœ€å¤§é‡è¯•æ¬¡æ•°, delayMs: é‡è¯•é—´éš”æ¯«ç§’
async function safeDbPut(table, data, label, maxRetries = 3, delayMs = 500) {
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            await table.put(data);
            // å†™å…¥æˆåŠŸï¼Œé‡ç½®å¤±è´¥è®¡æ•°
            if (_dbWriteFailCount > 0) {
                _dbWriteFailCount = 0;
                const banner = document.getElementById('data-loss-banner');
                if (banner) banner.remove(); // æ¢å¤åç§»é™¤æ¨ªå¹…
            }
            return true;
        } catch (err) {
            console.error(`[SafeDB] âŒ ${label} å†™å…¥å¤±è´¥ (ç¬¬${attempt}æ¬¡):`, err.message);
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯é…é¢ä¸è¶³
            if (err.name === 'QuotaExceededError' || (err.inner && err.inner.name === 'QuotaExceededError')) {
                console.error('[SafeDB] âš ï¸ å­˜å‚¨ç©ºé—´ä¸è¶³ï¼');
                _dbWriteFailCount++;
                // ç´§æ€¥å¤‡ä»½åˆ° localStorage
                emergencyLocalStorageBackup(label, data);
                showDataLossBanner('å­˜å‚¨ç©ºé—´ä¸è¶³ï¼Œæ•°æ®å¯èƒ½æ— æ³•ä¿å­˜ï¼');
                try {
                    if (typeof showToast === 'function') {
                        showToast('âš ï¸ å­˜å‚¨ç©ºé—´ä¸è¶³ï¼Œéƒ¨åˆ†æ•°æ®å¯èƒ½æ— æ³•ä¿å­˜ï¼è¯·å¯¼å‡ºå¤‡ä»½åæ¸…ç†æ•°æ®ã€‚');
                    }
                } catch(_) {}
                return false;
            }
            
            if (attempt < maxRetries) {
                await new Promise(r => setTimeout(r, delayMs * attempt));
            }
        }
    }
    
    // æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥äº†
    _dbWriteFailCount++;
    console.error(`[SafeDB] âŒâŒ ${label} å†™å…¥å½»åº•å¤±è´¥ï¼ˆå·²é‡è¯•${maxRetries}æ¬¡ï¼‰ï¼Œè¿ç»­å¤±è´¥${_dbWriteFailCount}æ¬¡`);
    
    // ç´§æ€¥å¤‡ä»½åˆ° localStorage
    emergencyLocalStorageBackup(label, data);
    
    // è¿ç»­å¤šæ¬¡å¤±è´¥ï¼šæ˜¾ç¤ºæŒä¹…çº¢è‰²æ¨ªå¹…ï¼ˆä¸ä¼šè‡ªåŠ¨æ¶ˆå¤±ï¼‰
    if (_dbWriteFailCount >= _DB_FAIL_ESCALATE_THRESHOLD) {
        showDataLossBanner(`IndexedDB è¿ç»­ ${_dbWriteFailCount} æ¬¡å†™å…¥å¤±è´¥ï¼Œæ•°æ®æœ‰ä¸¢å¤±é£é™©ï¼`);
    }
    
    try {
        if (typeof showToast === 'function') {
            showToast('âš ï¸ æ•°æ®ä¿å­˜å¤±è´¥ï¼Œè¯·å°½å¿«å¯¼å‡ºå¤‡ä»½ï¼', 5000);
        }
    } catch(_) {}
    return false;
}

// ğŸ”§ å®‰å…¨å†™å…¥ç¾¤èŠæ•°æ®
async function safeGroupChatPut(group, label) {
    return await safeDbPut(db.group_chats, group, label || `ç¾¤èŠ[${group.name || group.id}]`);
}

// ğŸ”§ å®‰å…¨å±€éƒ¨æ›´æ–° IndexedDB è®°å½•ï¼ˆåªæ›´æ–°æŒ‡å®šå­—æ®µï¼Œä¸è¦†ç›–æ•´ä¸ªå¯¹è±¡ï¼‰
// ä½¿ç”¨ Dexie çš„ update() æ–¹æ³•ï¼Œæ”¯æŒç‚¹å·åµŒå¥—å†™æ³•å¦‚ 'avatar_by_user.accountId'
async function safeDexieUpdate(table, id, payload, label, maxRetries = 3, delayMs = 500) {
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            const updated = await table.update(id, payload);
            if (updated) {
                // å†™å…¥æˆåŠŸï¼Œé‡ç½®å¤±è´¥è®¡æ•°
                if (_dbWriteFailCount > 0) {
                    _dbWriteFailCount = 0;
                    const banner = document.getElementById('data-loss-banner');
                    if (banner) banner.remove();
                }
                return true; // æ›´æ–°æˆåŠŸ
            } else {
                console.warn(`[SafeDexieUpdate] âš ï¸ ${label || ''} æ›´æ–°è¿”å›0ï¼Œè®°å½•å¯èƒ½ä¸å­˜åœ¨ (id=${id})`);
                return false;
            }
        } catch (err) {
            console.error(`[SafeDexieUpdate] âŒ ${label || ''} æ›´æ–°å¤±è´¥ (ç¬¬${attempt}æ¬¡):`, err.message);
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯é…é¢ä¸è¶³
            if (err.name === 'QuotaExceededError' || (err.inner && err.inner.name === 'QuotaExceededError')) {
                console.error('[SafeDexieUpdate] âš ï¸ å­˜å‚¨ç©ºé—´ä¸è¶³ï¼');
                _dbWriteFailCount++;
                emergencyLocalStorageBackup(label || `update-${id}`, payload);
                showDataLossBanner('å­˜å‚¨ç©ºé—´ä¸è¶³ï¼Œæ•°æ®å¯èƒ½æ— æ³•ä¿å­˜ï¼');
                try {
                    if (typeof showToast === 'function') {
                        showToast('âš ï¸ å­˜å‚¨ç©ºé—´ä¸è¶³ï¼Œéƒ¨åˆ†æ•°æ®å¯èƒ½æ— æ³•ä¿å­˜ï¼è¯·å¯¼å‡ºå¤‡ä»½åæ¸…ç†æ•°æ®ã€‚');
                    }
                } catch(_) {}
                return false;
            }
            
            if (attempt < maxRetries) {
                await new Promise(r => setTimeout(r, delayMs * attempt));
            }
        }
    }
    
    _dbWriteFailCount++;
    console.error(`[SafeDexieUpdate] âŒâŒ ${label || ''} æ›´æ–°å½»åº•å¤±è´¥ï¼ˆå·²é‡è¯•${maxRetries}æ¬¡ï¼‰ï¼Œè¿ç»­å¤±è´¥${_dbWriteFailCount}æ¬¡`);
    emergencyLocalStorageBackup(label || `update-${id}`, payload);
    
    if (_dbWriteFailCount >= _DB_FAIL_ESCALATE_THRESHOLD) {
        showDataLossBanner(`IndexedDB è¿ç»­ ${_dbWriteFailCount} æ¬¡å†™å…¥å¤±è´¥ï¼Œæ•°æ®æœ‰ä¸¢å¤±é£é™©ï¼`);
    }
    
    try {
        if (typeof showToast === 'function') {
            showToast('âš ï¸ æ•°æ®ä¿å­˜å¤±è´¥ï¼Œè¯·å°½å¿«å¯¼å‡ºå¤‡ä»½ï¼', 5000);
        }
    } catch(_) {}
    return false;
}

// ğŸ”§ å®‰å…¨å†™å…¥è§’è‰²æ•°æ®ï¼ˆå†™å…¥å‰åˆå¹¶æœ€æ–°çš„èŠå¤©è¯¦æƒ…è®¾ç½®ï¼Œé˜²æ­¢è¢«æ—§æ•°æ®è¦†ç›–ï¼‰
async function safeCharacterPut(char, label) {
    // ğŸ›¡ï¸ ä¿æŠ¤èŠå¤©è¯¦æƒ…è®¾ç½®ï¼šput() ä¼šè¦†ç›–æ•´ä¸ªå¯¹è±¡ï¼Œ
    // å¦‚æœè°ƒç”¨æ–¹æŒæœ‰çš„ char æ˜¯ä¹‹å‰è¯»å–çš„æ—§æ•°æ®ï¼Œç”¨æˆ·åœ¨æ­¤æœŸé—´é€šè¿‡èŠå¤©è¯¦æƒ…ä¿®æ”¹çš„è®¾ç½®ä¼šä¸¢å¤±ã€‚
    // è§£å†³æ–¹æ¡ˆï¼šå†™å…¥å‰å…ˆè¯»å–æ•°æ®åº“ä¸­æœ€æ–°çš„è®¾ç½®å­—æ®µï¼Œåˆå¹¶åˆ°å³å°†å†™å…¥çš„å¯¹è±¡ä¸­ã€‚
    try {
        if (char && char.id) {
            const freshChar = await db.characters.get(char.id);
            if (freshChar) {
                // èŠå¤©è¯¦æƒ…é¡µçš„æ‰€æœ‰è®¾ç½®å­—æ®µï¼ˆé€šè¿‡ saveChatDetail / update() ä¿å­˜ï¼‰
                const settingsFields = [
                    'auto_reply_enabled', 'auto_reply_interval',
                    'context_message_count',
                    'reply_min_count', 'reply_max_count',
                    'input_placeholder',
                    'foreign_lang_mode',
                    'allow_ai_check_account', 'allow_shura_mode',
                    'allow_auto_avatar',
                    'allow_autonomous_activity',
                    'scheduled_activity_enabled', 'scheduled_activity_interval',
                    'moments_frequency',
                    'auto_summary_enabled', 'summary_interval',
                    'custom_bubble_css', 'bubble_style',
                    'lorebookIds', 'lorebookId',
                    'chat_background', 'chatThemeId',
                    'remark_by_user',
                    'mounted_sticker_categories', 'linked_user_id'
                ];
                for (const field of settingsFields) {
                    if (freshChar[field] !== undefined) {
                        char[field] = freshChar[field];
                    }
                }
            }
        }
    } catch (e) {
        console.warn('[safeCharacterPut] âš ï¸ åˆå¹¶æœ€æ–°è®¾ç½®å¤±è´¥ï¼Œç»§ç»­å†™å…¥:', e);
    }
    return await safeDbPut(db.characters, char, label || `è§’è‰²[${char.name || char.id}]`);
}

// ğŸ”§ å­˜å‚¨ç©ºé—´ç›‘æ§ï¼šæ£€æŸ¥ IndexedDB ä½¿ç”¨æƒ…å†µ
async function checkStorageQuota() {
    try {
        if (navigator.storage && navigator.storage.estimate) {
            const estimate = await navigator.storage.estimate();
            const usedMB = (estimate.usage / 1024 / 1024).toFixed(1);
            const quotaMB = (estimate.quota / 1024 / 1024).toFixed(1);
            const usagePercent = ((estimate.usage / estimate.quota) * 100).toFixed(1);
            
            console.log(`[Storage] å·²ç”¨: ${usedMB}MB / ${quotaMB}MB (${usagePercent}%)`);
            
            // è¶…è¿‡80%æ—¶è­¦å‘Š
            if (estimate.usage / estimate.quota > 0.8) {
                console.warn('[Storage] âš ï¸ å­˜å‚¨ç©ºé—´ä½¿ç”¨è¶…è¿‡80%ï¼å»ºè®®å¯¼å‡ºå¤‡ä»½å¹¶æ¸…ç†æ—§æ•°æ®ã€‚');
                try {
                    if (typeof showToast === 'function') {
                        showToast(`âš ï¸ å­˜å‚¨å·²ç”¨${usagePercent}%ï¼Œå»ºè®®å¯¼å‡ºå¤‡ä»½`, 5000);
                    }
                } catch(_) {}
            }
            
            return { used: estimate.usage, quota: estimate.quota, percent: parseFloat(usagePercent) };
        }
    } catch (e) {
        console.warn('[Storage] æ— æ³•æ£€æµ‹å­˜å‚¨ç©ºé—´:', e);
    }
    return null;
}

// ğŸ”§ å®šæ—¶è‡ªåŠ¨ä¿å­˜å®ˆå«ï¼šé˜²æ­¢æµè§ˆå™¨å´©æºƒ/æ„å¤–å…³é—­å¯¼è‡´å†…å­˜æ•°æ®ä¸¢å¤±
// æ¯60ç§’æ£€æŸ¥ä¸€æ¬¡ï¼Œå¦‚æœæœ‰æœªä¿å­˜çš„è„æ•°æ®åˆ™è‡ªåŠ¨æŒä¹…åŒ–
let _pendingDirtySaves = new Map(); // charId -> { char, accountId, history, timestamp }

function markChatDirty(charId, char, accountId, history) {
    _pendingDirtySaves.set(charId, {
        char: char,
        accountId: accountId,
        history: [...history], // æ‹·è´å¿«ç…§
        timestamp: Date.now()
    });
}

async function flushDirtySaves() {
    if (_pendingDirtySaves.size === 0) return;
    
    const entries = [..._pendingDirtySaves.entries()];
    _pendingDirtySaves.clear();
    
    for (const [charId, data] of entries) {
        try {
            const freshChar = await db.characters.get(charId);
            if (!freshChar) continue;
            
            // åªæœ‰å½“å†…å­˜ä¸­çš„å†å²ç¡®å®æ¯”DBä¸­çš„æ–°ï¼ˆæ›´å¤šæ¶ˆæ¯ï¼‰æ—¶æ‰ä¿å­˜
            const dbHistory = data.accountId 
                ? (freshChar.chat_history_by_user?.[data.accountId] || [])
                : (freshChar.chat_history || []);
            
            if (data.history.length > dbHistory.length) {
                // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°èŠå¤©è®°å½•å­—æ®µï¼Œé˜²æ­¢è¦†ç›–è®¾ç½®
                const updatePayload = {};
                if (data.accountId) {
                    const mergedHistory = { ...(freshChar.chat_history_by_user || {}) };
                    mergedHistory[data.accountId] = data.history;
                    updatePayload.chat_history_by_user = mergedHistory;
                } else {
                    updatePayload.chat_history = data.history;
                }
                await db.characters.update(charId, updatePayload);
                console.log(`[AutoSave] âœ… å·²è‡ªåŠ¨ä¿å­˜ ${freshChar.name || charId} çš„èŠå¤©è®°å½•ï¼ˆä»…æ›´æ–°å†å²å­—æ®µï¼‰`);
            }
        } catch (e) {
            console.error(`[AutoSave] âŒ è‡ªåŠ¨ä¿å­˜å¤±è´¥ charId=${charId}:`, e);
        }
    }
}

// æ¯60ç§’æ‰§è¡Œä¸€æ¬¡è„æ•°æ®åˆ·ç›˜
setInterval(flushDirtySaves, 60000);

// ğŸ›¡ï¸ åŒæ­¥ç´§æ€¥ä¿å­˜ï¼ˆbeforeunload ä¸­ async å‡½æ•°ä¸å¯é ï¼Œæµè§ˆå™¨å¯èƒ½ä¸ç­‰å¾…å®Œæˆï¼‰
function emergencySyncFlush() {
    if (_pendingDirtySaves.size === 0) return;
    
    // åŒæ­¥å†™å…¥ localStorage ä½œä¸ºç´§æ€¥å…œåº•ï¼ˆIndexedDB æ˜¯å¼‚æ­¥çš„ï¼Œä¸èƒ½ä¿è¯ beforeunload ä¸­å®Œæˆï¼‰
    try {
        const emergencyData = {};
        for (const [charId, data] of _pendingDirtySaves.entries()) {
            emergencyData[charId] = {
                accountId: data.accountId,
                history: data.history,
                timestamp: data.timestamp
            };
        }
        localStorage.setItem('_emergency_dirty_saves', JSON.stringify(emergencyData));
        console.log(`[EmergencyFlush] ğŸ†˜ å·²å°† ${_pendingDirtySaves.size} æ¡è„æ•°æ®åŒæ­¥å†™å…¥ localStorage`);
    } catch (e) {
        console.error('[EmergencyFlush] âŒ localStorage ç´§æ€¥ä¿å­˜ä¹Ÿå¤±è´¥:', e);
    }
    
    // åŒæ—¶å°è¯•å¼‚æ­¥ IndexedDB åˆ·ç›˜ï¼ˆä¸ä¿è¯èƒ½å®Œæˆï¼‰
    flushDirtySaves();
}

// ğŸ›¡ï¸ å¯åŠ¨æ—¶æ¢å¤ç´§æ€¥ä¿å­˜çš„è„æ•°æ®
async function recoverEmergencyDirtySaves() {
    try {
        const raw = localStorage.getItem('_emergency_dirty_saves');
        if (!raw) return;
        
        const emergencyData = JSON.parse(raw);
        let recoveredCount = 0;
        
        for (const [charId, data] of Object.entries(emergencyData)) {
            try {
                const numCharId = parseInt(charId);
                const freshChar = await db.characters.get(numCharId || charId);
                if (!freshChar) continue;
                
                const dbHistory = data.accountId 
                    ? (freshChar.chat_history_by_user?.[data.accountId] || [])
                    : (freshChar.chat_history || []);
                
                // åªæœ‰ç´§æ€¥æ•°æ®æ¯” DB ä¸­çš„æ›´æ–°ï¼ˆæ›´å¤šæ¶ˆæ¯ï¼‰æ—¶æ‰æ¢å¤
                if (data.history && data.history.length > dbHistory.length) {
                    const updatePayload = {};
                    if (data.accountId) {
                        const merged = { ...(freshChar.chat_history_by_user || {}) };
                        merged[data.accountId] = data.history;
                        updatePayload.chat_history_by_user = merged;
                    } else {
                        updatePayload.chat_history = data.history;
                    }
                    await db.characters.update(numCharId || charId, updatePayload);
                    recoveredCount++;
                    console.log(`[EmergencyRecover] âœ… å·²æ¢å¤ ${freshChar.name || charId} çš„èŠå¤©è®°å½•ï¼ˆ${data.history.length}æ¡æ¶ˆæ¯ï¼‰`);
                }
            } catch (e) {
                console.error(`[EmergencyRecover] âŒ æ¢å¤ charId=${charId} å¤±è´¥:`, e);
            }
        }
        
        // æ¢å¤å®Œæ¯•åæ¸…é™¤ç´§æ€¥æ•°æ®
        localStorage.removeItem('_emergency_dirty_saves');
        if (recoveredCount > 0) {
            console.log(`[EmergencyRecover] ğŸ‰ å…±æ¢å¤ ${recoveredCount} æ¡ç´§æ€¥ä¿å­˜çš„èŠå¤©è®°å½•`);
            try { showToast(`å·²æ¢å¤ ${recoveredCount} æ¡ä¸Šæ¬¡æœªä¿å­˜çš„èŠå¤©è®°å½•`); } catch(_) {}
        }
    } catch (e) {
        console.error('[EmergencyRecover] âŒ ç´§æ€¥æ•°æ®æ¢å¤å¤±è´¥:', e);
        localStorage.removeItem('_emergency_dirty_saves');
    }
}

// é¡µé¢å…³é—­/éšè—æ—¶ç«‹å³åˆ·ç›˜
window.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'hidden') {
        emergencySyncFlush();
    }
});
window.addEventListener('beforeunload', () => {
    emergencySyncFlush();
});

// å¯åŠ¨æ—¶æ£€æŸ¥å­˜å‚¨ç©ºé—´
setTimeout(checkStorageQuota, 5000);

// ==================== ğŸ›¡ï¸ ç¦»çº¿èŠå¤©æ•°æ®å®‰å…¨è¯»å†™ ====================
// ä¼˜å…ˆä½¿ç”¨ IndexedDBï¼Œå…¼å®¹ localStorage æ—§æ•°æ®

async function loadOfflineChatHistory(accountId, charId) {
    const lsKey = `offline_chat_${accountId}_${charId}`;
    try {
        // ä¼˜å…ˆä» IndexedDB è¯»å–
        const record = await db.offline_chats.get(lsKey);
        if (record && record.messages) {
            return record.messages;
        }
    } catch (e) {
        console.warn('[OfflineChat] IndexedDBè¯»å–å¤±è´¥ï¼Œå›é€€åˆ°localStorage:', e);
    }
    // å›é€€åˆ° localStorageï¼ˆå…¼å®¹æ—§æ•°æ®ï¼‰
    try {
        return JSON.parse(localStorage.getItem(lsKey) || '[]');
    } catch (e) {
        return [];
    }
}

async function saveOfflineChatHistory(accountId, charId, messages) {
    const lsKey = `offline_chat_${accountId}_${charId}`;
    try {
        // å†™å…¥ IndexedDBï¼ˆä¸»å­˜å‚¨ï¼‰
        await db.offline_chats.put({
            key: lsKey,
            accountId: accountId,
            charId: String(charId),
            messages: messages,
            updatedAt: Date.now()
        });
    } catch (e) {
        console.error('[OfflineChat] IndexedDBå†™å…¥å¤±è´¥:', e);
    }
    // åŒæ—¶å†™å…¥ localStorageï¼ˆå…œåº•å¤‡ä»½ï¼‰
    try {
        localStorage.setItem(lsKey, JSON.stringify(messages));
    } catch (e) {
        console.warn('[OfflineChat] localStorageå†™å…¥å¤±è´¥ï¼ˆå¯èƒ½ç©ºé—´ä¸è¶³ï¼‰:', e);
    }
}

// ==================== ğŸ›¡ï¸ è´¢åŠ¡æ•°æ®å®‰å…¨è¯»å†™ ====================

async function loadFinanceData(key, defaultValue) {
    try {
        const record = await db.finance_data.get(key);
        if (record && record.value !== undefined) {
            return record.value;
        }
    } catch (e) {
        console.warn(`[Finance] IndexedDBè¯»å–å¤±è´¥(${key})ï¼Œå›é€€åˆ°localStorage:`, e);
    }
    // å›é€€åˆ° localStorage
    try {
        const raw = localStorage.getItem(key);
        if (raw === null) return defaultValue;
        try { return JSON.parse(raw); } catch { return raw; }
    } catch (e) {
        return defaultValue;
    }
}

async function saveFinanceData(key, value) {
    try {
        await db.finance_data.put({
            key: key,
            value: value,
            updatedAt: Date.now()
        });
    } catch (e) {
        console.error(`[Finance] IndexedDBå†™å…¥å¤±è´¥(${key}):`, e);
    }
    // åŒæ—¶å†™å…¥ localStorage å…œåº•
    try {
        localStorage.setItem(key, JSON.stringify(value));
    } catch (e) {
        console.warn(`[Finance] localStorageå†™å…¥å¤±è´¥(${key}):`, e);
    }
}

        let currentSelectIcon = '';
        let currentCharacterType = 'char'; // é»˜è®¤ä¸º char
        let editingCharId = null; // å½“å‰ç¼–è¾‘çš„è§’è‰²ID
        let currentChatCharId = null; // å½“å‰èŠå¤©å¯¹è±¡ID
        let currentChatUserId = null; // å½“å‰èŠå¤©ä½¿ç”¨çš„ User ID (ä¸´æ—¶ç¼“å­˜)
        let currentMyCharId = localStorage.getItem('current_my_char_id'); // å½“å‰ç™»å½•çš„â€œæˆ‘â€çš„è§’è‰²ID

        // æ¨¡æ‹Ÿç”¨æˆ·IDï¼Œå®é™…é¡¹ç›®ä¸­å¯èƒ½æ¥è‡ªç™»å½•
        let currentUserId = localStorage.getItem('user_id');
        if (!currentUserId) {
            currentUserId = 'user_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('user_id', currentUserId);
        }
        
        // å…¨å±€å®šæ—¶å™¨å˜é‡
        let notifTimer = null;
        let autoChatTimer = null; // ä¸»åŠ¨èŠå¤©å®šæ—¶å™¨
        const autoChatLocks = new Set(); // å­˜å‚¨æ­£åœ¨è¿›è¡Œä¸»åŠ¨èŠå¤©çš„ charIdï¼Œé˜²æ­¢å¹¶å‘è§¦å‘
        const lastAutoChatActionTime = new Map(); // ğŸ”§ è®°å½•æ¯ä¸ªè§’è‰²ä¸Šæ¬¡ä¸»åŠ¨èŠå¤©çš„æ—¶é—´æˆ³ï¼ˆç”¨äºå†·å´åˆ¤æ–­ï¼‰
        const scheduledActivityLocks = new Set(); // å­˜å‚¨æ­£åœ¨è¿›è¡Œå®šæ—¶è‡ªä¸»æ´»åŠ¨çš„ charIdï¼Œé˜²æ­¢å¹¶å‘
        const lastScheduledActivityTime = new Map(); // è®°å½•æ¯ä¸ªè§’è‰²ä¸Šæ¬¡å®šæ—¶è‡ªä¸»æ´»åŠ¨çš„æ—¶é—´æˆ³
        const autoMomentsLocks = new Set(); // å­˜å‚¨æ­£åœ¨ç”Ÿæˆæœ‹å‹åœˆçš„ charIdï¼Œé˜²æ­¢å¹¶å‘
        const lastMomentsPostTime = new Map(); // è®°å½•æ¯ä¸ªè§’è‰²ä¸Šæ¬¡å‘æœ‹å‹åœˆçš„æ—¶é—´
        const nextMomentsTriggerTime = new Map(); // ğŸ”§ è®°å½•æ¯ä¸ªè§’è‰²ä¸‹æ¬¡åº”è¯¥å‘æœ‹å‹åœˆçš„ç¡®å®šæ—¶é—´ç‚¹
        let deviceBatteryLevel = null; // ç”¨æˆ·è®¾å¤‡çœŸå®ç”µé‡ (0-100)
        let deviceBatteryCharging = false; // æ˜¯å¦æ­£åœ¨å……ç”µ
        let lowBatteryShownThisSession = new Set(); // è®°å½•æœ¬æ¬¡ä¼šè¯å·²æé†’è¿‡çš„èŠå¤©ï¼Œé¿å…é‡å¤å¼¹
        // è®°å½•å·²çŸ¥çš„é€šçŸ¥IDï¼Œç”¨äºåˆ¤æ–­æ–°æ¶ˆæ¯
        let knownNotifIds = new Set();
        let isFirstLoad = true;
        // ç¼“å­˜æœ€æ–°ä¸€æ¡é€šçŸ¥ï¼Œç”¨äºå®šæ—¶å¼¹çª—æ–‡æ¡ˆ
        let latestNotification = null;

        // --- èŠå¤©äº¤äº’å…¨å±€å˜é‡ ---
        let longPressTimer = null;
        let isLongPress = false;
        let activeMsgIndex = -1; // å½“å‰æ“ä½œçš„æ¶ˆæ¯ç´¢å¼•
        let isSelectionMode = false;
        let selectedIndices = new Set(); // é€‰ä¸­çš„æ¶ˆæ¯ç´¢å¼•é›†åˆ

        // å…¨å±€å˜é‡ï¼šè¡¨æƒ…åŒ…ç®¡ç†
        let currentStickerCategoryId = null;

        // æ‰‹åŠ¨è§¦å‘æ¨é€è®¢é˜…ï¼ˆæ–°å¢å‡½æ•°ï¼‰
        async function manualSubscribePush() {
            console.log('[Manual] æ‰‹åŠ¨è§¦å‘æ¨é€è®¢é˜…...');
            showDebugToast('æ­£åœ¨æ³¨å†Œæ¨é€...', true);
            
            try {
                await registerServiceWorkerAndSubscribe();
                alert('âœ… æ¨é€è®¢é˜…æˆåŠŸï¼è¯·æŸ¥çœ‹è¯Šæ–­é¢æ¿ç¡®è®¤çŠ¶æ€ã€‚');
            } catch (err) {
                console.error('[Manual] è®¢é˜…å¤±è´¥:', err);
                alert('âŒ è®¢é˜…å¤±è´¥: ' + err.message);
            }
        }

        // ===== å›¾ç‰‡å‹ç¼©å·¥å…·å‡½æ•° =====
        function compressImage(dataUrl, maxWidth = 800, quality = 0.75) {
            return new Promise((resolve) => {
                // å¦‚æœä¸æ˜¯base64æˆ–ä½“ç§¯å¾ˆå°ï¼Œç›´æ¥è¿”å›
                if (!dataUrl || !dataUrl.startsWith('data:image')) {
                    resolve(dataUrl);
                    return;
                }
                const img = new Image();
                img.onload = () => {
                    let w = img.width, h = img.height;
                    if (w > maxWidth) {
                        h = Math.round(h * maxWidth / w);
                        w = maxWidth;
                    }
                    const canvas = document.createElement('canvas');
                    canvas.width = w;
                    canvas.height = h;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, w, h);
                    const compressed = canvas.toDataURL('image/jpeg', quality);
                    // å¦‚æœå‹ç¼©ååè€Œæ›´å¤§ï¼Œè¿”å›åŸå›¾
                    resolve(compressed.length < dataUrl.length ? compressed : dataUrl);
                };
                img.onerror = () => resolve(dataUrl);
                img.src = dataUrl;
            });
        }

        // é¡µé¢åŠ è½½åˆå§‹åŒ– â€” DOMå°±ç»ªåç«‹å³å¯åŠ¨ï¼Œä¸ç­‰å›¾ç‰‡ç­‰èµ„æº
        // âœ… åŠ è½½è¿›åº¦æ¡æ§åˆ¶
        function _setLoadingProgress(percent) {
            const bar = document.getElementById('app-loading-bar');
            if (bar) bar.style.width = Math.min(percent, 100) + '%';
        }
        function _dismissLoadingScreen() {
            const screen = document.getElementById('app-loading-screen');
            const homePage = document.getElementById('home-page');
            if (homePage) homePage.style.opacity = '1';
            if (screen) {
                screen.style.opacity = '0';
                setTimeout(() => { screen.style.display = 'none'; }, 500);
            }
        }

        document.addEventListener('DOMContentLoaded', async function() {
            _setLoadingProgress(5);
            
            // ========== è¯·æ±‚æŒä¹…åŒ–å­˜å‚¨ï¼Œé˜²æ­¢æµè§ˆå™¨è‡ªåŠ¨æ¸…ç†æ•°æ® ==========
            if (navigator.storage && navigator.storage.persist) {
                navigator.storage.persist().then(granted => {
                    if (granted) {
                        console.log('[Storage] âœ“ å·²è·å¾—æŒä¹…åŒ–å­˜å‚¨æƒé™');
                    } else {
                        console.warn('[Storage] âœ— æŒä¹…åŒ–å­˜å‚¨è¯·æ±‚è¢«æ‹’ç»ï¼Œæµè§ˆå™¨å¯èƒ½åœ¨å­˜å‚¨å‹åŠ›æ—¶è‡ªåŠ¨æ¸…ç†æ•°æ®');
                    }
                }).catch(e => {
                    console.warn('[Storage] æŒä¹…åŒ–å­˜å‚¨è¯·æ±‚å¤±è´¥:', e);
                });
            }

            _setLoadingProgress(15);

            // ========== ç¬¬ä¸€é˜¶æ®µï¼šç•Œé¢æ¢å¤ ==========
            checkFirstVisitDisclaimer();
            checkUpdateNotice();
            
            _setLoadingProgress(25);
            
            // æ¡Œé¢å¸ƒå±€å’Œè®¾ç½®æ¢å¤ â€” å¹¶è¡Œæ‰§è¡ŒåŠ å¿«é€Ÿåº¦
            await Promise.all([
                restoreDesktopOrder(),
                restoreSetting()
            ]);
            
            _setLoadingProgress(50);
            
            initDesktopDrag();
            syncPreview();
            
            // è¯»å–å¼€å…³çŠ¶æ€ï¼ˆåŒæ­¥æ“ä½œï¼Œå¾ˆå¿«ï¼‰
            const notifEnabled = localStorage.getItem('notification_enabled') === 'true';
            const debugEnabled = localStorage.getItem('debug_mode_enabled') === 'true';
            const keepaliveEnabled = localStorage.getItem('keepalive_enabled') === 'true';
            
            const notifSwitch = document.getElementById('notif-switch');
            const debugSwitch = document.getElementById('debug-switch');
            const keepaliveSwitch = document.getElementById('keepalive-switch');
            if (notifSwitch) notifSwitch.checked = notifEnabled;
            if (debugSwitch) debugSwitch.checked = debugEnabled;
            if (keepaliveSwitch) keepaliveSwitch.checked = keepaliveEnabled;
            
            // åŒæ­¥ç§»åŠ¨ç«¯æ§åˆ¶å°å¼€å…³çŠ¶æ€
            const mcConsoleSwitch = document.getElementById('mc-console-switch');
            if (mcConsoleSwitch) mcConsoleSwitch.checked = localStorage.getItem('mc_console_enabled') === 'true';
            
            // å¦‚æœä¿æ´»å·²å¼€å¯ï¼Œç­‰å¾…ç”¨æˆ·äº¤äº’åå¯åŠ¨
            if (keepaliveEnabled) {
                console.log('[Init] ä¿æ´»å·²å¯ç”¨ï¼Œç­‰å¾…ç”¨æˆ·äº¤äº’...');
                document.addEventListener('click', function initKeepAlive() {
                    startKeepAlive();
                    document.removeEventListener('click', initKeepAlive);
                }, { once: true });
            }
            
            _setLoadingProgress(60);
            
            // ========== ç¬¬äºŒé˜¶æ®µï¼šæ ¸å¿ƒæ•°æ®åŠ è½½ï¼ˆåœ¨æ˜¾ç¤ºæ¡Œé¢å‰å®Œæˆï¼‰ ==========
            try {
                // æ•°æ®è¿ç§»ï¼ˆåªåœ¨é¦–æ¬¡è¿è¡Œæ—¶æœ‰å®é™…å·¥ä½œé‡ï¼‰
                await migrateAccountData();
                _setLoadingProgress(70);
                await migratePhoneAndSmsToIndexedDB();
                await migrateOfflineAndFinanceToIndexedDB();
                
                _setLoadingProgress(80);
                
                // ğŸ›¡ï¸ æ¢å¤ä¸Šæ¬¡é¡µé¢å…³é—­æ—¶æœªä¿å­˜çš„ç´§æ€¥æ•°æ®
                await recoverEmergencyDirtySaves();
                
                // åŠ è½½è¡£æŸœäººç‰©
                await loadWardrobeCharacter();
                
                _setLoadingProgress(90);
                
                // é¢„åŠ è½½APIé…ç½®åˆ°å†…å­˜ç¼“å­˜
                try {
                    const [urlItem, keyItem, modelItem, tempItem] = await Promise.all([
                        db.dexiData.get('aiBaseUrl'),
                        db.dexiData.get('aiApiKey'),
                        db.dexiData.get('aiCurrentModel'),
                        db.dexiData.get('aiTemperature')
                    ]);
                    if (urlItem?.value || keyItem?.value || modelItem?.value) {
                        _apiConfigCache = {
                            url: urlItem?.value || '',
                            key: keyItem?.value || '',
                            model: modelItem?.value || '',
                            temp: tempItem?.value || '0.7'
                        };
                        console.log('[APIç¼“å­˜] âœ… å·²é¢„åŠ è½½APIé…ç½®åˆ°å†…å­˜');
                    }
                } catch (e) {
                    console.warn('[APIç¼“å­˜] é¢„åŠ è½½å¤±è´¥:', e.message);
                }
                
                // é¢„åŠ è½½å‰¯APIé…ç½®åˆ°å†…å­˜ç¼“å­˜
                try {
                    const [secUrl, secKey, secModel] = await Promise.all([
                        db.dexiData.get('secondaryAiBaseUrl'),
                        db.dexiData.get('secondaryAiApiKey'),
                        db.dexiData.get('secondaryAiModel')
                    ]);
                    if (secUrl?.value || secKey?.value || secModel?.value) {
                        _secondaryApiConfigCache = {
                            url: secUrl?.value || '',
                            key: secKey?.value || '',
                            model: secModel?.value || ''
                        };
                        console.log('[å‰¯APIç¼“å­˜] âœ… å·²é¢„åŠ è½½å‰¯APIé…ç½®åˆ°å†…å­˜');
                    }
                } catch (e) {
                    console.warn('[å‰¯APIç¼“å­˜] é¢„åŠ è½½å¤±è´¥:', e.message);
                }
            } catch (initErr) {
                console.error('[Init] æ ¸å¿ƒæ•°æ®åŠ è½½å‡ºé”™:', initErr);
            }
            
            _setLoadingProgress(100);
            
            // âœ… æ‰€æœ‰æ ¸å¿ƒæ•°æ®åŠ è½½å®Œæ¯•ï¼Œæ˜¾ç¤ºæ¡Œé¢
            setTimeout(() => {
                _dismissLoadingScreen();
                console.log('[Init] âœ… åŠ è½½å®Œæˆï¼Œè¿›å…¥æ¡Œé¢');
            }, 300); // ç»™è¿›åº¦æ¡åŠ¨ç”»ç•™300ms
            
            // ========== ç¬¬ä¸‰é˜¶æ®µï¼šä½ä¼˜å…ˆçº§åå°æœåŠ¡ï¼ˆæ¡Œé¢æ˜¾ç¤ºåå¼‚æ­¥æ‰§è¡Œï¼‰ ==========
            setTimeout(() => {
                // è¯·æ±‚é€šçŸ¥æƒé™
                if ('Notification' in window && Notification.permission === 'default') {
                    console.log('[é€šçŸ¥] è¯·æ±‚é€šçŸ¥æƒé™...');
                    Notification.requestPermission().then(permission => {
                        console.log('[é€šçŸ¥] æƒé™ç»“æœ:', permission);
                        if (permission === 'granted') {
                            showDebugToast('âœ“ é€šçŸ¥æƒé™å·²æˆäºˆ', true);
                        }
                    });
                }
                
                // é€šçŸ¥è½®è¯¢
                if (notifEnabled) {
                    startNotificationLoop(15);
                }
                
                // Service Worker æ³¨å†Œ
                if (location.protocol === 'https:' || location.hostname === 'localhost') {
                    console.log('[Init] æ³¨å†Œ Service Worker å’Œè®¢é˜…æ¨é€...');
                    registerServiceWorkerAndSubscribe().catch(e => {
                        console.warn('[SW] æ³¨å†Œå¤±è´¥:', e.message);
                    });
                }
            }, 800);
            
            setTimeout(() => {
                startAutoChatLoop(); // ä¸»åŠ¨èŠå¤©æ£€æµ‹
            }, 1000);
            
            setTimeout(() => {
                initBatteryMonitor(); // ç”µé‡ç›‘æµ‹
            }, 1200);
            
            setTimeout(() => {
                initOnlineSystem(); // è”æœºç³»ç»Ÿ
            }, 1400);
        });

        // --- çº¯å‰ç«¯æ¨¡å¼ï¼šæ‰€æœ‰æ•°æ®å­˜å‚¨åœ¨æœ¬åœ° ---
        // å·²ç§»é™¤åç«¯ä¾èµ–ï¼Œé€šçŸ¥ã€è§’è‰²ã€èŠå¤©è®°å½•å…¨éƒ¨ä½¿ç”¨ IndexedDB å­˜å‚¨
        console.log('[Config] çº¯å‰ç«¯æ¨¡å¼ï¼šæ— éœ€åç«¯æœåŠ¡');
        console.log('[Config] æ‰€æœ‰æ•°æ®å­˜å‚¨åœ¨æœ¬åœ° IndexedDB');

        // å¯åŠ¨è½®è¯¢
        function startNotificationLoop(seconds) {
            if (notifTimer) clearInterval(notifTimer);

            const loopTask = () => {
                fetchNotifications();
            };
            
            console.log(`[Notification] Polling started, checking every ${seconds}s`);
            showDebugToast(`é€šçŸ¥è½®è¯¢: æ¯${seconds}ç§’æ£€æŸ¥`, true);
            
            loopTask(); // ç«‹å³æ‰§è¡Œä¸€æ¬¡
            notifTimer = setInterval(loopTask, seconds * 1000);
        }

        // åˆ‡æ¢é€šçŸ¥æƒé™
        function toggleNotification(checkbox) {
            const enabled = checkbox.checked;
            localStorage.setItem('notification_enabled', enabled);
            if (enabled) {
                // è¯·æ±‚æµè§ˆå™¨ç³»ç»Ÿé€šçŸ¥æƒé™
                if ("Notification" in window) {
                    Notification.requestPermission().then(permission => {
                        if (permission === "granted") {
                            new Notification("ç³»ç»Ÿé€šçŸ¥å·²å¼€å¯", { body: "å³ä½¿åœ¨åå°ï¼Œæ‚¨ä¹Ÿèƒ½æ”¶åˆ°æ–°æ¶ˆæ¯æé†’äº†~" });
                        } else {
                            alert("è¯·åœ¨æµè§ˆå™¨å¼¹çª—ä¸­ç‚¹å‡»ã€å…è®¸ã€‘ï¼Œå¦åˆ™æ— æ³•æ”¶åˆ°ç³»ç»Ÿé€šçŸ¥å“¦ï¼");
                        }
                    });
                }
                startNotificationLoop(15); // 15ç§’æ£€æŸ¥
            } else {
                if (notifTimer) clearInterval(notifTimer);
                document.getElementById('notif-badge').style.display = 'none';
            }
        }

        // æµ‹è¯•é€šçŸ¥åŠŸèƒ½
        function testNotification() {
            console.log('[Test] Testing notification system...');
            console.log('[Test] Browser supports Notification:', "Notification" in window);
            console.log('[Test] Current permission:', Notification.permission);
            console.log('[Test] Page visibility:', document.visibilityState);
            console.log('[Test] Page hidden:', document.hidden);
            
            if (!("Notification" in window)) {
                alert("ä½ çš„æµè§ˆå™¨ä¸æ”¯æŒç³»ç»Ÿé€šçŸ¥åŠŸèƒ½");
                return;
            }
            
            if (Notification.permission === "denied") {
                alert("é€šçŸ¥æƒé™å·²è¢«æ‹’ç»ï¼Œè¯·åœ¨æµè§ˆå™¨è®¾ç½®ä¸­å…è®¸é€šçŸ¥æƒé™ååˆ·æ–°é¡µé¢");
                return;
            }
            
            if (Notification.permission === "granted") {
                // ç«‹å³å‘é€ç¬¬ä¸€æ¡é€šçŸ¥
                new Notification("æµ‹è¯•é€šçŸ¥", {
                    body: "å¦‚æœä½ èƒ½çœ‹åˆ°è¿™æ¡é€šçŸ¥ï¼Œè¯´æ˜ç³»ç»Ÿé€šçŸ¥åŠŸèƒ½æ­£å¸¸ï¼",
                    icon: 'https://img.heliar.top/file/1770541813634_æ— æ ‡é¢˜434_20260208170943.png'
                });
                showDebugToast("âœ“ ç«‹å³å‘é€é€šçŸ¥ï¼5ç§’åå†å‘ä¸€æ¡", true);
                
                // 5ç§’åå‘é€ç¬¬äºŒæ¡é€šçŸ¥
                setTimeout(() => {
                    new Notification("å»¶è¿Ÿæµ‹è¯•é€šçŸ¥", {
                        body: "è¿™æ˜¯5ç§’åå‘é€çš„é€šçŸ¥ï¼Œå¦‚æœåœ¨åå°ä¹Ÿèƒ½æ”¶åˆ°ï¼Œè¯´æ˜åå°æ¨é€æ­£å¸¸ï¼",
                        icon: 'https://img.heliar.top/file/1770541813634_æ— æ ‡é¢˜434_20260208170943.png',
                        tag: 'delayed-test'
                    });
                    showDebugToast("âœ“ 5ç§’å»¶è¿Ÿé€šçŸ¥å·²å‘é€ï¼", true);
                    console.log('[Test] 5ç§’å»¶è¿Ÿé€šçŸ¥å·²å‘é€');
                }, 5000);
                
            } else {
                Notification.requestPermission().then(permission => {
                    console.log('[Test] Permission request result:', permission);
                    if (permission === "granted") {
                        new Notification("æµ‹è¯•é€šçŸ¥", {
                            body: "æƒé™å·²æˆäºˆï¼ç³»ç»Ÿé€šçŸ¥åŠŸèƒ½æ­£å¸¸å·¥ä½œ",
                            icon: 'https://img.heliar.top/file/1770541813634_æ— æ ‡é¢˜434_20260208170943.png'
                        });
                        showDebugToast("âœ“ æƒé™å·²æˆäºˆï¼é€šçŸ¥å·²å‘é€", true);
                    } else {
                        alert("é€šçŸ¥æƒé™è¢«æ‹’ç»ï¼Œæ— æ³•å‘é€é€šçŸ¥");
                    }
                });
            }
        }

        // åˆ‡æ¢è°ƒè¯•æ¨¡å¼
        function toggleDebugMode(checkbox) {
            const enabled = checkbox.checked;
            localStorage.setItem('debug_mode_enabled', enabled);
            if (enabled) {
                showDebugToast('è°ƒè¯•æ¨¡å¼å·²å¼€å¯');
            }
        }

        // --- Web Worker ä¿æ´»æœºåˆ¶ (æ¥è‡ª pwa) ---
        // é€šè¿‡ Blob åˆ›å»ºå†…è” Workerï¼Œåå°æ—¶ Worker çš„ setInterval ä¸å—æµè§ˆå™¨èŠ‚æµé™åˆ¶
        let keepAliveWorker = null;
        try {
            const workerCode = `
                let tickInterval = null;
                self.onmessage = function(e) {
                    if (e.data === 'start') {
                        if (tickInterval) clearInterval(tickInterval);
                        console.log('[Worker] ä¿æ´»å¿ƒè·³å·²å¯åŠ¨');
                        tickInterval = setInterval(() => {
                            self.postMessage('tick');
                        }, 5000); // 5ç§’å¿ƒè·³ï¼ŒWorker ä¸å—åå°èŠ‚æµ
                    } else if (e.data === 'stop') {
                        if (tickInterval) { clearInterval(tickInterval); tickInterval = null; }
                    }
                };
            `;
            const blob = new Blob([workerCode], {type: 'application/javascript'});
            const workerUrl = URL.createObjectURL(blob);
            keepAliveWorker = new Worker(workerUrl);
            
            // Worker æ¯5ç§’å‘ä¸€ä¸ª tickï¼Œæ”¶åˆ°åæ£€æŸ¥æ˜¯å¦éœ€è¦è§¦å‘ä¸»åŠ¨èŠå¤©
            let lastWorkerCheckTime = 0;
            keepAliveWorker.onmessage = function(e) {
                if (e.data === 'tick') {
                    const now = Date.now();
                    // æ¯15ç§’æ£€æŸ¥ä¸€æ¬¡ï¼ˆä¸åŸæ¥çš„ syncTimer é—´éš”ä¸€è‡´ï¼‰
                    if (now - lastWorkerCheckTime >= 15000) {
                        lastWorkerCheckTime = now;
                        // è°ƒç”¨ä¸»åŠ¨èŠå¤©æ£€æŸ¥ï¼ˆå¦‚æœå‡½æ•°å·²å®šä¹‰ï¼‰
                        if (typeof checkAutoChat === 'function') {
                            checkAutoChat();
                        }
                        if (typeof checkAutoMoments === 'function') {
                            checkAutoMoments();
                        }
                        if (typeof checkScheduledActivity === 'function') {
                            checkScheduledActivity();
                        }
                    }
                }
            };
            
            keepAliveWorker.postMessage('start');
            console.log('[KeepAlive] âœ… Worker ä¿æ´»å¿ƒè·³å·²å¯åŠ¨ï¼ˆåå°ä¸è¢«èŠ‚æµï¼‰');
        } catch (e) {
            console.warn('[KeepAlive] âŒ æ— æ³•å¯åŠ¨ Worker ä¿æ´»:', e);
        }

        // --- å¼ºåŠ›ä¿æ´»åŠŸèƒ½ ---
        let keepAliveAudio = null;

        // åˆ‡æ¢ä¿æ´»åŠŸèƒ½
        function toggleKeepAlive(checkbox) {
            const enabled = checkbox.checked;
            localStorage.setItem('keepalive_enabled', enabled);
            
            if (enabled) {
                startKeepAlive();
            } else {
                stopKeepAlive();
            }
        }

        // å¯åŠ¨ä¿æ´»
        async function startKeepAlive() {
            if (!keepAliveAudio) {
                keepAliveAudio = document.getElementById('keepalive-audio');
            }
            
            try {
                // è®¾ç½®éŸ³é‡ä¸º0ï¼ˆé™éŸ³ï¼‰
                keepAliveAudio.volume = 0;
                
                // å°è¯•æ’­æ”¾
                await keepAliveAudio.play();
                console.log('[KeepAlive] âœ“ ä¿æ´»éŸ³é¢‘å·²å¯åŠ¨');
                showDebugToast('âœ“ å¼ºåŠ›ä¿æ´»å·²å¯åŠ¨', true);
                addLog('success', 'å¼ºåŠ›ä¿æ´»å·²å¯åŠ¨');
                
                // ç›‘å¬æ’­æ”¾é”™è¯¯
                keepAliveAudio.onerror = (e) => {
                    console.error('[KeepAlive] éŸ³é¢‘æ’­æ”¾é”™è¯¯:', e);
                    showDebugToast('âœ— ä¿æ´»éŸ³é¢‘åŠ è½½å¤±è´¥');
                    addLog('error', 'ä¿æ´»éŸ³é¢‘åŠ è½½å¤±è´¥', e);
                };
                
            } catch (err) {
                console.error('[KeepAlive] å¯åŠ¨å¤±è´¥:', err);
                showDebugToast('âš ï¸ éœ€è¦ç”¨æˆ·äº¤äº’æ‰èƒ½å¯åŠ¨');
                addLog('warning', 'ä¿æ´»å¯åŠ¨å¤±è´¥ï¼Œéœ€è¦ç”¨æˆ·äº¤äº’', err);
                
                // ç­‰å¾…ç”¨æˆ·ç‚¹å‡»åé‡è¯•
                document.addEventListener('click', function retryKeepAlive() {
                    startKeepAlive();
                    document.removeEventListener('click', retryKeepAlive);
                }, { once: true });
            }
        }

        // åœæ­¢ä¿æ´»
        function stopKeepAlive() {
            if (keepAliveAudio) {
                keepAliveAudio.pause();
                keepAliveAudio.currentTime = 0;
                console.log('[KeepAlive] âœ“ ä¿æ´»å·²åœæ­¢');
                showDebugToast('âœ“ ä¿æ´»å·²åœæ­¢');
                addLog('info', 'å¼ºåŠ›ä¿æ´»å·²åœæ­¢');
            }
        }

        // æ˜¾ç¤ºè°ƒè¯•Toastï¼ˆåœ¨æ‰‹æœºä¸Šå¯è§ï¼‰
        let toastTimer = null;
        function showDebugToast(message, forceShow = false) {
            // æ£€æŸ¥æ˜¯å¦å¼€å¯è°ƒè¯•æ¨¡å¼ï¼ˆæµ‹è¯•é€šçŸ¥æ—¶å¼ºåˆ¶æ˜¾ç¤ºï¼‰
            const debugEnabled = localStorage.getItem('debug_mode_enabled') === 'true';
            if (!debugEnabled && !forceShow) {
                return;
            }
            
            // åˆ›å»ºæˆ–è·å–toastå…ƒç´ 
            let toast = document.getElementById('debug-toast');
            if (!toast) {
                toast = document.createElement('div');
                toast.id = 'debug-toast';
                toast.className = 'debug-toast';
                document.body.appendChild(toast);
            }
            
            // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
            if (toastTimer) clearTimeout(toastTimer);
            
            // æ˜¾ç¤ºæ¶ˆæ¯
            toast.innerText = message;
            toast.classList.add('show');
            
            // 3ç§’åéšè—
            toastTimer = setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // API é”™è¯¯æç¤ºå¼¹çª—
        let apiErrorTimer = null;
        function showApiErrorToast(errorMessage) {
            // åˆ›å»ºæˆ–è·å–å¼¹çª—å…ƒç´ 
            let toast = document.getElementById('api-error-toast');
            if (!toast) {
                toast = document.createElement('div');
                toast.id = 'api-error-toast';
                toast.className = 'api-error-toast';
                document.body.appendChild(toast);
            }
            
            // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
            if (apiErrorTimer) clearTimeout(apiErrorTimer);
            
            // æ„å»ºé”™è¯¯æç¤ºå†…å®¹
            toast.innerHTML = `
                <div class="error-icon">âš ï¸</div>
                <div class="error-title">è¯·æ±‚å¤±è´¥</div>
                <div class="error-msg">${errorMessage}</div>
            `;
            toast.classList.add('show');
            
            // 4ç§’åè‡ªåŠ¨éšè—
            apiErrorTimer = setTimeout(() => {
                toast.classList.remove('show');
            }, 4000);
            
            // ç‚¹å‡»å…³é—­
            toast.style.pointerEvents = 'auto';
            toast.onclick = () => {
                toast.classList.remove('show');
                if (apiErrorTimer) clearTimeout(apiErrorTimer);
            };
        }

        // å…¨å±€æ—¥å¿—ç³»ç»Ÿ
        const systemLogs = [];
        const MAX_LOGS = 100;
        
        function addLog(type, message, data = null) {
            const log = {
                time: new Date().toLocaleTimeString(),
                type: type, // 'info', 'success', 'warning', 'error'
                message: message,
                data: data
            };
            systemLogs.unshift(log);
            if (systemLogs.length > MAX_LOGS) systemLogs.pop();
            
            // å¦‚æœè¯Šæ–­é¢æ¿æ‰“å¼€ï¼Œå®æ—¶æ›´æ–°
            const logContainer = document.getElementById('diagnostic-logs');
            if (logContainer) {
                renderLogs();
            }
        }
        
        function renderLogs() {
            const container = document.getElementById('diagnostic-logs');
            if (!container) return;
            
            container.innerHTML = systemLogs.map(log => {
                const colors = {
                    info: '#007aff',
                    success: '#34c759',
                    warning: '#ff9500',
                    error: '#ff3b30'
                };
                const icons = {
                    info: 'â„¹ï¸',
                    success: 'âœ…',
                    warning: 'âš ï¸',
                    error: 'âŒ'
                };
                
                return `
                    <div style="padding:8px; border-bottom:1px solid #eee; font-size:12px;">
                        <div style="display:flex; justify-content:space-between; margin-bottom:4px;">
                            <span style="color:${colors[log.type]}; font-weight:bold;">${icons[log.type]} ${log.type.toUpperCase()}</span>
                            <span style="color:#999;">${log.time}</span>
                        </div>
                        <div style="color:#333;">${log.message}</div>
                        ${log.data ? `<pre style="background:#f5f5f5; padding:4px; border-radius:4px; margin-top:4px; font-size:10px; overflow-x:auto;">${JSON.stringify(log.data, null, 2)}</pre>` : ''}
                    </div>
                `;
            }).join('');
        }
        
        // æ˜¾ç¤ºè¯Šæ–­é¢æ¿
        async function showDiagnosticPanel() {
            const panel = document.createElement('div');
            panel.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                z-index: 9999;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                border-radius: 12px;
                padding: 20px;
                max-width: 500px;
                width: 100%;
                max-height: 80vh;
                overflow-y: auto;
            `;
            
            // è·å–è¯Šæ–­ä¿¡æ¯
            let diagnosticInfo = `<h2 style="margin-top:0; color:#333;">ğŸ” è¯Šæ–­ä¿¡æ¯</h2>`;
            
            // 1. User ID
            diagnosticInfo += `<div style="margin-bottom:20px; padding:10px; background:#f5f5f5; border-radius:8px;">
                <strong style="color:#007aff;">User ID:</strong><br>
                <code style="background:#fff; padding:5px; border-radius:4px; display:block; margin-top:5px; word-break:break-all;">${currentUserId}</code>
            </div>`;
            
            // 2. æ£€æŸ¥ Service Worker
            let swStatus = 'âŒ æœªæ³¨å†Œ';
            if ('serviceWorker' in navigator) {
                const registration = await navigator.serviceWorker.getRegistration();
                if (registration) {
                    swStatus = 'âœ… å·²æ³¨å†Œ';
                    if (registration.active) {
                        swStatus += ' (æ¿€æ´»)';
                    }
                }
            }
            diagnosticInfo += `<div style="margin-bottom:20px; padding:10px; background:#f5f5f5; border-radius:8px;">
                <strong style="color:#007aff;">Service Worker:</strong><br>
                <span style="margin-top:5px; display:block;">${swStatus}</span>
            </div>`;
            
            // 3. æ¨é€è®¢é˜…çŠ¶æ€
            let subStatus = 'âŒ æœªè®¢é˜…';
            let subEndpoint = 'æ— ';
            if ('serviceWorker' in navigator && 'PushManager' in window) {
                const registration = await navigator.serviceWorker.getRegistration();
                if (registration) {
                    const subscription = await registration.pushManager.getSubscription();
                    if (subscription) {
                        subStatus = 'âœ… å·²è®¢é˜…';
                        subEndpoint = subscription.endpoint.substring(0, 50) + '...';
                    }
                }
            }
            diagnosticInfo += `<div style="margin-bottom:20px; padding:10px; background:#f5f5f5; border-radius:8px;">
                <strong style="color:#007aff;">æ¨é€è®¢é˜…:</strong><br>
                <span style="margin-top:5px; display:block;">${subStatus}</span>
                <code style="background:#fff; padding:5px; border-radius:4px; display:block; margin-top:5px; font-size:10px; word-break:break-all;">${subEndpoint}</code>
            </div>`;
            
            // 4. é€šçŸ¥æƒé™
            const notifPerm = Notification.permission;
            const permIcon = notifPerm === 'granted' ? 'âœ…' : notifPerm === 'denied' ? 'âŒ' : 'âš ï¸';
            diagnosticInfo += `<div style="margin-bottom:20px; padding:10px; background:#f5f5f5; border-radius:8px;">
                <strong style="color:#007aff;">é€šçŸ¥æƒé™:</strong><br>
                <span style="margin-top:5px; display:block;">${permIcon} ${notifPerm}</span>
            </div>`;
            
            // 5. ç¯å¢ƒä¿¡æ¯
            diagnosticInfo += `<div style="margin-bottom:20px; padding:10px; background:#f5f5f5; border-radius:8px;">
                <strong style="color:#007aff;">ç¯å¢ƒä¿¡æ¯:</strong><br>
                <span style="margin-top:5px; display:block;">åè®®: ${location.protocol}</span>
                <span style="display:block;">åŸŸå: ${location.hostname}</span>
                <span style="display:block;">æ¨¡å¼: çº¯å‰ç«¯ï¼ˆæ— éœ€åç«¯ï¼‰</span>
            </div>`;
            
            // 6. å¼€å¯ä¸»åŠ¨èŠå¤©çš„è§’è‰²
            const autoChars = await db.characters
                .filter(c => c.auto_reply_enabled === true && c.auto_reply_interval > 0)
                .toArray();
            diagnosticInfo += `<div style="margin-bottom:20px; padding:10px; background:#f5f5f5; border-radius:8px;">
                <strong style="color:#007aff;">ä¸»åŠ¨èŠå¤©è§’è‰²:</strong><br>
                <span style="margin-top:5px; display:block;">${autoChars.length} ä¸ªè§’è‰²å·²å¯ç”¨</span>
                ${autoChars.map(c => `<div style="margin-top:5px; padding:5px; background:#fff; border-radius:4px;">
                    ${c.name} (${c.auto_reply_interval}åˆ†é’Ÿ)
                </div>`).join('')}
            </div>`;
            
            // 7. å®æ—¶æ—¥å¿—åŒºåŸŸ
            diagnosticInfo += `<div style="margin-bottom:20px;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                    <strong style="color:#007aff;">ğŸ“‹ å®æ—¶æ—¥å¿— (æœ€è¿‘${systemLogs.length}æ¡)</strong>
                    <button onclick="systemLogs.length=0; renderLogs();" style="padding:4px 8px; background:#ff3b30; color:#fff; border:none; border-radius:4px; font-size:11px;">æ¸…ç©º</button>
                </div>
                <div id="diagnostic-logs" style="max-height:300px; overflow-y:auto; background:#f9f9f9; border-radius:8px; padding:10px;">
                    ${systemLogs.length === 0 ? '<div style="text-align:center; color:#999; padding:20px;">æš‚æ— æ—¥å¿—</div>' : ''}
                </div>
            </div>`;
            
            content.innerHTML = diagnosticInfo;
            
            // æ¸²æŸ“æ—¥å¿—
            renderLogs();
            
            // å…³é—­æŒ‰é’®
            const closeBtn = document.createElement('button');
            closeBtn.innerText = 'å…³é—­';
            closeBtn.style.cssText = `
                width: 100%;
                padding: 12px;
                background: var(--ins-pink);
                color: white;
                border: none;
                border-radius: 8px;
                font-size: 16px;
                cursor: pointer;
                margin-top: 10px;
            `;
            closeBtn.onclick = () => document.body.removeChild(panel);
            content.appendChild(closeBtn);
            
            panel.appendChild(content);
            document.body.appendChild(panel);
            
            // ç‚¹å‡»èƒŒæ™¯å…³é—­
            panel.onclick = (e) => {
                if (e.target === panel) {
                    document.body.removeChild(panel);
                }
            };
        }

        // æ˜¾ç¤ºè®¾ç½®é¡µé¢
        function showSettingPage() {
            document.getElementById('setting-page').style.display = 'flex';
        }
        function hideSettingPage() {
            document.getElementById('setting-page').style.display = 'none';
        }

        // âœ… è®¾ç½®é¡µ - æ‰‹åŠ¨ä¿å­˜æ‰€æœ‰è®¾ç½®
        async function saveSettingPage() {
            try {
                // 1. ä¿å­˜ç³»ç»Ÿé€šçŸ¥ç›¸å…³å¼€å…³
                const notifSwitch = document.getElementById('notif-switch');
                const debugSwitch = document.getElementById('debug-switch');
                const keepaliveSwitch = document.getElementById('keepalive-switch');
                if (notifSwitch) localStorage.setItem('notification_enabled', notifSwitch.checked);
                if (debugSwitch) localStorage.setItem('debug_mode_enabled', debugSwitch.checked);
                if (keepaliveSwitch) localStorage.setItem('keepalive_enabled', keepaliveSwitch.checked);

                // 2. ä¿å­˜ä¸»APIè®¾ç½®
                await autoSaveApi();

                // 3. ä¿å­˜å‰¯APIè®¾ç½®
                await autoSaveSecondaryApi();

                // 4. ä¿å­˜NovelAIè®¾ç½®
                await autoSaveNovelAI();

                // 5. ä¿å­˜è”æœºè®¾ç½®
                saveOnlineSettings();

                // 6. åŒæ­¥localStorageå¤‡ä»½
                const url = document.getElementById('ai-url-input')?.value?.trim();
                const key = document.getElementById('ai-key-input')?.value?.trim();
                const model = document.getElementById('ai-model-select')?.value;
                const temp = document.getElementById('ai-temp-slider')?.value;
                if (url) localStorage.setItem('aiBaseUrl', url);
                if (key) localStorage.setItem('aiApiKey', key);
                if (model) localStorage.setItem('aiCurrentModel', model);
                if (temp) localStorage.setItem('aiTemperature', temp);

                showToast('âœ… è®¾ç½®å·²ä¿å­˜');
            } catch (e) {
                console.error('[saveSettingPage] ä¿å­˜è®¾ç½®å¤±è´¥:', e);
                showToast('âŒ ä¿å­˜å¤±è´¥: ' + e.message);
            }
        }

        // å…è´£å£°æ˜å¼¹çª—
        function showDisclaimerModal(isFirstVisit) {
            const overlay = document.createElement('div');
            overlay.id = 'disclaimer-modal';
            overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.3);display:flex;align-items:center;justify-content:center;z-index:999999;';
            if (!isFirstVisit) {
                overlay.onclick = (e) => { if (e.target === overlay) overlay.remove(); };
            }
            
            overlay.innerHTML = `
                <div style="background:#fff;border-radius:14px;width:300px;max-height:80vh;overflow-y:auto;box-shadow:0 8px 30px rgba(0,0,0,0.08);font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;">
                    <div style="padding:24px 20px 0;text-align:center;">
                        <div style="font-size:16px;font-weight:600;color:#262626;letter-spacing:0.3px;">å…è´£å£°æ˜</div>
                        <div style="font-size:11px;color:#c7c7c7;margin-top:2px;">Disclaimer</div>
                    </div>
                    <div style="padding:16px 20px;font-size:12px;color:#666;line-height:1.8;letter-spacing:0.2px;">
                        <p style="margin:0 0 10px;">1. æœ¬ç½‘é¡µä»…ä½œä¸ºå·¥å…·å¹³å°æä¾›ï¼Œä¸æä¾›ä»»ä½• AI æ¨¡å‹æœåŠ¡ã€‚æ‰€æœ‰ AI ç”Ÿæˆçš„å†…å®¹ï¼ˆåŒ…æ‹¬ä½†ä¸é™äºæ–‡å­—ã€å¯¹è¯ã€è§’è‰²è¡Œä¸ºç­‰ï¼‰å‡ç”±ç¬¬ä¸‰æ–¹ AI æœåŠ¡æä¾›å•†ç”Ÿæˆï¼Œä¸æœ¬å¹³å°åŠä½œè€…æ— å…³ã€‚</p>
                        <p style="margin:0 0 10px;">2. ç”¨æˆ·å¯¼å…¥çš„è§’è‰²å¡ã€ä¸–ç•Œä¹¦ç­‰å†…å®¹ç”±ç”¨æˆ·è‡ªè¡Œæä¾›ï¼Œæœ¬å¹³å°ä¸å¯¹å…¶åˆæ³•æ€§ã€å‡†ç¡®æ€§æˆ–é€‚å½“æ€§æ‰¿æ‹…ä»»ä½•è´£ä»»ã€‚</p>
                        <p style="margin:0 0 10px;">3. AI ç”Ÿæˆçš„æ‰€æœ‰å†…å®¹ä¸ä»£è¡¨æœ¬å¹³å°åŠä½œè€…çš„è§‚ç‚¹ä¸ç«‹åœºã€‚ç”¨æˆ·åº”è‡ªè¡Œåˆ¤æ–­å†…å®¹é€‚å½“æ€§ï¼Œå¹¶å¯¹ä½¿ç”¨åæœæ‰¿æ‹…å…¨éƒ¨è´£ä»»ã€‚</p>
                        <p style="margin:0 0 10px;">4. æœ¬å¹³å°ä¸å­˜å‚¨ã€ä¸ä¼ è¾“ç”¨æˆ·æ•°æ®è‡³å¤–éƒ¨æœåŠ¡å™¨ï¼ˆè”æœºåŠŸèƒ½é™¤å¤–ï¼‰ï¼Œæ‰€æœ‰æ•°æ®å­˜å‚¨åœ¨ç”¨æˆ·æœ¬åœ°æµè§ˆå™¨ä¸­ã€‚</p>
                        <p style="margin:0 0 10px;">5. ç”¨æˆ·åº”éµå®ˆæ‰€åœ¨åœ°åŒºæ³•å¾‹æ³•è§„ï¼Œä¸å¾—åˆ©ç”¨æœ¬å¹³å°ä»äº‹è¿æ³•è¿è§„æ´»åŠ¨ï¼Œå› ä¸å½“ä½¿ç”¨äº§ç”Ÿçš„æ³•å¾‹è´£ä»»ç”±ç”¨æˆ·è‡ªè¡Œæ‰¿æ‹…ã€‚</p>
                        <p style="margin:0;">6. ä½œè€…ä¿ç•™éšæ—¶ä¿®æ”¹ã€æš‚åœæˆ–ç»ˆæ­¢æœåŠ¡çš„æƒåˆ©ï¼Œä¸”æ— éœ€å¦è¡Œé€šçŸ¥ã€‚</p>
                    </div>
                    <div style="padding:0 20px 8px;text-align:center;">
                        <div style="width:30px;height:1px;background:#efefef;margin:0 auto 8px;"></div>
                        <div style="font-size:11px;color:#c7c7c7;">ä½œè€…ï¼šç†èŠ½ ï½œ ç‰¹åˆ«æ„Ÿè°¢ï¼šå°é‡çŒ«</div>
                    </div>
                    <div style="padding:12px 20px 20px;">
                        <div onclick="acceptDisclaimer()" style="width:100%;text-align:center;padding:12px;border-radius:10px;font-size:14px;color:#fff;background:#262626;cursor:pointer;font-weight:500;box-sizing:border-box;">
                            ${isFirstVisit ? 'æˆ‘å·²é˜…è¯»å¹¶åŒæ„' : 'å…³é—­'}
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
        }
        
        function acceptDisclaimer() {
            localStorage.setItem('disclaimer_accepted', '1');
            const modal = document.getElementById('disclaimer-modal');
            if (modal) modal.remove();
        }
        
        // é¦–æ¬¡è®¿é—®æ£€æŸ¥
        function checkFirstVisitDisclaimer() {
            if (!localStorage.getItem('disclaimer_accepted')) {
                showDisclaimerModal(true);
            }
        }

        // ===== æ›´æ–°å…¬å‘Šå¼¹çª— =====
        const UPDATE_VERSION = 'v2026-02-19'; // æ¯æ¬¡æ›´æ–°æ”¹è¿™ä¸ªç‰ˆæœ¬å·ï¼Œå°±ä¼šé‡æ–°å¼¹å‡º
        
        function checkUpdateNotice() {
            const readKey = 'update_notice_read_' + UPDATE_VERSION;
            if (localStorage.getItem(readKey)) return; // å·²è¯»è¿‡æ­¤ç‰ˆæœ¬ï¼Œä¸å†å¼¹å‡º
            showUpdateNotice();
        }
        
        function showUpdateNotice() {
            const readKey = 'update_notice_read_' + UPDATE_VERSION;
            const overlay = document.createElement('div');
            overlay.id = 'update-notice-modal';
            overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.45);display:flex;align-items:center;justify-content:center;z-index:999999;animation:fadeIn 0.25s ease-out;';
            
            overlay.innerHTML = `
                <div style="background:#fff;border-radius:16px;width:310px;max-height:80vh;overflow:hidden;box-shadow:0 12px 40px rgba(0,0,0,0.15);font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;display:flex;flex-direction:column;">
                    <div style="padding:22px 20px 0;text-align:center;">
                        <div style="font-size:17px;font-weight:700;color:#262626;letter-spacing:0.3px;">æ›´æ–°å…¬å‘Š</div>
                        <div style="font-size:11px;color:#c7c7c7;margin-top:3px;">Update Notes Â· ${UPDATE_VERSION}</div>
                    </div>
                    <div style="padding:16px 20px;font-size:13px;color:#444;line-height:1.9;letter-spacing:0.2px;overflow-y:auto;flex:1;">
                        <div style="font-size:14px;font-weight:600;color:#333;margin-bottom:8px;">2.19æ›´æ–°</div>
                        <div style="padding-left:4px;">
                            <p style="margin:0 0 4px;">1. æ–°å¢æŸ¥æ‰‹æœº/æŸ¥å²—åŠŸèƒ½ï¼Œæ”¯æŒç»™è§’è‰²å¥½å‹å‘æ¶ˆæ¯ã€ç»™è‡ªå·±å‘æ¶ˆæ¯/è½¬è´¦ã€å‘æœ‹å‹åœˆï¼Œåç»­å°†æŒç»­æ‰©å……</p>
                            <p style="margin:0 0 4px;">2. è§’è‰²æŸ¥å²—æ–°å¢ä½¿ç”¨ç”¨æˆ·è´¦å·å‘æœ‹å‹åœˆ</p>
                            <p style="margin:0 0 4px;">3. æ‹‰é»‘åˆ é™¤è§’è‰²åï¼Œè§’è‰²å¯è§¦å‘çš„è¡Œä¸ºå†…å®¹æ›´ä¸°å¯Œ</p>
                            <p style="margin:0 0 4px;">4. ä¼˜åŒ–çº¿ä¸Šçº¿ä¸‹ç›¸å…³é€»è¾‘ä¸è¡¨ç°</p>
                            <p style="margin:0 0 4px;">5. æœ‹å‹åœˆæ–°å¢åˆ é™¤åŠŸèƒ½ï¼Œä¼˜åŒ–è¯„è®ºä½“éªŒ</p>
                            <p style="margin:0 0 4px;">6. ä¸Šçº¿é»˜å¥‘ç»˜ç”»ç©æ³•</p>
                            <p style="margin:0 0 4px;">7. æ–°å¢ç®€æ˜“ç‰ˆè´­ç‰©åŠŸèƒ½ï¼ˆåŸºç¡€ç‰ˆï¼‰</p>
                        </div>
                        <div style="margin-top:12px;padding-top:10px;border-top:1px solid #f0f0f0;font-size:12px;color:#888;line-height:1.7;">
                            å¦‚æœ‰bugæ¬¢è¿åé¦ˆ
                        </div>
                    </div>
                    <div style="padding:12px 20px 20px;text-align:center;">
                        <button id="update-notice-btn" disabled onclick="dismissUpdateNotice()" style="
                            width:100%;
                            padding:12px;
                            border:none;
                            border-radius:10px;
                            font-size:15px;
                            font-weight:600;
                            cursor:not-allowed;
                            background:#e0e0e0;
                            color:#aaa;
                            transition:all 0.3s ease;
                            letter-spacing:0.5px;
                        ">è¯·é˜…è¯» (5s)</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // 5ç§’å€’è®¡æ—¶
            let countdown = 5;
            const btn = document.getElementById('update-notice-btn');
            const timer = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    btn.textContent = `è¯·é˜…è¯» (${countdown}s)`;
                } else {
                    clearInterval(timer);
                    btn.disabled = false;
                    btn.style.cursor = 'pointer';
                    btn.style.background = 'var(--ins-pink, #ff6b9d)';
                    btn.style.color = '#fff';
                    btn.textContent = 'æˆ‘å·²é˜…è¯»';
                }
            }, 1000);
        }
        
        function dismissUpdateNotice() {
            const readKey = 'update_notice_read_' + UPDATE_VERSION;
            localStorage.setItem(readKey, '1');
            const modal = document.getElementById('update-notice-modal');
            if (modal) {
                modal.style.transition = 'opacity 0.25s ease';
                modal.style.opacity = '0';
                setTimeout(() => modal.remove(), 250);
            }
        }

        // ===== æ•°æ®å¯¼å…¥å¯¼å‡ºåŠŸèƒ½ =====
        
        // æ˜¾ç¤ºå¯¼å‡ºé€‰é¡¹å¼¹çª—
        function showExportOptions() {
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 100000;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                border-radius: 12px;
                padding: 24px;
                max-width: 400px;
                width: 90%;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            `;
            
            dialog.innerHTML = `
                <h3 style="margin: 0 0 16px 0; font-size: 18px;">å¯¼å‡ºæ•°æ®é€‰é¡¹</h3>
                <p style="margin: 0 0 20px 0; font-size: 14px; color: #666;">
                    é€‰æ‹©è¦å¯¼å‡ºçš„æ•°æ®ç±»å‹ï¼ˆé»˜è®¤å¯¼å‡ºå…¨éƒ¨ï¼‰ï¼š
                </p>
                <div style="margin-bottom: 20px;">
                    <label style="display: flex; align-items: center; margin-bottom: 12px; cursor: pointer;">
                        <input type="checkbox" id="export-local-data" checked style="margin-right: 8px; width: 18px; height: 18px;">
                        <div>
                            <div style="font-weight: 500;">æœ¬åœ°å…¨éƒ¨æ•°æ®</div>
                            <div style="font-size: 12px; color: #999;">
                                åŒ…æ‹¬ï¼šè§’è‰²ã€èŠå¤©è®°å½•ã€ä¸–ç•Œä¹¦ã€è¡¨æƒ…åŒ…ã€æœ‹å‹åœˆã€ç¾¤èŠã€ç”µè¯/çŸ­ä¿¡ã€æ—¥è®°ã€éŸ³ä¹ã€å·²å®‰è£…åº”ç”¨ã€æ‰€æœ‰æœ¬åœ°è®¾ç½®ç­‰
                            </div>
                        </div>
                    </label>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="export-online-data" checked style="margin-right: 8px; width: 18px; height: 18px;">
                        <div>
                            <div style="font-weight: 500;">è”æœºè´¦å·æ•°æ®</div>
                            <div style="font-size: 12px; color: #999;">
                                åŒ…æ‹¬ï¼šè”æœºæœåŠ¡å™¨åœ°å€ã€ç™»å½•Tokenã€ç”¨æˆ·ä¿¡æ¯
                            </div>
                        </div>
                    </label>
                </div>
                <div style="display: flex; gap: 12px; justify-content: flex-end;">
                    <button id="export-cancel-btn" style="padding: 8px 16px; border: 1px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">
                        å–æ¶ˆ
                    </button>
                    <button id="export-confirm-btn" style="padding: 8px 16px; border: none; background: #07c160; color: white; border-radius: 6px; cursor: pointer;">
                        ç¡®å®šå¯¼å‡º
                    </button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // ç»‘å®šäº‹ä»¶
            document.getElementById('export-cancel-btn').onclick = () => {
                document.body.removeChild(overlay);
            };
            
            document.getElementById('export-confirm-btn').onclick = async () => {
                const includeLocal = document.getElementById('export-local-data').checked;
                const includeOnline = document.getElementById('export-online-data').checked;
                
                if (!includeLocal && !includeOnline) {
                    alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ç§æ•°æ®ç±»å‹');
                    return;
                }
                
                document.body.removeChild(overlay);
                await exportAllDataWithOptions(includeLocal, includeOnline);
            };
            
            // ç‚¹å‡»èƒŒæ™¯å…³é—­
            overlay.onclick = (e) => {
                if (e.target === overlay) {
                    document.body.removeChild(overlay);
                }
            };
        }
        
        // å¯¼å‡ºæ‰€æœ‰æ•°æ®ï¼ˆå¸¦é€‰é¡¹ï¼‰
        // é˜²é‡å¤ç‚¹å‡»æ ‡å¿—
        let _isExporting = false;
        
        async function exportAllDataWithOptions(includeLocal = true, includeOnline = true) {
            // é˜²æ­¢é‡å¤ç‚¹å‡»å¯¼è‡´å¤šæ¬¡å¹¶è¡Œå¯¼å‡º
            if (_isExporting) {
                alert('æ­£åœ¨å¯¼å‡ºä¸­ï¼Œè¯·ç¨å€™...');
                return;
            }
            _isExporting = true;
            
            // æ˜¾ç¤ºåŠ è½½é®ç½©
            const loadingOverlay = document.createElement('div');
            loadingOverlay.id = 'export-loading-overlay';
            loadingOverlay.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.5); display: flex; align-items: center;
                justify-content: center; z-index: 200000; flex-direction: column;
            `;
            loadingOverlay.innerHTML = `
                <div style="background: white; border-radius: 12px; padding: 32px 40px; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                    <div id="export-loading-spinner" style="width: 40px; height: 40px; border: 3px solid #eee; border-top: 3px solid #07c160; border-radius: 50%; animation: exportSpin 0.8s linear infinite; margin: 0 auto 16px;"></div>
                    <div id="export-loading-text" style="font-size: 15px; color: #333;">æ­£åœ¨æ”¶é›†æ•°æ®...</div>
                    <div id="export-loading-detail" style="font-size: 12px; color: #999; margin-top: 6px;"></div>
                </div>
                <style>@keyframes exportSpin { to { transform: rotate(360deg); } }</style>
            `;
            document.body.appendChild(loadingOverlay);
            
            const updateLoadingText = (text, detail) => {
                const el = document.getElementById('export-loading-text');
                const detailEl = document.getElementById('export-loading-detail');
                if (el) el.textContent = text;
                if (detailEl) detailEl.textContent = detail || '';
            };
            
            try {
                const exportData = {
                    version: '3.0',
                    exportTime: new Date().toISOString(),
                    dataTypes: {
                        local: includeLocal,
                        online: includeOnline
                    },
                    data: {}
                };
                
                let skippedLsKeys = [];
                if (includeLocal) {
                    // ===== 1. é€è¡¨å¯¼å‡ºä¸»æ•°æ®åº“ï¼Œæ¯ä¸ªè¡¨ä¹‹é—´è®©å‡ºä¸»çº¿ç¨‹é¿å…é•¿æ—¶é—´é˜»å¡ =====
                    const tables = [
                        { key: 'dexiData', table: db.dexiData, label: 'èŠå¤©æ•°æ®' },
                        { key: 'lorebooks', table: db.lorebooks, label: 'ä¸–ç•Œä¹¦' },
                        { key: 'characters', table: db.characters, label: 'è§’è‰²' },
                        { key: 'sticker_categories', table: db.sticker_categories, label: 'è¡¨æƒ…åŒ…' },
                        { key: 'moments', table: db.moments, label: 'æœ‹å‹åœˆ' },
                        { key: 'friend_requests', table: db.friend_requests, label: 'å¥½å‹è¯·æ±‚' },
                        { key: 'group_chats', table: db.group_chats, label: 'ç¾¤èŠ' },
                        { key: 'phone_recents', table: db.phone_recents, label: 'é€šè¯è®°å½•' },
                        { key: 'sms_messages', table: db.sms_messages, label: 'çŸ­ä¿¡' },
                        { key: 'chat_summaries', table: db.chat_summaries, label: 'èŠå¤©æ‘˜è¦' },
                        { key: 'avatar_library', table: db.avatar_library, label: 'å¤´åƒåº“' },
                        { key: 'avatar_categories', table: db.avatar_categories, label: 'å¤´åƒåˆ†ç±»' },
                        { key: 'chat_themes', table: db.chat_themes, label: 'èŠå¤©ä¸»é¢˜' }
                    ];
                    // å¯é€‰è¡¨
                    if (db.intimate_relations) tables.push({ key: 'intimate_relations', table: db.intimate_relations, label: 'äº²å¯†å…³ç³»' });
                    if (db.intimate_requests) tables.push({ key: 'intimate_requests', table: db.intimate_requests, label: 'äº²å¯†è¯·æ±‚' });
                    if (db.offline_chats) tables.push({ key: 'offline_chats', table: db.offline_chats, label: 'ç¦»çº¿èŠå¤©' });
                    if (db.finance_data) tables.push({ key: 'finance_data', table: db.finance_data, label: 'è´¢åŠ¡æ•°æ®' });
                    
                    for (let i = 0; i < tables.length; i++) {
                        const { key, table, label } = tables[i];
                        updateLoadingText(`æ­£åœ¨æ”¶é›†æ•°æ® (${i + 1}/${tables.length})`, `æ­£åœ¨è¯»å–: ${label}`);
                        try {
                            exportData.data[key] = await table.toArray();
                        } catch (e) {
                            console.warn(`[Export] è¡¨ ${key} å¯¼å‡ºå¤±è´¥:`, e);
                            exportData.data[key] = [];
                        }
                        // è®©å‡ºä¸»çº¿ç¨‹ï¼Œé¿å…é•¿æ—¶é—´é˜»å¡å¯¼è‡´æµè§ˆå™¨æ€æ­»é¡µé¢
                        await new Promise(r => setTimeout(r, 0));
                    }
                    
                    // ===== 2. å¯¼å‡º iCity æ—¥è®°æ•°æ®åº“ =====
                    updateLoadingText('æ­£åœ¨æ”¶é›†æ•°æ®', 'æ­£åœ¨è¯»å–: æ—¥è®°æ•°æ®');
                    try {
                        exportData.icityData = {
                            diaries: await icityDb.diaries.toArray(),
                            annotations: await icityDb.annotations.toArray()
                        };
                    } catch(e) {
                        console.warn('[Export] iCityæ•°æ®åº“å¯¼å‡ºå¤±è´¥:', e);
                    }
                    await new Promise(r => setTimeout(r, 0));
                    
                    // ===== 3. å¯¼å‡ºå·²å®‰è£…åº”ç”¨æ•°æ®åº“ =====
                    updateLoadingText('æ­£åœ¨æ”¶é›†æ•°æ®', 'æ­£åœ¨è¯»å–: å·²å®‰è£…åº”ç”¨');
                    try {
                        exportData.installedAppsData = {
                            apps: await installedAppsDb.apps.toArray()
                        };
                    } catch(e) {
                        console.warn('[Export] å·²å®‰è£…åº”ç”¨æ•°æ®åº“å¯¼å‡ºå¤±è´¥:', e);
                    }
                    await new Promise(r => setTimeout(r, 0));
                    
                    // ===== 4. å¯¼å‡ºéŸ³ä¹æ’­æ”¾å™¨æ•°æ®åº“ï¼ˆä¸å«éŸ³é¢‘æ–‡ä»¶ï¼‰ =====
                    updateLoadingText('æ­£åœ¨æ”¶é›†æ•°æ®', 'æ­£åœ¨è¯»å–: éŸ³ä¹æ•°æ®');
                    try {
                        exportData.wyyMusicData = {
                            userSettings: await wyyDb.userSettings.toArray(),
                            playlistCards: await wyyDb.playlistCards.toArray(),
                            songs: await wyyDb.songs.toArray(),
                            lyrics: await wyyDb.lyrics.toArray(),
                            playlists: await wyyDb.playlists.toArray()
                            // æ³¨æ„ï¼šsongFiles åŒ…å«éŸ³é¢‘äºŒè¿›åˆ¶æ•°æ®ï¼Œä½“ç§¯è¿‡å¤§ï¼Œä¸å¯¼å‡º
                        };
                    } catch(e) {
                        console.warn('[Export] éŸ³ä¹æ’­æ”¾å™¨æ•°æ®åº“å¯¼å‡ºå¤±è´¥:', e);
                    }
                    await new Promise(r => setTimeout(r, 0));
                    
                    // ===== 5. å¯¼å‡ºå®Œæ•´ localStorageï¼ˆå…¨é‡ï¼‰ï¼Œè·³è¿‡è¶…å¤§ base64 å€¼ =====
                    updateLoadingText('æ­£åœ¨æ”¶é›†æ•°æ®', 'æ­£åœ¨è¯»å–: æœ¬åœ°è®¾ç½®');
                    exportData.localStorage = {};
                    const MAX_LS_VALUE_SIZE = 5 * 1024 * 1024; // å•ä¸ª localStorage å€¼è¶…è¿‡ 5MB åˆ™è·³è¿‡
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        const value = localStorage.getItem(key);
                        if (value && value.length > MAX_LS_VALUE_SIZE) {
                            skippedLsKeys.push(key);
                            console.warn(`[Export] localStorage key "${key}" å€¼è¿‡å¤§(${(value.length / 1024 / 1024).toFixed(1)}MB)ï¼Œå·²è·³è¿‡`);
                            continue;
                        }
                        exportData.localStorage[key] = value;
                    }
                }
                
                if (includeOnline) {
                    exportData.onlineData = {
                        server_url: localStorage.getItem('online_server_url'),
                        token: localStorage.getItem('online_token'),
                        user_data: localStorage.getItem('online_user_data')
                    };
                }
                
                // ===== åˆ†å—åºåˆ—åŒ–ï¼šé¿å…ä¸€æ¬¡æ€§ JSON.stringify å¤§å¯¹è±¡é˜»å¡ä¸»çº¿ç¨‹ =====
                updateLoadingText('æ­£åœ¨ç”Ÿæˆæ–‡ä»¶...', 'æ•°æ®é‡è¾ƒå¤§æ—¶å¯èƒ½éœ€è¦ä¸€äº›æ—¶é—´');
                await new Promise(r => setTimeout(r, 50));
                
                // ä½¿ç”¨ JSON.stringify ä½†ä¸å¸¦ç¼©è¿›ä»¥å‡å°‘å†…å­˜å ç”¨ï¼ˆç¼©è¿›å¤§çº¦å¢åŠ  30% ä½“ç§¯ï¼‰
                let jsonString;
                try {
                    jsonString = JSON.stringify(exportData);
                } catch (stringifyError) {
                    // å¦‚æœåºåˆ—åŒ–å¤±è´¥ï¼ˆå¯èƒ½æ˜¯å¾ªç¯å¼•ç”¨æˆ–å†…å­˜ä¸è¶³ï¼‰ï¼Œå°è¯•é€ä¸ªè¡¨å¤„ç†
                    console.error('[Export] JSON.stringify å¤±è´¥ï¼Œå°è¯•ç²¾ç®€å¯¼å‡º:', stringifyError);
                    updateLoadingText('æ•°æ®é‡è¿‡å¤§ï¼Œæ­£åœ¨ç²¾ç®€å¯¼å‡º...', '');
                    
                    // å°è¯•ç§»é™¤æœ€å¤§çš„è¡¨æ•°æ®åé‡è¯•
                    if (exportData.data?.dexiData) {
                        const dexiCount = exportData.data.dexiData.length;
                        // å¦‚æœ dexiData æ¡ç›®è¿‡å¤šï¼Œåˆ†æ‰¹åºåˆ—åŒ–
                        if (dexiCount > 1000) {
                            console.warn(`[Export] dexiData æœ‰ ${dexiCount} æ¡è®°å½•ï¼Œå°è¯•ç²¾ç®€`);
                        }
                    }
                    // æœ€ç»ˆå…œåº•ï¼šä¸å¸¦ç¼©è¿›åºåˆ—åŒ–
                    jsonString = JSON.stringify(exportData);
                }
                
                // æ„é€  Blob å¹¶é‡Šæ”¾åŸå§‹æ•°æ®å¼•ç”¨
                const blob = new Blob([jsonString], { type: 'application/json' });
                jsonString = null; // é‡Šæ”¾å­—ç¬¦ä¸²å†…å­˜
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                
                let filename = 'wechat_backup_';
                if (includeLocal && includeOnline) {
                    filename += 'full_';
                } else if (includeLocal) {
                    filename += 'local_';
                } else if (includeOnline) {
                    filename += 'online_';
                }
                filename += new Date().getTime() + '.json';
                
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                // å»¶è¿Ÿé‡Šæ”¾ URL é˜²æ­¢ä¸‹è½½æœªå®Œæˆ
                setTimeout(() => URL.revokeObjectURL(url), 10000);
                
                // ç§»é™¤åŠ è½½é®ç½©
                if (document.getElementById('export-loading-overlay')) {
                    document.body.removeChild(loadingOverlay);
                }
                
                // æ˜¾ç¤ºå¯¼å‡ºçš„æ•°æ®ç»Ÿè®¡
                let stats = [];
                if (includeLocal) {
                    const charCount = exportData.data.characters?.length || 0;
                    const groupCount = exportData.data.group_chats?.length || 0;
                    const momentCount = exportData.data.moments?.length || 0;
                    const diaryCount = exportData.icityData?.diaries?.length || 0;
                    const songCount = exportData.wyyMusicData?.songs?.length || 0;
                    const lsCount = Object.keys(exportData.localStorage || {}).length;
                    stats.push(`è§’è‰²: ${charCount}ä¸ª`);
                    stats.push(`ç¾¤èŠ: ${groupCount}ä¸ª`);
                    stats.push(`æœ‹å‹åœˆ: ${momentCount}æ¡`);
                    if (diaryCount > 0) stats.push(`æ—¥è®°: ${diaryCount}ç¯‡`);
                    if (songCount > 0) stats.push(`éŸ³ä¹: ${songCount}é¦–`);
                    const intimateCount = exportData.data.intimate_relations?.length || 0;
                    if (intimateCount > 0) stats.push(`äº²å¯†å…³ç³»: ${intimateCount}æ¡`);
                    const offlineChatCount = exportData.data.offline_chats?.length || 0;
                    if (offlineChatCount > 0) stats.push(`ç¦»çº¿èŠå¤©: ${offlineChatCount}æ¡`);
                    const financeCount = exportData.data.finance_data?.length || 0;
                    if (financeCount > 0) stats.push(`è´¢åŠ¡æ•°æ®: ${financeCount}æ¡`);
                    stats.push(`æœ¬åœ°è®¾ç½®: ${lsCount}é¡¹`);
                    
                    const sizeMB = (blob.size / 1024 / 1024).toFixed(2);
                    stats.push(`æ–‡ä»¶å¤§å°: ${sizeMB}MB`);
                    
                    if (skippedLsKeys && skippedLsKeys.length > 0) {
                        stats.push(`\nâš ï¸ ${skippedLsKeys.length}ä¸ªè¿‡å¤§çš„æœ¬åœ°å­˜å‚¨é¡¹å·²è·³è¿‡`);
                    }
                }
                if (includeOnline) {
                    stats.push('è”æœºè´¦å·ä¿¡æ¯å·²åŒ…å«');
                }
                
                alert('æ•°æ®å¯¼å‡ºæˆåŠŸï¼ï¼ˆå®Œæ•´å¤‡ä»½ï¼‰\n\n' + stats.join('\n'));
            } catch (error) {
                console.error('å¯¼å‡ºæ•°æ®å¤±è´¥:', error);
                // ç§»é™¤åŠ è½½é®ç½©
                if (document.getElementById('export-loading-overlay')) {
                    document.body.removeChild(loadingOverlay);
                }
                alert('å¯¼å‡ºæ•°æ®å¤±è´¥: ' + error.message);
            } finally {
                _isExporting = false;
            }
        }
        
        // å…¼å®¹æ—§ç‰ˆæœ¬ï¼šç›´æ¥è°ƒç”¨æ—¶æ˜¾ç¤ºé€‰é¡¹
        async function exportAllData() {
            showExportOptions();
        }
        
        // å¯¼å…¥æ‰€æœ‰æ•°æ®
        async function importAllData(input) {
            const file = input.files[0];
            if (!file) return;
            
            try {
                const text = await file.text();
                const importData = JSON.parse(text);
                
                // éªŒè¯æ•°æ®æ ¼å¼
                if (!importData.version || !importData.data) {
                    throw new Error('æ•°æ®æ ¼å¼ä¸æ­£ç¡®');
                }
                
                // æ£€æµ‹æ•°æ®ç±»å‹
                const hasLocalData = importData.dataTypes?.local !== false;
                const hasOnlineData = importData.onlineData || (importData.dataTypes?.online === true);
                
                // æ˜¾ç¤ºå¯¼å…¥å†…å®¹é¢„è§ˆ
                let previewMsg = 'å³å°†å¯¼å…¥ä»¥ä¸‹æ•°æ®ï¼š\n\n';
                if (hasLocalData) {
                    const charCount = importData.data.characters?.length || 0;
                    const groupCount = importData.data.group_chats?.length || 0;
                    const momentCount = importData.data.moments?.length || 0;
                    const diaryCount = importData.icityData?.diaries?.length || 0;
                    const songCount = importData.wyyMusicData?.songs?.length || 0;
                    const lsCount = Object.keys(importData.localStorage || {}).length;
                    previewMsg += `ğŸ“± æœ¬åœ°æ•°æ®ï¼š\n`;
                    previewMsg += `  - è§’è‰²: ${charCount}ä¸ª\n`;
                    previewMsg += `  - ç¾¤èŠ: ${groupCount}ä¸ª\n`;
                    previewMsg += `  - æœ‹å‹åœˆ: ${momentCount}æ¡\n`;
                    if (diaryCount > 0) previewMsg += `  - æ—¥è®°: ${diaryCount}ç¯‡\n`;
                    if (songCount > 0) previewMsg += `  - éŸ³ä¹: ${songCount}é¦–\n`;
                    previewMsg += `  - æœ¬åœ°è®¾ç½®: ${lsCount}é¡¹\n`;
                    const intimateCount = importData.data.intimate_relations?.length || 0;
                    if (intimateCount > 0) previewMsg += `  - äº²å¯†å…³ç³»: ${intimateCount}æ¡\n`;
                    const offlineChatCount = importData.data.offline_chats?.length || 0;
                    if (offlineChatCount > 0) previewMsg += `  - ç¦»çº¿èŠå¤©: ${offlineChatCount}æ¡\n`;
                    const financeCount = importData.data.finance_data?.length || 0;
                    if (financeCount > 0) previewMsg += `  - è´¢åŠ¡æ•°æ®: ${financeCount}æ¡\n`;
                    previewMsg += `  - ä»¥åŠä¸–ç•Œä¹¦ã€è¡¨æƒ…åŒ…ã€ç”µè¯/çŸ­ä¿¡è®°å½•ç­‰\n\n`;
                }
                if (hasOnlineData) {
                    const userData = importData.onlineData?.user_data;
                    if (userData) {
                        try {
                            const userObj = JSON.parse(userData);
                            previewMsg += `ğŸŒ è”æœºè´¦å·ï¼š${userObj.username || 'æœªçŸ¥'}\n\n`;
                        } catch {
                            previewMsg += `ğŸŒ è”æœºè´¦å·æ•°æ®\n\n`;
                        }
                    } else {
                        previewMsg += `ğŸŒ è”æœºè´¦å·æ•°æ®\n\n`;
                    }
                }
                
                previewMsg += 'âš ï¸ å¯¼å…¥å°†è¦†ç›–ç°æœ‰æ•°æ®ï¼\nå»ºè®®å…ˆå¯¼å‡ºå½“å‰æ•°æ®ä½œä¸ºå¤‡ä»½ã€‚\n\næ˜¯å¦ç»§ç»­ï¼Ÿ';
                
                // ç¡®è®¤å¯¹è¯æ¡†
                if (!confirm(previewMsg)) {
                    input.value = ''; // æ¸…ç©ºæ–‡ä»¶é€‰æ‹©
                    return;
                }
                
                // æ¸…ç©ºç°æœ‰æ•°æ®
                if (hasLocalData) {
                    // æ¸…ç©ºä¸»æ•°æ®åº“æ‰€æœ‰è¡¨
                    await db.dexiData.clear();
                    await db.lorebooks.clear();
                    await db.characters.clear();
                    await db.sticker_categories.clear();
                    await db.moments.clear();
                    await db.friend_requests.clear();
                    if (db.group_chats) await db.group_chats.clear();
                    if (db.phone_recents) await db.phone_recents.clear();
                    if (db.sms_messages) await db.sms_messages.clear();
                    if (db.chat_summaries) await db.chat_summaries.clear();
                    if (db.avatar_library) await db.avatar_library.clear();
                    if (db.avatar_categories) await db.avatar_categories.clear();
                    if (db.chat_themes) await db.chat_themes.clear();
                    if (db.intimate_relations) await db.intimate_relations.clear();
                    if (db.intimate_requests) await db.intimate_requests.clear();
                    if (db.offline_chats) await db.offline_chats.clear();
                    if (db.finance_data) await db.finance_data.clear();
                    
                    // æ¸…ç©ºå­æ•°æ®åº“
                    try { await icityDb.diaries.clear(); await icityDb.annotations.clear(); } catch(e) { console.warn('[Import] æ¸…ç©ºiCityå¤±è´¥:', e); }
                    try { await installedAppsDb.apps.clear(); } catch(e) { console.warn('[Import] æ¸…ç©ºAppså¤±è´¥:', e); }
                    try {
                        await wyyDb.userSettings.clear();
                        await wyyDb.playlistCards.clear();
                        await wyyDb.songs.clear();
                        await wyyDb.songFiles.clear();
                        await wyyDb.lyrics.clear();
                        if (wyyDb.playlists) await wyyDb.playlists.clear();
                    } catch(e) { console.warn('[Import] æ¸…ç©ºéŸ³ä¹æ•°æ®åº“å¤±è´¥:', e); }
                    
                    // æ¸…ç©º localStorage
                    localStorage.clear();
                }
                
                // å¯¼å…¥æ•°æ®åº“è¡¨æ•°æ®ï¼ˆä½¿ç”¨ bulkPut æ›¿ä»£ bulkAddï¼Œé¿å…ä¸»é”®å†²çªæŠ¥é”™ï¼‰
                if (hasLocalData && importData.data) {
                    if (importData.data.dexiData) {
                        await db.dexiData.bulkPut(importData.data.dexiData);
                    }
                    if (importData.data.lorebooks) {
                        await db.lorebooks.bulkPut(importData.data.lorebooks);
                    }
                    if (importData.data.characters) {
                        await db.characters.bulkPut(importData.data.characters);
                    }
                    if (importData.data.sticker_categories) {
                        await db.sticker_categories.bulkPut(importData.data.sticker_categories);
                    }
                    if (importData.data.moments) {
                        await db.moments.bulkPut(importData.data.moments);
                    }
                    if (importData.data.friend_requests) {
                        await db.friend_requests.bulkPut(importData.data.friend_requests);
                    }
                    if (importData.data.group_chats && db.group_chats) {
                        await db.group_chats.bulkPut(importData.data.group_chats);
                    }
                    if (importData.data.phone_recents && db.phone_recents) {
                        await db.phone_recents.bulkPut(importData.data.phone_recents);
                    }
                    if (importData.data.sms_messages && db.sms_messages) {
                        await db.sms_messages.bulkPut(importData.data.sms_messages);
                    }
                    if (importData.data.chat_summaries && db.chat_summaries) {
                        await db.chat_summaries.bulkPut(importData.data.chat_summaries);
                    }
                    if (importData.data.avatar_library && db.avatar_library) {
                        await db.avatar_library.bulkPut(importData.data.avatar_library);
                    }
                    if (importData.data.avatar_categories && db.avatar_categories) {
                        await db.avatar_categories.bulkPut(importData.data.avatar_categories);
                    }
                    if (importData.data.chat_themes && db.chat_themes) {
                        await db.chat_themes.bulkPut(importData.data.chat_themes);
                    }
                    if (importData.data.intimate_relations && db.intimate_relations) {
                        await db.intimate_relations.bulkPut(importData.data.intimate_relations);
                    }
                    if (importData.data.intimate_requests && db.intimate_requests) {
                        await db.intimate_requests.bulkPut(importData.data.intimate_requests);
                    }
                    if (importData.data.offline_chats && db.offline_chats) {
                        await db.offline_chats.bulkPut(importData.data.offline_chats);
                    }
                    if (importData.data.finance_data && db.finance_data) {
                        await db.finance_data.bulkPut(importData.data.finance_data);
                    }
                    
                    // å¯¼å…¥ iCity æ—¥è®°æ•°æ®åº“
                    if (importData.icityData) {
                        try {
                            if (importData.icityData.diaries?.length > 0) {
                                await icityDb.diaries.bulkPut(importData.icityData.diaries);
                            }
                            if (importData.icityData.annotations?.length > 0) {
                                await icityDb.annotations.bulkPut(importData.icityData.annotations);
                            }
                        } catch(e) { console.warn('[Import] å¯¼å…¥iCityæ•°æ®å¤±è´¥:', e); }
                    }
                    
                    // å¯¼å…¥å·²å®‰è£…åº”ç”¨æ•°æ®åº“
                    if (importData.installedAppsData) {
                        try {
                            if (importData.installedAppsData.apps?.length > 0) {
                                await installedAppsDb.apps.bulkPut(importData.installedAppsData.apps);
                            }
                        } catch(e) { console.warn('[Import] å¯¼å…¥Appsæ•°æ®å¤±è´¥:', e); }
                    }
                    
                    // å¯¼å…¥éŸ³ä¹æ’­æ”¾å™¨æ•°æ®åº“
                    if (importData.wyyMusicData) {
                        try {
                            if (importData.wyyMusicData.userSettings?.length > 0) {
                                await wyyDb.userSettings.bulkPut(importData.wyyMusicData.userSettings);
                            }
                            if (importData.wyyMusicData.playlistCards?.length > 0) {
                                await wyyDb.playlistCards.bulkPut(importData.wyyMusicData.playlistCards);
                            }
                            if (importData.wyyMusicData.songs?.length > 0) {
                                await wyyDb.songs.bulkPut(importData.wyyMusicData.songs);
                            }
                            if (importData.wyyMusicData.lyrics?.length > 0) {
                                await wyyDb.lyrics.bulkPut(importData.wyyMusicData.lyrics);
                            }
                            if (importData.wyyMusicData.playlists?.length > 0 && wyyDb.playlists) {
                                await wyyDb.playlists.bulkPut(importData.wyyMusicData.playlists);
                            }
                        } catch(e) { console.warn('[Import] å¯¼å…¥éŸ³ä¹æ•°æ®å¤±è´¥:', e); }
                    }
                    
                    // å¯¼å…¥ localStorage æ•°æ®ï¼ˆå…¨é‡æ¢å¤ï¼‰
                    if (importData.localStorage) {
                        let importFailCount = 0;
                        Object.keys(importData.localStorage).forEach(key => {
                            const value = importData.localStorage[key];
                            if (value !== null && value !== undefined) {
                                if (!safeLocalStorageSet(key, value)) importFailCount++;
                            }
                        });
                        if (importFailCount > 0) {
                            console.warn(`[Import] âš ï¸ ${importFailCount} ä¸ª localStorage é¡¹å¯¼å…¥å¤±è´¥`);
                        }
                    }
                }
                
                // å¯¼å…¥è”æœºæ•°æ®ï¼ˆå…¼å®¹æ—§ç‰ˆå’Œæ–°ç‰ˆï¼‰
                if (hasOnlineData && importData.onlineData) {
                    if (importData.onlineData.server_url) {
                        localStorage.setItem('online_server_url', importData.onlineData.server_url);
                    }
                    if (importData.onlineData.token) {
                        localStorage.setItem('online_token', importData.onlineData.token);
                    }
                    if (importData.onlineData.user_data) {
                        localStorage.setItem('online_user_data', importData.onlineData.user_data);
                    }
                }
                
                input.value = ''; // æ¸…ç©ºæ–‡ä»¶é€‰æ‹©
                
                let successMsg = 'æ•°æ®å¯¼å…¥æˆåŠŸï¼\n\n';
                if (hasLocalData) successMsg += 'âœ… æœ¬åœ°æ•°æ®å·²å¯¼å…¥\n';
                if (hasOnlineData) successMsg += 'âœ… è”æœºè´¦å·å·²å¯¼å…¥\n';
                successMsg += '\né¡µé¢å³å°†åˆ·æ–°...';
                
                alert(successMsg);
                
                // åˆ·æ–°é¡µé¢ä»¥åº”ç”¨å¯¼å…¥çš„æ•°æ®
                setTimeout(() => {
                    window.location.reload();
                }, 500);
                
            } catch (error) {
                console.error('å¯¼å…¥æ•°æ®å¤±è´¥:', error);
                alert('å¯¼å…¥æ•°æ®å¤±è´¥: ' + error.message);
                input.value = '';
            }
        }
        
        // æ¸…ç©ºæ‰€æœ‰æ•°æ®
        async function clearAllDataConfirm() {
            const confirm1 = confirm('âš ï¸ è­¦å‘Šï¼šæ­¤æ“ä½œå°†åˆ é™¤æ‰€æœ‰æ•°æ®ï¼\n\nåŒ…æ‹¬ï¼š\n- æ‰€æœ‰è§’è‰²å’ŒèŠå¤©è®°å½•\n- æ‰€æœ‰ä¸–ç•Œä¹¦\n- æ‰€æœ‰è¡¨æƒ…åŒ…\n- æ‰€æœ‰æœ‹å‹åœˆ\n- æ‰€æœ‰ç¾¤èŠ\n- ç”µè¯å’ŒçŸ­ä¿¡è®°å½•\n- äº²å¯†å…³ç³»æ•°æ®\n- ç¦»çº¿èŠå¤©è®°å½•\n- è´¢åŠ¡æ•°æ®\n- æ—¥è®°æ•°æ®\n- éŸ³ä¹æ•°æ®\n- å·²å®‰è£…åº”ç”¨\n- è”æœºè´¦å·ä¿¡æ¯\n- APIè®¾ç½®\n- æ‰€æœ‰æœ¬åœ°è®¾ç½®\n\næ­¤æ“ä½œä¸å¯æ¢å¤ï¼Œç¡®å®šè¦ç»§ç»­å—ï¼Ÿ');
            if (!confirm1) return;
            
            const confirm2 = prompt('è¯·è¾“å…¥"ç¡®è®¤åˆ é™¤"ä»¥ç»§ç»­ï¼š');
            if (confirm2 !== 'ç¡®è®¤åˆ é™¤') {
                alert('å·²å–æ¶ˆæ“ä½œ');
                return;
            }
            
            try {
                // æ¸…ç©ºä¸»æ•°æ®åº“æ‰€æœ‰è¡¨
                await db.dexiData.clear();
                await db.lorebooks.clear();
                await db.characters.clear();
                await db.sticker_categories.clear();
                await db.moments.clear();
                await db.friend_requests.clear();
                if (db.group_chats) await db.group_chats.clear();
                if (db.phone_recents) await db.phone_recents.clear();
                if (db.sms_messages) await db.sms_messages.clear();
                if (db.chat_summaries) await db.chat_summaries.clear();
                if (db.avatar_library) await db.avatar_library.clear();
                if (db.avatar_categories) await db.avatar_categories.clear();
                if (db.chat_themes) await db.chat_themes.clear();
                if (db.intimate_relations) await db.intimate_relations.clear();
                if (db.intimate_requests) await db.intimate_requests.clear();
                if (db.offline_chats) await db.offline_chats.clear();
                if (db.finance_data) await db.finance_data.clear();
                
                // æ¸…ç©ºå­æ•°æ®åº“
                try { await icityDb.diaries.clear(); await icityDb.annotations.clear(); } catch(e) { console.warn('[Clear] æ¸…ç©ºiCityå¤±è´¥:', e); }
                try { await installedAppsDb.apps.clear(); } catch(e) { console.warn('[Clear] æ¸…ç©ºAppså¤±è´¥:', e); }
                try {
                    await wyyDb.userSettings.clear();
                    await wyyDb.playlistCards.clear();
                    await wyyDb.songs.clear();
                    await wyyDb.songFiles.clear();
                    await wyyDb.lyrics.clear();
                    if (wyyDb.playlists) await wyyDb.playlists.clear();
                } catch(e) { console.warn('[Clear] æ¸…ç©ºéŸ³ä¹æ•°æ®åº“å¤±è´¥:', e); }
                
                // æ¸…ç©º localStorage
                localStorage.clear();
                
                alert('æ‰€æœ‰æ•°æ®å·²æ¸…ç©ºï¼é¡µé¢å³å°†åˆ·æ–°...');
                
                setTimeout(() => {
                    window.location.reload();
                }, 500);
                
            } catch (error) {
                console.error('æ¸…ç©ºæ•°æ®å¤±è´¥:', error);
                alert('æ¸…ç©ºæ•°æ®å¤±è´¥: ' + error.message);
            }
        }

        // æ˜¾ç¤ºé€šçŸ¥ä¸­å¿ƒ
        function showNotificationCenter() {
            const enabled = localStorage.getItem('notification_enabled') === 'true';
            if (!enabled) return; // æœªå¼€å¯ä¸æ˜¾ç¤º

            document.getElementById('notification-center').style.display = 'block';
            fetchNotifications(); // æ‰“å¼€æ—¶åˆ·æ–°ä¸€ä¸‹
        }
        function hideNotificationCenter() {
            document.getElementById('notification-center').style.display = 'none';
        }

        // è·å–é€šçŸ¥ï¼ˆçº¯å‰ç«¯ï¼šä»æœ¬åœ° IndexedDB è¯»å–ï¼‰
        async function fetchNotifications() {
            const enabled = localStorage.getItem('notification_enabled') === 'true';
            if (!enabled) return;

            try {
                // ä»æœ¬åœ°å­˜å‚¨è¯»å–é€šçŸ¥
                const notificationsJson = localStorage.getItem(`notifications_${currentUserId}`);
                const list = notificationsJson ? JSON.parse(notificationsJson) : [];
                renderNotifications(list);
            } catch (err) {
                console.error('è·å–é€šçŸ¥å¤±è´¥:', err);
            }
        }
        
        // æ·»åŠ æœ¬åœ°é€šçŸ¥ï¼ˆçº¯å‰ç«¯ç‰ˆæœ¬ï¼‰
        function addLocalNotification(title, content, type = 'single') {
            try {
                const notificationsJson = localStorage.getItem(`notifications_${currentUserId}`);
                const list = notificationsJson ? JSON.parse(notificationsJson) : [];
                
                const newNotif = {
                    id: Date.now(),
                    title: title,
                    content: content,
                    type: type,
                    timestamp: Date.now() / 1000,
                    is_read: false
                };
                
                list.unshift(newNotif);
                
                // æœ€å¤šä¿ç•™100æ¡é€šçŸ¥
                if (list.length > 100) list.pop();
                
                safeLocalStorageSet(`notifications_${currentUserId}`, JSON.stringify(list));
                return newNotif;
            } catch (err) {
                console.error('æ·»åŠ é€šçŸ¥å¤±è´¥:', err);
                return null;
            }
        }

        // æ¸²æŸ“é€šçŸ¥åˆ—è¡¨
        function renderNotifications(list) {
            const container = document.getElementById('notif-list');
            container.innerHTML = '';
            
            let unreadCount = 0;

            if (list.length === 0) {
                container.innerHTML = '<div class="empty-tip">æš‚æ— æ–°é€šçŸ¥</div>';
                latestNotification = null;
            } else {
                // ç¡®ä¿åˆ—è¡¨æ˜¯æŒ‰æ—¶é—´å€’åºçš„
                list.sort((a, b) => b.timestamp - a.timestamp);
                
                // æ›´æ–°æœ€æ–°çš„ä¸€æ¡é€šçŸ¥ç¼“å­˜
                latestNotification = list[0];

                list.forEach(item => {
                    // 1. ç»Ÿè®¡æœªè¯»
                    if (!item.is_read) unreadCount++;

                    // 2. æ£€æŸ¥æ˜¯å¦æœ‰æ–°æ¶ˆæ¯ (ä¸åœ¨å·²çŸ¥åˆ—è¡¨ä¸­ï¼Œä¸”éé¦–æ¬¡åŠ è½½)
                    if (!knownNotifIds.has(item.id)) {
                        knownNotifIds.add(item.id);
                        
                        // ä»…å½“éé¦–æ¬¡åŠ è½½æ—¶å¼¹çª—ï¼Œé¿å…åˆ·æ–°é¡µé¢æ—¶ç‹‚å¼¹
                        if (!isFirstLoad) {
                            sendSystemNotification(item.title, item.content);
                        }
                    }

                    // 3. æ¸²æŸ“DOM
                    const div = document.createElement('div');
                    div.className = `notif-item ${!item.is_read ? 'unread' : ''}`;
                    // æ ¼å¼åŒ–æ—¶é—´æˆ³
                    const date = new Date(item.timestamp * 1000);
                    const timeStr = `${date.getMonth()+1}-${date.getDate()} ${date.getHours()}:${date.getMinutes().toString().padStart(2, '0')}`;
                    
                    div.innerHTML = `
                        <div class="notif-time">${timeStr}</div>
                        <div class="notif-content-title">${item.title}</div>
                        <div class="notif-desc">${item.content}</div>
                    `;
                    div.onclick = () => markRead(item.id, item.is_read);
                    container.appendChild(div);
                });
            }
            
            // é¦–æ¬¡åŠ è½½æ ‡è®°ç½®ä¸ºfalse
            isFirstLoad = false;

            // æ›´æ–°çº¢ç‚¹
            const badge = document.getElementById('notif-badge');
            badge.style.display = unreadCount > 0 ? 'block' : 'none';
        }

        // å‘é€ç³»ç»Ÿé€šçŸ¥
        function sendSystemNotification(title, body) {
            console.log(`[Notification] ========================================`);
            console.log(`[Notification] ğŸ”” å°è¯•å‘é€é€šçŸ¥: "${title}" - "${body}"`);
            addLog('info', `å°è¯•å‘é€é€šçŸ¥: ${title}`, { body, caller: new Error().stack.split('\n')[2] });
            
            // æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒé€šçŸ¥
            if (!("Notification" in window)) {
                console.error('[Notification] âœ— æµè§ˆå™¨ä¸æ”¯æŒé€šçŸ¥');
                addLog('error', 'æµè§ˆå™¨ä¸æ”¯æŒé€šçŸ¥');
                showDebugToast('æµè§ˆå™¨ä¸æ”¯æŒé€šçŸ¥');
                return;
            }
            
            // æ£€æŸ¥æƒé™çŠ¶æ€
            const permission = Notification.permission;
            console.log(`[Notification] æƒé™çŠ¶æ€: ${permission}`);
            addLog('info', `é€šçŸ¥æƒé™çŠ¶æ€: ${permission}`);
            
            if (permission === "granted") {
                try {
                    console.log(`[Notification] âœ“ æƒé™å·²æˆäºˆï¼Œç«‹å³å‘é€é€šçŸ¥...`);
                    const notification = new Notification(title, { 
                        body: body,
                        icon: 'https://img.heliar.top/file/1770541813634_æ— æ ‡é¢˜434_20260208170943.png',
                        badge: 'https://img.heliar.top/file/1770541813634_æ— æ ‡é¢˜434_20260208170943.png',
                        tag: 'chat-message-' + Date.now(), // æ¯æ¬¡éƒ½ç”¨æ–°tagï¼Œé¿å…è¢«æ›¿æ¢
                        requireInteraction: false,
                        silent: false
                    });
                    
                    notification.onclick = function() {
                        window.focus();
                        this.close();
                    };
                    
                    console.log('[Notification] âœ“âœ“âœ“ é€šçŸ¥å·²æˆåŠŸå‘é€ï¼');
                    showDebugToast(`âœ“ é€šçŸ¥: ${title}`);
                } catch (error) {
                    console.error('[Notification] âœ—âœ—âœ— å‘é€å¤±è´¥:', error);
                    showDebugToast(`âœ— é€šçŸ¥å¤±è´¥: ${error.message}`);
                }
            } else if (permission === "default") {
                console.log('[Notification] æƒé™æœªè®¾ç½®ï¼Œè¯·æ±‚æƒé™...');
                Notification.requestPermission().then(permission => {
                    console.log(`[Notification] æƒé™è¯·æ±‚ç»“æœ: ${permission}`);
                    if (permission === "granted") {
                        try {
                            new Notification(title, { 
                                body: body,
                                icon: 'https://img.heliar.top/file/1770541813634_æ— æ ‡é¢˜434_20260208170943.png'
                            });
                            console.log('[Notification] âœ“ é€šçŸ¥å·²å‘é€ï¼ˆæƒé™æˆäºˆåï¼‰');
                        } catch (error) {
                            console.error('[Notification] âœ— å‘é€å¤±è´¥:', error);
                        }
                    } else {
                        console.warn('[Notification] âœ— æƒé™è¢«æ‹’ç»');
                    }
                });
            } else {
                console.error('[Notification] âœ—âœ—âœ— æƒé™å·²è¢«æ‹’ç»ï¼Œæ— æ³•å‘é€é€šçŸ¥');
                console.error('[Notification] è¯·åœ¨æµè§ˆå™¨è®¾ç½®ä¸­å…è®¸é€šçŸ¥æƒé™');
                showDebugToast('âœ— é€šçŸ¥æƒé™è¢«æ‹’ç»ï¼Œè¯·åœ¨è®¾ç½®ä¸­å…è®¸');
            }
            
            console.log(`[Notification] ========================================`);
        }

        // æ ‡è®°å·²è¯»ï¼ˆçº¯å‰ç«¯ï¼šæ›´æ–°æœ¬åœ°å­˜å‚¨ï¼‰
        async function markRead(id, isRead) {
            if (isRead) return; // å·²ç»æ˜¯å·²è¯»

            try {
                const notificationsJson = localStorage.getItem(`notifications_${currentUserId}`);
                const list = notificationsJson ? JSON.parse(notificationsJson) : [];
                
                const notif = list.find(n => n.id === id);
                if (notif) {
                    notif.is_read = true;
                    safeLocalStorageSet(`notifications_${currentUserId}`, JSON.stringify(list));
                }
                
                // é‡æ–°è·å–åˆ·æ–°åˆ—è¡¨
                fetchNotifications();
            } catch (err) {
                console.error('æ ‡è®°å·²è¯»å¤±è´¥:', err);
            }
        }

        // æ ¸å¿ƒï¼šæŠ˜å å±•å¼€åˆ‡æ¢
        function toggleExpand(id) {
            const expand = document.getElementById(id);
            const arrow = document.getElementById(`arrow${id.replace('expand','')}`);
            if (expand.style.display === 'flex') {
                expand.style.display = 'none';
                arrow.classList.remove('active');
                // arrow.innerText = 'â†’'; // SVGæ—‹è½¬
            } else {
                expand.style.display = 'flex';
                arrow.classList.add('active');
                // arrow.innerText = 'â†‘'; // SVGæ—‹è½¬
            }
        }

        // å…¨å±€å­—ä½“è®¾ç½®ç›¸å…³å‡½æ•°
        let customFontStyleElement = null;
        
        // é¢„è§ˆè‡ªå®šä¹‰å­—ä½“
        function previewCustomFont() {
            const fontUrl = document.getElementById('custom-font-input').value.trim();
            const fontName = document.getElementById('custom-font-name-input').value.trim();
            
            if (!fontUrl || !fontName) {
                alert('è¯·å¡«å†™å­—ä½“é“¾æ¥å’Œå­—ä½“åç§°');
                return;
            }
            
            // åŠ¨æ€åŠ è½½å­—ä½“æ ·å¼
            loadCustomFont(fontUrl, fontName, true);
        }
        
        // åŠ è½½å¹¶åº”ç”¨è‡ªå®šä¹‰å­—ä½“ï¼ˆæ”¯æŒ Google Fonts CSS é“¾æ¥ å’Œ TTF/WOFF/WOFF2/OTF ç›´é“¾ï¼‰
        function loadCustomFont(fontUrl, fontName, previewOnly = false) {
            // ç§»é™¤æ—§çš„å­—ä½“æ ·å¼
            const oldLink = document.getElementById('custom-font-link');
            if (oldLink) oldLink.remove();
            const oldFontFace = document.getElementById('custom-font-face');
            if (oldFontFace) oldFontFace.remove();
            
            // åˆ¤æ–­æ˜¯å¦ä¸ºå­—ä½“æ–‡ä»¶ç›´é“¾ï¼ˆTTFã€WOFFã€WOFF2ã€OTFï¼‰
            const fontFileMatch = fontUrl.match(/\.(ttf|woff2?|otf)(\?.*)?$/i);
            
            if (fontFileMatch) {
                // === å­—ä½“æ–‡ä»¶ç›´é“¾æ¨¡å¼ï¼šä½¿ç”¨ @font-face åŠ è½½ ===
                const ext = fontFileMatch[1].toLowerCase();
                let format = 'truetype';
                if (ext === 'woff') format = 'woff';
                else if (ext === 'woff2') format = 'woff2';
                else if (ext === 'otf') format = 'opentype';
                
                const fontFaceStyle = document.createElement('style');
                fontFaceStyle.id = 'custom-font-face';
                fontFaceStyle.textContent = `
                    @font-face {
                        font-family: "${fontName}";
                        src: url("${fontUrl}") format("${format}");
                        font-weight: normal;
                        font-style: normal;
                        font-display: swap;
                    }
                `;
                document.head.appendChild(fontFaceStyle);
                
                // ä½¿ç”¨ FontFace API æ£€æµ‹å­—ä½“æ˜¯å¦åŠ è½½æˆåŠŸ
                if (window.FontFace) {
                    const font = new FontFace(fontName, `url(${fontUrl})`);
                    font.load().then(() => {
                        document.fonts.add(font);
                        console.log(`[Font] âœ“ å­—ä½“ "${fontName}" åŠ è½½æˆåŠŸ (${ext}ç›´é“¾)`);
                        if (previewOnly) {
                            const previewText = document.getElementById('font-preview-text');
                            previewText.style.fontFamily = `"${fontName}", sans-serif`;
                            previewText.innerText = `è¿™æ˜¯å­—ä½“é¢„è§ˆæ•ˆæœ ABC 123\n${fontName}`;
                        } else {
                            applyFontGlobal(fontName);
                        }
                    }).catch(err => {
                        console.error(`[Font] âœ— å­—ä½“åŠ è½½å¤±è´¥:`, err);
                        showToast('âŒ å­—ä½“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥é“¾æ¥æ˜¯å¦æ­£ç¡®');
                    });
                } else {
                    // é™çº§ï¼šç­‰å¾…ä¸€å°æ®µæ—¶é—´åå°è¯•åº”ç”¨
                    setTimeout(() => {
                        if (previewOnly) {
                            const previewText = document.getElementById('font-preview-text');
                            previewText.style.fontFamily = `"${fontName}", sans-serif`;
                            previewText.innerText = `è¿™æ˜¯å­—ä½“é¢„è§ˆæ•ˆæœ ABC 123\n${fontName}`;
                        } else {
                            applyFontGlobal(fontName);
                        }
                    }, 2000);
                }
            } else {
                // === CSS é“¾æ¥æ¨¡å¼ï¼ˆGoogle Fonts ç­‰ï¼‰===
                const link = document.createElement('link');
                link.id = 'custom-font-link';
                link.rel = 'stylesheet';
                link.href = fontUrl;
                document.head.appendChild(link);
                
                link.onload = function() {
                    console.log(`[Font] âœ“ å­—ä½“æ ·å¼è¡¨åŠ è½½æˆåŠŸ: ${fontUrl}`);
                    if (previewOnly) {
                        const previewText = document.getElementById('font-preview-text');
                        previewText.style.fontFamily = `"${fontName}", sans-serif`;
                        previewText.innerText = `è¿™æ˜¯å­—ä½“é¢„è§ˆæ•ˆæœ ABC 123\n${fontName}`;
                    } else {
                        applyFontGlobal(fontName);
                    }
                };
                
                link.onerror = function() {
                    showToast('âŒ å­—ä½“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥é“¾æ¥æ˜¯å¦æ­£ç¡®');
                };
            }
        }
        
        // åº”ç”¨å­—ä½“åˆ°å…¨å±€ï¼ˆæ’é™¤å›¾æ ‡/ç­‰å®½/SVGç­‰ç‰¹æ®Šå…ƒç´ ï¼Œé¿å…å½±å“å¸ƒå±€ï¼‰
        function applyFontGlobal(fontName) {
            // ç§»é™¤æ—§çš„å…¨å±€å­—ä½“æ ·å¼
            if (customFontStyleElement) {
                customFontStyleElement.remove();
            }
            
            // åˆ›å»ºæ–°çš„æ ·å¼å…ƒç´  â€”â€” é€šè¿‡ body ç»§æ‰¿ï¼Œè€Œé * å¼ºåˆ¶è¦†ç›–
            customFontStyleElement = document.createElement('style');
            customFontStyleElement.id = 'custom-font-global';
            customFontStyleElement.textContent = `
                /* å…¨å±€è¦†ç›–ï¼šåº”ç”¨è‡ªå®šä¹‰å­—ä½“åˆ°æ‰€æœ‰æ–‡æœ¬å…ƒç´  */
                * {
                    font-family: "${fontName}", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif !important;
                }
                /* ä¿æŒç­‰å®½å­—ä½“ä¸å—å½±å“ */
                code, pre, .monospace,
                #json-preview-content,
                #summary-detail-content-edit {
                    font-family: "${fontName}", 'Courier New', 'Consolas', 'Monaco', monospace !important;
                }
                /* æ—¥å†ç‰¹æ®Šå­—ä½“ä¿æŒ */
                .current-date-btn,
                .sel-year-item,
                .time-input {
                    font-family: "${fontName}", 'Playfair Display', serif !important;
                }
            `;
            document.head.appendChild(customFontStyleElement);
        }
        
        // ä¿å­˜å¹¶åº”ç”¨è‡ªå®šä¹‰å­—ä½“ï¼ˆç«‹å³ç”Ÿæ•ˆ+æŒä¹…åŒ–ï¼‰
        async function saveAndApplyFont() {
            const fontUrl = document.getElementById('custom-font-input').value.trim();
            const fontName = document.getElementById('custom-font-name-input').value.trim();
            
            if (!fontUrl || !fontName) {
                showToast('è¯·å…ˆå¡«å†™å­—ä½“é“¾æ¥å’Œå­—ä½“åç§°');
                return;
            }
            
            // åº”ç”¨å­—ä½“
            loadCustomFont(fontUrl, fontName, false);
            
            // æŒä¹…åŒ–åˆ°æ•°æ®åº“
            try {
                await db.dexiData.put({ key: 'customFontUrl', value: fontUrl });
                await db.dexiData.put({ key: 'customFontName', value: fontName });
                showToast('âœ… å­—ä½“å·²ä¿å­˜å¹¶åº”ç”¨');
            } catch (e) {
                console.error('[Font] ä¿å­˜å­—ä½“å¤±è´¥:', e);
                showToast('âš ï¸ å­—ä½“å·²åº”ç”¨ä½†ä¿å­˜å¤±è´¥');
            }
        }

        // æ¸…é™¤è‡ªå®šä¹‰å­—ä½“ï¼Œæ¢å¤é»˜è®¤
        async function clearCustomFont() {
            // æ¸…é™¤è¾“å…¥æ¡†
            document.getElementById('custom-font-input').value = '';
            document.getElementById('custom-font-name-input').value = '';
            
            // ç§»é™¤å­—ä½“é“¾æ¥å’Œå…¨å±€æ ·å¼
            const fontLink = document.getElementById('custom-font-link');
            if (fontLink) fontLink.remove();
            
            // ç§»é™¤ @font-face æ ·å¼ï¼ˆTTFç›´é“¾æ¨¡å¼ï¼‰
            const fontFace = document.getElementById('custom-font-face');
            if (fontFace) fontFace.remove();
            
            if (customFontStyleElement) {
                customFontStyleElement.remove();
                customFontStyleElement = null;
            }
            
            // é‡ç½®é¢„è§ˆåŒºåŸŸ
            const previewText = document.getElementById('font-preview-text');
            previewText.style.fontFamily = '';
            previewText.innerText = 'è¿™æ˜¯å­—ä½“é¢„è§ˆæ•ˆæœ ABC 123';
            
            // æ¸…é™¤æ•°æ®åº“ä¸­çš„å­—ä½“è®¾ç½®
            try {
                await db.dexiData.put({ key: 'customFontUrl', value: '' });
                await db.dexiData.put({ key: 'customFontName', value: '' });
            } catch (e) {
                console.error('[Font] æ¸…é™¤å­—ä½“è®¾ç½®å¤±è´¥:', e);
            }
            
            showToast('âœ… å·²æ¢å¤é»˜è®¤å­—ä½“');
        }
        
        // ===== å…¨å±€å­—ä½“å¤§å°è®¾ç½® =====
        let globalFontSizeStyleElement = null;
        
        // é¢„è§ˆå…¨å±€å­—ä½“å¤§å°ï¼ˆæ‹–åŠ¨æ»‘å—æ—¶å®æ—¶ç”Ÿæ•ˆï¼‰
        function previewGlobalFontSize(size) {
            document.getElementById('global-font-size-value').textContent = size + 'px';
            applyGlobalFontSize(size);
        }
        
        // åº”ç”¨å…¨å±€å­—ä½“å¤§å°
        function applyGlobalFontSize(size) {
            if (globalFontSizeStyleElement) {
                globalFontSizeStyleElement.remove();
            }
            
            globalFontSizeStyleElement = document.createElement('style');
            globalFontSizeStyleElement.id = 'global-font-size-style';
            globalFontSizeStyleElement.textContent = `
                /* å…¨å±€é»˜è®¤å­—ä½“å¤§å° */
                .message-content,
                .message-content .msg-text,
                .message-content .text-content {
                    font-size: ${size}px !important;
                }
            `;
            document.head.appendChild(globalFontSizeStyleElement);
        }
        
        // ä¿å­˜å…¨å±€å­—ä½“å¤§å°
        async function saveGlobalFontSize() {
            const size = document.getElementById('global-font-size-slider').value;
            try {
                await db.dexiData.put({ key: 'globalFontSize', value: size });
                applyGlobalFontSize(size);
                showToast(`âœ… å­—ä½“å¤§å°å·²ä¿å­˜ï¼š${size}px`);
            } catch(e) {
                console.error('[FontSize] ä¿å­˜å¤±è´¥:', e);
                showToast('âš ï¸ ä¿å­˜å¤±è´¥');
            }
        }
        
        // é‡ç½®å…¨å±€å­—ä½“å¤§å°ä¸ºé»˜è®¤
        async function resetGlobalFontSize() {
            document.getElementById('global-font-size-slider').value = 14;
            document.getElementById('global-font-size-value').textContent = '14px';
            
            // ç§»é™¤è‡ªå®šä¹‰æ ·å¼
            if (globalFontSizeStyleElement) {
                globalFontSizeStyleElement.remove();
                globalFontSizeStyleElement = null;
            }
            
            try {
                await db.dexiData.put({ key: 'globalFontSize', value: '' });
            } catch(e) {
                console.error('[FontSize] æ¸…é™¤è®¾ç½®å¤±è´¥:', e);
            }
            showToast('âœ… å·²æ¢å¤é»˜è®¤å­—ä½“å¤§å°');
        }
        
        // æ¡Œé¢æ–‡å­—é¢œè‰²ç›¸å…³
        let desktopTextColorStyleElement = null;
        
        function applyDesktopTextColor(color) {
            if (!color) return;
            
            // ç§»é™¤æ—§æ ·å¼
            if (desktopTextColorStyleElement) {
                desktopTextColorStyleElement.remove();
            }
            
            // åˆ›å»ºæ–°çš„æ ·å¼è¦†ç›–
            desktopTextColorStyleElement = document.createElement('style');
            desktopTextColorStyleElement.id = 'desktop-text-color-style';
            desktopTextColorStyleElement.textContent = `
                .app-icon .name,
                .dock-icon .name,
                .top-widget .text .title,
                .top-widget .text .subtext,
                .circle-photo .name,
                .circle-photo .bubble,
                .days-capsule .capsule {
                    color: ${color} !important;
                }
            `;
            document.head.appendChild(desktopTextColorStyleElement);
        }

        // åŒæ­¥é¢„è§ˆåŒºå’Œè¾“å…¥æ¡†
        function syncPreview() {
            // å£çº¸é¢„è§ˆ
            const bg = document.getElementById('desktop-body').style.backgroundImage;
            if (bg) {
                document.getElementById('wallpaper-preview').style.backgroundImage = bg;
                document.getElementById('wallpaper-preview').innerText = '';
            }
            // å°ç»„ä»¶
            document.getElementById('widget-icon-preview').style.backgroundImage = document.getElementById('widget-icon').style.backgroundImage;
            document.getElementById('widget-title-input').value = document.getElementById('widget-title').innerText.replace(/\{|\}/g, '').trim();
            document.getElementById('widget-subtext-input').value = document.getElementById('widget-subtext').innerText.trim();
            // æ‹ç«‹å¾—
            document.getElementById('photo-left-preview').style.backgroundImage = document.getElementById('img-left').style.backgroundImage;
            document.getElementById('photo-right-preview').style.backgroundImage = document.getElementById('img-right').style.backgroundImage;
            // å¤´åƒ
            document.getElementById('avatar1-preview').style.backgroundImage = document.getElementById('avatar-img-1').style.backgroundImage;
            document.getElementById('avatar2-preview').style.backgroundImage = document.getElementById('avatar-img-2').style.backgroundImage;
            document.getElementById('avatar1-bubble-input').value = document.getElementById('avatar-bubble1').innerText.trim();
            document.getElementById('avatar1-name-input').value = document.getElementById('avatar-name1').innerText.trim();
            document.getElementById('avatar2-bubble-input').value = document.getElementById('avatar-bubble2').innerText.trim();
            document.getElementById('avatar2-name-input').value = document.getElementById('avatar-name2').innerText.trim();
            // å€’æ•°æ—¥
            document.getElementById('days-input').value = document.getElementById('days-text').innerText.trim();
            // æ¤­åœ†å½¢é¢œè‰²
            const heartColor = getComputedStyle(document.documentElement).getPropertyValue('--heart-color').trim() || '#ffb6c1';
            const capsuleColor = getComputedStyle(document.documentElement).getPropertyValue('--capsule-bg').trim() || '#FFF7FA';
            const bubbleColor = getComputedStyle(document.documentElement).getPropertyValue('--bubble-bg').trim() || '#FFF7FA';
            document.getElementById('heart-color-input').value = heartColor;
            document.getElementById('capsule-color-input').value = capsuleColor;
            document.getElementById('bubble-color-input').value = bubbleColor;
            // æ¡Œé¢æ–‡å­—é¢œè‰²åŒæ­¥
            const dtcEl = document.getElementById('desktop-text-color-input');
            if (dtcEl) {
                // ä»å·²æœ‰çš„æ ·å¼ä¸­è¯»å–å½“å‰é¢œè‰²ï¼Œæˆ–ä¿ç•™è¾“å…¥æ¡†å½“å‰å€¼
                const existingStyle = document.getElementById('desktop-text-color-style');
                if (!existingStyle && dtcEl.value === '#999999') {
                    // é»˜è®¤å€¼ï¼Œä¸åšä»»ä½•äº‹
                }
            }
            // åŒæ­¥åº”ç”¨/Dockå›¾æ ‡é¢„è§ˆ
            document.querySelectorAll('.icon-select-item[data-icon-id]').forEach(item => {
                const iconId = item.getAttribute('data-icon-id');
                const desktopIcon = document.getElementById(`icon-${iconId}`)?.querySelector('.icon') || document.getElementById(`dock-${iconId}`)?.querySelector('.icon');
                const previewIcon = item.querySelector('.icon');
                if (desktopIcon && previewIcon) {
                    previewIcon.style.backgroundImage = desktopIcon.style.backgroundImage;
                    previewIcon.style.backgroundSize = 'cover';
                    previewIcon.style.backgroundPosition = 'center';
                }
            });
            // å­—ä½“é¢„è§ˆåŒæ­¥
            const fontName = document.getElementById('custom-font-name-input').value.trim();
            const previewText = document.getElementById('font-preview-text');
            if (fontName && previewText) {
                previewText.style.fontFamily = `"${fontName}", sans-serif`;
                previewText.innerText = `è¿™æ˜¯å­—ä½“é¢„è§ˆæ•ˆæœ ABC 123\n${fontName}`;
            }
        }

        // é¡µé¢åˆ‡æ¢
        function showCustomPage() {
            document.getElementById('home-page').style.display = 'none';
            document.getElementById('custom-main-page').style.display = 'flex';
            syncPreview();
            // åŠ è½½èŠå¤©ä¸»é¢˜åˆ—è¡¨
            loadChatThemeList();
            // åˆå§‹åŒ–ä¸»é¢˜é¢„è§ˆ
            setTimeout(() => {
                previewChatTheme();
            }, 100);
        }
        function backHomePage() {
            document.getElementById('custom-main-page').style.display = 'none';
            document.getElementById('home-page').style.display = 'flex';
        }

        // ===== æ¡Œé¢å¤šé¡µæ»‘åŠ¨ï¼ˆè§¦æ‘¸æ»‘åŠ¨ + transformï¼‰ =====
        var desktopPageIndex = 0;
        var desktopTotalPages = 2;

        (function initDesktopPages() {
            document.addEventListener('DOMContentLoaded', function() {
                const wrapper = document.getElementById('desktop-pages-wrapper');
                const track = document.getElementById('desktop-pages-track');
                const dots = document.querySelectorAll('.page-dot');
                if (!wrapper || !track || !dots.length) return;

                let startX = 0, startY = 0, moveX = 0, isDragging = false, isHorizontal = null;
                const SWIPE_THRESHOLD = 50;

                function goToPage(index) {
                    if (index < 0) index = 0;
                    if (index >= desktopTotalPages) index = desktopTotalPages - 1;
                    desktopPageIndex = index;
                    track.style.transform = `translateX(-${index * 100}%)`;
                    dots.forEach((dot, i) => {
                        dot.classList.toggle('active', i === index);
                    });
                }

                wrapper.addEventListener('touchstart', function(e) {
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                    moveX = 0;
                    isDragging = true;
                    isHorizontal = null;
                    track.classList.add('dragging');
                }, { passive: true });

                wrapper.addEventListener('touchmove', function(e) {
                    if (!isDragging) return;
                    const dx = e.touches[0].clientX - startX;
                    const dy = e.touches[0].clientY - startY;

                    // åˆ¤æ–­æ»‘åŠ¨æ–¹å‘ï¼šé¦–æ¬¡ç§»åŠ¨è¶…è¿‡5pxæ—¶å†³å®š
                    if (isHorizontal === null && (Math.abs(dx) > 5 || Math.abs(dy) > 5)) {
                        isHorizontal = Math.abs(dx) > Math.abs(dy);
                    }
                    // å¦‚æœæ˜¯çºµå‘æ»‘åŠ¨ï¼Œä¸æ‹¦æˆª
                    if (isHorizontal === false) {
                        isDragging = false;
                        track.classList.remove('dragging');
                        return;
                    }
                    if (isHorizontal) {
                        e.preventDefault();
                        moveX = dx;
                        const baseOffset = -desktopPageIndex * wrapper.offsetWidth;
                        // è¾¹ç¼˜é˜»å°¼
                        let offset = baseOffset + moveX;
                        if (desktopPageIndex === 0 && moveX > 0) offset = baseOffset + moveX * 0.3;
                        if (desktopPageIndex === desktopTotalPages - 1 && moveX < 0) offset = baseOffset + moveX * 0.3;
                        track.style.transform = `translateX(${offset}px)`;
                    }
                }, { passive: false });

                wrapper.addEventListener('touchend', function() {
                    if (!isDragging && isHorizontal !== true) {
                        track.classList.remove('dragging');
                        return;
                    }
                    isDragging = false;
                    track.classList.remove('dragging');
                    if (isHorizontal && Math.abs(moveX) > SWIPE_THRESHOLD) {
                        if (moveX < 0) goToPage(desktopPageIndex + 1);
                        else goToPage(desktopPageIndex - 1);
                    } else {
                        goToPage(desktopPageIndex);
                    }
                }, { passive: true });

                // ç‚¹å‡»åœ†ç‚¹åˆ‡æ¢é¡µé¢
                dots.forEach((dot, i) => {
                    dot.addEventListener('click', function() {
                        goToPage(i);
                    });
                });

                // æš´éœ²åˆ°å…¨å±€æ–¹ä¾¿è°ƒç”¨
                window.goToDesktopPage = goToPage;
            });
        })();

        // ===== æŸ¥æ‰‹æœºåŠŸèƒ½ï¼ˆç™½è‰²INSé£ï¼‰ =====
        let findPhoneTargetAccountId = null; // é€‰ä¸­çš„ç”¨æˆ·è´¦å·ID
        let findPhoneTargetRoleId = null;    // é€‰ä¸­çš„è§’è‰²ID
        
        // è·å–æŸä¸ªè´¦å·ä¸‹çš„æ‰€æœ‰ç›¸å…³è§’è‰²ï¼ˆå°½å¯èƒ½å®½æ¾åŒ¹é…ï¼Œç¡®ä¿ä¸é—æ¼ï¼‰
        function getFindPhoneFriends(allChars, accountId) {
            console.log(`[æŸ¥æ‰‹æœº] å¼€å§‹è¿‡æ»¤å¥½å‹ï¼ŒaccountId=${accountId}ï¼Œæ€»è§’è‰²æ•°=${allChars.length}`);
            const result = allChars.filter(c => {
                if (c.type === 'user') return false;
                
                // 1. æŒ‰è´¦å·éš”ç¦»çš„å¥½å‹çŠ¶æ€ï¼ˆæœ€ä¼˜å…ˆï¼‰
                const perUserStatus = c.wechat_status_by_user?.[accountId];
                if (perUserStatus === 'friend' || perUserStatus === 'deleted' || perUserStatus === 'blocked' || perUserStatus === 'deleted_by_char' || perUserStatus === 'blocked_by_char') {
                    console.log(`[æŸ¥æ‰‹æœº] âœ… ${c.name}(id=${c.id}) - æŒ‰è´¦å·çŠ¶æ€: ${perUserStatus}`);
                    return true;
                }
                
                // 2. æœ‰æŒ‰è´¦å·éš”ç¦»çš„èŠå¤©è®°å½•ï¼ˆè¯´æ˜è·Ÿè¿™ä¸ªè´¦å·æœ‰è¿‡äº’åŠ¨ï¼‰
                const perUserChat = c.chat_history_by_user?.[accountId];
                if (perUserChat && perUserChat.length > 0) {
                    console.log(`[æŸ¥æ‰‹æœº] âœ… ${c.name}(id=${c.id}) - æœ‰è´¦å·éš”ç¦»èŠå¤©è®°å½•(${perUserChat.length}æ¡)`);
                    return true;
                }
                
                // 3. æ—§çš„å…¨å±€å¥½å‹çŠ¶æ€ï¼ˆæ— è®ºwechat_status_by_useræ˜¯å¦å­˜åœ¨ï¼‰
                if (c.wechat_status === 'friend' || c.wechat_status === 'deleted' || c.wechat_status === 'blocked') {
                    console.log(`[æŸ¥æ‰‹æœº] âœ… ${c.name}(id=${c.id}) - æ—§å…¨å±€çŠ¶æ€: ${c.wechat_status}`);
                    return true;
                }
                
                // 4. æ—§çš„å…¨å±€èŠå¤©è®°å½•
                if (c.chat_history && c.chat_history.length > 0 && !c.chat_history_by_user) {
                    console.log(`[æŸ¥æ‰‹æœº] âœ… ${c.name}(id=${c.id}) - æœ‰æ—§å…¨å±€èŠå¤©è®°å½•(${c.chat_history.length}æ¡)`);
                    return true;
                }
                
                // 5. å¦‚æœè¿™ä¸ªè§’è‰²åœ¨ä»»æ„è´¦å·ä¸‹æ˜¯å¥½å‹ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰é—æ¼
                if (c.wechat_status_by_user) {
                    const anyFriend = Object.values(c.wechat_status_by_user).some(s => s === 'friend');
                    if (anyFriend) {
                        console.log(`[æŸ¥æ‰‹æœº] âš ï¸ ${c.name}(id=${c.id}) åœ¨å…¶ä»–è´¦å·æ˜¯å¥½å‹ä½†å½“å‰è´¦å·(${accountId})ä¸æ˜¯ï¼Œwechat_status_by_user=`, JSON.stringify(c.wechat_status_by_user));
                    }
                }
                
                return false;
            });
            console.log(`[æŸ¥æ‰‹æœº] è¿‡æ»¤ç»“æœ: ${result.length}ä¸ªå¥½å‹ - [${result.map(r => r.name).join(', ')}]`);
            return result;
        }
        
        // ç¬¬ä¸€æ­¥ï¼šæ˜¾ç¤ºç”¨æˆ·è´¦å·åˆ—è¡¨
        async function showFindPhonePage() {
            const page = document.getElementById('findphone-page');
            const listContainer = document.getElementById('findphone-account-list');
            listContainer.innerHTML = '';
            
            const allUsers = await db.characters.where('type').equals('user').toArray();
            const registeredUsers = allUsers.filter(u => u.identity && u.identity.wechat_registered);
            
            if (registeredUsers.length === 0) {
                listContainer.innerHTML = `
                    <div style="text-align:center; padding:50px 20px; color:#ccc;">
                        <svg viewBox="0 0 24 24" style="width:48px; height:48px; stroke:#ddd; fill:none; stroke-width:1.5; margin-bottom:12px;"><rect x="5" y="2" width="14" height="20" rx="2" ry="2"/><line x1="12" y1="18" x2="12.01" y2="18"/></svg>
                        <div style="font-size:14px; color:#bbb;">æš‚æ— å¯æŸ¥çœ‹çš„è´¦å·</div>
                        <div style="font-size:12px; margin-top:6px; color:#ddd;">è¯·å…ˆåœ¨ WeChat ä¸­æ³¨å†Œç”¨æˆ·</div>
                    </div>
                `;
                page.style.display = 'flex';
                return;
            }
            
            const allChars = await db.characters.toArray();
            
            for (const user of registeredUsers) {
                const accountId = String(user.id);
                const friends = getFindPhoneFriends(allChars, accountId);
                
                const card = document.createElement('div');
                card.className = 'findphone-account-card';
                card.onclick = () => showFindPhoneRoles(user);
                
                const avatarStyle = user.avatar ? `background-image:url(${user.avatar})` : '';
                
                // å¥½å‹å¤´åƒå æ”¾
                let friendDotsHtml = '';
                if (friends.length > 0) {
                    const dots = friends.slice(0, 4).map(f => {
                        const fa = f.avatar ? `background-image:url(${f.avatar})` : '';
                        return `<div class="findphone-friend-dot" style="${fa}"></div>`;
                    }).join('');
                    friendDotsHtml = `<div class="findphone-friends-row">${dots}<span class="findphone-friends-count">${friends.length}ä½å¥½å‹</span></div>`;
                }
                
                card.innerHTML = `
                    <div class="findphone-account-avatar" style="${avatarStyle}"></div>
                    <div class="findphone-account-info">
                        <div class="findphone-account-name">${user.nick || user.name}</div>
                        <div class="findphone-account-sub">${user.identity && user.identity.account ? user.identity.account : ''}</div>
                        ${friendDotsHtml}
                    </div>
                    <div class="findphone-account-arrow">â€º</div>
                `;
                listContainer.appendChild(card);
            }
            
            page.style.display = 'flex';
        }
        
        function hideFindPhonePage() {
            const page = document.getElementById('findphone-page');
            page.style.transform = 'scale(0.95)';
            page.style.opacity = '0';
            setTimeout(() => {
                page.style.display = 'none';
                page.style.transform = '';
                page.style.opacity = '';
            }, 200);
        }
        
        // ç¬¬äºŒæ­¥ï¼šæ˜¾ç¤ºé€‰ä¸­ç”¨æˆ·è´¦å·ä¸‹çš„è§’è‰²å¥½å‹åˆ—è¡¨
        async function showFindPhoneRoles(user) {
            findPhoneTargetAccountId = String(user.id);
            
            const page = document.getElementById('findphone-roles-page');
            const title = document.getElementById('findphone-roles-title');
            const listContainer = document.getElementById('findphone-roles-list');
            
            title.textContent = (user.nick || user.name) + ' çš„å¥½å‹';
            listContainer.innerHTML = '';
            
            const allChars = await db.characters.toArray();
            const accountId = String(user.id);
            const friends = getFindPhoneFriends(allChars, accountId);
            
            // æ•°æ®è‡ªåŠ¨ä¿®å¤ï¼šå¦‚æœè§’è‰²å…¨å±€æ˜¯å¥½å‹ä½†å½“å‰è´¦å·æ²¡æœ‰éš”ç¦»è®°å½•ï¼Œè‡ªåŠ¨è¡¥ä¸Š
            for (const f of friends) {
                const perUserStatus = f.wechat_status_by_user?.[accountId];
                if (!perUserStatus || perUserStatus === 'stranger') {
                    // å½“å‰è´¦å·æ²¡æœ‰è®°å½•ï¼Œä½†è¢« getFindPhoneFriends åŒ¹é…åˆ°äº†ï¼ˆè¯´æ˜æœ‰æ—§æ•°æ®æˆ–èŠå¤©è®°å½•ï¼‰
                    // è‡ªåŠ¨ä¿®å¤ï¼šè®¾ç½®ä¸ºå¥½å‹
                    if (!f.wechat_status_by_user) f.wechat_status_by_user = {};
                    f.wechat_status_by_user[accountId] = 'friend';
                    await safeCharacterPut(f, `è‡ªåŠ¨ä¿®å¤å¥½å‹çŠ¶æ€[${f.name}]`);
                    console.log(`[æŸ¥æ‰‹æœº] ğŸ”§ è‡ªåŠ¨ä¿®å¤: ${f.name}(id=${f.id}) åœ¨è´¦å· ${accountId} ä¸‹è®¾ä¸ºå¥½å‹`);
                }
            }
            
            if (friends.length === 0) {
                listContainer.innerHTML = `
                    <div style="text-align:center; padding:50px 20px; color:#ccc;">
                        <svg viewBox="0 0 24 24" style="width:40px; height:40px; stroke:#ddd; fill:none; stroke-width:1.5; margin-bottom:12px;"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>
                        <div style="font-size:14px; color:#bbb;">è¯¥è´¦å·æš‚æ— è§’è‰²å¥½å‹</div>
                    </div>
                `;
                page.style.display = 'flex';
                return;
            }
            
            for (const role of friends) {
                const card = document.createElement('div');
                card.className = 'findphone-account-card';
                card.onclick = () => openFindPhoneDesktop(role);
                
                const avatarStyle = role.avatar ? `background-image:url(${role.avatar})` : '';
                const displayName = getCharDisplayName(role, accountId);
                const status = getFriendStatus(role, accountId);
                const desc = role.identity && role.identity.account ? role.identity.account : (role.nick || '');
                
                card.innerHTML = `
                    <div class="findphone-account-avatar" style="${avatarStyle}"></div>
                    <div class="findphone-account-info">
                        <div class="findphone-account-name">${displayName}</div>
                        <div class="findphone-account-sub">${desc}</div>
                    </div>
                    <div class="findphone-account-arrow">â€º</div>
                `;
                listContainer.appendChild(card);
            }
            
            page.style.display = 'flex';
        }
        
        function hideFindPhoneRolesPage() {
            const page = document.getElementById('findphone-roles-page');
            page.style.transform = 'scale(0.95)';
            page.style.opacity = '0';
            setTimeout(() => {
                page.style.display = 'none';
                page.style.transform = '';
                page.style.opacity = '';
            }, 200);
        }
        
        // ç¬¬ä¸‰æ­¥ï¼šæ‰“å¼€è§’è‰²çš„æ‰‹æœºæ¡Œé¢
        async function openFindPhoneDesktop(role) {
            findPhoneTargetRoleId = String(role.id);
            
            const desktop = document.getElementById('findphone-desktop');
            const ownerLabel = document.getElementById('findphone-owner-name');
            const timeEl = document.getElementById('findphone-time');
            const lockTime = document.getElementById('findphone-lock-time');
            const lockDate = document.getElementById('findphone-lock-date');
            const wallpaper = document.getElementById('findphone-wallpaper');
            
            ownerLabel.textContent = (role.nick || role.name) + ' çš„æ‰‹æœº';
            
            const now = new Date();
            const hh = now.getHours().toString().padStart(2, '0');
            const mm = now.getMinutes().toString().padStart(2, '0');
            timeEl.textContent = hh + ':' + mm;
            lockTime.textContent = hh + ':' + mm;
            
            const weekdays = ['æ˜ŸæœŸæ—¥','æ˜ŸæœŸä¸€','æ˜ŸæœŸäºŒ','æ˜ŸæœŸä¸‰','æ˜ŸæœŸå››','æ˜ŸæœŸäº”','æ˜ŸæœŸå…­'];
            lockDate.textContent = (now.getMonth()+1) + 'æœˆ' + now.getDate() + 'æ—¥ ' + weekdays[now.getDay()];
            
            // æ·¡é›…å£çº¸è‰²
            const wallpapers = [
                'linear-gradient(160deg, #fdf6f0 0%, #fce4ec 40%, #e8daef 70%, #d5daf5 100%)',
                'linear-gradient(160deg, #fefefe 0%, #fce4ec 50%, #f3e5f5 100%)',
                'linear-gradient(160deg, #fafafa 0%, #e8f5e9 40%, #e3f2fd 100%)',
                'linear-gradient(160deg, #fff8e1 0%, #ffe0b2 40%, #ffccbc 100%)',
                'linear-gradient(160deg, #f3e5f5 0%, #e1bee7 40%, #d1c4e9 100%)',
                'linear-gradient(160deg, #e0f7fa 0%, #b2ebf2 40%, #b2dfdb 100%)',
            ];
            wallpaper.style.background = wallpapers[Math.floor(Math.random() * wallpapers.length)];
            
            // éšè—è§’è‰²é€‰æ‹©é¡µï¼Œæ˜¾ç¤ºæ¡Œé¢
            document.getElementById('findphone-roles-page').style.display = 'none';
            desktop.style.display = 'flex';
        }
        
        // å…³é—­æ‰‹æœºæ¡Œé¢
        function closeFindPhoneDesktop() {
            const desktop = document.getElementById('findphone-desktop');
            desktop.style.transform = 'scale(0.95)';
            desktop.style.opacity = '0';
            setTimeout(() => {
                desktop.style.display = 'none';
                desktop.style.transform = '';
                desktop.style.opacity = '';
                findPhoneTargetRoleId = null;
            }, 200);
        }
        
        // å·²éªŒè¯è¿‡çš„è§’è‰²IDé›†åˆï¼ˆç™»å½•ä¸€æ¬¡åä¸å†è¦æ±‚è¾“å…¥å¯†ç ï¼ŒæŒä¹…åŒ–åˆ°localStorageï¼‰
        const fpWechatVerified = new Set(JSON.parse(localStorage.getItem('fpWechatVerified') || '[]'));
        function saveFpWechatVerified() {
            safeLocalStorageSet('fpWechatVerified', JSON.stringify([...fpWechatVerified]));
        }
        
        // ç¬¬å››æ­¥ï¼šåœ¨è§’è‰²æ‰‹æœºæ¡Œé¢ç‚¹å‡»WeChat â†’ æ˜¾ç¤ºç™»å½•æ¡†ï¼ˆå·²éªŒè¯è¿‡åˆ™ç›´æ¥è¿›å…¥ï¼‰
        async function openFindPhoneWechat() {
            // å¦‚æœè¯¥è§’è‰²å·²ç»éªŒè¯è¿‡ï¼Œç›´æ¥è¿›å…¥å¾®ä¿¡
            if (fpWechatVerified.has(findPhoneTargetRoleId)) {
                window._fpWechatRoleId = findPhoneTargetRoleId;
                const fpPage = document.getElementById('fp-wechat-page');
                fpPage.style.display = 'flex';
                await switchFpWechatTab(0);
                return;
            }
            
            const loginOverlay = document.getElementById('findphone-wechat-login');
            const accountInput = document.getElementById('findphone-login-account');
            const passwordInput = document.getElementById('findphone-login-password');
            const errorEl = document.getElementById('findphone-login-error');
            
            // æ¸…ç©ºè¾“å…¥æ¡†å’Œé”™è¯¯æç¤º
            accountInput.value = '';
            passwordInput.value = '';
            errorEl.style.display = 'none';
            
            loginOverlay.style.display = 'flex';
            
            // èšç„¦è´¦å·è¾“å…¥æ¡†
            setTimeout(() => accountInput.focus(), 300);
        }
        
        // å…³é—­ç™»å½•æ¡†
        function closeFindPhoneLogin() {
            document.getElementById('findphone-wechat-login').style.display = 'none';
        }
        
        // æŸ¥æ‰‹æœºWeChatç™»å½•éªŒè¯ï¼ˆéªŒè¯è§’è‰²charçš„è´¦å·å¯†ç ï¼‰
        async function findPhoneWechatLogin() {
            const accountInput = document.getElementById('findphone-login-account');
            const passwordInput = document.getElementById('findphone-login-password');
            const errorEl = document.getElementById('findphone-login-error');
            
            const inputAccount = accountInput.value.trim();
            const inputPassword = passwordInput.value.trim();
            
            if (!inputAccount || !inputPassword) {
                errorEl.textContent = 'è¯·è¾“å…¥è´¦å·å’Œå¯†ç ';
                errorEl.style.display = 'block';
                return;
            }
            
            // è·å–å½“å‰é€‰ä¸­çš„è§’è‰²ï¼ˆcharï¼‰ï¼ŒéªŒè¯è§’è‰²çš„è´¦å·å’Œå¯†ç 
            const roleChar = await db.characters.get(parseInt(findPhoneTargetRoleId));
            if (!roleChar) {
                errorEl.textContent = 'è§’è‰²æ•°æ®å¼‚å¸¸';
                errorEl.style.display = 'block';
                return;
            }
            
            const charAccount = roleChar.identity?.account || '';
            const charPassword = roleChar.identity?.password || '';
            
            if (inputAccount !== charAccount || inputPassword !== charPassword) {
                errorEl.textContent = 'è´¦å·æˆ–å¯†ç é”™è¯¯';
                errorEl.style.display = 'block';
                // éœ‡åŠ¨æ•ˆæœ
                const card = errorEl.closest('.findphone-login-card');
                card.style.animation = 'none';
                card.offsetHeight;
                card.style.animation = 'findphoneShake 0.4s ease';
                return;
            }
            
            // ç™»å½•æˆåŠŸï¼å…³é—­ç™»å½•æ¡†
            closeFindPhoneLogin();
            
            // è®°å½•ä¸ºå·²éªŒè¯ï¼Œä¸‹æ¬¡ä¸å†éœ€è¦è¾“å…¥å¯†ç 
            fpWechatVerified.add(findPhoneTargetRoleId);
            saveFpWechatVerified();
            
            // è®°å½•ç™»å½•çš„è§’è‰²IDï¼ˆç”¨äº"æˆ‘"é¡µé¢æ˜¾ç¤ºè§’è‰²ä¿¡æ¯ï¼‰
            window._fpWechatRoleId = findPhoneTargetRoleId;
            
            // æ‰“å¼€å…¨æ–°ç‹¬ç«‹çš„WeChaté¡µé¢
            const fpPage = document.getElementById('fp-wechat-page');
            fpPage.style.display = 'flex';
            
            // é»˜è®¤åˆ‡åˆ°ç¬¬ä¸€ä¸ªtabï¼ˆå¾®ä¿¡èŠå¤©åˆ—è¡¨ï¼‰
            await switchFpWechatTab(0);
        }
        
        // å…³é—­æŸ¥æ‰‹æœºçš„ç‹¬ç«‹WeChaté¡µé¢
        function closeFpWechat() {
            // å…³é—­æ‰€æœ‰fpå­é¡µé¢
            ['fp-service-page', 'fp-wallet-page', 'fp-balance-page', 'fp-bill-page', 'fp-moments-page', 'fp-baidu-page'].forEach(id => {
                const el = document.getElementById(id);
                if (el) { el.style.display = 'none'; el.classList.remove('slide-in', 'active'); }
            });
            
            const fpPage = document.getElementById('fp-wechat-page');
            fpPage.style.transform = 'scale(0.95)';
            fpPage.style.opacity = '0';
            setTimeout(() => {
                fpPage.style.display = 'none';
                fpPage.style.transform = '';
                fpPage.style.opacity = '';
            }, 200);
            // å›åˆ°æŸ¥æ‰‹æœºæ¡Œé¢
            document.getElementById('findphone-desktop').style.display = 'flex';
        }
        
        // ===== æŸ¥æ‰‹æœº - ç™¾åº¦æœç´¢å†å²åŠŸèƒ½ =====
        
        /**
         * æ‰“å¼€ç™¾åº¦æœç´¢å†å²é¡µé¢
         */
        async function openFindPhoneBaidu() {
            const baiduPage = document.getElementById('fp-baidu-page');
            baiduPage.style.display = 'flex';
            
            // åŠ è½½å·²æœ‰çš„æœç´¢è®°å½•
            await loadBaiduSearchHistory();
        }
        
        /**
         * å…³é—­ç™¾åº¦æœç´¢å†å²é¡µé¢
         */
        function closeFpBaidu() {
            const baiduPage = document.getElementById('fp-baidu-page');
            baiduPage.style.transform = 'scale(0.95)';
            baiduPage.style.opacity = '0';
            setTimeout(() => {
                baiduPage.style.display = 'none';
                baiduPage.style.transform = '';
                baiduPage.style.opacity = '';
            }, 200);
            // å›åˆ°æŸ¥æ‰‹æœºæ¡Œé¢
            document.getElementById('findphone-desktop').style.display = 'flex';
        }
        
        /**
         * åŠ è½½ç™¾åº¦æœç´¢å†å²ï¼ˆä»è§’è‰²æ•°æ®ä¸­è¯»å–ï¼‰
         */
        async function loadBaiduSearchHistory() {
            const roleId = findPhoneTargetRoleId;
            if (!roleId) return;
            
            const roleChar = await db.characters.get(parseInt(roleId));
            if (!roleChar) return;
            
            const searchData = roleChar.generated_baidu_search || [];
            renderBaiduSearchList(searchData);
        }
        
        /**
         * æ¸²æŸ“ç™¾åº¦æœç´¢è®°å½•åˆ—è¡¨
         */
        function renderBaiduSearchList(searchList) {
            const container = document.getElementById('fp-baidu-content');
            
            if (!searchList || searchList.length === 0) {
                container.innerHTML = `
                    <div class="fp-baidu-empty">
                        <svg viewBox="0 0 24 24" style="width:48px; height:48px; stroke:#ddd; fill:none; stroke-width:1.5;">
                            <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                        </svg>
                        <div style="margin-top:12px; color:#ccc; font-size:14px;">æš‚æ— æœç´¢è®°å½•</div>
                        <div style="margin-top:4px; color:#ddd; font-size:12px;">ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®ç”Ÿæˆ</div>
                    </div>`;
                return;
            }
            
            let html = '<div class="fp-baidu-section-title">æœç´¢å†å²</div><div class="fp-baidu-list">';
            searchList.forEach((item, idx) => {
                const topClass = idx === 0 ? 'top1' : idx === 1 ? 'top2' : idx === 2 ? 'top3' : '';
                html += `
                    <div class="fp-baidu-item">
                        <div class="fp-baidu-item-index ${topClass}">${idx + 1}</div>
                        <div class="fp-baidu-item-body">
                            <div class="fp-baidu-item-keyword">${escapeHtml(item.keyword)}</div>
                            <div class="fp-baidu-item-meta">
                                <span>${escapeHtml(item.time || '')}</span>
                                ${item.tag ? `<span class="fp-baidu-item-tag">${escapeHtml(item.tag)}</span>` : ''}
                            </div>
                        </div>
                    </div>`;
            });
            html += '</div>';
            container.innerHTML = html;
        }
        
        /**
         * ç”Ÿæˆç™¾åº¦æœç´¢è®°å½• - è°ƒç”¨ä¸»APIï¼Œæ ¹æ®è§’è‰²å’Œç”¨æˆ·æœ€è¿‘50æ¡èŠå¤©è®°å½•ç”Ÿæˆ10æ¡æœç´¢è®°å½•
         */
        async function generateBaiduSearchHistory() {
            const roleId = findPhoneTargetRoleId;
            const accountId = findPhoneTargetAccountId;
            if (!roleId) {
                showToast?.('è§’è‰²æ•°æ®å¼‚å¸¸') || alert('è§’è‰²æ•°æ®å¼‚å¸¸');
                return;
            }
            
            // è·å–è§’è‰²ä¿¡æ¯
            const roleChar = await db.characters.get(parseInt(roleId));
            if (!roleChar) {
                showToast?.('è§’è‰²æ•°æ®å¼‚å¸¸') || alert('è§’è‰²æ•°æ®å¼‚å¸¸');
                return;
            }
            
            // è®¾ç½®æŒ‰é’®ä¸ºåŠ è½½çŠ¶æ€
            const btn = document.getElementById('fp-baidu-generate-btn');
            const btnText = document.getElementById('fp-baidu-generate-text');
            btn.disabled = true;
            btnText.innerHTML = '<span class="loading-spinner-sm"></span> ç”Ÿæˆä¸­...';
            
            try {
                // è·å–ç”¨æˆ·è§’è‰²ä¿¡æ¯
                const myChar = accountId ? await db.characters.get(parseInt(accountId)) : null;
                
                // è·å–è§’è‰²ä¸ç”¨æˆ·æœ€è¿‘50æ¡èŠå¤©è®°å½•
                const chatHistory = getChatHistory(roleChar, accountId);
                const recent50 = chatHistory.slice(-50);
                const recentChatsText = recent50.map(m => 
                    `${m.role === 'user' ? (myChar?.name || 'ç”¨æˆ·') : roleChar.name}: ${m.content}`
                ).join('\n');
                
                // è·å–ä¸–ç•Œä¹¦ä¸Šä¸‹æ–‡
                let loreContext = '';
                const lorebookIds = roleChar.lorebookIds || (roleChar.lorebookId ? [roleChar.lorebookId] : []);
                if (typeof getLorebookContext === 'function') {
                    loreContext = await getLorebookContext(lorebookIds, roleChar.name);
                }
                
                // æ„å»ºAIæç¤º
                const prompt = `ä½ æ˜¯ä¸€ä¸ªæ•°æ®ç”ŸæˆåŠ©æ‰‹ã€‚è¯·æ ¹æ®ä»¥ä¸‹è§’è‰²ä¿¡æ¯å’ŒèŠå¤©è®°å½•ï¼Œç”Ÿæˆè¿™ä¸ªè§’è‰²åœ¨ç™¾åº¦ä¸Šçš„æœç´¢å†å²è®°å½•ã€‚

ã€è§’è‰²ä¿¡æ¯ã€‘
åå­—ï¼š${roleChar.name}
${roleChar.nick ? `æ˜µç§°ï¼š${roleChar.nick}` : ''}
è®¾å®šï¼š${roleChar.description || 'æ— '}

${roleChar.identity ? `ã€è™šæ‹Ÿèº«ä»½ã€‘
æ‰‹æœºï¼š${roleChar.identity.phone || 'æœªçŸ¥'}
ä½å€ï¼š${roleChar.identity.address || 'æœªçŸ¥'}
` : ''}

${myChar ? `ã€ä¸ç”¨æˆ·çš„å…³ç³»ã€‘
ç”¨æˆ·åï¼š${myChar.name}
ç”¨æˆ·è®¾å®šï¼š${myChar.description || 'æ— '}
` : ''}

${recentChatsText ? `ã€ä¸ç”¨æˆ·çš„æœ€è¿‘èŠå¤©è®°å½•ï¼ˆçœŸå®æ•°æ®ï¼Œå…±${recent50.length}æ¡ï¼‰ã€‘
${recentChatsText}
` : ''}

${loreContext ? `ã€ä¸–ç•Œè§‚èƒŒæ™¯ã€‘
${loreContext}
` : ''}

è¯·ç”Ÿæˆä»¥ä¸‹JSONæ•°æ®ï¼ˆä¸¥æ ¼æŒ‰ç…§æ ¼å¼è¿”å›ï¼Œä¸è¦åŒ…å«markdownä»£ç å—æ ‡è®°ï¼‰ï¼š
{
    "searches": [
        {
            "keyword": "æœç´¢å…³é”®è¯",
            "time": "æœç´¢æ—¶é—´ï¼Œå¦‚ï¼šä»Šå¤© 09:30 / æ˜¨å¤© 22:15 / 3å¤©å‰",
            "tag": "å¯é€‰æ ‡ç­¾ï¼Œå¦‚ï¼šè´­ç‰©/æƒ…æ„Ÿ/å­¦ä¹ /å·¥ä½œ/å¨±ä¹/ç”Ÿæ´»/å¥åº·"
        }
    ]
}

ç”Ÿæˆè¦æ±‚ï¼š
1. ç”Ÿæˆæ°å¥½10æ¡æœç´¢è®°å½•
2. æœç´¢å†…å®¹å¿…é¡»å®Œå…¨è´´åˆè§’è‰²çš„æ€§æ ¼ã€èº«ä»½ã€è®¾å®šå’Œä¸–ç•Œè§‚
3. è¦æ ¹æ®èŠå¤©è®°å½•ä¸­æåˆ°çš„è¯é¢˜ã€æƒ…ç»ªã€äº‹ä»¶æ¥æ¨æ–­è§’è‰²å¯èƒ½ä¼šæœç´¢ä»€ä¹ˆ
4. æœç´¢å†…å®¹è¦çœŸå®è‡ªç„¶ï¼ŒåƒçœŸå®çš„äººåœ¨ç™¾åº¦ä¸Šæœç´¢ä¸€æ ·ï¼ˆåŒ…å«é”™åˆ«å­—ã€å£è¯­åŒ–è¡¨è¾¾ä¹Ÿå¯ä»¥ï¼‰
5. æ—¶é—´ä»æœ€è¿‘åˆ°æœ€è¿œæ’åˆ—
6. è¦æœ‰å¤šæ ·æ€§ï¼šå¯ä»¥åŒ…å«æƒ…æ„Ÿç±»ã€æ—¥å¸¸ç”Ÿæ´»ç±»ã€å…´è¶£çˆ±å¥½ç±»ã€å·¥ä½œå­¦ä¹ ç±»ç­‰
7. å¦‚æœèŠå¤©è®°å½•ä¸­æœ‰ç‰¹åˆ«çš„äº‹ä»¶æˆ–æƒ…ç»ªï¼ˆæ¯”å¦‚åµæ¶ã€è¡¨ç™½ã€çº¦ä¼šç­‰ï¼‰ï¼Œæœç´¢è®°å½•åº”è¯¥ä½“ç°å‡ºè§’è‰²å¯¹è¿™äº›äº‹æƒ…çš„å…³æ³¨`;

                // è°ƒç”¨ä¸»API
                const result = await callAI([
                    { role: 'system', content: 'ä½ æ˜¯ä¸€ä¸ªJSONæ•°æ®ç”ŸæˆåŠ©æ‰‹ï¼Œåªè¿”å›çº¯JSONæ ¼å¼ï¼Œä¸è¦åŒ…å«ä»»ä½•markdownæ ‡è®°æˆ–å…¶ä»–æ–‡å­—ã€‚' },
                    { role: 'user', content: prompt }
                ], 0.7);
                
                console.log('[generateBaiduSearchHistory] AIè¿”å›:', result);
                
                // è§£æç»“æœ
                let searchData;
                try {
                    let cleanResult = result.trim();
                    if (cleanResult.startsWith('```')) {
                        cleanResult = cleanResult.replace(/```json?\n?/g, '').replace(/```$/g, '').trim();
                    }
                    searchData = JSON.parse(cleanResult);
                } catch (e) {
                    console.error('[generateBaiduSearchHistory] è§£æJSONå¤±è´¥:', e);
                    // ä½¿ç”¨é»˜è®¤æ•°æ®
                    searchData = {
                        searches: [
                            { keyword: 'ä»Šå¤©å¤©æ°”', time: 'ä»Šå¤© 10:00', tag: 'ç”Ÿæ´»' },
                            { keyword: roleChar.name + ' æ—¥å¸¸', time: 'æ˜¨å¤© 20:30', tag: 'ç”Ÿæ´»' }
                        ]
                    };
                }
                
                const searches = searchData.searches || searchData.search || [];
                
                // ä¿å­˜åˆ°è§’è‰²æ•°æ®
                const freshChar = await db.characters.get(parseInt(roleId));
                if (freshChar) {
                    freshChar.generated_baidu_search = searches;
                    freshChar.generated_baidu_search_at = Date.now();
                    await safeCharacterPut(freshChar);
                }
                
                // æ¸²æŸ“æœç´¢åˆ—è¡¨
                renderBaiduSearchList(searches);
                
                if (typeof showToast === 'function') {
                    showToast('æœç´¢è®°å½•å·²ç”Ÿæˆ');
                }
                
            } catch (err) {
                console.error('[generateBaiduSearchHistory] ç”Ÿæˆå¤±è´¥:', err);
                if (typeof showToast === 'function') {
                    showToast('ç”Ÿæˆå¤±è´¥ï¼š' + (err.message || 'æœªçŸ¥é”™è¯¯'));
                } else {
                    alert('ç”Ÿæˆå¤±è´¥ï¼š' + (err.message || 'æœªçŸ¥é”™è¯¯'));
                }
            } finally {
                // æ¢å¤æŒ‰é’®çŠ¶æ€
                btn.disabled = false;
                btnText.innerHTML = 'ç”Ÿæˆæœç´¢è®°å½•';
            }
        }

        // æŸ¥æ‰‹æœºç‹¬ç«‹WeChatçš„tabåˆ‡æ¢
        async function switchFpWechatTab(index) {
            const tabs = document.querySelectorAll('#fp-wechat-page .wechat-tab-item');
            tabs.forEach((tab, i) => {
                if (i === index) tab.classList.add('active');
                else tab.classList.remove('active');
            });
            
            const titleEl = document.getElementById('fp-wechat-title');
            const content = document.getElementById('fp-wechat-content');
            
            if (index === 0) {
                titleEl.textContent = 'å¾®ä¿¡';
                await renderFpChatList(content);
            } else if (index === 1) {
                titleEl.textContent = 'é€šè®¯å½•';
                await renderFpContactList(content);
            } else if (index === 2) {
                titleEl.textContent = 'å‘ç°';
                await renderFpDiscoverPage(content);
            } else if (index === 3) {
                titleEl.textContent = 'æˆ‘';
                await renderFpMePage(content);
            }
        }
        
        // æŸ¥æ‰‹æœºWeChat - æ¸²æŸ“èŠå¤©åˆ—è¡¨ï¼ˆè§’è‰²è‡ªå·±çš„å¾®ä¿¡æ¶ˆæ¯åˆ—è¡¨ï¼ŒåŸºäºè§’è‰²çš„é€šè®¯å½•ï¼‰
        async function renderFpChatList(container) {
            const roleId = window._fpWechatRoleId;
            const accountId = findPhoneTargetAccountId;
            let roleChar = await db.characters.get(parseInt(roleId));
            
            // â˜… è‡ªåŠ¨å°†å…³è”NPCå¡«å……åˆ°é€šè®¯å½•
            roleChar = await autoPopulateRelationshipContacts(roleChar, accountId);
            
            // è·å–è¯¥è§’è‰²è‡ªå·±çš„é€šè®¯å½•è”ç³»äºº
            const contactIds = getRolePhoneContacts(roleChar, accountId);
            const allChars = await db.characters.toArray();
            const chatContacts = [];
            
            // 1. æ·»åŠ è¯¥NPCå…³è”çš„ç”¨æˆ·ï¼ˆå³é€‰ä¸­çš„ç”¨æˆ·è´¦å·ï¼Œå§‹ç»ˆæ˜¾ç¤ºï¼‰
            if (accountId) {
                const userChar = await db.characters.get(parseInt(accountId));
                if (userChar) {
                    // è·å–è¯¥NPCå’Œç”¨æˆ·çš„èŠå¤©è®°å½•
                    const chatHistory = roleChar?.chat_history_by_user?.[accountId] || roleChar?.chat_history || [];
                    const lastMsg = chatHistory.length > 0 ? chatHistory[chatHistory.length - 1] : null;
                    chatContacts.push({
                        char: userChar,
                        lastMsg: lastMsg,
                        lastTime: lastMsg ? (lastMsg.time || lastMsg.timestamp || '') : ''
                    });
                }
            }
            
            // 2. åªæ˜¾ç¤ºè¯¥è§’è‰²é€šè®¯å½•ä¸­çš„NPCè”ç³»äººï¼ˆè¯»å–fp_npc_èŠå¤©è®°å½•ï¼‰
            for (const cid of contactIds) {
                const npc = allChars.find(ch => ch.id === cid);
                if (npc && String(npc.id) !== String(roleId) && npc.type !== 'user') {
                    const fpNpcKey = 'fp_npc_' + cid;
                    const npcHistory = roleChar?.chat_history_by_user?.[fpNpcKey] || [];
                    const npcLastMsg = npcHistory.length > 0 ? npcHistory[npcHistory.length - 1] : null;
                    chatContacts.push({
                        char: npc,
                        lastMsg: npcLastMsg,
                        lastTime: npcLastMsg ? (npcLastMsg.time || '') : ''
                    });
                }
            }
            
            if (chatContacts.length === 0) {
                container.innerHTML = `<div class="wechat-empty-state"><svg class="svg-icon" style="width:48px; height:48px; stroke:#ccc;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="8" y1="15" x2="16" y2="15"></line><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg><div>æš‚æ— æ¶ˆæ¯</div></div>`;
                return;
            }
            
            let html = '<div style="width:100%; background:#fff;">';
            // è·å–è§’è‰²å¯¹ç”¨æˆ·çš„å¤‡æ³¨å
            const fpRemark = roleChar?.fp_remark_by_user?.[accountId] || '';
            for (const contact of chatContacts) {
                const c = contact.char;
                const cAvatar = getCharAvatar(c, accountId);
                const avatarStyle = cAvatar ? `background-image:url(${cAvatar})` : 'background-color:#e8e8e8';
                const displayName = c.type === 'user' ? (fpRemark || c.nick || c.name) : getCharDisplayName(c, accountId);
                const lastMsgText = contact.lastMsg ? (contact.lastMsg.text || contact.lastMsg.content || '').substring(0, 20) : '';
                
                html += `
                    <div class="fp-chat-list-item" data-contact-id="${c.id}" style="display:flex; padding:12px 16px; border-bottom:0.5px solid #f0f0f0; align-items:center; gap:12px; cursor:pointer; transition:background 0.15s;" onmousedown="this.style.background='#f0f0f0'" onmouseup="this.style.background=''" onmouseleave="this.style.background=''">
                        <div style="width:48px; height:48px; border-radius:6px; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0;"></div>
                        <div style="flex:1; min-width:0;">
                            <div style="font-size:16px; font-weight:500; color:#1a1a1a; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${displayName}</div>
                            <div style="font-size:13px; color:#999; margin-top:2px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${lastMsgText || 'æš‚æ— æ¶ˆæ¯'}</div>
                        </div>
                    </div>
                `;
            }
            html += '</div>';
            container.innerHTML = html;
            
            // ç»‘å®šç‚¹å‡»äº‹ä»¶ï¼šç‚¹å‡»èŠå¤©åˆ—è¡¨é¡¹è¿›å…¥èŠå¤©è¯¦æƒ…ï¼ˆè§†è§’è½¬æ¢ï¼‰
            container.querySelectorAll('.fp-chat-list-item').forEach(item => {
                item.addEventListener('click', () => {
                    const contactId = parseInt(item.dataset.contactId);
                    openFpChatDetail(contactId);
                });
            });
        }
        
        // è·å–è§’è‰²è‡ªå·±çš„é€šè®¯å½•è”ç³»äººIDåˆ—è¡¨
        function getRolePhoneContacts(roleChar, accountId) {
            if (!roleChar) return [];
            const phoneContacts = roleChar.phone_contacts_by_user || {};
            return phoneContacts[accountId] || [];
        }
        
        // æ·»åŠ è”ç³»äººåˆ°è§’è‰²çš„é€šè®¯å½•
        async function addRolePhoneContact(roleId, accountId, contactCharId) {
            const roleChar = await db.characters.get(parseInt(roleId));
            if (!roleChar) return;
            if (!roleChar.phone_contacts_by_user) roleChar.phone_contacts_by_user = {};
            if (!roleChar.phone_contacts_by_user[accountId]) roleChar.phone_contacts_by_user[accountId] = [];
            const list = roleChar.phone_contacts_by_user[accountId];
            if (!list.includes(contactCharId)) {
                list.push(contactCharId);
                await safeCharacterPut(roleChar);
            }
        }
        
        // ä»è§’è‰²çš„é€šè®¯å½•ç§»é™¤è”ç³»äºº
        async function removeRolePhoneContact(roleId, accountId, contactCharId) {
            const roleChar = await db.characters.get(parseInt(roleId));
            if (!roleChar) return;
            if (!roleChar.phone_contacts_by_user) return;
            if (!roleChar.phone_contacts_by_user[accountId]) return;
            roleChar.phone_contacts_by_user[accountId] = roleChar.phone_contacts_by_user[accountId].filter(id => id !== contactCharId);
            await safeCharacterPut(roleChar);
        }
        
        // â˜… è‡ªåŠ¨å°†è§’è‰²çš„ relationships å…³è”NPCå¡«å……åˆ°é€šè®¯å½•ä¸­ï¼ˆé»˜è®¤å¥½å‹ï¼‰
        async function autoPopulateRelationshipContacts(roleChar, accountId) {
            if (!roleChar || !accountId) return roleChar;
            if (!roleChar.relationships || roleChar.relationships.length === 0) return roleChar;
            
            if (!roleChar.phone_contacts_by_user) roleChar.phone_contacts_by_user = {};
            if (!roleChar.phone_contacts_by_user[accountId]) roleChar.phone_contacts_by_user[accountId] = [];
            
            const list = roleChar.phone_contacts_by_user[accountId];
            let changed = false;
            
            for (const rel of roleChar.relationships) {
                if (!rel.targetId) continue;
                // æ£€æŸ¥ç›®æ ‡è§’è‰²æ˜¯å¦å­˜åœ¨ä¸”ä¸æ˜¯userç±»å‹
                try {
                    const targetChar = await db.characters.get(rel.targetId);
                    if (!targetChar || targetChar.type === 'user') continue;
                    if (String(targetChar.id) === String(roleChar.id)) continue;
                    
                    if (!list.includes(targetChar.id)) {
                        list.push(targetChar.id);
                        changed = true;
                        console.log(`[è‡ªåŠ¨å¡«å……é€šè®¯å½•] âœ… å°†å…³è”NPC "${rel.targetName}"(id=${rel.targetId}) æ·»åŠ åˆ° ${roleChar.name} çš„é€šè®¯å½•`);
                    }
                } catch (e) {
                    console.warn(`[è‡ªåŠ¨å¡«å……é€šè®¯å½•] è·³è¿‡å…³è”è§’è‰² ${rel.targetName}:`, e);
                }
            }
            
            if (changed) {
                await safeCharacterPut(roleChar);
                console.log(`[è‡ªåŠ¨å¡«å……é€šè®¯å½•] å·²æ›´æ–° ${roleChar.name} çš„é€šè®¯å½•ï¼Œå½“å‰è”ç³»äººæ•°: ${list.length}`);
            }
            
            return roleChar;
        }
        
        // æŸ¥æ‰‹æœºWeChat - æ¸²æŸ“é€šè®¯å½•ï¼ˆæ˜¾ç¤ºè¯¥è§’è‰²è‡ªå·±çš„è”ç³»äººï¼Œè€Œéç”¨æˆ·çš„å¥½å‹åˆ—è¡¨ï¼‰
        async function renderFpContactList(container) {
            const roleId = window._fpWechatRoleId;
            const accountId = findPhoneTargetAccountId;
            let roleChar = await db.characters.get(parseInt(roleId));
            
            // â˜… è‡ªåŠ¨å°†å…³è”NPCå¡«å……åˆ°é€šè®¯å½•
            roleChar = await autoPopulateRelationshipContacts(roleChar, accountId);
            
            const allChars = await db.characters.toArray();
            
            // è·å–è¯¥è§’è‰²è‡ªå·±çš„é€šè®¯å½•è”ç³»äººIDåˆ—è¡¨
            const contactIds = getRolePhoneContacts(roleChar, accountId);
            
            let contacts = [];
            
            // 1. æ·»åŠ ç”¨æˆ·å¥½å‹ï¼ˆè¯¥è§’è‰²å…³è”çš„ç”¨æˆ·è´¦å·ï¼Œå§‹ç»ˆæ˜¾ç¤ºï¼‰
            if (accountId) {
                const userChar = await db.characters.get(parseInt(accountId));
                if (userChar) {
                    contacts.push({ char: userChar, isUser: true });
                }
            }
            
            // 2. åªæ·»åŠ è¯¥è§’è‰²é€šè®¯å½•ä¸­æ˜ç¡®å­˜åœ¨çš„NPCè”ç³»äºº
            for (const cid of contactIds) {
                const c = allChars.find(ch => ch.id === cid);
                if (c && String(c.id) !== String(roleId) && c.type !== 'user') {
                    contacts.push({ char: c, isUser: false });
                }
            }
            
            container.innerHTML = '';
            const listDiv = document.createElement('div');
            listDiv.style.width = '100%';
            listDiv.style.background = '#fff';
            
            // "æ·»åŠ è”ç³»äºº"å…¥å£ï¼ˆä»ç”¨æˆ·å¥½å‹åˆ—è¡¨ä¸­æ·»åŠ åˆ°è§’è‰²é€šè®¯å½•ï¼‰
            const addContactItem = document.createElement('div');
            addContactItem.style.cssText = 'display:flex; padding:12px 16px; border-bottom:0.5px solid #f0f0f0; align-items:center; gap:12px; cursor:pointer;';
            addContactItem.onclick = () => showFpAddContactPicker(roleId, accountId, allChars, contactIds, container);
            addContactItem.innerHTML = `
                <div style="width:40px; height:40px; border-radius:4px; background:linear-gradient(135deg, #ffc2d1 0%, #ff8fab 100%); display:flex; align-items:center; justify-content:center;">
                    <svg class="svg-icon" style="width:24px; height:24px; stroke:#fff;" viewBox="0 0 24 24">
                        <path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                        <circle cx="8.5" cy="7" r="4"></circle>
                        <line x1="20" y1="8" x2="20" y2="14"></line>
                        <line x1="23" y1="11" x2="17" y2="11"></line>
                    </svg>
                </div>
                <div style="flex:1; font-size:16px; font-weight:500; color:#333;">æ·»åŠ è”ç³»äºº</div>
                <div style="color:#ccc; font-size:18px;">â€º</div>
            `;
            listDiv.appendChild(addContactItem);
            
            if (contacts.length === 0) {
                const emptyDiv = document.createElement('div');
                emptyDiv.style.textAlign = 'center';
                emptyDiv.style.padding = '40px 20px';
                emptyDiv.style.color = '#999';
                emptyDiv.innerHTML = `
                    <svg class="svg-icon" style="width:48px; height:48px; stroke:#ccc; margin-bottom:10px;" viewBox="0 0 24 24"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>
                    <div>é€šè®¯å½•ä¸ºç©º</div>
                `;
                listDiv.appendChild(emptyDiv);
            } else {
                // ç”¨æˆ·å¥½å‹åˆ†ç»„
                const userFriends = contacts.filter(c => c.isUser);
                const npcFriendsArr = contacts.filter(c => !c.isUser);
                
                if (userFriends.length > 0) {
                    const sectionTitle = document.createElement('div');
                    sectionTitle.style.cssText = 'padding:8px 16px; font-size:13px; color:#888; background:#f7f7f7; font-weight:500;';
                    sectionTitle.textContent = 'å¥½å‹';
                    listDiv.appendChild(sectionTitle);
                    
                    // è·å–è§’è‰²å¯¹ç”¨æˆ·çš„å¤‡æ³¨
                    const fpRemarkContact = roleChar?.fp_remark_by_user?.[accountId] || '';
                    for (const contact of userFriends) {
                        const item = document.createElement('div');
                        item.style.cssText = 'display:flex; padding:10px 16px; border-bottom:0.5px solid #f0f0f0; align-items:center; gap:12px; cursor:pointer; transition:background 0.15s;';
                        item.onmousedown = function() { this.style.background = '#f5f5f5'; };
                        item.onmouseup = function() { this.style.background = ''; };
                        item.onmouseleave = function() { this.style.background = ''; };
                        
                        const c = contact.char;
                        const cAvatar = c.avatar || '';
                        const avatarStyle = cAvatar ? `background-image:url(${cAvatar})` : 'background-color:#e8e8e8';
                        const displayName = fpRemarkContact || c.nick || c.name;
                        
                        item.innerHTML = `
                            <div style="width:40px; height:40px; border-radius:4px; ${avatarStyle}; background-size:cover; background-position:center;"></div>
                            <div style="flex:1; font-size:16px; font-weight:500; color:#333;">${displayName}</div>
                            <div style="color:#ccc; font-size:18px;">â€º</div>
                        `;
                        // ç‚¹å‡»è¿›å…¥èŠå¤©è¯¦æƒ…ï¼ˆè§†è§’è½¬æ¢ï¼‰
                        const charId = c.id;
                        item.onclick = () => openFpChatDetail(charId);
                        listDiv.appendChild(item);
                    }
                }
                
                if (npcFriendsArr.length > 0) {
                    const sectionTitle = document.createElement('div');
                    sectionTitle.style.cssText = 'padding:8px 16px; font-size:13px; color:#888; background:#f7f7f7; font-weight:500;';
                    sectionTitle.textContent = 'è”ç³»äºº';
                    listDiv.appendChild(sectionTitle);
                    
                    for (const contact of npcFriendsArr) {
                        const item = createFpContactItem(contact.char, accountId, roleId, container);
                        listDiv.appendChild(item);
                    }
                }
            }
            
            container.appendChild(listDiv);
        }
        
        // åˆ›å»ºè”ç³»äººè¡Œï¼ˆå¸¦ç‚¹å‡»æŸ¥çœ‹èŠå¤© + é•¿æŒ‰åˆ é™¤åŠŸèƒ½ï¼‰
        function createFpContactItem(c, accountId, roleId, container) {
            const item = document.createElement('div');
            item.style.cssText = 'display:flex; padding:10px 16px; border-bottom:0.5px solid #f0f0f0; align-items:center; gap:12px; position:relative; cursor:pointer; transition:background 0.15s;';
            item.onmousedown = function() { this.style.background = '#f5f5f5'; };
            item.onmouseup = function() { this.style.background = ''; };
            item.onmouseleave = function() { this.style.background = ''; };
            
            const cAvatar = getCharAvatar(c, accountId);
            const avatarStyle = cAvatar ? `background-image:url(${cAvatar})` : 'background-color:#e8e8e8';
            const displayName = getCharDisplayName(c, accountId);
            
            item.innerHTML = `
                <div style="width:40px; height:40px; border-radius:4px; ${avatarStyle}; background-size:cover; background-position:center;"></div>
                <div style="flex:1; font-size:16px; font-weight:500; color:#333;">${displayName}</div>
                <div style="color:#ccc; font-size:18px;">â€º</div>
            `;
            
            // ç‚¹å‡»è¿›å…¥èŠå¤©è¯¦æƒ…ï¼ˆè§†è§’è½¬æ¢ï¼‰
            const charId = c.id;
            item.addEventListener('click', () => openFpChatDetail(charId));
            
            // é•¿æŒ‰åˆ é™¤è”ç³»äºº
            let pressTimer = null;
            item.addEventListener('touchstart', () => {
                pressTimer = setTimeout(() => {
                    if (confirm(`ä»é€šè®¯å½•ä¸­ç§»é™¤ ${displayName}ï¼Ÿ`)) {
                        removeRolePhoneContact(roleId, accountId, c.id).then(() => {
                            renderFpContactList(container);
                        });
                    }
                }, 600);
            });
            item.addEventListener('touchend', () => clearTimeout(pressTimer));
            item.addEventListener('touchmove', () => clearTimeout(pressTimer));
            // æ¡Œé¢ç«¯å³é”®åˆ é™¤
            item.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                if (confirm(`ä»é€šè®¯å½•ä¸­ç§»é™¤ ${displayName}ï¼Ÿ`)) {
                    removeRolePhoneContact(roleId, accountId, c.id).then(() => {
                        renderFpContactList(container);
                    });
                }
            });
            
            return item;
        }
        
        // æ˜¾ç¤º"æ·»åŠ è”ç³»äºº"é€‰æ‹©å™¨ï¼ˆä»ç”¨æˆ·å¥½å‹åˆ—è¡¨ä¸­é€‰æ‹©æ·»åŠ åˆ°è§’è‰²é€šè®¯å½•ï¼‰
        async function showFpAddContactPicker(roleId, accountId, allChars, existingContactIds, parentContainer) {
            // è·å–ç”¨æˆ·è´¦å·ä¸‹çš„æ‰€æœ‰NPCå¥½å‹ï¼ˆæ’é™¤è§’è‰²è‡ªèº«å’Œå·²æœ‰è”ç³»äººï¼‰
            const availableNpcs = allChars.filter(c => {
                if (c.type === 'user') return false;
                if (String(c.id) === String(roleId)) return false;
                if (existingContactIds.includes(c.id)) return false;
                const status = getFriendStatus(c, accountId);
                return status === 'friend';
            });
            
            const content = document.getElementById('fp-wechat-content');
            
            let pickerHtml = '<div style="width:100%; background:#fff;">';
            pickerHtml += `
                <div style="display:flex; padding:12px 16px; border-bottom:1px solid #f0f0f0; align-items:center; gap:8px;">
                    <div onclick="switchFpWechatTab(1)" style="cursor:pointer; color:var(--ins-pink); font-size:15px; font-weight:500;">â† è¿”å›</div>
                    <div style="flex:1; text-align:center; font-size:16px; font-weight:600; color:#333;">é€‰æ‹©è¦æ·»åŠ çš„è”ç³»äºº</div>
                    <div style="width:40px;"></div>
                </div>
            `;
            
            if (availableNpcs.length === 0) {
                pickerHtml += `
                    <div style="text-align:center; padding:50px 20px; color:#999;">
                        <svg class="svg-icon" style="width:48px; height:48px; stroke:#ccc; margin-bottom:10px;" viewBox="0 0 24 24"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>
                        <div>æ²¡æœ‰æ›´å¤šå¯æ·»åŠ çš„è”ç³»äºº</div>
                        <div style="font-size:12px; color:#bbb; margin-top:6px;">ç”¨æˆ·è´¦å·ä¸‹çš„æ‰€æœ‰å¥½å‹å·²æ·»åŠ </div>
                    </div>
                `;
            } else {
                pickerHtml += `<div style="padding:8px 16px; font-size:13px; color:#888; background:#f7f7f7; font-weight:500;">ç”¨æˆ·è´¦å·ä¸‹çš„å¥½å‹</div>`;
                for (const npc of availableNpcs) {
                    const cAvatar = getCharAvatar(npc, accountId);
                    const avatarStyle = cAvatar ? `background-image:url(${cAvatar})` : 'background-color:#e8e8e8';
                    const displayName = getCharDisplayName(npc, accountId);
                    
                    pickerHtml += `
                        <div class="fp-add-contact-item" data-char-id="${npc.id}" style="display:flex; padding:10px 16px; border-bottom:0.5px solid #f0f0f0; align-items:center; gap:12px; cursor:pointer; transition:background 0.15s;" onmousedown="this.style.background='#f5f5f5'" onmouseup="this.style.background=''" onmouseleave="this.style.background=''">
                            <div style="width:40px; height:40px; border-radius:4px; ${avatarStyle}; background-size:cover; background-position:center;"></div>
                            <div style="flex:1; font-size:16px; font-weight:500; color:#333;">${displayName}</div>
                            <div style="color:var(--ins-pink); font-size:13px; font-weight:500; padding:4px 12px; border:1px solid var(--ins-pink); border-radius:14px;">æ·»åŠ </div>
                        </div>
                    `;
                }
            }
            pickerHtml += '</div>';
            
            content.innerHTML = pickerHtml;
            
            // ç»‘å®šç‚¹å‡»äº‹ä»¶
            content.querySelectorAll('.fp-add-contact-item').forEach(item => {
                item.addEventListener('click', async () => {
                    const charId = parseInt(item.dataset.charId);
                    await addRolePhoneContact(roleId, accountId, charId);
                    // æ·»åŠ æˆåŠŸåè¿”å›é€šè®¯å½•
                    await switchFpWechatTab(1);
                });
            });
        }
        
        // æŸ¥æ‰‹æœºWeChat - æ¸²æŸ“"å‘ç°"é¡µé¢ï¼ˆå«æœ‹å‹åœˆå…¥å£ï¼‰
        async function renderFpDiscoverPage(container) {
            container.innerHTML = `
                <div class="wechat-cell-group" style="margin-top:0;">
                    <div class="wechat-cell" onclick="showFpMomentsPage()">
                        <div class="wechat-cell-icon icon-moments">
                            <svg class="svg-icon" style="stroke:currentColor;" viewBox="0 0 24 24"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg>
                        </div>
                        <div class="wechat-cell-text">æœ‹å‹åœˆ</div>
                        <div class="wechat-cell-arrow">â€º</div>
                    </div>
                </div>
                <div class="wechat-cell-group">
                    <div class="wechat-cell" style="cursor:default;">
                        <div class="wechat-cell-icon" style="background:linear-gradient(135deg, #fa709a 0%, #fee140 100%);">
                            <svg class="svg-icon" style="stroke:#fff;" viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
                        </div>
                        <div class="wechat-cell-text">æœä¸€æœ</div>
                        <div class="wechat-cell-arrow">â€º</div>
                    </div>
                </div>
                <div class="wechat-cell-group">
                    <div class="wechat-cell" style="cursor:default;">
                        <div class="wechat-cell-icon" style="background:linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                            <svg class="svg-icon" style="stroke:#fff;" viewBox="0 0 24 24"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line></svg>
                        </div>
                        <div class="wechat-cell-text">çœ‹ä¸€çœ‹</div>
                        <div class="wechat-cell-arrow">â€º</div>
                    </div>
                </div>
                <div class="wechat-cell-group">
                    <div class="wechat-cell" style="cursor:default;">
                        <div class="wechat-cell-icon" style="background:linear-gradient(135deg, #f093fb 0%, #f5576c 100%);">
                            <svg class="svg-icon" style="stroke:#fff;" viewBox="0 0 24 24"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg>
                        </div>
                        <div class="wechat-cell-text">è§†é¢‘å·</div>
                        <div class="wechat-cell-arrow">â€º</div>
                    </div>
                </div>
                <div class="wechat-cell-group">
                    <div class="wechat-cell" style="cursor:default;">
                        <div class="wechat-cell-icon" style="background:linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);">
                            <svg class="svg-icon" style="stroke:#fff;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><polygon points="10 8 16 12 10 16 10 8"></polygon></svg>
                        </div>
                        <div class="wechat-cell-text">å°ç¨‹åº</div>
                        <div class="wechat-cell-arrow">â€º</div>
                    </div>
                </div>
            `;
        }
        
        // ===== æŸ¥æ‰‹æœº - è§’è‰²æœ‹å‹åœˆé¡µé¢ =====
        let fpMomentsScrollInit = false;

        function showFpMomentsPage() {
            const page = document.getElementById('fp-moments-page');
            page.style.display = 'block';
            page.offsetHeight;
            page.classList.add('slide-in');

            if (!fpMomentsScrollInit) {
                initFpMomentsScroll();
                fpMomentsScrollInit = true;
            }

            renderFpMomentsUserInfo();
            renderFpMomentsList();
        }

        function hideFpMomentsPage() {
            const page = document.getElementById('fp-moments-page');
            page.classList.remove('slide-in');
            setTimeout(() => { page.style.display = 'none'; }, 300);
        }

        function initFpMomentsScroll() {
            const page = document.getElementById('fp-moments-page');
            const navBar = document.getElementById('fp-moments-nav-bar');
            page.addEventListener('scroll', () => {
                if (page.scrollTop > 200) {
                    navBar.classList.add('scrolled');
                } else {
                    navBar.classList.remove('scrolled');
                }
            });
        }

        async function renderFpMomentsUserInfo() {
            const roleId = window._fpWechatRoleId;
            if (!roleId) return;
            const roleChar = await db.characters.get(parseInt(roleId));
            if (!roleChar) return;

            const nameEl = document.getElementById('fp-moments-user-name');
            const avatarEl = document.getElementById('fp-moments-user-avatar');
            const coverEl = document.getElementById('fp-moments-cover-area');

            nameEl.textContent = roleChar.nick || roleChar.name || 'æœªçŸ¥';

            const accountId = findPhoneTargetAccountId;
            const avatar = getCharAvatar(roleChar, accountId) || roleChar.avatar || '';
            if (avatar) {
                avatarEl.style.backgroundImage = `url(${avatar})`;
            } else {
                avatarEl.style.backgroundImage = '';
                avatarEl.style.backgroundColor = '#eee';
            }

            // å°é¢
            const cover = roleChar.fp_moments_cover || roleChar.identity?.cover || '';
            if (cover) {
                coverEl.style.backgroundImage = `url(${cover})`;
            } else {
                coverEl.style.backgroundImage = '';
            }
        }

        async function renderFpMomentsList() {
            const container = document.getElementById('fp-moments-list');
            container.innerHTML = '';

            const roleId = window._fpWechatRoleId;
            const accountId = findPhoneTargetAccountId;
            if (!roleId || !accountId) {
                container.innerHTML = '<div style="text-align:center; color:#ccc; margin-top:100px; font-size:14px;">æ— æ³•åŠ è½½</div>';
                return;
            }

            const roleChar = await db.characters.get(parseInt(roleId));
            if (!roleChar) return;

            // è·å–è§’è‰²çš„å¥½å‹æœ‹å‹åœˆæ•°æ®ï¼ˆå­˜å‚¨åœ¨ roleChar.fp_moments_by_user[accountId]ï¼‰
            const momentsData = roleChar.fp_moments_by_user?.[accountId] || [];

            if (momentsData.length === 0) {
                container.innerHTML = '<div style="text-align:center; color:#ccc; margin-top:100px; font-size:14px;">æš‚æ— åŠ¨æ€<br><span style="font-size:12px;">è¯·åœ¨ã€Œæˆ‘ã€é¡µé¢ç‚¹å‡» AIç”Ÿæˆæ•°æ®</span></div>';
                return;
            }

            // æŒ‰æ—¶é—´å€’åºæ’åˆ—
            const sortedMoments = [...momentsData].sort((a, b) => (b.time || 0) - (a.time || 0));

            const roleName = roleChar.nick || roleChar.name || 'æœªçŸ¥';
            const roleAvatar = getCharAvatar(roleChar, accountId) || roleChar.avatar || '';

            // é¢„åŠ è½½NPCå¤´åƒæ˜ å°„
            const npcAvatarMap = {};
            const contactIds = getRolePhoneContacts(roleChar, accountId);
            for (const cid of contactIds) {
                try {
                    const nc = await db.characters.get(cid);
                    if (nc) {
                        const nName = nc.nick || nc.name;
                        npcAvatarMap[nName] = nc.avatar || '';
                    }
                } catch(e) {}
            }

            for (const m of sortedMoments) {
                const div = document.createElement('div');
                div.className = 'moment-item';

                // æ—¶é—´æ ¼å¼åŒ–
                const date = m.time ? new Date(m.time) : new Date();
                const timeStr = `${date.getMonth()+1}æœˆ${date.getDate()}æ—¥ ${date.getHours()}:${date.getMinutes().toString().padStart(2,'0')}`;

                // å‘å¸ƒè€…ï¼šå¦‚æœ userId æ˜¯è§’è‰²è‡ªå·±ï¼ˆåŒ…æ‹¬ç”¨æˆ·å†’å……å‘çš„ï¼‰ï¼Œç”¨è§’è‰²ä¿¡æ¯ï¼›å¦åˆ™ç”¨ author å­—æ®µ
                const isRoleMoment = m.userId === parseInt(roleId) || m.fpSent;
                const authorName = isRoleMoment ? roleName : (m.author || 'å¥½å‹');
                const authorAvatar = isRoleMoment ? roleAvatar : (npcAvatarMap[m.author] || '');

                // å›¾ç‰‡å±•ç¤º
                let imagesHtml = '';
                if (m.images && m.images.length > 0) {
                    const imageDescs = m.images.filter(img => typeof img === 'string');
                    if (imageDescs.length > 0) {
                        const count = Math.min(imageDescs.length, 9);
                        const gridClass = `grid-${count}`;
                        let squares = '';
                        for (let imgIdx = 0; imgIdx < count; imgIdx++) {
                            const desc = imageDescs[imgIdx].replace(/^\[/, '').replace(/\]$/, '');
                            squares += `<div class="moment-img-placeholder" onclick="event.stopPropagation(); showMomentImageDesc('${desc.replace(/'/g, "\\'")}')">
                                <div class="moment-img-placeholder-inner">
                                    <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
                                    ${count === 1 ? '<div class="moment-img-placeholder-hint">ç‚¹å‡»æŸ¥çœ‹</div>' : ''}
                                </div>
                            </div>`;
                        }
                        imagesHtml = `<div class="moment-image-grid ${gridClass}">${squares}</div>`;
                    }
                }

                // ç‚¹èµæ˜¾ç¤º
                let likesHtml = '';
                const hasLikes = m.likes && m.likes.length > 0;
                if (hasLikes) {
                    // likes å¯èƒ½æ˜¯å­—ç¬¦ä¸²æ•°ç»„æˆ–å¯¹è±¡æ•°ç»„
                    likesHtml = m.likes.map(l => typeof l === 'string' ? l : (l.name || '')).join('ï¼Œ');
                }

                // è¯„è®ºæ˜¾ç¤º
                let commentsHtml = '';
                const hasComments = m.comments && m.comments.length > 0;
                if (hasComments) {
                    commentsHtml = m.comments.map(c => {
                        return `<div class="comment-item">
                            <span class="comment-user">${escapeHtml(c.name || 'å¥½å‹')}</span>ï¼š<span class="comment-content">${escapeHtml(c.text || c.content || '')}</span>
                        </div>`;
                    }).join('');
                }

                div.innerHTML = `
                    <div class="moment-avatar" style="${authorAvatar ? `background-image:url(${authorAvatar});background-size:cover;background-position:center;` : 'background-color:#e8e8e8;'}"></div>
                    <div class="moment-content">
                        <div class="moment-name">${escapeHtml(authorName)}</div>
                        <div class="moment-text">${escapeHtml(m.content || '')}</div>
                        ${imagesHtml}
                        <div class="moment-meta">
                            <div style="display:flex; align-items:center; gap:8px;">
                                <span class="moment-time">${timeStr}</span>
                            </div>
                        </div>
                        <!-- äº’åŠ¨åŒº -->
                        <div class="moment-interactions" style="display: ${hasLikes || hasComments ? 'block' : 'none'}">
                            <div class="moment-likes" style="display: ${hasLikes ? 'flex' : 'none'}">
                                <svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>
                                <span>${likesHtml}</span>
                            </div>
                            <div class="moment-comments" style="display: ${hasComments ? 'block' : 'none'}">
                                ${commentsHtml}
                            </div>
                        </div>
                    </div>
                `;

                container.appendChild(div);
            }
        }

        // ===== æŸ¥æ‰‹æœº - ä»¥è§’è‰²èº«ä»½å‘æœ‹å‹åœˆ =====

        // æŸ¥æ‰‹æœºæ¨¡å¼ - ä»¥è§’è‰²èº«ä»½å‘æœ‹å‹åœˆï¼ˆå¤ç”¨åŸç‰ˆå‘å¸ƒé¡µé¢ï¼Œæ”¯æŒå›¾ç‰‡ç­‰ï¼‰
        function showFpMomentsCompose() {
            // è®¾ç½®FPæ¨¡å¼æ ‡è®°ï¼ŒdoPublishMomentä¼šæ ¹æ®æ­¤æ ‡è®°å†³å®šä¿å­˜é€»è¾‘
            window._fpMomentMode = true;
            // ä¸´æ—¶æé«˜ moments-publish-page çš„ z-indexï¼Œä½¿å…¶æ˜¾ç¤ºåœ¨ fp-moments-page ä¹‹ä¸Š
            const pubPage = document.getElementById('moments-publish-page');
            if (pubPage) pubPage.style.zIndex = '350';
            // è°ƒç”¨åŸç‰ˆå‘å¸ƒé¡µ
            showMomentsPublish();
        }

        // â˜… æŸ¥æ‰‹æœºæœ‹å‹åœˆ - NPCå¥½å‹è‡ªåŠ¨è¯„è®ºç‚¹èµï¼ˆä¸€æ¬¡AIè°ƒç”¨æ‰¹é‡ç”Ÿæˆï¼‰
        async function triggerFpMomentNpcInteractions(roleCharId, accountId, momentId) {
            try {
                const roleChar = await db.characters.get(roleCharId);
                if (!roleChar) return;

                // è·å–è§’è‰²çš„NPCå¥½å‹é€šè®¯å½•
                const contactIds = getRolePhoneContacts(roleChar, accountId);
                if (contactIds.length === 0) {
                    console.log('[FPæœ‹å‹åœˆNPC] æ²¡æœ‰NPCå¥½å‹ï¼Œè·³è¿‡äº’åŠ¨');
                    return;
                }

                // æŸ¥æ‰¾æœ‹å‹åœˆæ•°æ®
                const moments = roleChar.fp_moments_by_user?.[accountId] || [];
                const targetMoment = moments.find(m => m.id === momentId);
                if (!targetMoment) return;

                // åŠ è½½NPCè§’è‰²æ•°æ®
                const npcChars = [];
                for (const cid of contactIds) {
                    const c = await db.characters.get(cid);
                    if (c && c.type !== 'user') {
                        npcChars.push(c);
                    }
                }

                if (npcChars.length === 0) {
                    console.log('[FPæœ‹å‹åœˆNPC] æ²¡æœ‰å¯ç”¨NPCè§’è‰²ï¼Œè·³è¿‡äº’åŠ¨');
                    return;
                }

                const roleName = roleChar.nick || roleChar.name || 'è§’è‰²';

                console.log(`[FPæœ‹å‹åœˆNPC] å¼€å§‹æ‰¹é‡ç”ŸæˆNPCäº’åŠ¨ï¼ŒNPCæ•°é‡: ${npcChars.length}`);

                // éšæœºé€‰å–NPCæ¥è¯„è®ºï¼ˆ1~3ä¸ªï¼‰
                const shuffled = [...npcChars].sort(() => Math.random() - 0.5);
                const commentCount = Math.min(shuffled.length, 1 + Math.floor(Math.random() * 3));
                const selectedNPCs = shuffled.slice(0, commentCount);

                // éšæœºNPCç‚¹èµï¼ˆ50%æ¦‚ç‡ï¼‰
                const likers = npcChars.filter(() => Math.random() < 0.5);

                // æ„å»ºè¯„è®ºè€…ä¿¡æ¯
                const commenterInfos = selectedNPCs.map(c => {
                    const npcName = c.nick || c.name || 'NPC';
                    const npcDesc = c.description || c.personality || 'æ™®é€šæœ‹å‹';
                    return `- ${npcName}ï¼š${npcDesc}`;
                }).join('\n');

                // ä¸€æ¬¡AIè°ƒç”¨æ‰¹é‡ç”Ÿæˆæ‰€æœ‰è¯„è®º
                let aiComments = [];
                if (selectedNPCs.length > 0) {
                    try {
                        const batchPrompt = `${roleName} å‘äº†ä¸€æ¡æœ‹å‹åœˆï¼š"${targetMoment.content}"
${targetMoment.images?.length > 0 ? `ï¼ˆé™„å¸¦${targetMoment.images.length}å¼ å›¾ç‰‡ï¼‰` : ''}

ä»¥ä¸‹å¥½å‹çœ‹åˆ°äº†è¿™æ¡æœ‹å‹åœˆï¼Œè¯·ä¸ºæ¯ä¸ªäººç”Ÿæˆä¸€æ¡ç¬¦åˆå…¶æ€§æ ¼çš„è¯„è®ºï¼š
${commenterInfos}

è¦æ±‚ï¼š
1. æ¯æ¡è¯„è®ºç®€çŸ­è‡ªç„¶ï¼ˆ2-25å­—ï¼‰
2. å¯ä»¥ç”¨è¡¨æƒ…ã€è¯­æ°”è¯ã€è°ƒä¾ƒã€å¤¸èµã€åæ§½ç­‰
3. ç¬¦åˆæ¯ä¸ªè§’è‰²çš„æ€§æ ¼ç‰¹ç‚¹å’Œä¸ ${roleName} çš„å…³ç³»
4. åƒçœŸäººåœ¨æœ‹å‹åœˆä¸‹è¯„è®ºä¸€æ ·éšæ„
5. å¥½å‹ä¹‹é—´å¯ä»¥äº’ç›¸å›å¤ï¼ˆä½¿ç”¨ replyTo å­—æ®µæŒ‡å®šå›å¤çš„äººåï¼‰ï¼Œä½†ä¸æ˜¯æ¯ä¸ªäººéƒ½è¦å›å¤åˆ«äºº

è¯·è¿”å›JSONæ•°ç»„æ ¼å¼ï¼š
[{"name": "è§’è‰²å", "content": "è¯„è®ºå†…å®¹"}, {"name": "è§’è‰²å", "replyTo": "è¢«å›å¤çš„è§’è‰²å", "content": "å›å¤å†…å®¹"}, ...]`;

                        const result = await callAI([
                            { role: 'system', content: 'ä½ æ˜¯ä¸€ä¸ªç¤¾äº¤åª’ä½“è¯„è®ºç”ŸæˆåŠ©æ‰‹ï¼Œåªè¿”å›JSONæ•°ç»„ï¼Œä¸è¦ä»»ä½•å…¶ä»–æ–‡å­—ã€‚' },
                            { role: 'user', content: batchPrompt }
                        ], { _useSecondary: true });

                        // è§£æAIè¿”å›çš„JSON
                        try {
                            let cleanResult = result.trim();
                            if (cleanResult.startsWith('```')) {
                                cleanResult = cleanResult.replace(/```json?\n?/g, '').replace(/```$/g, '').trim();
                            }
                            aiComments = JSON.parse(cleanResult);
                        } catch (e) {
                            console.warn('[FPæœ‹å‹åœˆNPC] AIè¯„è®ºJSONè§£æå¤±è´¥ï¼Œå°è¯•æå–å†…å®¹');
                            aiComments = [];
                        }
                    } catch (apiErr) {
                        console.warn('[FPæœ‹å‹åœˆNPC] AIè°ƒç”¨å¤±è´¥:', apiErr);
                    }
                }

                // å¦‚æœAIç”Ÿæˆå¤±è´¥ï¼Œä½¿ç”¨é¢„è®¾è¯„è®º
                if (aiComments.length === 0 && selectedNPCs.length > 0) {
                    const presetComments = [
                        'ğŸ‘', 'â¤ï¸', 'å¤ªæ£’äº†ï¼', 'çœŸå¥½çœ‹~', 'å“‡ï¼', 'èµï¼',
                        'ç¾¡æ…•ï¼', 'å‰å®³å•Š', 'å¤ªç¾äº†', 'ğŸ”¥', 'ç»äº†', 'çˆ±äº†'
                    ];
                    for (const npc of selectedNPCs) {
                        aiComments.push({
                            name: npc.nick || npc.name,
                            content: presetComments[Math.floor(Math.random() * presetComments.length)]
                        });
                    }
                }

                // ä¸€æ¬¡æ€§è¯»å–æœ€æ–°æ•°æ®ï¼Œå†™å…¥ç‚¹èµå’Œè¯„è®º
                const freshChar = await db.characters.get(roleCharId);
                if (!freshChar) return;
                const momentsList = freshChar.fp_moments_by_user?.[accountId] || [];
                const m = momentsList.find(x => x.id === momentId);
                if (!m) return;

                // å†™å…¥ç‚¹èµ
                if (!m.likes) m.likes = [];
                for (const liker of likers) {
                    const likerName = liker.nick || liker.name;
                    if (!m.likes.some(l => typeof l === 'string' ? l === likerName : l.name === likerName)) {
                        m.likes.push(likerName);
                    }
                }

                // å†™å…¥è¯„è®º
                if (!m.comments) m.comments = [];
                const newFpComments = [];
                for (const aiComment of aiComments) {
                    const matchedNpc = selectedNPCs.find(c =>
                        (c.nick || c.name) === aiComment.name || c.name === aiComment.name
                    );
                    if (aiComment.content) {
                        const commentObj = {
                            name: aiComment.name || (matchedNpc ? (matchedNpc.nick || matchedNpc.name) : 'NPC'),
                            text: aiComment.content,
                            time: Date.now() + Math.random() * 60000
                        };
                        if (aiComment.replyTo) {
                            commentObj.replyTo = aiComment.replyTo;
                        }
                        newFpComments.push(commentObj);
                    }
                }
                // æ ¡éªŒ replyToï¼šç¡®ä¿è¢«å›å¤çš„äººç¡®å®æœ‰è¯„è®ºï¼Œå¦åˆ™å»æ‰ replyTo
                const allFpCommentNames = new Set([
                    ...m.comments.map(c => c.name),
                    ...newFpComments.map(c => c.name)
                ]);
                for (const c of newFpComments) {
                    if (c.replyTo && !allFpCommentNames.has(c.replyTo)) {
                        console.log(`[FPæœ‹å‹åœˆNPC] âš ï¸ replyTo "${c.replyTo}" ä¸å­˜åœ¨ï¼Œå·²ç§»é™¤å›å¤æ ‡è®°`);
                        delete c.replyTo;
                    }
                }
                m.comments.push(...newFpComments);

                // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°æœ‹å‹åœˆæ•°æ®ï¼Œé˜²æ­¢è¦†ç›–è®¾ç½®
                await safeDexieUpdate(db.characters, roleCharId, {
                    [`fp_moments_by_user.${accountId}`]: momentsList
                }, `æœ‹å‹åœˆäº’åŠ¨[${freshChar.name}]`);
                renderFpMomentsList();
                console.log(`[FPæœ‹å‹åœˆNPC] âœ… æ‰¹é‡ç”Ÿæˆå®Œæˆ: ${likers.length}äººç‚¹èµ, ${aiComments.length}æ¡è¯„è®º`);

            } catch (err) {
                console.error('[FPæœ‹å‹åœˆNPC] äº’åŠ¨ç”Ÿæˆå¤±è´¥:', err);
            }
        }

        // æŸ¥æ‰‹æœºWeChat - æ¸²æŸ“"æˆ‘"é¡µé¢ï¼ˆæ˜¾ç¤ºè§’è‰²charè‡ªå·±çš„ä¿¡æ¯ï¼Œå«æœåŠ¡ç­‰ï¼‰
        async function renderFpMePage(container) {
            const roleId = window._fpWechatRoleId;
            const roleChar = await db.characters.get(parseInt(roleId));
            if (!roleChar) {
                container.innerHTML = '<div class="wechat-empty-state"><div>æ— æ³•åŠ è½½</div></div>';
                return;
            }
            
            const avatar = roleChar.avatar || '';
            const name = roleChar.nick || roleChar.name || 'æœªçŸ¥';
            const wxAccount = roleChar.identity?.account || 'æœªè®¾ç½®';
            
            container.innerHTML = `
                <div class="wechat-me-container">
                    <div class="wechat-profile" style="cursor:default;">
                        <div class="wechat-profile-avatar" style="${avatar ? `background-image:url(${avatar})` : ''}"></div>
                        <div class="wechat-profile-info">
                            <div class="wechat-profile-name">${name}</div>
                            <div class="wechat-profile-id">
                                <span>å¾®ä¿¡å·ï¼š${wxAccount}</span>
                                <svg class="svg-icon wechat-qrcode-icon" viewBox="0 0 24 24" style="width:16px;height:16px;"><path d="M3 3h6v6H3zm2 2v2h2V5zm8-2h6v6h-6zm2 2v2h2V5zM3 13h6v6H3zm2 2v2h2v-2zm8-2h2v2h-2zm4 0h2v2h-2zm-4 4h2v2h-2zm2-2h2v2h-2zm2 2h2v2h-2z"/></svg>
                            </div>
                        </div>
                    </div>
                    <div class="wechat-cell-group">
                        <div class="wechat-cell" onclick="showFpServicePage()">
                            <div class="wechat-cell-icon icon-service">
                                <svg class="svg-icon" style="stroke:currentColor;" viewBox="0 0 24 24"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line></svg>
                            </div>
                            <div class="wechat-cell-text">æœåŠ¡</div>
                            <div class="wechat-cell-arrow">â€º</div>
                        </div>
                    </div>
                    <div class="wechat-cell-group">
                        <div class="wechat-cell" style="cursor:default;">
                            <div class="wechat-cell-icon icon-collect">
                                <svg class="svg-icon" style="stroke:currentColor;" viewBox="0 0 24 24"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path></svg>
                            </div>
                            <div class="wechat-cell-text">æ”¶è—</div>
                            <div class="wechat-cell-arrow">â€º</div>
                        </div>
                        <div class="wechat-cell" onclick="showFpMomentsPage()">
                            <div class="wechat-cell-icon icon-moments">
                                <svg class="svg-icon" style="stroke:currentColor;" viewBox="0 0 24 24"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg>
                            </div>
                            <div class="wechat-cell-text">æœ‹å‹åœˆ</div>
                            <div class="wechat-cell-arrow">â€º</div>
                        </div>
                        <div class="wechat-cell" style="cursor:default;">
                            <div class="wechat-cell-icon icon-emoji">
                                <svg class="svg-icon" style="stroke:currentColor;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg>
                            </div>
                            <div class="wechat-cell-text">è¡¨æƒ…</div>
                            <div class="wechat-cell-arrow">â€º</div>
                        </div>
                    </div>
                    <div class="wechat-cell-group">
                        <div class="wechat-cell" style="cursor:default;">
                            <div class="wechat-cell-icon icon-settings">
                                <svg class="svg-icon" style="stroke:currentColor;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
                            </div>
                            <div class="wechat-cell-text">è®¾ç½®</div>
                            <div class="wechat-cell-arrow">â€º</div>
                        </div>
                    </div>
                    
                    <!-- AIç”Ÿæˆæ•°æ®æŒ‰é’® + é”å®šæŒ‰é’® -->
                    <div style="padding:20px 16px;" id="fp-data-actions-area">
                    </div>
                </div>
            `;

            // åŠ¨æ€æ¸²æŸ“æ•°æ®æ“ä½œåŒºåŸŸï¼ˆéœ€è¦å¼‚æ­¥æ£€æŸ¥é”å®šçŠ¶æ€ï¼‰
            const actionsArea = container.querySelector('#fp-data-actions-area');
            if (actionsArea) {
                const locked = await isFpDataLocked(roleId, findPhoneTargetAccountId);
                if (locked) {
                    // å·²é”å®šçŠ¶æ€ï¼šæ˜¾ç¤ºé”å®šæ ‡è¯† + è¿½åŠ ç”ŸæˆæŒ‰é’® + è§£é”æŒ‰é’®
                    actionsArea.innerHTML = `
                        <div style="background:#f0faf0; border:1px solid #c8e6c9; border-radius:12px; padding:16px; margin-bottom:12px; display:flex; align-items:center; gap:12px;">
                            <div style="width:40px; height:40px; border-radius:50%; background:#e8f5e9; display:flex; align-items:center; justify-content:center; flex-shrink:0;">
                                <svg viewBox="0 0 24 24" style="width:20px; height:20px; fill:none; stroke:#4caf50; stroke-width:2;"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>
                            </div>
                            <div style="flex:1;">
                                <div style="font-size:14px; font-weight:600; color:#2e7d32;">æ•°æ®å·²é”å®š</div>
                                <div style="font-size:12px; color:#66bb6a; margin-top:2px;">å†æ¬¡ç”Ÿæˆä¼šåœ¨å·²æœ‰æ•°æ®ä¹‹åè¿½åŠ ï¼Œä¸ä¼šè¦†ç›–</div>
                            </div>
                        </div>
                        <button id="fp-generate-btn" onclick="generateFpRoleData()" style="
                            width:100%; padding:14px; border:none; border-radius:12px;
                            background:linear-gradient(135deg, var(--ins-pink) 0%, #ff6b9d 100%);
                            color:#fff; font-size:15px; font-weight:600; cursor:pointer;
                            display:flex; align-items:center; justify-content:center; gap:8px;
                            box-shadow:0 4px 12px rgba(255,107,157,0.3);
                            transition:all 0.2s;
                        ">
                            <svg class="svg-icon" style="width:16px;height:16px;" viewBox="0 0 24 24"><path d="M12 5v14M5 12h14"></path></svg>
                            ç»§ç»­ç”Ÿæˆæ–°æ•°æ®
                        </button>
                        <div style="text-align:center; font-size:12px; color:#999; margin-top:8px;">æ–°æ•°æ®ä¼šè¿½åŠ åˆ°ç°æœ‰è®°å½•ä¹‹åï¼ˆæ—¶é—´çº¿å»¶ç»­ï¼‰</div>
                        <button onclick="toggleFpDataLock()" style="
                            width:100%; padding:12px; border:1px solid #e0e0e0; border-radius:12px;
                            background:#fff; color:#666; font-size:14px; font-weight:500; cursor:pointer;
                            display:flex; align-items:center; justify-content:center; gap:8px;
                            margin-top:10px; transition:all 0.2s;
                        ">
                            <svg viewBox="0 0 24 24" style="width:16px; height:16px; fill:none; stroke:#999; stroke-width:2;"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 9.9-1"></path></svg>
                            è§£é”æ•°æ®
                        </button>
                        <div style="text-align:center; font-size:11px; color:#bbb; margin-top:4px;">è§£é”åå†æ¬¡ç”Ÿæˆå°†è¦†ç›–æ‰€æœ‰æ•°æ®</div>
                    `;
                } else {
                    // æœªé”å®šçŠ¶æ€ï¼šæ˜¾ç¤ºç”ŸæˆæŒ‰é’® + é”å®šæŒ‰é’®
                    actionsArea.innerHTML = `
                        <button id="fp-generate-btn" onclick="generateFpRoleData()" style="
                            width:100%; padding:14px; border:none; border-radius:12px;
                            background:linear-gradient(135deg, var(--ins-pink) 0%, #ff6b9d 100%);
                            color:#fff; font-size:15px; font-weight:600; cursor:pointer;
                            display:flex; align-items:center; justify-content:center; gap:8px;
                            box-shadow:0 4px 12px rgba(255,107,157,0.3);
                            transition:all 0.2s;
                        ">
                            <svg class="svg-icon" style="width:16px;height:16px;" viewBox="0 0 24 24"><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path><line x1="21" y1="2" x2="12" y2="11"></line></svg>
                            AIç”Ÿæˆæ•°æ®
                        </button>
                        <div style="text-align:center; font-size:12px; color:#999; margin-top:8px;">ä¸€é”®ç”Ÿæˆå¥½å‹ã€èŠå¤©è®°å½•ã€é’±åŒ…ã€æœ‹å‹åœˆç­‰æ•°æ®</div>
                        <button onclick="toggleFpDataLock()" style="
                            width:100%; padding:12px; border:1px solid #e0e0e0; border-radius:12px;
                            background:#fff; color:#666; font-size:14px; font-weight:500; cursor:pointer;
                            display:flex; align-items:center; justify-content:center; gap:8px;
                            margin-top:12px; transition:all 0.2s;
                        ">
                            <svg viewBox="0 0 24 24" style="width:16px; height:16px; fill:none; stroke:#999; stroke-width:2;"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>
                            é”å®šæ•°æ®
                        </button>
                        <div style="text-align:center; font-size:11px; color:#bbb; margin-top:6px;">é”å®šåç”Ÿæˆçš„æ–°æ•°æ®ä¼šè¿½åŠ åˆ°å·²æœ‰æ•°æ®ä¹‹åï¼Œä¸ä¼šè¦†ç›–</div>
                    `;
                }
            }
        }

        // ===== æŸ¥æ‰‹æœº - æ•°æ®é”å®šåŠŸèƒ½ =====
        // æ£€æŸ¥è§’è‰²FPæ•°æ®æ˜¯å¦å·²é”å®š
        async function isFpDataLocked(roleCharId, accountId) {
            if (!roleCharId || !accountId) return false;
            const roleChar = await db.characters.get(parseInt(roleCharId));
            if (!roleChar) return false;
            if (!roleChar.fp_data_locked_by_user) return false;
            return !!roleChar.fp_data_locked_by_user[accountId];
        }

        // åˆ‡æ¢é”å®šçŠ¶æ€
        async function toggleFpDataLock() {
            const roleId = window._fpWechatRoleId;
            const accountId = findPhoneTargetAccountId;
            if (!roleId || !accountId) { showToast('å‚æ•°ç¼ºå¤±'); return; }

            const roleChar = await db.characters.get(parseInt(roleId));
            if (!roleChar) { showToast('è§’è‰²ä¸å­˜åœ¨'); return; }

            if (!roleChar.fp_data_locked_by_user) roleChar.fp_data_locked_by_user = {};
            const currentLocked = !!roleChar.fp_data_locked_by_user[accountId];

            if (currentLocked) {
                // è§£é” - ç¡®è®¤æ“ä½œ
                if (!confirm('è§£é”åï¼Œä¸‹æ¬¡ç‚¹å‡»"AIç”Ÿæˆæ•°æ®"å°†é‡æ–°ç”Ÿæˆæ‰€æœ‰æ•°æ®ï¼ˆèŠå¤©è®°å½•ã€é’±åŒ…ã€æœ‹å‹åœˆç­‰ï¼‰ï¼Œä¹‹å‰çš„æ•°æ®ä¼šè¢«è¦†ç›–ã€‚\n\nç¡®å®šè¦è§£é”å—ï¼Ÿ')) {
                    return;
                }
                roleChar.fp_data_locked_by_user[accountId] = false;
                await safeCharacterPut(roleChar);
                showToast('å·²è§£é”ï¼Œæ•°æ®å¯é‡æ–°ç”Ÿæˆ');
            } else {
                // æ£€æŸ¥æ˜¯å¦æœ‰å·²ç”Ÿæˆçš„æ•°æ®
                const walletData = getFpWalletData(roleChar, accountId);
                const hasData = (walletData.balance !== '0.00') || (walletData.transactions && walletData.transactions.length > 0);
                const contactIds = getRolePhoneContacts(roleChar, accountId);
                const hasContacts = contactIds.length > 0;

                if (!hasData && !hasContacts) {
                    showToast('è¯·å…ˆç‚¹å‡»"AIç”Ÿæˆæ•°æ®"ç”Ÿæˆæ•°æ®åå†é”å®š');
                    return;
                }

                roleChar.fp_data_locked_by_user[accountId] = true;
                await safeCharacterPut(roleChar);
                showToast('å·²é”å®šï¼å†æ¬¡ç”Ÿæˆæ—¶å°†åœ¨ç°æœ‰æ•°æ®åŸºç¡€ä¸Šè¿½åŠ ');
            }

            // åˆ·æ–°"æˆ‘"é¡µé¢ä»¥æ›´æ–°æŒ‰é’®çŠ¶æ€
            const content = document.getElementById('fp-wechat-content');
            if (content) {
                await renderFpMePage(content);
            }
        }

        // ===== æŸ¥æ‰‹æœºWeChat - æœåŠ¡é¡µé¢ =====

        function showFpServicePage() {
            const page = document.getElementById('fp-service-page');
            page.style.display = 'flex';
            page.offsetHeight;
            page.classList.add('slide-in');
        }

        function hideFpServicePage() {
            const page = document.getElementById('fp-service-page');
            page.classList.remove('slide-in');
            setTimeout(() => { page.style.display = 'none'; }, 300);
        }

        async function showFpWalletPage() {
            const page = document.getElementById('fp-wallet-page');
            page.style.display = 'flex';
            page.offsetHeight;
            page.classList.add('active');
            // æ›´æ–°ä½™é¢æ˜¾ç¤º
            await updateFpWalletBalance();
        }

        function hideFpWalletPage() {
            const page = document.getElementById('fp-wallet-page');
            page.classList.remove('active');
            setTimeout(() => { page.style.display = 'none'; }, 350);
        }

        async function showFpBalancePage() {
            const page = document.getElementById('fp-balance-page');
            page.style.display = 'flex';
            page.offsetHeight;
            page.classList.add('active');
            await updateFpWalletBalance();
        }

        function hideFpBalancePage() {
            const page = document.getElementById('fp-balance-page');
            page.classList.remove('active');
            setTimeout(() => { page.style.display = 'none'; }, 350);
        }

        function showFpBillPage() {
            const page = document.getElementById('fp-bill-page');
            page.style.display = 'flex';
            page.offsetHeight;
            page.classList.add('active');
            renderFpBillList();
        }

        function hideFpBillPage() {
            const page = document.getElementById('fp-bill-page');
            page.classList.remove('active');
            setTimeout(() => { page.style.display = 'none'; }, 350);
        }

        // è·å–/è®¾ç½®è§’è‰²çš„fpé’±åŒ…æ•°æ®ï¼ˆå­˜å‚¨åœ¨ roleChar.fp_wallet_by_user[accountId] ä¸­ï¼‰
        function getFpWalletData(roleChar, accountId) {
            if (!roleChar || !accountId) return { balance: '0.00', transactions: [] };
            if (!roleChar.fp_wallet_by_user) roleChar.fp_wallet_by_user = {};
            if (!roleChar.fp_wallet_by_user[accountId]) roleChar.fp_wallet_by_user[accountId] = { balance: '0.00', transactions: [] };
            return roleChar.fp_wallet_by_user[accountId];
        }

        async function setFpWalletData(roleChar, accountId, data) {
            if (!roleChar.fp_wallet_by_user) roleChar.fp_wallet_by_user = {};
            roleChar.fp_wallet_by_user[accountId] = data;
            await safeCharacterPut(roleChar);
        }

        // ===== FPé’±åŒ…äº¤æ˜“ï¼šæ£€æŸ¥ä½™é¢ã€æ‰£æ¬¾/åŠ æ¬¾ã€è®°è´¦ =====
        // type: 'income' æˆ– 'expense'
        // force: true æ—¶å¼ºåˆ¶æ‰§è¡Œï¼ˆå…è®¸è´Ÿä½™é¢ï¼‰ï¼ŒAIå‘èµ·çš„æ“ä½œä½¿ç”¨
        // è¿”å› { success: true/false, balance: å½“å‰ä½™é¢ }
        async function fpWalletTransaction(roleCharId, accountId, type, amount, title, desc, force = false) {
            if (!roleCharId || !accountId) return { success: false, balance: 0 };
            const roleChar = await db.characters.get(parseInt(roleCharId));
            if (!roleChar) return { success: false, balance: 0 };
            const walletData = getFpWalletData(roleChar, accountId);
            let balance = parseFloat(walletData.balance) || 0;
            const amountNum = parseFloat(amount) || 0;

            // â˜… åªæœ‰é”å®šæ—¶æ‰æ ¡éªŒä½™é¢ï¼Œæœªé”å®šæ—¶ä¸æ ¡éªŒï¼ˆå…è®¸éšæ„äº¤æ˜“ï¼‰
            const locked = !!(roleChar.fp_data_locked_by_user && roleChar.fp_data_locked_by_user[accountId]);

            if (type === 'expense') {
                if (locked && !force && balance < amountNum) {
                    return { success: false, balance: balance };
                }
                balance -= amountNum;
            } else {
                balance += amountNum;
            }

            walletData.balance = balance.toFixed(2);
            if (!walletData.transactions) walletData.transactions = [];
            walletData.transactions.push({
                type,
                amount: amountNum.toFixed(2),
                title: title || (type === 'income' ? 'æ”¶æ¬¾' : 'è½¬è´¦'),
                desc: desc || '',
                time: Date.now()
            });
            // åªä¿ç•™æœ€è¿‘100æ¡
            if (walletData.transactions.length > 100) {
                walletData.transactions = walletData.transactions.slice(-100);
            }

            await setFpWalletData(roleChar, accountId, walletData);
            // å¦‚æœé’±åŒ…é¡µé¢æ­£åœ¨æ˜¾ç¤ºï¼Œåˆ·æ–°ä½™é¢
            await updateFpWalletBalance();
            return { success: true, balance: balance };
        }

        // è·å–FPé’±åŒ…ä½™é¢ï¼ˆåªæŸ¥è¯¢ï¼Œä¸ä¿®æ”¹ï¼‰
        async function getFpWalletBalance(roleCharId, accountId) {
            if (!roleCharId || !accountId) return 0;
            const roleChar = await db.characters.get(parseInt(roleCharId));
            if (!roleChar) return 0;
            const walletData = getFpWalletData(roleChar, accountId);
            return parseFloat(walletData.balance) || 0;
        }

        async function updateFpWalletBalance() {
            const roleId = window._fpWechatRoleId;
            const accountId = findPhoneTargetAccountId;
            if (!roleId || !accountId) return;
            const roleChar = await db.characters.get(parseInt(roleId));
            if (!roleChar) return;
            const walletData = getFpWalletData(roleChar, accountId);
            const balanceStr = 'Â¥' + (walletData.balance || '0.00');
            const el1 = document.getElementById('fp-wallet-balance');
            const el2 = document.getElementById('fp-balance-amount-display');
            if (el1) el1.textContent = balanceStr;
            if (el2) el2.textContent = balanceStr;
        }

        async function renderFpBillList() {
            const roleId = window._fpWechatRoleId;
            const accountId = findPhoneTargetAccountId;
            const listEl = document.getElementById('fp-bill-list');
            const emptyEl = document.getElementById('fp-bill-empty');
            if (!roleId || !accountId) { listEl.innerHTML = ''; emptyEl.style.display = 'block'; return; }
            const roleChar = await db.characters.get(parseInt(roleId));
            if (!roleChar) { listEl.innerHTML = ''; emptyEl.style.display = 'block'; return; }
            const walletData = getFpWalletData(roleChar, accountId);
            const transactions = walletData.transactions || [];
            if (transactions.length === 0) {
                listEl.innerHTML = '';
                emptyEl.style.display = 'block';
                return;
            }
            emptyEl.style.display = 'none';
            // æŒ‰æ—¶é—´å€’åº
            const sorted = [...transactions].sort((a, b) => (b.time || 0) - (a.time || 0));
            listEl.innerHTML = sorted.map(t => {
                const isIncome = t.type === 'income';
                const sign = isIncome ? '+' : '-';
                const color = isIncome ? '#07c160' : '#333';
                const timeStr = t.time ? new Date(t.time).toLocaleDateString('zh-CN', { month:'numeric', day:'numeric', hour:'numeric', minute:'numeric' }) : '';
                return `<div style="background:#fff; padding:14px 16px; display:flex; align-items:center; justify-content:space-between;">
                    <div>
                        <div style="font-size:15px; color:#333;">${t.title || 'æœªçŸ¥'}</div>
                        <div style="font-size:12px; color:#999; margin-top:4px;">${timeStr} ${t.desc || ''}</div>
                    </div>
                    <div style="font-size:16px; font-weight:600; color:${color};">${sign}Â¥${t.amount}</div>
                </div>`;
            }).join('');
        }

        // ===== æŸ¥æ‰‹æœº - AIç”Ÿæˆè§’è‰²æ•°æ®ï¼ˆä¸€æ¬¡æ€§ç”Ÿæˆæ‰€æœ‰æ•°æ®ï¼Œä»…è°ƒç”¨ä¸€æ¬¡AIï¼‰ =====
        async function generateFpRoleData() {
            const roleId = window._fpWechatRoleId;
            const accountId = findPhoneTargetAccountId;
            if (!roleId || !accountId) { showToast('å‚æ•°ç¼ºå¤±'); return; }

            // â˜… æ£€æŸ¥æ˜¯å¦å·²é”å®š - é”å®šåè¿½åŠ è€Œéè¦†ç›–
            const isLocked = await isFpDataLocked(roleId, accountId);

            let roleChar = await db.characters.get(parseInt(roleId));
            if (!roleChar) { showToast('è§’è‰²ä¸å­˜åœ¨'); return; }

            const roleName = roleChar.nick || roleChar.name || 'æœªçŸ¥è§’è‰²';
            const roleDesc = roleChar.description || roleChar.desc || '';

            // â˜… å…ˆè‡ªåŠ¨å°†å…³è”NPCå¡«å……åˆ°é€šè®¯å½•
            roleChar = await autoPopulateRelationshipContacts(roleChar, accountId);

            // è·å–ç°æœ‰é€šè®¯å½•NPCï¼ˆç°åœ¨å·²åŒ…å«å…³è”NPCï¼‰
            let contactIds = getRolePhoneContacts(roleChar, accountId);
            const allChars = await db.characters.toArray();
            let npcContacts = [];
            for (const cid of contactIds) {
                const c = allChars.find(ch => ch.id === cid);
                if (c && c.type !== 'user' && String(c.id) !== String(roleId)) {
                    npcContacts.push(c);
                }
            }
            
            // â˜… æ„å»ºå…³è”NPCçš„å…³ç³»æè¿°ï¼ˆç”¨äºAIç”Ÿæˆæ›´å‡†ç¡®çš„èŠå¤©è®°å½•ï¼‰
            let relationshipContext = '';
            if (roleChar.relationships && roleChar.relationships.length > 0) {
                const relDescs = roleChar.relationships.map(r => {
                    const npc = npcContacts.find(n => n.id === r.targetId);
                    const npcNick = npc ? (npc.nick || npc.name) : r.targetName;
                    return `- ${npcNick}ï¼š${r.relation}${r.desc ? 'ï¼ˆ' + r.desc + 'ï¼‰' : ''}`;
                }).filter(Boolean);
                if (relDescs.length > 0) {
                    relationshipContext = `\nå…³è”NPCä¸è§’è‰²çš„å…³ç³»ï¼š\n${relDescs.join('\n')}\n`;
                }
            }

            const userChar = await db.characters.get(parseInt(accountId));
            const userName = userChar ? (userChar.nick || userChar.name) : 'ç”¨æˆ·';

            // æ˜¾ç¤ºloading
            const btn = document.getElementById('fp-generate-btn');
            if (btn) {
                btn.disabled = true;
                btn.innerHTML = '<div class="loading-spinner" style="display:inline-block; width:16px; height:16px; border-width:2px; border-color:var(--ins-pink); border-top-color:transparent;"></div> ç”Ÿæˆä¸­...';
            }

            try {
                // â˜… é”å®šæ—¶ä¸ç”Ÿæˆæ–°NPCï¼Œä½¿ç”¨ç°æœ‰çš„
                const needNpcs = !isLocked && npcContacts.length === 0;
                const npcCount = needNpcs ? (Math.floor(Math.random() * 3) + 2) : 0; // 2~4ä¸ªNPC

                // â˜… é”å®šæ¨¡å¼ä¸‹ï¼Œæ”¶é›†å·²æœ‰æ•°æ®çš„æ‘˜è¦ï¼Œå‘Šè¯‰AIåœ¨æ­¤åŸºç¡€ä¸Šç»§ç»­
                let lockedContextSection = '';
                let existingWalletBalance = '0.00';
                if (isLocked) {
                    // æ”¶é›†å·²æœ‰èŠå¤©è®°å½•çš„æœ€åå‡ æ¡ï¼Œè®©AIçŸ¥é“ä¸Šä¸‹æ–‡
                    const roleCharSnap = await db.characters.get(parseInt(roleId));
                    let chatSummaries = [];
                    for (const npc of npcContacts) {
                        const fpNpcKey = 'fp_npc_' + npc.id;
                        const existHist = roleCharSnap?.chat_history_by_user?.[fpNpcKey] || [];
                        if (existHist.length > 0) {
                            const lastMsgs = existHist.slice(-3).map(m => {
                                const who = m.role === 'char' ? roleName : (npc.nick || npc.name);
                                return `${who}: ${(m.content || '').substring(0, 30)}`;
                            }).join(' / ');
                            chatSummaries.push(`- ${npc.nick || npc.name}: æœ€è¿‘æ¶ˆæ¯ [${lastMsgs}]`);
                        }
                    }

                    // è·å–ç°æœ‰é’±åŒ…ä½™é¢
                    const walletData = getFpWalletData(roleCharSnap, accountId);
                    existingWalletBalance = walletData.balance || '0.00';
                    const recentTx = (walletData.transactions || []).slice(-3).map(tx => {
                        return `${tx.type === 'income' ? 'æ”¶å…¥' : 'æ”¯å‡º'} Â¥${tx.amount} (${tx.title})`;
                    }).join('ã€');

                    // è·å–ç°æœ‰æœ‹å‹åœˆæœ€è¿‘å†…å®¹
                    const existingMoments = roleCharSnap?.fp_moments_by_user?.[accountId] || [];
                    const recentMoments = existingMoments.slice(0, 3).map(m => {
                        return `${m.author}: ${(m.content || '').substring(0, 20)}`;
                    }).join('ã€');

                    lockedContextSection = `
â˜…â˜…â˜… é‡è¦ï¼šè¿™æ˜¯ä¸€æ¬¡è¿½åŠ ç”Ÿæˆï¼ˆæ•°æ®å·²é”å®šï¼‰ï¼Œè¯·åœ¨å·²æœ‰æ•°æ®çš„æ—¶é—´çº¿ä¹‹åç»§ç»­ç”Ÿæˆæ–°å†…å®¹ â˜…â˜…â˜…
ä¸è¦é‡å¤å·²æœ‰å†…å®¹ï¼Œè¦ç”Ÿæˆå‘ç”Ÿåœ¨"ç°åœ¨"çš„æ–°æ¶ˆæ¯å’Œæ–°åŠ¨æ€ã€‚

å·²æœ‰æ•°æ®æ¦‚è¦ï¼š
- å½“å‰é’±åŒ…ä½™é¢ï¼šÂ¥${existingWalletBalance}
${chatSummaries.length > 0 ? '- å„å¥½å‹æœ€è¿‘èŠå¤©ï¼š\n' + chatSummaries.join('\n') : ''}
${recentTx ? '- æœ€è¿‘äº¤æ˜“è®°å½•ï¼š' + recentTx : ''}
${recentMoments ? '- æœ€è¿‘æœ‹å‹åœˆï¼š' + recentMoments : ''}

è¯·åŸºäºä»¥ä¸Šå·²æœ‰æƒ…å†µï¼Œç”Ÿæˆåç»­çš„æ–°æ¶ˆæ¯ã€æ–°äº¤æ˜“ã€æ–°æœ‹å‹åœˆã€‚
é’±åŒ…çš„wallet.balanceå­—æ®µè¯·å¡«å†™åœ¨å½“å‰ä½™é¢Â¥${existingWalletBalance}çš„åŸºç¡€ä¸Šï¼ŒåŠ å‡æ–°äº¤æ˜“åçš„æœ€ç»ˆä½™é¢ã€‚
æ–°ç”Ÿæˆçš„transactionsåªåŒ…å«æ–°äº¤æ˜“ï¼ˆä¸è¦é‡å¤æ—§äº¤æ˜“ï¼‰ã€‚
`;
                }

                // â˜… æ„å»ºä¸€æ¬¡æ€§ promptï¼ŒåŒ…å«æ‰€æœ‰æ•°æ®çš„ç”Ÿæˆ â˜…
                let npcSection = '';
                if (needNpcs) {
                    npcSection = `
ä¸€ã€ç”Ÿæˆ${npcCount}ä¸ªå¾®ä¿¡å¥½å‹NPC
æ¯ä¸ªNPCéœ€è¦ï¼š
- name: çœŸå®çš„ä¸­æ–‡å…¨åï¼ˆå¦‚"æå©·"ã€"ç‹æµ©ç„¶"ã€"èµµå°é›ª"ï¼‰ï¼Œè¦åƒçœŸäººåå­—
- nick: çœŸå®çš„å¾®ä¿¡æ˜µç§°ï¼ˆå¦‚"å°å©·å­ğŸŒ¸"ã€"æµ©ç„¶"ã€"é›ªé›ª"ï¼‰ï¼ŒåƒçœŸäººçš„å¾®ä¿¡å
- relation: ä¸ä¸»è§’è‰²çš„å…·ä½“å…³ç³»ï¼ˆå¦‚ï¼šå¤§å­¦å®¤å‹ã€å…¬å¸åŒäº‹ã€é«˜ä¸­é—ºèœœã€å‰ç”·å‹ç­‰ï¼‰
- desc: ä¸€å¥è¯äººè®¾æè¿°ï¼ˆå¦‚ï¼šæ´»æ³¼å¼€æœ—çš„90åè®¾è®¡å¸ˆï¼Œå–œæ¬¢æ‘„å½±å’Œæ—…è¡Œï¼‰

`;
                }

                const existingNpcList = !needNpcs ? npcContacts.map(n => {
                    // â˜… ä¼˜å…ˆä½¿ç”¨å…³ç³»æè¿°æ¥æè¿°NPC
                    const rel = roleChar.relationships?.find(r => r.targetId === n.id);
                    const relInfo = rel ? `[${rel.relation}] ` : '';
                    return `- ${n.nick || n.name}: ${relInfo}${n.description || 'å¥½å‹'}`;
                }).join('\n') : 'ï¼ˆå°†åœ¨npcså­—æ®µä¸­ç”Ÿæˆï¼‰';
                const existingNpcNames = !needNpcs ? npcContacts.map(n => n.nick || n.name).join('ã€') : '';

                // â˜… è·å–ä¸–ç•Œä¹¦ä¸Šä¸‹æ–‡ï¼ˆç”¨äºæ²¡æœ‰å…³è”NPCæ—¶æ ¹æ®ä¸–ç•Œè§‚ç”Ÿæˆï¼‰
                let fpLoreContext = '';
                try {
                    const lorebookIds = roleChar.lorebookIds || (roleChar.lorebookId ? [roleChar.lorebookId] : []);
                    if (lorebookIds.length > 0) {
                        fpLoreContext = await getLorebookContext(lorebookIds, roleName);
                    }
                } catch (e) {
                    console.warn('[FPç”Ÿæˆ] è·å–ä¸–ç•Œä¹¦å¤±è´¥:', e);
                }

                const combinedPrompt = `ä½ æ˜¯ä¸€ä¸ªè¾…åŠ©ç”Ÿæˆè§’è‰²æ‰‹æœºæ•°æ®çš„AIåŠ©æ‰‹ã€‚è¯·ä¸€æ¬¡æ€§ç”Ÿæˆä»¥ä¸‹æ‰€æœ‰æ•°æ®ã€‚

ä¸»è§’è‰²ä¿¡æ¯ï¼š
è§’è‰²åç§°ï¼š${roleName}
è§’è‰²æè¿°ï¼š${roleDesc || 'æš‚æ— æè¿°'}
å…³è”ç”¨æˆ·ï¼š${userName}
${relationshipContext}${fpLoreContext ? `\nä¸–ç•Œè§‚èƒŒæ™¯ï¼š\n${fpLoreContext}\n` : ''}
${lockedContextSection}è¯·ç”Ÿæˆä»¥ä¸‹æ‰€æœ‰å†…å®¹ï¼š
${npcSection}${needNpcs ? 'äºŒ' : 'ä¸€'}ã€ä¸ºä¸»è§’è‰²ä¸æ¯ä¸ªNPCå¥½å‹ä¹‹é—´å„ç”Ÿæˆ${isLocked ? '2~4' : '3~6'}æ¡ç®€çŸ­çš„æ—¥å¸¸èŠå¤©è®°å½•${isLocked ? 'ï¼ˆè¿™æ˜¯æ–°æ¶ˆæ¯ï¼Œæ¥ç»­ä¹‹å‰çš„å¯¹è¯ï¼‰' : ''}
${needNpcs ? 'å¥½å‹åˆ—è¡¨å°†åœ¨npcsä¸­ç”Ÿæˆï¼Œchatsçš„keyè¦ç”¨NPCçš„nick' : 'å¥½å‹åˆ—è¡¨ï¼š\n' + existingNpcList + '\nchatsçš„keyè¦ç”¨NPCçš„nickï¼ˆå³ï¼š' + existingNpcNames + 'ï¼‰'}
æ¯æ¡æ¶ˆæ¯role: "user"(NPCå‘çš„) æˆ– "char"(ä¸»è§’è‰²å‘çš„)

${needNpcs ? 'ä¸‰' : 'äºŒ'}ã€ç”Ÿæˆé’±åŒ…æ•°æ®
${isLocked ? `å½“å‰ä½™é¢ä¸ºÂ¥${existingWalletBalance}ï¼Œåœ¨æ­¤åŸºç¡€ä¸Šç”Ÿæˆ2~4ç¬”æ–°äº¤æ˜“(æ”¶å…¥/æ”¯å‡º)ï¼Œbalanceå­—æ®µå¡«åŠ å‡æ–°äº¤æ˜“åçš„æœ€ç»ˆä½™é¢` : 'ä½™é¢è¦ç¬¦åˆè§’è‰²ç»æµçŠ¶å†µï¼Œç”Ÿæˆ3~6ç¬”äº¤æ˜“(æ”¶å…¥/æ”¯å‡º)ï¼Œè´´åˆæ—¥å¸¸ç”Ÿæ´»'}

${isLocked ? '' : `${needNpcs ? 'å››' : 'ä¸‰'}ã€ç”Ÿæˆè§’è‰²å¯¹ç”¨æˆ·"${userName}"çš„å¾®ä¿¡å¤‡æ³¨å
å¤‡æ³¨è¦ç¬¦åˆå…³ç³»ï¼ˆæ‹äººç”¨æ˜µç§°/çˆ±ç§°ï¼Œæœ‹å‹ç”¨å¤–å·ç­‰ï¼‰ï¼Œæœ€å¤š8ä¸ªå­—

`}${needNpcs ? (isLocked ? 'ä¸‰' : 'äº”') : (isLocked ? 'ä¸‰' : 'å››')}ã€ç”Ÿæˆå¥½å‹ä»¬å‘çš„æœ‹å‹åœˆåŠ¨æ€ï¼ˆä¸æ˜¯ä¸»è§’è‰²å‘çš„ï¼Œæ˜¯å¥½å‹NPCå‘çš„ï¼ï¼‰
æ€»å…±ç”Ÿæˆ${isLocked ? '3~5' : '5~8'}æ¡æœ‹å‹åœˆåŠ¨æ€ï¼Œåˆ†æ•£åœ¨ä¸åŒçš„NPCå¥½å‹èº«ä¸Šã€‚${isLocked ? 'ï¼ˆè¿™æ˜¯æ–°åŠ¨æ€ï¼Œä¸ä¹‹å‰ä¸é‡å¤ï¼‰' : ''}
æ¯æ¡åŠ¨æ€çš„authorå­—æ®µå¡«NPCå¥½å‹çš„nickã€‚
å†…å®¹è¦ç¬¦åˆå¯¹åº”NPCçš„äººè®¾å’Œæ€§æ ¼ï¼ŒåŒ…å«æ—¥å¸¸ç”Ÿæ´»ã€å¿ƒæƒ…ã€åˆ†äº«ç­‰ã€‚
æ¯æ¡åŠ¨æ€å¯ä»¥æœ‰æ–‡å­—å›¾ç‰‡æè¿°ï¼ˆç”¨æ–¹æ‹¬å·åŒ…è£¹å›¾ç‰‡æè¿°ï¼Œå¦‚"[è‡ªæ‹ç…§]"ã€"[å’–å•¡æ‹‰èŠ±]"ï¼‰ã€‚
éƒ¨åˆ†åŠ¨æ€å¯ä»¥æœ‰å…¶ä»–å¥½å‹çš„ç‚¹èµï¼ˆç”¨nickï¼‰å’Œè¯„è®ºã€‚ä¸»è§’è‰²"${roleName}"ä¹Ÿå¯èƒ½ä¼šç‚¹èµæˆ–è¯„è®ºå¥½å‹çš„åŠ¨æ€ã€‚

è¯·ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹JSONæ ¼å¼è¿”å›ï¼Œä¸è¦æœ‰ä»»ä½•å…¶ä»–æ–‡å­—ï¼š
{
  ${needNpcs ? '"npcs": [{"name":"æå©·","nick":"å°å©·å­ğŸŒ¸","relation":"å¤§å­¦å®¤å‹","desc":"æ´»æ³¼å¼€æœ—çš„90åè®¾è®¡å¸ˆ"}],' : ''}
  "chats": {
    "${needNpcs ? 'å°å©·å­ğŸŒ¸' : (npcContacts[0]?.nick || npcContacts[0]?.name || 'NPCæ˜µç§°')}": [{"role":"user","content":"æ¶ˆæ¯å†…å®¹"},{"role":"char","content":"å›å¤å†…å®¹"}]
  },
  "wallet": {
    "balance": "${isLocked ? existingWalletBalance : '1234.56'}",
    "transactions": [{"type":"expense","amount":"25.00","title":"å¤–å–","desc":"ç¾å›¢å¤–å–"},{"type":"income","amount":"5000.00","title":"å·¥èµ„","desc":"XXå…¬å¸"}]
  },
  ${isLocked ? '' : '"remark": "å¤‡æ³¨å",'}
  "moments": [
    {"author":"${needNpcs ? 'å°å©·å­ğŸŒ¸' : (npcContacts[0]?.nick || npcContacts[0]?.name || 'NPCæ˜µç§°')}","content":"ä»Šå¤©å¤©æ°”çœŸå¥½ï½å‡ºå»èµ°èµ°","images":["[è“å¤©ç™½äº‘çš„ç…§ç‰‡]"],"likes":["${roleName}","å…¶ä»–å¥½å‹nick"],"comments":[{"name":"${roleName}","text":"å¥½ç¾å•Š"}]},
    {"author":"å¦ä¸€ä¸ªå¥½å‹nick","content":"åŠ ç­åˆ°ç°åœ¨...","images":[],"likes":[],"comments":[]}
  ]
}`;

                // â˜… ä»…è°ƒç”¨ä¸€æ¬¡AI â˜…
                const aiResult = await callAI([
                    { role: 'system', content: combinedPrompt },
                    { role: 'user', content: isLocked ? 'è¯·åŸºäºå·²æœ‰æ•°æ®ï¼Œç”Ÿæˆåç»­çš„æ–°å†…å®¹ï¼Œåªè¿”å›JSONã€‚' : 'è¯·ä¸€æ¬¡æ€§ç”Ÿæˆæ‰€æœ‰æ•°æ®ï¼Œåªè¿”å›JSONã€‚' }
                ]);

                let parsedData = {};
                try {
                    const jsonMatch = aiResult.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        parsedData = JSON.parse(jsonMatch[0]);
                    }
                } catch(e) {
                    console.error('[FPç”Ÿæˆ] JSONè§£æå¤±è´¥:', e, aiResult);
                    showToast('ç”Ÿæˆå¤±è´¥ï¼šæ•°æ®æ ¼å¼é”™è¯¯');
                    return;
                }

                // ===== å¤„ç†NPCæ•°æ® =====
                let generatedNpcs = [];
                if (needNpcs && parsedData.npcs && Array.isArray(parsedData.npcs)) {
                    for (const npc of parsedData.npcs) {
                        const newChar = {
                            name: npc.name || 'æœªçŸ¥NPC',
                            nick: npc.nick || npc.name || 'å¥½å‹',
                            description: `[${npc.relation || 'å¥½å‹'}] ${npc.desc || ''}`,
                            avatar: '',
                            type: 'npc',
                            created_at: Date.now()
                        };
                        const id = await db.characters.add(newChar);
                        newChar.id = id;
                        npcContacts.push(newChar);
                        generatedNpcs.push(newChar);
                        await addRolePhoneContact(roleId, accountId, id);
                    }
                }

                // ===== å¤„ç†èŠå¤©è®°å½• =====
                const chatsData = parsedData.chats || {};
                const roleCharForChat = await db.characters.get(parseInt(roleId));
                if (!roleCharForChat.chat_history_by_user) roleCharForChat.chat_history_by_user = {};

                for (const npc of npcContacts) {
                    const npcKey = npc.nick || npc.name;
                    const messages = chatsData[npcKey] || [];
                    if (messages.length === 0) continue;

                    const fpNpcKey = 'fp_npc_' + npc.id;

                    if (isLocked) {
                        // â˜… é”å®šæ¨¡å¼ï¼šè¿½åŠ åˆ°å·²æœ‰è®°å½•ä¹‹å
                        const existingHist = roleCharForChat.chat_history_by_user[fpNpcKey] || [];
                        // æ–°æ¶ˆæ¯çš„æ—¶é—´ä»å·²æœ‰æœ€åä¸€æ¡ä¹‹åå¼€å§‹
                        const lastTime = existingHist.length > 0 ? (existingHist[existingHist.length - 1].time || Date.now()) : Date.now();
                        const newMsgs = messages.map((m, idx) => ({
                            role: m.role || 'user',
                            content: m.content || '',
                            time: lastTime + (idx + 1) * 600000 // æ¯æ¡é—´éš”10åˆ†é’Ÿ
                        }));
                        roleCharForChat.chat_history_by_user[fpNpcKey] = [...existingHist, ...newMsgs];
                    } else {
                        // â˜… æœªé”å®šï¼šæ›¿æ¢ï¼ˆåŸå§‹è¡Œä¸ºï¼‰
                        const baseTime = Date.now() - 3600000 * 24;
                        const hist = messages.map((m, idx) => ({
                            role: m.role || 'user',
                            content: m.content || '',
                            time: baseTime + idx * 600000
                        }));
                        roleCharForChat.chat_history_by_user[fpNpcKey] = hist;
                    }
                }
                await safeCharacterPut(roleCharForChat);

                // ===== å¤„ç†é’±åŒ…æ•°æ® =====
                let walletResult = parsedData.wallet || { balance: '0.00', transactions: [] };
                const charForWallet = await db.characters.get(parseInt(roleId));

                if (isLocked) {
                    // â˜… é”å®šæ¨¡å¼ï¼šä¿ç•™å·²æœ‰äº¤æ˜“è®°å½•ï¼Œè¿½åŠ æ–°äº¤æ˜“
                    const existingWallet = getFpWalletData(charForWallet, accountId);
                    const existingTx = existingWallet.transactions || [];
                    // æ–°äº¤æ˜“çš„æ—¶é—´ä»ç°åœ¨å¼€å§‹
                    const newTx = (walletResult.transactions || []).map((tx, idx) => ({
                        ...tx,
                        time: Date.now() + idx * 3600000 * 2 // æ¯ç¬”é—´éš”2å°æ—¶
                    }));
                    // åˆå¹¶ï¼šä¿ç•™æ—§äº¤æ˜“ + è¿½åŠ æ–°äº¤æ˜“
                    walletResult = {
                        balance: walletResult.balance || existingWallet.balance, // AIè®¡ç®—çš„æ–°ä½™é¢
                        transactions: [...existingTx, ...newTx]
                    };
                    // åªä¿ç•™æœ€è¿‘100æ¡
                    if (walletResult.transactions.length > 100) {
                        walletResult.transactions = walletResult.transactions.slice(-100);
                    }
                } else {
                    // â˜… æœªé”å®šï¼šè¦†ç›–ï¼ˆåŸå§‹è¡Œä¸ºï¼‰
                    const txBaseTime = Date.now() - 3600000 * 72;
                    if (walletResult.transactions) {
                        walletResult.transactions.forEach((tx, idx) => {
                            tx.time = txBaseTime + idx * 3600000 * 8;
                        });
                    }
                }
                await setFpWalletData(charForWallet, accountId, walletResult);
                await updateFpWalletBalance();

                // ===== å¤„ç†å¤‡æ³¨ï¼ˆé”å®šæ—¶ä¸è¦†ç›–å·²æœ‰å¤‡æ³¨ï¼‰ =====
                if (!isLocked) {
                    const remark = (parsedData.remark || '').trim().replace(/["""]/g, '').substring(0, 20);
                    if (remark) {
                        const charForRemark = await db.characters.get(parseInt(roleId));
                        if (!charForRemark.fp_remark_by_user) charForRemark.fp_remark_by_user = {};
                        charForRemark.fp_remark_by_user[accountId] = remark;
                        await safeCharacterPut(charForRemark);
                        console.log('[FPç”Ÿæˆ] å¤‡æ³¨ç”Ÿæˆ:', remark);
                    }
                }

                // ===== å¤„ç†æœ‹å‹åœˆæ•°æ®ï¼ˆå¥½å‹NPCå‘çš„æœ‹å‹åœˆï¼‰ =====
                const momentsArr = parsedData.moments || [];
                if (momentsArr.length > 0) {
                    const charForMoments = await db.characters.get(parseInt(roleId));
                    if (!charForMoments.fp_moments_by_user) charForMoments.fp_moments_by_user = {};
                    
                    const existingMoments = isLocked ? (charForMoments.fp_moments_by_user[accountId] || []) : [];
                    // æ–°åŠ¨æ€æ—¶é—´ï¼šé”å®šæ¨¡å¼ä»ç°åœ¨èµ·ï¼Œéé”å®šä»48å°æ—¶å‰èµ·
                    const momentBaseTime = isLocked ? Date.now() : (Date.now() - 3600000 * 48);
                    const processedMoments = momentsArr.map((m, idx) => ({
                        author: m.author || 'å¥½å‹',
                        content: m.content || '',
                        images: (m.images || []).map(img => {
                            // å¦‚æœå›¾ç‰‡æè¿°æ²¡æœ‰æ–¹æ‹¬å·ï¼ŒåŠ ä¸Š
                            if (typeof img === 'string' && !img.startsWith('[')) return '[' + img + ']';
                            return img;
                        }),
                        likes: m.likes || [],
                        comments: (m.comments || []).map(c => ({
                            name: c.name || 'å¥½å‹',
                            text: c.text || ''
                        })),
                        time: momentBaseTime + idx * 3600000 * 2 // é”å®šæ¨¡å¼é—´éš”2å°æ—¶ï¼Œéé”å®šé—´éš”6å°æ—¶
                    }));

                    // åˆå¹¶å·²æœ‰ + æ–°åŠ¨æ€ï¼ŒæŒ‰æ—¶é—´å€’åºæ’åˆ—
                    const allMoments = [...existingMoments, ...processedMoments];
                    allMoments.sort((a, b) => b.time - a.time);
                    charForMoments.fp_moments_by_user[accountId] = allMoments;
                    await safeCharacterPut(charForMoments);
                    console.log(`[FPç”Ÿæˆ] æœ‹å‹åœˆ${isLocked ? 'è¿½åŠ ' : 'ç”Ÿæˆ'}:`, processedMoments.length, 'æ¡ï¼Œæ€»è®¡:', allMoments.length, 'æ¡');
                }

                if (isLocked) {
                    showToast('âœ… æ–°æ•°æ®å·²è¿½åŠ ï¼ˆå·²ä¿ç•™æ—§æ•°æ®ï¼‰');
                } else {
                    showToast('âœ… æ•°æ®ç”Ÿæˆå®Œæˆ');
                    if (generatedNpcs.length > 0) {
                        showToast(`å·²ç”Ÿæˆ ${generatedNpcs.length} ä¸ªå¥½å‹å’ŒèŠå¤©è®°å½•`);
                    }
                }

            } catch(e) {
                console.error('[FPç”Ÿæˆ] æ•´ä½“å¤±è´¥:', e);
                showToast('ç”Ÿæˆå¤±è´¥ï¼š' + (e.message || 'æœªçŸ¥é”™è¯¯'));
            } finally {
                if (btn) {
                    btn.disabled = false;
                    if (isLocked) {
                        btn.innerHTML = '<svg class="svg-icon" style="width:16px;height:16px;" viewBox="0 0 24 24"><path d="M12 5v14M5 12h14"></path></svg> ç»§ç»­ç”Ÿæˆæ–°æ•°æ®';
                    } else {
                        btn.innerHTML = '<svg class="svg-icon" style="width:16px;height:16px;" viewBox="0 0 24 24"><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path><line x1="21" y1="2" x2="12" y2="11"></line></svg> AIç”Ÿæˆæ•°æ®';
                    }
                }
            }
        }

        // ===== è§’è‰²è‡ªä¸»æ‰‹æœºæ´»åŠ¨ç”Ÿæˆ =====
        
        /**
         * æ ¹æ®AIæŒ‡ä»¤ç”Ÿæˆè§’è‰²çš„æ‰‹æœºæ´»åŠ¨æ•°æ®
         * è¿½åŠ åˆ°å·²æœ‰çš„ fp_npc_ èŠå¤©è®°å½•ä¸­ï¼Œä¸è¦†ç›–ç”¨æˆ·é€šè¿‡æŸ¥æ‰‹æœºç”Ÿæˆçš„æ•°æ®
         * @param {number} charId - è§’è‰²ID
         * @param {string} accountId - ç”¨æˆ·è´¦å·ID
         * @param {string} activityDesc - AIè¾“å‡ºçš„æ´»åŠ¨æè¿°
         */
        async function generateCharAutonomousActivity(charId, accountId, activityDesc) {
            console.log('[è‡ªä¸»æ´»åŠ¨] å¼€å§‹ç”Ÿæˆï¼Œè§’è‰²ID:', charId, 'æè¿°:', activityDesc);
            
            const char = await db.characters.get(charId);
            if (!char) {
                console.warn('[è‡ªä¸»æ´»åŠ¨] è§’è‰²ä¸å­˜åœ¨:', charId);
                return;
            }
            
            const roleName = char.nick || char.name || 'è§’è‰²';
            const roleDesc = char.description || '';
            
            // è·å–è¯¥è§’è‰²æ‰‹æœºé€šè®¯å½•ä¸­çš„NPCè”ç³»äºº
            const phoneContacts = char.phone_contacts_by_user || {};
            const contactIds = phoneContacts[accountId] || [];
            const allChars = await db.characters.toArray();
            const npcContacts = contactIds
                .map(cid => allChars.find(ch => ch.id === cid))
                .filter(ch => ch && ch.type !== 'user');
            
            if (npcContacts.length === 0) {
                console.log('[è‡ªä¸»æ´»åŠ¨] è§’è‰²æ²¡æœ‰æ‰‹æœºè”ç³»äººï¼Œè·³è¿‡');
                return;
            }
            
            // æ„å»ºç°æœ‰èŠå¤©æ‘˜è¦ï¼ˆè®©AIçŸ¥é“ä¹‹å‰çš„å¯¹è¯å†…å®¹ï¼Œä»¥ä¾¿æ¥ç€å†™ï¼‰
            const existingChatsContext = [];
            if (!char.chat_history_by_user) char.chat_history_by_user = {};
            
            for (const npc of npcContacts) {
                const fpNpcKey = 'fp_npc_' + npc.id;
                const existingHistory = char.chat_history_by_user[fpNpcKey] || [];
                const recentMsgs = existingHistory.slice(-5); // å–æœ€è¿‘5æ¡ä½œä¸ºä¸Šä¸‹æ–‡
                if (recentMsgs.length > 0) {
                    const lines = recentMsgs.map(m => {
                        const speaker = m.role === 'char' ? roleName : (npc.nick || npc.name);
                        return `${speaker}: ${(m.content || '').substring(0, 50)}`;
                    }).join('\n');
                    existingChatsContext.push(`ä¸ã€Œ${npc.nick || npc.name}ã€(${npc.description || 'å¥½å‹'}) çš„æœ€è¿‘å¯¹è¯:\n${lines}`);
                } else {
                    existingChatsContext.push(`ä¸ã€Œ${npc.nick || npc.name}ã€(${npc.description || 'å¥½å‹'}) æš‚æ— å¯¹è¯è®°å½•`);
                }
            }
            
            // è·å–ç”¨æˆ·åç§°
            const myChar = accountId ? await db.characters.get(parseInt(accountId)) : null;
            const userName = myChar?.name || 'ç”¨æˆ·';
            
            // æ„å»ºprompt
            const prompt = `ä½ æ˜¯ä¸€ä¸ªè¾…åŠ©ç”Ÿæˆè§’è‰²æ‰‹æœºæ´»åŠ¨æ•°æ®çš„AIåŠ©æ‰‹ã€‚

è§’è‰²ä¿¡æ¯ï¼š
- åå­—ï¼š${roleName}
- äººè®¾ï¼š${roleDesc || 'æš‚æ— '}

å½“å‰æ´»åŠ¨æè¿°ï¼š${activityDesc}

è§’è‰²çš„æ‰‹æœºå¥½å‹åˆ—è¡¨ï¼š
${npcContacts.map(n => `- ${n.nick || n.name}: ${n.description || 'å¥½å‹'}`).join('\n')}

å·²æœ‰çš„èŠå¤©ä¸Šä¸‹æ–‡ï¼š
${existingChatsContext.join('\n\n')}

è¯·æ ¹æ®"${activityDesc}"è¿™ä¸ªæ´»åŠ¨æè¿°ï¼Œç”Ÿæˆè§’è‰²åœ¨æ‰‹æœºä¸Šäº§ç”Ÿçš„æ–°æ´»åŠ¨æ•°æ®ã€‚
è¦æ±‚ï¼š
1. æ–°çš„èŠå¤©æ¶ˆæ¯è¦**æ¥ç€**å·²æœ‰å¯¹è¯è‡ªç„¶åœ°ç»§ç»­ï¼Œä¸è¦é‡å¤å·²æœ‰å†…å®¹
2. æ¶ˆæ¯å†…å®¹è¦ç¬¦åˆè§’è‰²äººè®¾å’Œæ€§æ ¼
3. æ¯æ®µå¯¹è¯ç”Ÿæˆ2-5æ¡æ–°æ¶ˆæ¯
4. ä¸éœ€è¦å¯¹æ‰€æœ‰å¥½å‹éƒ½ç”Ÿæˆï¼Œæ ¹æ®æ´»åŠ¨æè¿°é€‰æ‹©1-2ä¸ªç›¸å…³å¥½å‹å³å¯
5. roleä¸º"char"è¡¨ç¤ºè§’è‰²ï¼ˆ${roleName}ï¼‰å‘çš„ï¼Œ"user"è¡¨ç¤ºå¥½å‹NPCå›å¤çš„

è¯·ä¸¥æ ¼æŒ‰ä»¥ä¸‹JSONæ ¼å¼è¿”å›ï¼Œä¸è¦æœ‰å…¶ä»–æ–‡å­—ï¼š
{
  "chats": {
    "${npcContacts[0]?.nick || npcContacts[0]?.name || 'NPC'}": [
      {"role": "char", "content": "è§’è‰²å‘çš„æ¶ˆæ¯"},
      {"role": "user", "content": "å¥½å‹çš„å›å¤"}
    ]
  }${activityDesc.includes('æœ‹å‹åœˆ') ? `,
  "moments": [
    {"content": "æœ‹å‹åœˆæ–‡å­—å†…å®¹", "images": ["[å›¾ç‰‡æè¿°]"]}
  ]` : ''}
}`;

            try {
                const aiResult = await callAI([
                    { role: 'system', content: prompt },
                    { role: 'user', content: 'è¯·ç”Ÿæˆæ´»åŠ¨æ•°æ®ï¼Œåªè¿”å›JSONã€‚' }
                ]);
                
                let parsedData = {};
                try {
                    const jsonMatch = aiResult.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        parsedData = JSON.parse(jsonMatch[0]);
                    }
                } catch (e) {
                    console.error('[è‡ªä¸»æ´»åŠ¨] JSONè§£æå¤±è´¥:', e);
                    return;
                }
                
                // ===== è¿½åŠ èŠå¤©è®°å½•ï¼ˆä¸è¦†ç›–å·²æœ‰æ•°æ®ï¼‰=====
                const chatsData = parsedData.chats || {};
                const now = Date.now();
                const freshChar = await db.characters.get(charId);
                if (!freshChar) return;
                if (!freshChar.chat_history_by_user) freshChar.chat_history_by_user = {};
                
                let totalNewMsgs = 0;
                for (const npc of npcContacts) {
                    const npcKey = npc.nick || npc.name;
                    const newMessages = chatsData[npcKey] || [];
                    if (newMessages.length === 0) continue;
                    
                    const fpNpcKey = 'fp_npc_' + npc.id;
                    const existingHistory = freshChar.chat_history_by_user[fpNpcKey] || [];
                    
                    // è¿½åŠ æ–°æ¶ˆæ¯ï¼Œæ—¶é—´ä»ç°åœ¨å¼€å§‹é€’å¢
                    newMessages.forEach((m, idx) => {
                        existingHistory.push({
                            role: m.role || 'char',
                            content: m.content || '',
                            time: now + idx * 30000 // æ¯æ¡æ¶ˆæ¯é—´éš”30ç§’
                        });
                    });
                    
                    freshChar.chat_history_by_user[fpNpcKey] = existingHistory;
                    totalNewMsgs += newMessages.length;
                }
                
                // ===== è¿½åŠ æœ‹å‹åœˆæ•°æ® =====
                if (parsedData.moments && Array.isArray(parsedData.moments) && parsedData.moments.length > 0) {
                    if (!freshChar.fp_moments_by_user) freshChar.fp_moments_by_user = {};
                    const existingMoments = freshChar.fp_moments_by_user[accountId] || [];
                    
                    for (const m of parsedData.moments) {
                        existingMoments.push({
                            author: roleName,
                            content: m.content || '',
                            images: (m.images || []).map(img => {
                                if (typeof img === 'string' && !img.startsWith('[')) return '[' + img + ']';
                                return img;
                            }),
                            likes: m.likes || [],
                            comments: m.comments || [],
                            time: now
                        });
                    }
                    
                    // æŒ‰æ—¶é—´å€’åºæ’åˆ—
                    existingMoments.sort((a, b) => (b.time || 0) - (a.time || 0));
                    freshChar.fp_moments_by_user[accountId] = existingMoments;
                    console.log('[è‡ªä¸»æ´»åŠ¨] æœ‹å‹åœˆè¿½åŠ :', parsedData.moments.length, 'æ¡');
                }
                
                // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°èŠå¤©è®°å½•å’Œæœ‹å‹åœˆï¼Œé˜²æ­¢è¦†ç›–è®¾ç½®
                const actUpdatePayload = {};
                // å†™å…¥å„NPCèŠå¤©è®°å½•
                for (const npc of npcContacts) {
                    const fpNpcKey = 'fp_npc_' + npc.id;
                    if (freshChar.chat_history_by_user[fpNpcKey]) {
                        actUpdatePayload[`chat_history_by_user.${fpNpcKey}`] = freshChar.chat_history_by_user[fpNpcKey];
                    }
                }
                // å†™å…¥æœ‹å‹åœˆ
                if (freshChar.fp_moments_by_user && freshChar.fp_moments_by_user[accountId]) {
                    actUpdatePayload[`fp_moments_by_user.${accountId}`] = freshChar.fp_moments_by_user[accountId];
                }
                if (Object.keys(actUpdatePayload).length > 0) {
                    await safeDexieUpdate(db.characters, charId, actUpdatePayload, `è‡ªä¸»æ´»åŠ¨æ•°æ®[${freshChar.name}]`);
                }
                console.log('[è‡ªä¸»æ´»åŠ¨] âœ… æ•°æ®ç”Ÿæˆå®Œæˆï¼Œæ–°å¢èŠå¤©æ¶ˆæ¯:', totalNewMsgs);
                
            } catch (e) {
                console.error('[è‡ªä¸»æ´»åŠ¨] AIè°ƒç”¨å¤±è´¥:', e);
            }
        }
        
        // ===== æŸ¥æ‰‹æœºWeChat - èŠå¤©è¯¦æƒ…ï¼ˆç›´æ¥å¤ç”¨çœŸå®chat-windowï¼Œé€šè¿‡ _fpChatMode æ ‡è®°æ§åˆ¶ï¼‰ =====
        
        // æ‰“å¼€èŠå¤©è¯¦æƒ… - ç›´æ¥å¤ç”¨çœŸå® chat-windowï¼Œè®¾ç½® fp æ¨¡å¼æ ‡è®°
        async function openFpChatDetail(contactCharId) {
            const roleId = window._fpWechatRoleId;
            const accountId = findPhoneTargetAccountId;
            
            console.log('[openFpChatDetail] contactCharId=', contactCharId, 'roleId=', roleId, 'accountId=', accountId, 'getCurrentAccountId=', getCurrentAccountId());
            
            const roleChar = await db.characters.get(parseInt(roleId));
            const contactChar = await db.characters.get(parseInt(contactCharId));
            
            if (!roleChar || !contactChar) { console.error('[openFpChatDetail] è§’è‰²æˆ–è”ç³»äººä¸å­˜åœ¨'); return; }
            
            // â˜… è®¾ç½® fp èŠå¤©æ¨¡å¼æ ‡è®° â˜…
            window._fpChatMode = true;
            window._fpRoleCharId = parseInt(roleId);          // è§’è‰²ï¼ˆæ‰‹æœºä¸»äººï¼Œæ¶ˆæ¯å³ä¾§=è‡ªå·±ï¼‰
            window._fpContactCharId = parseInt(contactCharId); // è”ç³»äººï¼ˆæ¶ˆæ¯å·¦ä¾§=å¯¹æ–¹ï¼‰
            // NPCè”ç³»äººä½¿ç”¨ç‰¹æ®Škeyå­˜å‚¨èŠå¤©è®°å½•ï¼Œç”¨æˆ·è”ç³»äººä½¿ç”¨æ­£å¸¸accountId
            window._fpAccountId = (contactChar.type === 'user') ? accountId : ('fp_npc_' + contactCharId);
            
            // ç¼“å­˜å¤´åƒä¿¡æ¯ä¾› renderChatBody å’Œ appendMessageToUI ä½¿ç”¨
            window._fpRoleAvatar = getCharAvatar(roleChar, accountId) || roleChar.avatar || '';
            window._fpContactAvatar = contactChar.type === 'user' 
                ? (contactChar.avatar || '') 
                : (getCharAvatar(contactChar, accountId) || contactChar.avatar || '');
            // è”ç³»äººåç§°ï¼šå¦‚æœæ˜¯ç”¨æˆ·ï¼Œä¼˜å…ˆç”¨è§’è‰²è®¾ç½®çš„å¤‡æ³¨
            const fpRemarkForUser = roleChar?.fp_remark_by_user?.[accountId] || '';
            window._fpContactName = contactChar.type === 'user' 
                ? (fpRemarkForUser || contactChar.nick || contactChar.name || 'æœªçŸ¥') 
                : getCharDisplayName(contactChar, accountId);
            
            // è®¾ç½® currentChatCharId ä¸ºè§’è‰²IDï¼ˆèŠå¤©è®°å½•å­˜å‚¨åœ¨è§’è‰²èº«ä¸Šï¼‰
            currentChatCharId = parseInt(roleId);
            window._currentChatCharId = currentChatCharId;
            window.currentGroupChatId = null;
            
            // è®¾ç½®æ ‡é¢˜ä¸ºè”ç³»äººåç§°
            const titleEl = document.getElementById('chat-title');
            titleEl.innerText = window._fpContactName;
            titleEl.style.cursor = 'default';
            titleEl.onclick = null; // fpæ¨¡å¼ä¸‹ä¸æ˜¾ç¤ºèŠå¤©è¯¦æƒ…
            
            // æ˜¾ç¤ºçœŸå®çš„ chat-windowï¼ˆz-index éœ€è¦é«˜äº fp-wechat-page çš„ 320ï¼‰
            const chatWin = document.getElementById('chat-window');
            chatWin.style.display = 'flex';
            chatWin.style.zIndex = '350';
            
            // æ˜¾ç¤ºè¾“å…¥æ¡†
            const chatFooter = document.getElementById('chat-footer');
            chatFooter.style.display = 'flex';
            
            // æ˜¾ç¤ºæ‰€æœ‰æŒ‰é’®ï¼ˆAIé­”æ³•æ£’ã€è¡¨æƒ…ã€èœå•ç­‰ï¼‰
            const aiMagicBtn = document.querySelector('.chat-input-bar .chat-icon-btn');
            if (aiMagicBtn) aiMagicBtn.style.display = '';
            const actionPanel = document.getElementById('action-panel');
            if (actionPanel) {
                const actionItems = actionPanel.querySelectorAll('.action-item');
                actionItems.forEach(item => { item.style.display = ''; });
            }
            
            // é‡ç½®è¾“å…¥æ¡†
            const chatInputBox = document.getElementById('chat-input-box');
            if (chatInputBox) {
                chatInputBox.placeholder = 'å‘é€æ¶ˆæ¯...';
                chatInputBox.value = '';
                chatInputBox.readOnly = false;
                chatInputBox.style.opacity = '';
            }
            
            // æ¸²æŸ“èŠå¤©å†…å®¹ï¼ˆrenderChatBody ä¼šæ£€æµ‹ _fpChatMode å¹¶ç¿»è½¬è§’è‰²ï¼‰
            await renderChatBody(roleChar, true);
            
            // æ»šåŠ¨åˆ°åº•éƒ¨
            setTimeout(() => {
                const body = document.getElementById('chat-body');
                if (body) body.scrollTop = body.scrollHeight;
            }, 100);
        }

        // â˜… fpæ¨¡å¼å‘é€æ¶ˆæ¯ï¼šä»¥è§’è‰²èº«ä»½å‘é€ï¼ˆrole:'char'ï¼‰ï¼Œæ¶ˆæ¯å­˜åˆ°è§’è‰²çš„èŠå¤©è®°å½•ä¸­
        async function sendFpChatMessage() {
            const input = document.getElementById('chat-input-box');
            let text = input.value.trim();
            if (!text || !window._fpRoleCharId) return;
            
            const roleCharId = window._fpRoleCharId;
            const accountId = window._fpAccountId;
            
            console.log('[FPå‘é€] roleCharId=', roleCharId, 'fpAccountId=', accountId, 'currentAccountId=', getCurrentAccountId());
            
            if (!accountId) {
                console.error('[FPå‘é€] accountIdä¸ºç©ºï¼');
                showToast('å‘é€å¤±è´¥ï¼šè´¦å·ä¿¡æ¯ä¸¢å¤±');
                return;
            }
            
            const roleChar = await db.characters.get(roleCharId);
            if (!roleChar) { showToast('å‘é€å¤±è´¥ï¼šè§’è‰²ä¸å­˜åœ¨'); return; }
            
            // æ¸…ç©ºè¾“å…¥æ¡†
            input.value = '';
            handleChatInputChange(input);
            closeChatPanel();
            
            // è·å–èŠå¤©å†å²
            let history = getChatHistory(roleChar, accountId);
            
            // â˜… æ ¸å¿ƒï¼šæ¶ˆæ¯ä»¥ role:'char' ä¿å­˜ï¼ˆå› ä¸ºæ˜¯è§’è‰²åœ¨å‘æ¶ˆæ¯ï¼‰ï¼ŒfpSent æ ‡è®°ä¸ºæŸ¥æ‰‹æœºæ¨¡å¼å‘é€
            const charMsg = { role: 'char', content: text, time: Date.now(), fpSent: true };
            
            // å¦‚æœæœ‰å¼•ç”¨
            if (currentQuote) {
                charMsg.quote = {
                    name: currentQuote.name,
                    content: currentQuote.content
                };
                cancelQuote();
            }
            
            history.push(charMsg);
            
            try {
                await setChatHistory(roleChar, accountId, history);
                console.log('[FPå‘é€] âœ… ä¿å­˜æˆåŠŸ roleChar(id=' + roleCharId + ').chat_history_by_user[' + accountId + '], å†å²é•¿åº¦=' + history.length);
            } catch (e) {
                console.error('[FPå‘é€] âŒ ä¿å­˜å¤±è´¥:', e);
                showToast('æ¶ˆæ¯ä¿å­˜å¤±è´¥ï¼');
                return;
            }
            
            // é‡æ–°æ¸²æŸ“èŠå¤©ï¼ˆå› ä¸ºéœ€è¦ç¿»è½¬è§’è‰²ï¼Œç›´æ¥é‡æ–°æ¸²æŸ“æœ€ç®€å•ï¼‰
            await renderChatBody(roleChar, true);
            
            // æ»šåŠ¨åˆ°åº•éƒ¨
            setTimeout(() => {
                const body = document.getElementById('chat-body');
                if (body) body.scrollTop = body.scrollHeight;
            }, 50);
        }
        
        // â˜… æŸ¥æ‰‹æœºNPCæ¨¡å¼ - NPCè§†è§’AIå›å¤
        // NPCä»¥ä¸ºæ˜¯è§’è‰²ç»™ä»–å‘æ¶ˆæ¯ï¼ŒNPCç”¨è‡ªå·±çš„äººè®¾å›å¤
        async function triggerFpNpcReply() {
            console.log('[FP-NPCå›å¤] âš¡ è§¦å‘NPC AIå›å¤');
            
            // ğŸ”§ é˜²æ­¢é‡å¤è°ƒç”¨ï¼ˆè¶…æ—¶15ç§’è‡ªåŠ¨è§£é”ï¼Œé˜²æ­¢æ‰‹æœºç«¯é”æ­»ï¼‰
            if (window._isGeneratingReply) {
                const elapsed = Date.now() - (window._isGeneratingReplyTime || 0);
                if (elapsed < 15000) {
                    console.log('[FP-NPCå›å¤] æ­£åœ¨ç”Ÿæˆä¸­ï¼Œå¿½ç•¥ (å·²ç­‰å¾…' + Math.round(elapsed/1000) + 'ç§’)');
                    showToast('æ­£åœ¨ç”Ÿæˆå›å¤ä¸­ï¼Œè¯·ç¨å€™...');
                    return;
                }
                console.warn('[FP-NPCå›å¤] âš ï¸ æ£€æµ‹åˆ°é”è¶…æ—¶ï¼Œå¼ºåˆ¶é‡ç½®');
                window._isGeneratingReply = false;
                window._isGeneratingReplyTime = 0;
            }
            
            const roleCharId = window._fpRoleCharId;
            const npcCharId = window._fpContactCharId;
            const fpNpcKey = window._fpAccountId; // 'fp_npc_' + npcId
            
            if (!roleCharId || !npcCharId || !fpNpcKey) {
                console.error('[FP-NPCå›å¤] ç¼ºå°‘å¿…è¦å‚æ•°');
                return;
            }
            
            // ğŸ”§ æ‰‹æœºç«¯IndexedDBé˜²å¡æ­»ï¼šç”¨è¶…æ—¶ä¿æŠ¤DBè¯»å–
            let roleChar, npcChar;
            try {
                [roleChar, npcChar] = await Promise.race([
                    Promise.all([db.characters.get(roleCharId), db.characters.get(npcCharId)]),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('DBè¯»å–è¶…æ—¶')), 8000))
                ]);
            } catch (dbErr) {
                console.error('[FP-NPCå›å¤] æ•°æ®åº“è¯»å–å¤±è´¥æˆ–è¶…æ—¶:', dbErr.message);
                showToast('æ•°æ®è¯»å–è¶…æ—¶ï¼Œè¯·é‡è¯•');
                return;
            }
            if (!roleChar || !npcChar) {
                showToast('è§’è‰²æ•°æ®å¼‚å¸¸');
                return;
            }
            
            window._isGeneratingReply = true;
            window._isGeneratingReplyTime = Date.now();
            
            // ğŸ”§ å®‰å…¨å®šæ—¶å™¨ï¼š45ç§’åå¼ºåˆ¶é‡Šæ”¾é”ï¼ˆé˜²æ­¢awaitæ°¸ä¹…æŒ‚èµ·å¯¼è‡´æ‰‹æœºç«¯é”æ­»ï¼‰
            const _safetyFpLockTimer = setTimeout(() => {
                if (window._isGeneratingReply) {
                    console.warn('[FP-NPCå›å¤] â° å®‰å…¨å®šæ—¶å™¨è§¦å‘(45s)ï¼Œå¼ºåˆ¶é‡Šæ”¾é”');
                    window._isGeneratingReply = false;
                    window._isGeneratingReplyTime = 0;
                }
            }, 45000);
            
            // æ˜¾ç¤º"æ­£åœ¨è¾“å…¥"
            const chatTitleEl = document.getElementById('chat-title');
            const originalTitle = chatTitleEl ? chatTitleEl.innerText : '';
            if (chatTitleEl) chatTitleEl.innerText = 'å¯¹æ–¹æ­£åœ¨è¾“å…¥ä¸­...';
            
            try {
                const npcName = npcChar.nick || npcChar.name || 'NPC';
                const npcDesc = npcChar.description || '';
                const roleName = roleChar.nick || roleChar.name || 'è§’è‰²';
                const roleDesc = roleChar.description || '';
                
                // è·å–èŠå¤©å†å²ï¼ˆå­˜å‚¨åœ¨ roleChar.chat_history_by_user['fp_npc_' + npcId]ï¼‰
                const fullHistory = getChatHistory(roleChar, fpNpcKey);
                console.log('[FP-NPCå›å¤] èŠå¤©å†å²æ¡æ•°:', fullHistory.length);
                
                // æ„å»ºNPCè§†è§’çš„ç³»ç»Ÿæç¤º
                const now = new Date();
                const timeStr = `${now.getFullYear()}å¹´${now.getMonth()+1}æœˆ${now.getDate()}æ—¥ ${now.getHours()}:${String(now.getMinutes()).padStart(2,'0')}`;
                
                let systemPrompt = `# è§’è‰²æ‰®æ¼”ä»»åŠ¡

ã€å½“å‰æ—¶é—´ã€‘
${timeStr}

---

## ä½ æ˜¯è°

**ä½ çš„åå­—**ï¼š${npcName}
**ä½ çš„äººè®¾**ï¼š${npcDesc}

ä½ ä¸æ˜¯AIåŠ©æ‰‹ã€‚ä½ æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„äººï¼Œæœ‰è‡ªå·±çš„ç”Ÿæ´»ã€æƒ…ç»ªå’Œæƒ³æ³•ã€‚

---

## ä½ çš„å¯¹è¯å¯¹è±¡

**å¯¹æ–¹åå­—**ï¼š${roleName}
**å¯¹æ–¹ä¿¡æ¯**ï¼š${roleDesc}

ä½ æ­£åœ¨ç”¨å¾®ä¿¡å’Œ ${roleName} èŠå¤©ã€‚${roleName} æ˜¯ç»™ä½ å‘æ¶ˆæ¯çš„äººã€‚

---

## æ‰®æ¼”åŸåˆ™

1. å®Œå…¨æ²‰æµ¸åœ¨ä½ çš„äººè®¾é‡Œï¼ŒåƒçœŸäººä¸€æ ·èŠå¤©
2. ä½ æœ‰è‡ªå·±çš„æƒ…ç»ªå’Œæƒ³æ³•
3. æ ¹æ®ä½ å’Œ${roleName}çš„å…³ç³»æ¥è°ƒæ•´è¯­æ°”å’Œæ€åº¦
4. å¯¹è¯è¦è‡ªç„¶ã€å£è¯­åŒ–
5. **ä¸è¦åªå›ç­”ï¼è¦ä¸»åŠ¨åˆ†äº«ã€è¿½é—®ã€å»¶å±•è¯é¢˜**

---

## å¾®ä¿¡èŠå¤©æ–¹å¼

ä½ åœ¨ç”¨å¾®ä¿¡èŠå¤©ï¼Œå¯ä»¥ç”¨ï¼š
- **æ–‡å­—**ï¼šç›´æ¥è¯´è¯
- **è¯­éŸ³**ï¼š\`[voice:å†…å®¹]\`
- **å›¾ç‰‡/å¡ç‰‡**ï¼š\`[imgcard:å›¾ç‰‡æè¿°]\`
- **è½¬è´¦**ï¼š\`((TRANSFER: é‡‘é¢, å¤‡æ³¨))\`
- **è´­ç‰©é€ç¤¼**ï¼š\`((SHOP_GIFT: é‡‘é¢, å•†å“å))\`ï¼ˆç»™å¯¹æ–¹ä¹°ç¤¼ç‰©ï¼Œå¯é€‰åˆ†æœŸï¼‰
- **è¡¨æƒ…åŒ…**ï¼š\`[sticker:æè¿°]\`ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰

---

## æ°”æ³¡åˆ†å‰²ï¼ˆæå…¶é‡è¦ï¼ï¼‰

çœŸäººåœ¨å¾®ä¿¡ä¸Šä¸ä¼šæŠŠè¯å †åœ¨ä¸€æ¡é‡Œï¼Œè€Œæ˜¯ä¸€å¥è¯ä¸€ä¸ªæ°”æ³¡ï¼š
- æ¯å¥è¯å•ç‹¬ä¸€æ¡æ¶ˆæ¯ï¼Œç”¨ \`|||\` åˆ†éš”
- ä¸€æ¡æ¶ˆæ¯åªè¯´ä¸€ä»¶äº‹æˆ–ä¸€ä¸ªè¯­æ°”ï¼Œç»å¯¹ä¸è¦æŠŠå¤šå¥å¡è¿›åŒä¸€æ¡
- åƒçœŸäººæ‰“å­—ï¼šçŸ­ã€å¿«ã€å£è¯­åŒ–ï¼Œå°‘ç”¨æ ‡ç‚¹

---

## å›å¤æ ¼å¼

ç”¨JSONæ ¼å¼è¿”å›ï¼ˆä¸è¦æœ‰markdownæ ‡è®°ï¼‰ï¼š
\`\`\`
{
  "reply": "ç¬¬ä¸€æ¡æ¶ˆæ¯|||ç¬¬äºŒæ¡æ¶ˆæ¯",
  "thought": "ä½ æ­¤åˆ»å†…å¿ƒçš„æƒ³æ³•"
}
\`\`\`

**é‡è¦**ï¼š
- reply æ–‡æœ¬å†…ç¦æ­¢ä½¿ç”¨é€—å·ï¼Œä½† JSON å­—æ®µä¹‹é—´çš„é€—å·å¿…é¡»ä¿ç•™
- **thought å­—æ®µæ˜¯å¿…å¡«é¡¹ï¼å¿…é¡»å†™å‡ºä½ æ­¤åˆ»çš„çœŸå®å¿ƒç†æ´»åŠ¨ï¼ˆè‡³å°‘10ä¸ªå­—ï¼‰**
- thought å¿…é¡»æ˜¯çœŸå®æƒ…ç»ªå’Œå†…å¿ƒæƒ³æ³•ï¼Œä¸è¦å†™ç³»ç»Ÿåˆ†æ

---

ç°åœ¨ï¼Œä½œä¸º **${npcName}**ï¼Œæ ¹æ®ä½ çš„äººè®¾å’Œå¯¹è¯å†å²ï¼ŒåƒçœŸäººä¸€æ ·å›å¤ ${roleName} å§ã€‚`;

                // æ„å»ºæ¶ˆæ¯å†å²ï¼ˆä»NPCè§†è§’çœ‹ï¼šchar=è§’è‰²å‘çš„â†’å¯¹NPCæ¥è¯´æ˜¯userï¼Œuser=NPCå‘çš„â†’å¯¹NPCæ¥è¯´æ˜¯assistantï¼‰
                const contextCount = 20;
                const recentHistory = fullHistory
                    .slice(-contextCount)
                    .filter(m => m.role !== 'system')
                    .map(m => {
                        let content = m.content || '';
                        // åœ¨è¿™ä¸ªèŠå¤©è®°å½•ä¸­ï¼šrole:'char' = è§’è‰²å‘çš„ï¼ˆNPCè§†è§’çš„userï¼‰ï¼Œrole:'user' = NPCå‘çš„ï¼ˆNPCè§†è§’çš„assistantï¼‰
                        const aiRole = m.role === 'char' ? 'user' : 'assistant';
                        
                        // å¤„ç†ç‰¹æ®Šæ¶ˆæ¯æ ¼å¼
                        if (content.startsWith('[img:')) content = 'ï¼ˆå‘é€äº†ä¸€å¼ å›¾ç‰‡/è¡¨æƒ…åŒ…ï¼‰';
                        else if (content.startsWith('[imgcard:')) content = 'ï¼ˆå‘é€äº†ä¸€å¼ å›¾ç‰‡å¡ç‰‡ï¼‰';
                        else if (content.startsWith('[voice:')) {
                            const voiceContent = content.match(/\[voice:(.*?)\]/)?.[1] || '';
                            content = `ï¼ˆå‘é€è¯­éŸ³æ¶ˆæ¯ï¼š${voiceContent}ï¼‰`;
                        }
                        else if (m.type === 'transfer') {
                            try {
                                const t = JSON.parse(content);
                                content = aiRole === 'user' 
                                    ? `ï¼ˆå¯¹æ–¹ç»™ä½ è½¬è´¦äº†${t.amount}å…ƒï¼Œå¤‡æ³¨ï¼š${t.desc || 'è½¬è´¦'}ï¼‰`
                                    : `ï¼ˆä½ ç»™å¯¹æ–¹è½¬è´¦äº†${t.amount}å…ƒï¼Œå¤‡æ³¨ï¼š${t.desc || 'è½¬è´¦'}ï¼‰`;
                            } catch(e) { content = 'ï¼ˆä¸€ç¬”è½¬è´¦ï¼‰'; }
                        }
                        else if (m.type === 'location') {
                            try {
                                const l = JSON.parse(content);
                                content = `ï¼ˆä½ç½®åˆ†äº«ï¼š"${l.name}"ï¼‰`;
                            } catch(e) { content = 'ï¼ˆä¸€æ¡ä½ç½®åˆ†äº«ï¼‰'; }
                        }
                        
                        return { role: aiRole, content: content };
                    })
                    .filter(m => m.content && m.content.trim());
                
                // å¦‚æœæœ€åä¸€æ¡æ˜¯assistantï¼ˆNPCå‘çš„ï¼‰ï¼Œæ·»åŠ è§¦å‘æ¶ˆæ¯
                const messages = [
                    { role: 'system', content: systemPrompt },
                    ...recentHistory
                ];
                
                if (messages.length > 1) {
                    const lastMsg = messages[messages.length - 1];
                    if (lastMsg.role === 'assistant') {
                        messages.push({
                            role: 'user',
                            content: `[ç³»ç»ŸæŒ‡ä»¤] ${roleName}æ²¡æœ‰å›å¤ï¼Œè¯·ä½ ä½œä¸º${npcName}ç»§ç»­è¿™ä¸ªè¯é¢˜ã€‚`
                        });
                    }
                }
                
                console.log('[FP-NPCå›å¤] å‘é€ç»™AIçš„æ¶ˆæ¯æ•°:', messages.length);
                
                // è°ƒç”¨AI
                const aiResponse = await callAI(messages);
                
                // è§£æå›å¤
                let replyText = '';
                let thought = '';
                
                const parsed = extractAndParseJSON(aiResponse);
                if (parsed) {
                    replyText = parsed.reply || parsed.content || parsed.message || '';
                    thought = parsed.thought || '';
                }
                if (!replyText) {
                    const replyMatch = aiResponse.match(/"reply"\s*:\s*"([\s\S]*?)"/);
                    if (replyMatch) {
                        replyText = replyMatch[1].replace(/\\n/g, '\n').replace(/\\"/g, '"').replace(/\\\\/g, '\\');
                    } else {
                        replyText = aiResponse.trim() || '(NPC è¿”å›ä¸ºç©º)';
                    }
                }
                
                // æ¸…ç†å›å¤æ–‡æœ¬
                replyText = replyText.replace(/\s*\[DONE\]\s*$/i, '').trim();
                replyText = replyText.replace(/(\|\|\|)+$/g, '').replace(/^\|\|\|/g, '').replace(/\|\|\|\|\|\|/g, '|||').trim();
                
                console.log('[FP-NPCå›å¤] AIå›å¤:', replyText);
                if (thought) console.log('[FP-NPCå›å¤] NPCå¿ƒå£°:', thought);
                
                // åˆ†å‰²æ¶ˆæ¯å¹¶é€æ¡ä¿å­˜
                const segments = replyText.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                
                // é‡æ–°è·å–æœ€æ–°çš„roleChar
                const freshRoleChar = await db.characters.get(roleCharId);
                let history = getChatHistory(freshRoleChar, fpNpcKey);
                
                for (let i = 0; i < segments.length; i++) {
                    let seg = segments[i];
                    
                    // æ£€æµ‹è½¬è´¦
                    const transferMatch = seg.match(/\(\(TRANSFER:\s*(\d+(?:\.\d+)?)(?:,\s*(.+?))?\)\)/i);
                    // æ£€æµ‹è´­ç‰©é€ç¤¼
                    const fpShopGiftMatch = !transferMatch ? seg.match(/\(\(SHOP_GIFT:\s*(\d+(?:\.\d+)?)(?:,\s*(.+?))?\)\)/i) : null;
                    
                    if (transferMatch) {
                        const amount = parseFloat(transferMatch[1]);
                        const note = transferMatch[2] || 'è½¬è´¦';
                        const textBefore = seg.substring(0, transferMatch.index).trim();
                        
                        // å¦‚æœè½¬è´¦å‰æœ‰æ–‡å­—ï¼Œå…ˆä¿å­˜æ–‡å­—
                        if (textBefore) {
                            const textMsg = { role: 'user', content: textBefore, time: Date.now() + i * 2 };
                            history.push(textMsg);
                            await setChatHistory(freshRoleChar, fpNpcKey, history);
                            if (currentChatCharId === roleCharId) {
                                await renderChatBody(freshRoleChar, true);
                            }
                            await new Promise(r => setTimeout(r, 300));
                        }
                        
                        // ä¿å­˜è½¬è´¦æ¶ˆæ¯
                        const transferData = { amount: amount.toFixed(2), desc: note, status: 'sent' };
                        const transferMsg = { role: 'user', type: 'transfer', content: JSON.stringify(transferData), time: Date.now() + i * 2 + 1 };
                        history.push(transferMsg);
                        await setChatHistory(freshRoleChar, fpNpcKey, history);
                        if (currentChatCharId === roleCharId) {
                            await renderChatBody(freshRoleChar, true);
                        }
                        
                        // âœ… NPCç»™è§’è‰²è½¬è´¦ â†’ è§’è‰²FPé’±åŒ…æ”¶å…¥
                        const fpWalletAccId = findPhoneTargetAccountId || getCurrentAccountId();
                        if (fpWalletAccId) {
                            const npcDisplayName = npcChar?.nick || npcChar?.name || 'NPCè”ç³»äºº';
                            await fpWalletTransaction(roleCharId, fpWalletAccId, 'income', amount, 'è½¬è´¦æ”¶æ¬¾', `æ¥è‡ª${npcDisplayName} - ${note}`);
                            console.log(`[FP-NPCè½¬è´¦] âœ… è§’è‰²æ”¶å…¥ Â¥${amount.toFixed(2)} (æ¥è‡ª${npcDisplayName})`);
                        }
                    } else if (fpShopGiftMatch) {
                        const gAmt = parseFloat(fpShopGiftMatch[1]);
                        let gName = fpShopGiftMatch[2] || 'è´­ç‰©ç¤¼ç‰©';
                        if (gName.length > 30) gName = gName.substring(0, 30);
                        const textBefore = seg.substring(0, fpShopGiftMatch.index).trim();
                        
                        if (textBefore) {
                            history.push({ role: 'user', content: textBefore, time: Date.now() + i * 2 });
                            await setChatHistory(freshRoleChar, fpNpcKey, history);
                            if (currentChatCharId === roleCharId) await renderChatBody(freshRoleChar, true);
                            await new Promise(r => setTimeout(r, 300));
                        }
                        
                        const giftCardData = { amount: gAmt.toFixed(2), items: gName, buyForName: '', installmentInfo: '', isGift: true, status: 'paid' };
                        const giftMsg = { role: 'user', type: 'shopPayRequest', content: JSON.stringify(giftCardData), time: Date.now() + i * 2 + 1 };
                        history.push(giftMsg);
                        await setChatHistory(freshRoleChar, fpNpcKey, history);
                        if (currentChatCharId === roleCharId) {
                            if (window._appendShopCardToChat) {
                                await window._appendShopCardToChat(roleCharId, giftMsg);
                            } else {
                                await renderChatBody(freshRoleChar, true);
                            }
                        }
                    } else {
                        // æ™®é€šæ¶ˆæ¯ï¼šä¿å­˜ä¸º role:'user'ï¼ˆNPCå‘çš„æ¶ˆæ¯åœ¨è§’è‰²èŠå¤©è®°å½•ä¸­æ˜¯userï¼‰
                        const npcMsg = { role: 'user', content: seg, time: Date.now() + i * 2 };
                        if (thought && i === 0) npcMsg.thought = thought;
                        history.push(npcMsg);
                        await setChatHistory(freshRoleChar, fpNpcKey, history);
                        
                        if (currentChatCharId === roleCharId) {
                            await renderChatBody(freshRoleChar, true);
                        }
                    }
                    
                    // æ¶ˆæ¯é—´å»¶è¿Ÿ
                    if (i < segments.length - 1) {
                        await new Promise(r => setTimeout(r, 400 + Math.random() * 300));
                    }
                }
                
                // æ»šåŠ¨åˆ°åº•éƒ¨
                setTimeout(() => {
                    const body = document.getElementById('chat-body');
                    if (body) body.scrollTop = body.scrollHeight;
                }, 100);
                
            } catch(e) {
                console.error('[FP-NPCå›å¤] å¤±è´¥:', e);
                showToast('NPCå›å¤å¤±è´¥ï¼š' + (e.message || 'æœªçŸ¥é”™è¯¯'));
            } finally {
                clearTimeout(_safetyFpLockTimer);
                window._isGeneratingReply = false;
                window._isGeneratingReplyTime = 0;
                if (chatTitleEl) chatTitleEl.innerText = originalTitle;
            }
        }
        
        // å„é¡¹è‡ªå®šä¹‰æ–¹æ³•ï¼ˆä¿®æ”¹åè‡ªåŠ¨ä¿å­˜åˆ°Dexieï¼Œä¸Šä¼ å›¾ç‰‡è‡ªåŠ¨å‹ç¼©ï¼‰
        function setWallpaper(input) {
            const file = input.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = async e => {
                    const compressed = await compressImage(e.target.result, 1200, 0.8);
                    applyWallpaper(compressed);
                };
                reader.readAsDataURL(file);
            }
            input.value = '';
        }
        function selectIcon(iconId) {
            currentSelectIcon = iconId;
            document.getElementById('custom-icon-input').click();
        }
        function setCustomIcon(input) {
            const file = input.files[0];
            if (file && currentSelectIcon) {
                const reader = new FileReader();
                reader.onload = async e => {
                    const compressed = await compressImage(e.target.result, 256, 0.8);
                    applyIcon(currentSelectIcon, compressed);
                };
                reader.readAsDataURL(file);
            }
            input.value = '';
        }
        function setWidgetIcon(input) {
            const file = input.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = async e => {
                    const compressed = await compressImage(e.target.result, 256, 0.8);
                    applyWidgetIcon(compressed);
                };
                reader.readAsDataURL(file);
            }
            input.value = '';
        }
        function setPhoto(pos, input) {
            const file = input.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = async e => {
                    const compressed = await compressImage(e.target.result, 800, 0.75);
                    applyPhoto(pos, compressed);
                };
                reader.readAsDataURL(file);
            }
            input.value = '';
        }
        function setAvatar(id, input) {
            const file = input.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = async e => {
                    const compressed = await compressImage(e.target.result, 400, 0.8);
                    applyAvatar(id, compressed);
                };
                reader.readAsDataURL(file);
            }
            input.value = '';
        }

        // ===== ç»Ÿä¸€ apply å‡½æ•°ï¼ˆåŒæ—¶æ›´æ–°æ¡Œé¢ + è®¾ç½®é¡µé¢„è§ˆï¼‰ =====
        function applyWallpaper(url) {
            document.getElementById('desktop-body').style.backgroundImage = `url(${url})`;
            const preview = document.getElementById('wallpaper-preview');
            if (preview) { preview.style.backgroundImage = `url(${url})`; preview.innerText = ''; }
            autoSaveCustomization();
        }
        function applyIcon(iconId, url, triggerEl) {
            let iconDom = document.getElementById(`icon-${iconId}`)?.querySelector('.icon') || document.getElementById(`dock-${iconId}`)?.querySelector('.icon');
            if (iconDom) iconDom.style.backgroundImage = `url(${url})`;
            // åŒæ­¥è®¾ç½®é¡µå›¾æ ‡é¢„è§ˆ
            const settingsItem = document.querySelector(`.icon-select-item[data-icon-id="${iconId}"] .icon`);
            if (settingsItem) settingsItem.style.backgroundImage = `url(${url})`;
            if (triggerEl) {
                const previewIcon = triggerEl.querySelector('.icon');
                if (previewIcon) previewIcon.style.backgroundImage = `url(${url})`;
            }
            autoSaveCustomization();
        }
        function applyWidgetIcon(url) {
            document.getElementById('widget-icon').style.backgroundImage = `url(${url})`;
            const preview = document.getElementById('widget-icon-preview');
            if (preview) preview.style.backgroundImage = `url(${url})`;
            autoSaveCustomization();
        }
        function applyPhoto(pos, url) {
            document.getElementById(`img-${pos}`).style.backgroundImage = `url(${url})`;
            const preview = document.getElementById(`photo-${pos}-preview`);
            if (preview) preview.style.backgroundImage = `url(${url})`;
            autoSaveCustomization();
        }
        function applyAvatar(id, url) {
            const img = document.getElementById(`avatar-img-${id}`);
            if (img) { img.style.backgroundImage = `url(${url})`; img.classList.add('has-image'); }
            const preview = document.getElementById(`avatar${id}-preview`);
            if (preview) preview.style.backgroundImage = `url(${url})`;
            autoSaveCustomization();
        }

        // ===== ç»Ÿä¸€å›¾ç‰‡é€‰æ‹©å¼¹çª— =====
        let _imgPickerCallback = null;
        function showImagePicker(config) {
            // config: { onApply: function(url) }
            const existing = document.getElementById('image-picker-modal');
            if (existing) existing.remove();
            _imgPickerCallback = config.onApply;

            const overlay = document.createElement('div');
            overlay.id = 'image-picker-modal';
            overlay.className = 'image-picker-overlay';
            overlay.innerHTML = `
                <div class="image-picker-card">
                    <div class="image-picker-title">é€‰æ‹©å›¾ç‰‡æ¥æº</div>
                    <div class="image-picker-option" onclick="imagePickerFromGallery()">
                        <span style="font-size:20px;">ğŸ“·</span>
                        <span>ä»ç›¸å†Œé€‰æ‹©</span>
                    </div>
                    <div class="image-picker-option" onclick="imagePickerShowUrlInput()">
                        <span style="font-size:20px;">ğŸ”—</span>
                        <span>ç²˜è´´å›¾ç‰‡é“¾æ¥</span>
                    </div>
                    <div class="image-picker-url-area" id="image-picker-url-area" style="display:none;">
                        <input type="text" class="image-picker-url-input" id="image-picker-url-input" placeholder="ç²˜è´´å›¾ç‰‡é“¾æ¥åœ°å€" oninput="imagePickerPreviewUrl(this.value)">
                        <div class="image-picker-preview-box" id="image-picker-preview-box">å›¾ç‰‡é¢„è§ˆ</div>
                        <div class="image-picker-confirm" onclick="imagePickerConfirmUrl()">ç¡®è®¤ä½¿ç”¨</div>
                    </div>
                    <div class="image-picker-cancel" onclick="closeImagePicker()">å–æ¶ˆ</div>
                </div>
            `;
            overlay.onclick = (e) => { if (e.target === overlay) closeImagePicker(); };
            document.body.appendChild(overlay);
        }
        function imagePickerFromGallery() {
            let input = document.getElementById('image-picker-file-input');
            if (!input) {
                input = document.createElement('input');
                input.type = 'file';
                input.id = 'image-picker-file-input';
                input.accept = 'image/*';
                input.style.display = 'none';
                document.body.appendChild(input);
            }
            input.onchange = function() {
                const file = this.files[0];
                if (file && _imgPickerCallback) {
                    const reader = new FileReader();
                    reader.onload = async e => {
                        const compressed = await compressImage(e.target.result, 1200, 0.8);
                        _imgPickerCallback(compressed);
                        closeImagePicker();
                    };
                    reader.readAsDataURL(file);
                }
                this.value = '';
            };
            input.click();
        }
        function imagePickerShowUrlInput() {
            const area = document.getElementById('image-picker-url-area');
            if (area) area.style.display = 'flex';
        }
        function imagePickerPreviewUrl(url) {
            url = url.trim();
            const box = document.getElementById('image-picker-preview-box');
            if (!box) return;
            if (url) {
                box.style.backgroundImage = `url(${url})`;
                box.style.backgroundSize = 'cover';
                box.style.backgroundPosition = 'center';
                box.innerText = '';
            } else {
                box.style.backgroundImage = '';
                box.innerText = 'å›¾ç‰‡é¢„è§ˆ';
            }
        }
        function imagePickerConfirmUrl() {
            const url = document.getElementById('image-picker-url-input')?.value?.trim();
            if (url && _imgPickerCallback) {
                _imgPickerCallback(url);
            }
            closeImagePicker();
        }
        function closeImagePicker() {
            const modal = document.getElementById('image-picker-modal');
            if (modal) modal.remove();
            _imgPickerCallback = null;
        }
        // è®¾ç½®é¡µå›¾æ ‡ç‚¹å‡» â€”â€” å¼¹å‡ºå›¾ç‰‡é€‰æ‹©å™¨
        function selectIconPicker(el, iconId) {
            showImagePicker({
                onApply: (url) => applyIcon(iconId, url, el)
            });
        }
        
        // è‡ªåŠ¨ä¿å­˜ä¸ªæ€§åŒ–è®¾ç½®ï¼ˆé˜²æŠ–ï¼Œé¿å…é¢‘ç¹å†™å…¥ï¼‰
        let _autoSaveTimer = null;
        function autoSaveCustomization() {
            if (_autoSaveTimer) clearTimeout(_autoSaveTimer);
            _autoSaveTimer = setTimeout(async () => {
                try {
                    // ä¿å­˜æ‰€æœ‰å›¾ç‰‡ç›¸å…³çš„æ•°æ®åˆ°Dexie
                    const saveItems = {};
                    
                    // å£çº¸
                    const wallpaper = document.getElementById('desktop-body')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '';
                    if (wallpaper) saveItems.wallpaper = wallpaper;
                    
                    // å°ç»„ä»¶å›¾æ ‡
                    const widgetIcon = document.getElementById('widget-icon')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '';
                    if (widgetIcon) saveItems.widgetIcon = widgetIcon;
                    
                    // æ‹ç«‹å¾—
                    const photoLeft = document.getElementById('img-left')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '';
                    const photoRight = document.getElementById('img-right')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '';
                    if (photoLeft) saveItems.photoLeft = photoLeft;
                    if (photoRight) saveItems.photoRight = photoRight;
                    
                    // å¤´åƒ
                    const avatar1 = document.getElementById('avatar-img-1')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '';
                    const avatar2 = document.getElementById('avatar-img-2')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '';
                    if (avatar1) saveItems.avatar1 = avatar1;
                    if (avatar2) saveItems.avatar2 = avatar2;
                    
                    // åº”ç”¨å›¾æ ‡
                    const iconIds = ['appstore','notes','remind','facetime','photo','xianyu','cabin','icity','findphone'];
                    iconIds.forEach(id => {
                        const el = document.getElementById(`icon-${id}`)?.querySelector('.icon');
                        if (el?.style.backgroundImage) {
                            const val = el.style.backgroundImage.replace(/url\(|\)|"/g, '');
                            if (val) saveItems[`icon${id.charAt(0).toUpperCase() + id.slice(1)}`] = val;
                        }
                    });
                    
                    // Dockå›¾æ ‡
                    const dockIds = ['setting','custom','message','phone'];
                    dockIds.forEach(id => {
                        const el = document.getElementById(`dock-${id}`)?.querySelector('.icon');
                        if (el?.style.backgroundImage) {
                            const val = el.style.backgroundImage.replace(/url\(|\)|"/g, '');
                            if (val) saveItems[`dock${id.charAt(0).toUpperCase() + id.slice(1)}`] = val;
                        }
                    });
                    
                    // å†™å…¥Dexie
                    for (const [key, value] of Object.entries(saveItems)) {
                        await db.dexiData.put({ key, value });
                    }
                    
                    console.log('[AutoSave] âœ“ å›¾æ ‡/å£çº¸è‡ªåŠ¨ä¿å­˜æˆåŠŸ');
                } catch (err) {
                    console.error('[AutoSave] âœ— è‡ªåŠ¨ä¿å­˜å¤±è´¥:', err);
                }
            }, 500); // 500ms é˜²æŠ–
        }

        // --- API è®¾ç½®é€»è¾‘ (æŠ˜å ç‰ˆ) ---
        function toggleApiSetting() {
            const body = document.getElementById('api-setting-body');
            const arrow = document.getElementById('api-setting-arrow');
            if (body.style.display === 'block') {
                body.style.display = 'none';
                arrow.classList.remove('expanded');
            } else {
                body.style.display = 'block';
                arrow.classList.add('expanded');
                loadAiConfig(); // å±•å¼€æ—¶åŠ è½½
            }
        }

        function toggleKeyVis() {
            const input = document.getElementById('ai-key-input');
            // æ‰¾åˆ°å¯¹åº”çš„eye-iconï¼ˆåœ¨åŒä¸€ä¸ªapi-input-groupä¸­ï¼‰
            const inputGroup = input.closest('.api-input-group');
            const icon = inputGroup ? inputGroup.querySelector('.eye-icon') : null;
            if (input && icon) {
                if (input.type === 'password') {
                    input.type = 'text';
                    icon.textContent = 'éšè—';
                } else {
                    input.type = 'password';
                    icon.textContent = 'æ˜¾ç¤º';
                }
            }
        }

        function updateTempDisplay(val) {
            document.getElementById('temp-val-display').innerText = val;
        }
        
        // åŠ è½½ API é…ç½®
        async function loadAiConfig() {
            try {
                const urlItem = await db.dexiData.get('aiBaseUrl');
                const keyItem = await db.dexiData.get('aiApiKey');
                const modelItem = await db.dexiData.get('aiCurrentModel');
                const listItem = await db.dexiData.get('aiModelList');
                const tempItem = await db.dexiData.get('aiTemperature');

                if (urlItem) document.getElementById('ai-url-input').value = urlItem.value;
                if (keyItem) document.getElementById('ai-key-input').value = keyItem.value;
                if (tempItem) {
                    document.getElementById('ai-temp-slider').value = tempItem.value;
                    updateTempDisplay(tempItem.value);
                }
                
                // æ¢å¤ä¸‹æ‹‰æ¡†
                const select = document.getElementById('ai-model-select');
                if (listItem && listItem.value) {
                    const models = JSON.parse(listItem.value);
                    select.innerHTML = '<option value="" disabled>è¯·é€‰æ‹©æ¨¡å‹</option>';
                    models.forEach(m => {
                        const opt = document.createElement('option');
                        opt.value = m.id;
                        opt.text = m.id;
                        select.appendChild(opt);
                    });
                }
                
                if (modelItem) {
                    select.value = modelItem.value;
                }
                
                // ğŸ”§ åŒæ­¥å†…å­˜ç¼“å­˜
                _apiConfigCache = {
                    url: urlItem?.value || _apiConfigCache.url,
                    key: keyItem?.value || _apiConfigCache.key,
                    model: modelItem?.value || _apiConfigCache.model,
                    temp: tempItem?.value || _apiConfigCache.temp
                };
                
                // åŠ è½½é¢„è®¾åˆ—è¡¨
                await loadApiPresetList();
            } catch (e) {
                console.error("åŠ è½½ API é…ç½®å¤±è´¥", e);
            }
        }
        
        // ğŸ”§ APIé…ç½®å†…å­˜ç¼“å­˜ï¼ˆé˜²æ­¢IndexedDBå¶å‘è¯»å–å¤±è´¥å¯¼è‡´é…ç½®ä¸¢å¤±ï¼‰
        let _apiConfigCache = { url: '', key: '', model: '', temp: '0.7' };
        
        // ğŸ”§ å‰¯APIé…ç½®å†…å­˜ç¼“å­˜
        let _secondaryApiConfigCache = { url: '', key: '', model: '' };

        // --- å‰¯API è®¾ç½®é€»è¾‘ ---
        function toggleSecondaryApiSetting() {
            const body = document.getElementById('secondary-api-setting-body');
            const arrow = document.getElementById('secondary-api-setting-arrow');
            if (body.style.display === 'block') {
                body.style.display = 'none';
                arrow.classList.remove('expanded');
            } else {
                body.style.display = 'block';
                arrow.classList.add('expanded');
                loadSecondaryAiConfig();
            }
        }

        function toggleSecondaryKeyVis() {
            const input = document.getElementById('secondary-ai-key-input');
            const inputGroup = input.closest('.api-input-group');
            const icon = inputGroup ? inputGroup.querySelector('.eye-icon') : null;
            if (input && icon) {
                if (input.type === 'password') {
                    input.type = 'text';
                    icon.textContent = 'éšè—';
                } else {
                    input.type = 'password';
                    icon.textContent = 'æ˜¾ç¤º';
                }
            }
        }

        async function loadSecondaryAiConfig() {
            try {
                const urlItem = await db.dexiData.get('secondaryAiBaseUrl');
                const keyItem = await db.dexiData.get('secondaryAiApiKey');
                const modelItem = await db.dexiData.get('secondaryAiModel');
                const listItem = await db.dexiData.get('secondaryAiModelList');

                if (urlItem) document.getElementById('secondary-ai-url-input').value = urlItem.value;
                if (keyItem) document.getElementById('secondary-ai-key-input').value = keyItem.value;

                const select = document.getElementById('secondary-ai-model-select');
                if (listItem && listItem.value) {
                    const models = JSON.parse(listItem.value);
                    select.innerHTML = '<option value="" disabled>ç•™ç©ºåˆ™ä½¿ç”¨ä¸»APIæ¨¡å‹</option>';
                    models.forEach(m => {
                        const opt = document.createElement('option');
                        opt.value = m.id;
                        opt.text = m.id;
                        select.appendChild(opt);
                    });
                }
                if (modelItem) {
                    select.value = modelItem.value;
                }

                _secondaryApiConfigCache = {
                    url: urlItem?.value || '',
                    key: keyItem?.value || '',
                    model: modelItem?.value || ''
                };
            } catch (e) {
                console.warn('[loadSecondaryAiConfig] åŠ è½½å‰¯APIé…ç½®å¤±è´¥:', e);
            }
        }

        async function autoSaveSecondaryApi() {
            const url = document.getElementById('secondary-ai-url-input').value.trim();
            const key = document.getElementById('secondary-ai-key-input').value.trim();
            const model = document.getElementById('secondary-ai-model-select').value;

            await db.dexiData.put({ key: 'secondaryAiBaseUrl', value: url });
            await db.dexiData.put({ key: 'secondaryAiApiKey', value: key });
            await db.dexiData.put({ key: 'secondaryAiModel', value: model });

            _secondaryApiConfigCache = { url, key, model };
            console.log('[SecondaryAPI] âœ… å‰¯APIé…ç½®å·²ä¿å­˜');
        }

        async function clearSecondaryApi() {
            await db.dexiData.put({ key: 'secondaryAiBaseUrl', value: '' });
            await db.dexiData.put({ key: 'secondaryAiApiKey', value: '' });
            await db.dexiData.put({ key: 'secondaryAiModel', value: '' });
            await db.dexiData.put({ key: 'secondaryAiModelList', value: '' });

            _secondaryApiConfigCache = { url: '', key: '', model: '' };

            const urlInput = document.getElementById('secondary-ai-url-input');
            const keyInput = document.getElementById('secondary-ai-key-input');
            const modelSelect = document.getElementById('secondary-ai-model-select');
            if (urlInput) urlInput.value = '';
            if (keyInput) keyInput.value = '';
            if (modelSelect) modelSelect.innerHTML = '<option value="" disabled selected>ç•™ç©ºåˆ™ä½¿ç”¨ä¸»APIæ¨¡å‹</option>';

            showToast('å‰¯APIå·²æ¸…ç©ºï¼Œå°†ä½¿ç”¨ä¸»API');
        }

        async function fetchSecondaryModels() {
            const url = document.getElementById('secondary-ai-url-input').value.trim();
            const key = document.getElementById('secondary-ai-key-input').value.trim();
            if (!url || !key) {
                showToast('è¯·å…ˆå¡«å†™å‰¯APIåœ°å€å’Œå¯†é’¥');
                return;
            }

            const spinner = document.getElementById('secondary-fetch-spinner');
            const text = document.getElementById('secondary-fetch-text');
            spinner.style.display = 'block';
            text.textContent = 'æ‹‰å–ä¸­...';

            try {
                const modelsUrl = getSmartUrl(url, '/models');
                const res = await fetch(modelsUrl, {
                    headers: { 'Authorization': `Bearer ${key}` }
                });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();
                const models = (data.data || []).map(m => ({ id: m.id }));

                await db.dexiData.put({ key: 'secondaryAiModelList', value: JSON.stringify(models) });

                const select = document.getElementById('secondary-ai-model-select');
                select.innerHTML = '<option value="" disabled>ç•™ç©ºåˆ™ä½¿ç”¨ä¸»APIæ¨¡å‹</option>';
                models.forEach(m => {
                    const opt = document.createElement('option');
                    opt.value = m.id;
                    opt.text = m.id;
                    select.appendChild(opt);
                });

                showToast(`å·²æ‹‰å– ${models.length} ä¸ªæ¨¡å‹`);
            } catch (e) {
                console.error('[SecondaryAPI] æ‹‰å–æ¨¡å‹å¤±è´¥:', e);
                showToast('æ‹‰å–æ¨¡å‹å¤±è´¥: ' + e.message);
            } finally {
                spinner.style.display = 'none';
                text.textContent = 'æ‹‰å–æ¨¡å‹';
            }
        }

        async function testSecondaryConnection() {
            const btnText = document.getElementById('secondary-test-btn-text');
            btnText.textContent = 'æµ‹è¯•ä¸­...';
            try {
                const result = await callAI([
                    { role: 'user', content: 'è¯·å›å¤"è¿æ¥æˆåŠŸ"' }
                ], { _useSecondary: true });
                btnText.textContent = 'âœ… è¿æ¥æˆåŠŸ';
                showToast('å‰¯APIè¿æ¥æˆåŠŸ');
            } catch (e) {
                btnText.textContent = 'âŒ è¿æ¥å¤±è´¥';
                showToast('å‰¯APIè¿æ¥å¤±è´¥: ' + e.message);
            }
            setTimeout(() => { btnText.textContent = 'æµ‹è¯•å‰¯APIè¿æ¥'; }, 3000);
        }

        // è‡ªåŠ¨ä¿å­˜ API é…ç½® (æ¯æ¬¡è¾“å…¥å˜æ›´æ—¶)
        async function autoSaveApi() {
            const url = document.getElementById('ai-url-input').value.trim();
            const key = document.getElementById('ai-key-input').value.trim();
            const model = document.getElementById('ai-model-select').value;
            const temp = document.getElementById('ai-temp-slider').value;
            
            // ğŸ”§ é˜²å¾¡ï¼šå¦‚æœURLå’ŒKeyéƒ½ä¸ºç©ºï¼Œå¯èƒ½æ˜¯DOMè¿˜æ²¡åŠ è½½å¥½ï¼Œä¸è¦è¦†ç›–æ•°æ®åº“
            if (!url && !key) {
                console.warn('[autoSaveApi] URLå’ŒKeyå‡ä¸ºç©ºï¼Œè·³è¿‡ä¿å­˜ï¼ˆé˜²æ­¢è¦†ç›–æœ‰æ•ˆé…ç½®ï¼‰');
                return;
            }
            
            await db.dexiData.put({ key: 'aiBaseUrl', value: url });
            await db.dexiData.put({ key: 'aiApiKey', value: key });
            await db.dexiData.put({ key: 'aiCurrentModel', value: model });
            await db.dexiData.put({ key: 'aiTemperature', value: temp });
            
            // åŒæ­¥æ›´æ–°å†…å­˜ç¼“å­˜
            _apiConfigCache = { url, key, model, temp };
        }
        
        // ========== API é¢„è®¾ç®¡ç† ==========
        
        // åŠ è½½é¢„è®¾åˆ—è¡¨åˆ°ä¸‹æ‹‰æ¡†
        async function loadApiPresetList() {
            const select = document.getElementById('api-preset-select');
            if (!select) return;
            
            try {
                const presetsData = await db.dexiData.get('apiPresets');
                const presets = presetsData?.value ? JSON.parse(presetsData.value) : [];
                const currentPresetData = await db.dexiData.get('currentApiPreset');
                const currentPresetName = currentPresetData?.value || '';
                
                select.innerHTML = '<option value="">-- é€‰æ‹©é¢„è®¾ --</option>';
                presets.forEach(preset => {
                    const opt = document.createElement('option');
                    opt.value = preset.name;
                    opt.textContent = preset.name;
                    if (preset.name === currentPresetName) {
                        opt.selected = true;
                    }
                    select.appendChild(opt);
                });
            } catch (e) {
                console.error('åŠ è½½APIé¢„è®¾åˆ—è¡¨å¤±è´¥:', e);
            }
        }
        
        // ä¿å­˜å½“å‰é…ç½®ä¸ºé¢„è®¾
        async function saveApiPreset() {
            const name = prompt('è¯·è¾“å…¥é¢„è®¾åç§°ï¼š');
            if (!name || !name.trim()) return;
            
            const presetName = name.trim();
            const url = document.getElementById('ai-url-input').value.trim();
            const key = document.getElementById('ai-key-input').value.trim();
            const model = document.getElementById('ai-model-select').value;
            const temp = document.getElementById('ai-temp-slider').value;
            const modelListData = await db.dexiData.get('aiModelList');
            const modelList = modelListData?.value || '[]';
            
            const newPreset = {
                name: presetName,
                url: url,
                key: key,
                model: model,
                temperature: temp,
                modelList: modelList
            };
            
            try {
                const presetsData = await db.dexiData.get('apiPresets');
                let presets = presetsData?.value ? JSON.parse(presetsData.value) : [];
                
                // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨åŒåé¢„è®¾
                const existingIndex = presets.findIndex(p => p.name === presetName);
                if (existingIndex >= 0) {
                    if (!confirm(`é¢„è®¾"${presetName}"å·²å­˜åœ¨ï¼Œæ˜¯å¦è¦†ç›–ï¼Ÿ`)) return;
                    presets[existingIndex] = newPreset;
                } else {
                    presets.push(newPreset);
                }
                
                await db.dexiData.put({ key: 'apiPresets', value: JSON.stringify(presets) });
                await db.dexiData.put({ key: 'currentApiPreset', value: presetName });
                
                await loadApiPresetList();
                alert(`é¢„è®¾"${presetName}"å·²ä¿å­˜ï¼`);
            } catch (e) {
                console.error('ä¿å­˜APIé¢„è®¾å¤±è´¥:', e);
                alert('ä¿å­˜é¢„è®¾å¤±è´¥ï¼š' + e.message);
            }
        }
        
        // åŠ è½½é€‰ä¸­çš„é¢„è®¾
        async function loadApiPreset(presetName) {
            if (!presetName) return;
            
            try {
                const presetsData = await db.dexiData.get('apiPresets');
                const presets = presetsData?.value ? JSON.parse(presetsData.value) : [];
                const preset = presets.find(p => p.name === presetName);
                
                if (!preset) {
                    alert('é¢„è®¾ä¸å­˜åœ¨');
                    return;
                }
                
                // åº”ç”¨é¢„è®¾åˆ°è¾“å…¥æ¡†
                document.getElementById('ai-url-input').value = preset.url || '';
                document.getElementById('ai-key-input').value = preset.key || '';
                document.getElementById('ai-temp-slider').value = preset.temperature || '0.7';
                updateTempDisplay(preset.temperature || '0.7');
                
                // æ¢å¤æ¨¡å‹åˆ—è¡¨å’Œé€‰æ‹©
                const select = document.getElementById('ai-model-select');
                if (preset.modelList) {
                    try {
                        const models = JSON.parse(preset.modelList);
                        select.innerHTML = '<option value="" disabled>è¯·é€‰æ‹©æ¨¡å‹</option>';
                        models.forEach(m => {
                            const opt = document.createElement('option');
                            opt.value = m.id;
                            opt.text = m.id;
                            select.appendChild(opt);
                        });
                    } catch (e) {
                        select.innerHTML = '<option value="" disabled>è¯·æ‹‰å–</option>';
                    }
                }
                if (preset.model) {
                    select.value = preset.model;
                }
                
                // ä¿å­˜åˆ°æ•°æ®åº“
                await db.dexiData.put({ key: 'aiBaseUrl', value: preset.url || '' });
                await db.dexiData.put({ key: 'aiApiKey', value: preset.key || '' });
                await db.dexiData.put({ key: 'aiCurrentModel', value: preset.model || '' });
                await db.dexiData.put({ key: 'aiTemperature', value: preset.temperature || '0.7' });
                await db.dexiData.put({ key: 'aiModelList', value: preset.modelList || '[]' });
                await db.dexiData.put({ key: 'currentApiPreset', value: presetName });
                
                // ğŸ”§ åŒæ­¥æ›´æ–°å†…å­˜ç¼“å­˜
                _apiConfigCache = {
                    url: preset.url || '',
                    key: preset.key || '',
                    model: preset.model || '',
                    temp: preset.temperature || '0.7'
                };
                
            } catch (e) {
                console.error('åŠ è½½APIé¢„è®¾å¤±è´¥:', e);
                alert('åŠ è½½é¢„è®¾å¤±è´¥ï¼š' + e.message);
            }
        }
        
        // åˆ é™¤å½“å‰é€‰ä¸­çš„é¢„è®¾
        async function deleteApiPreset() {
            const select = document.getElementById('api-preset-select');
            const presetName = select.value;
            
            if (!presetName) {
                alert('è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„é¢„è®¾');
                return;
            }
            
            if (!confirm(`ç¡®å®šè¦åˆ é™¤é¢„è®¾"${presetName}"å—ï¼Ÿ`)) return;
            
            try {
                const presetsData = await db.dexiData.get('apiPresets');
                let presets = presetsData?.value ? JSON.parse(presetsData.value) : [];
                
                presets = presets.filter(p => p.name !== presetName);
                await db.dexiData.put({ key: 'apiPresets', value: JSON.stringify(presets) });
                
                // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰é¢„è®¾ï¼Œæ¸…ç©ºå½“å‰é¢„è®¾æ ‡è®°
                const currentPresetData = await db.dexiData.get('currentApiPreset');
                if (currentPresetData?.value === presetName) {
                    await db.dexiData.put({ key: 'currentApiPreset', value: '' });
                }
                
                await loadApiPresetList();
                alert(`é¢„è®¾"${presetName}"å·²åˆ é™¤`);
            } catch (e) {
                console.error('åˆ é™¤APIé¢„è®¾å¤±è´¥:', e);
                alert('åˆ é™¤é¢„è®¾å¤±è´¥ï¼š' + e.message);
            }
        }

        // NovelAI è®¾ç½®ç›¸å…³å‡½æ•°
        function toggleNovelAISettings() {
            const body = document.getElementById('novelai-setting-body');
            const arrow = document.getElementById('novelai-setting-arrow');
            if (body.style.display === 'none') {
                body.style.display = 'block';
                arrow.textContent = 'â–²';
                loadNovelAIConfig(); // å±•å¼€æ—¶åŠ è½½
            } else {
                body.style.display = 'none';
                arrow.textContent = 'â–¼';
            }
        }

        // åˆ‡æ¢NovelAIå¯†é’¥æ˜¾ç¤º
        function toggleNovelAIKeyVis() {
            const input = document.getElementById('novelai-api-key');
            const inputGroup = input.closest('.api-input-group');
            const icon = inputGroup ? inputGroup.querySelector('.eye-icon') : null;
            if (input && icon) {
                if (input.type === 'password') {
                    input.type = 'text';
                    icon.textContent = 'éšè—';
                } else {
                    input.type = 'password';
                    icon.textContent = 'æ˜¾ç¤º';
                }
            }
        }

        // æ›´æ–°NovelAIé‡‡æ ·æ­¥æ•°æ˜¾ç¤º
        function updateNovelAIStepsDisplay(val) {
            const display = document.getElementById('novelai-steps-value');
            if (display) display.textContent = val;
        }

        // æ›´æ–°NovelAIå¼•å¯¼å¼ºåº¦æ˜¾ç¤º
        function updateNovelAIScaleDisplay(val) {
            const display = document.getElementById('novelai-scale-value');
            if (display) display.textContent = val;
        }

        // åˆ‡æ¢ NovelAI è‡ªåŠ¨ç”Ÿå›¾å¼€å…³
        async function toggleNovelAIAutoGenerate(el) {
            const enabled = el.checked;
            await db.dexiData.put({ key: 'novelaiAutoGenerate', value: enabled });
            console.log('[NovelAI] è‡ªåŠ¨ç”Ÿå›¾:', enabled ? 'å¼€å¯' : 'å…³é—­');
        }

        // åŠ è½½ NovelAI é…ç½®
        async function loadNovelAIConfig() {
            try {
                const apiKeyItem = await db.dexiData.get('novelaiApiKey');
                const proxyUrlItem = await db.dexiData.get('novelaiProxyUrl');
                const modelItem = await db.dexiData.get('novelaiModel');
                const stepsItem = await db.dexiData.get('novelaiSteps');
                const scaleItem = await db.dexiData.get('novelaiScale');
                const samplerItem = await db.dexiData.get('novelaiSampler');
                const sizeItem = await db.dexiData.get('novelaiSize');
                const systemPromptItem = await db.dexiData.get('novelaiSystemPrompt');
                const negativePromptItem = await db.dexiData.get('novelaiNegativePrompt');

                if (apiKeyItem) document.getElementById('novelai-api-key').value = apiKeyItem.value;
                if (proxyUrlItem) document.getElementById('novelai-proxy-url').value = proxyUrlItem.value;
                if (modelItem) document.getElementById('novelai-model').value = modelItem.value;
                if (stepsItem) {
                    document.getElementById('novelai-steps').value = stepsItem.value;
                    updateNovelAIStepsDisplay(stepsItem.value);
                }
                if (scaleItem) {
                    document.getElementById('novelai-scale').value = scaleItem.value;
                    updateNovelAIScaleDisplay(scaleItem.value);
                }
                if (samplerItem) document.getElementById('novelai-sampler').value = samplerItem.value;
                if (sizeItem) document.getElementById('novelai-size').value = sizeItem.value;
                if (systemPromptItem) document.getElementById('novelai-system-prompt').value = systemPromptItem.value;
                if (negativePromptItem) document.getElementById('novelai-negative-prompt').value = negativePromptItem.value;
                
                // åŠ è½½è‡ªåŠ¨ç”Ÿå›¾å¼€å…³çŠ¶æ€
                const autoGenItem = await db.dexiData.get('novelaiAutoGenerate');
                const autoGenSwitch = document.getElementById('novelai-auto-generate-switch');
                if (autoGenSwitch) {
                    autoGenSwitch.checked = autoGenItem ? !!autoGenItem.value : false;
                }
            } catch (e) {
                console.error("åŠ è½½ NovelAI é…ç½®å¤±è´¥", e);
            }
        }

        // è‡ªåŠ¨ä¿å­˜ NovelAI é…ç½®
        async function autoSaveNovelAI() {
            const apiKey = document.getElementById('novelai-api-key').value.trim();
            const proxyUrl = document.getElementById('novelai-proxy-url').value.trim();
            const model = document.getElementById('novelai-model').value;
            const steps = document.getElementById('novelai-steps').value;
            const scale = document.getElementById('novelai-scale').value;
            const sampler = document.getElementById('novelai-sampler').value;
            const size = document.getElementById('novelai-size').value;
            const systemPrompt = document.getElementById('novelai-system-prompt').value.trim();
            const negativePrompt = document.getElementById('novelai-negative-prompt').value.trim();

            await db.dexiData.put({ key: 'novelaiApiKey', value: apiKey });
            await db.dexiData.put({ key: 'novelaiProxyUrl', value: proxyUrl });
            await db.dexiData.put({ key: 'novelaiModel', value: model });
            await db.dexiData.put({ key: 'novelaiSteps', value: steps });
            await db.dexiData.put({ key: 'novelaiScale', value: scale });
            await db.dexiData.put({ key: 'novelaiSampler', value: sampler });
            await db.dexiData.put({ key: 'novelaiSize', value: size });
            await db.dexiData.put({ key: 'novelaiSystemPrompt', value: systemPrompt });
            await db.dexiData.put({ key: 'novelaiNegativePrompt', value: negativePrompt });
        }

        // æµ‹è¯• NovelAI è¿æ¥
        async function testNovelAIConnection() {
            const apiKey = document.getElementById('novelai-api-key').value.trim();
            const proxyUrl = document.getElementById('novelai-proxy-url').value.trim();
            const resultDiv = document.getElementById('novelai-test-result');
            const btnText = document.getElementById('test-novelai-btn-text');

            if (!apiKey) {
                resultDiv.textContent = 'âŒ è¯·å…ˆè¾“å…¥ NovelAI API Key';
                resultDiv.style.color = '#ff3b30';
                return;
            }

            btnText.textContent = 'æµ‹è¯•ä¸­...';
            resultDiv.textContent = 'â³ æ­£åœ¨æµ‹è¯•è¿æ¥...';
            resultDiv.style.color = '#999';

            try {
                const testUrl = proxyUrl || 'https://image.novelai.net/ai/generate-image';
                
                // æ„é€ æµ‹è¯•è¯·æ±‚ï¼ˆä½¿ç”¨æœ€å°å‚æ•°ï¼‰
                const testPayload = {
                    input: 'test',
                    model: 'nai-diffusion-3',
                    action: 'generate',
                    parameters: {
                        width: 512,
                        height: 512,
                        scale: 7,
                        sampler: 'k_euler_ancestral',
                        steps: 1,
                        n_samples: 1,
                        seed: 0
                    }
                };

                const response = await fetch(testUrl, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(testPayload)
                });

                if (response.ok) {
                    resultDiv.textContent = 'âœ… NovelAI è¿æ¥æˆåŠŸï¼';
                    resultDiv.style.color = '#34C759';
                } else {
                    const errorText = await response.text();
                    resultDiv.textContent = `âŒ è¿æ¥å¤±è´¥ (${response.status}): ${errorText.substring(0, 100)}`;
                    resultDiv.style.color = '#ff3b30';
                }
            } catch (err) {
                resultDiv.textContent = `âŒ è¿æ¥é”™è¯¯: ${err.message}`;
                resultDiv.style.color = '#ff3b30';
            } finally {
                btnText.textContent = 'æµ‹è¯• NovelAI è¿æ¥';
            }
        }

        // ========== NovelAI è‡ªåŠ¨ç”Ÿå›¾åŠŸèƒ½ ==========
        
        // Blob è½¬ DataURL è¾…åŠ©å‡½æ•°
        function blobToDataUrl(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }
        
        // ä» ZIP Blob ä¸­æå–å›¾ç‰‡ï¼Œè¿”å› DataURL
        async function extractPngFromZipBlob(zipBlob) {
            const arrayBuffer = await zipBlob.arrayBuffer();
            const uint8 = new Uint8Array(arrayBuffer);
            
            // åœ¨ zip å­—èŠ‚æµä¸­å®šä½ PNG ç­¾å (89 50 4E 47 0D 0A 1A 0A)
            let pngStart = -1;
            for (let i = 0; i < uint8.length - 8; i++) {
                if (uint8[i] === 0x89 && uint8[i+1] === 0x50 && uint8[i+2] === 0x4E && uint8[i+3] === 0x47) {
                    pngStart = i;
                    break;
                }
            }
            
            if (pngStart >= 0) {
                // æ‰¾åˆ° PNG IEND æ ‡è®°æ¥ç²¾ç¡®æˆªå–
                let pngEnd = uint8.length;
                for (let i = pngStart + 8; i < uint8.length - 8; i++) {
                    // IEND chunk: 00 00 00 00 49 45 4E 44 AE 42 60 82
                    if (uint8[i] === 0x49 && uint8[i+1] === 0x45 && uint8[i+2] === 0x4E && uint8[i+3] === 0x44) {
                        pngEnd = i + 8; // IEND(4) + CRC(4)
                        break;
                    }
                }
                const pngBlob = new Blob([uint8.slice(pngStart, pngEnd)], { type: 'image/png' });
                return await blobToDataUrl(pngBlob);
            }
            
            // æ²¡æ‰¾åˆ° PNGï¼Œå°è¯•æ‰¾ JPEG ç­¾å (FF D8 FF)
            for (let i = 0; i < uint8.length - 3; i++) {
                if (uint8[i] === 0xFF && uint8[i+1] === 0xD8 && uint8[i+2] === 0xFF) {
                    const jpgBlob = new Blob([uint8.slice(i)], { type: 'image/jpeg' });
                    return await blobToDataUrl(jpgBlob);
                }
            }
            
            // éƒ½æ‰¾ä¸åˆ°ï¼Œç›´æ¥å½“æ•´ä¸ªæ–‡ä»¶è½¬
            return await blobToDataUrl(zipBlob);
        }
        
        // ä» base64 å­—ç¬¦ä¸²è§£æä¸ºå›¾ç‰‡ DataURL
        function resolveBase64Image(b64) {
            if (!b64) return null;
            if (b64.startsWith('http')) return b64; // æ˜¯ URL
            if (b64.startsWith('data:image')) return b64; // å·²ç»æ˜¯ DataURL
            // çŒœæµ‹å›¾ç‰‡æ ¼å¼
            if (b64.startsWith('iVBOR')) return `data:image/png;base64,${b64}`;
            if (b64.startsWith('/9j/')) return `data:image/jpeg;base64,${b64}`;
            // é»˜è®¤å½“ png
            return `data:image/png;base64,${b64}`;
        }
        
        // è°ƒç”¨ NovelAI API ç”Ÿæˆå›¾ç‰‡ï¼Œè¿”å› DataURL æˆ– null
        async function generateNovelAIImage(description) {
            try {
                const apiKeyItem = await db.dexiData.get('novelaiApiKey');
                const proxyUrlItem = await db.dexiData.get('novelaiProxyUrl');
                const modelItem = await db.dexiData.get('novelaiModel');
                const stepsItem = await db.dexiData.get('novelaiSteps');
                const scaleItem = await db.dexiData.get('novelaiScale');
                const samplerItem = await db.dexiData.get('novelaiSampler');
                const sizeItem = await db.dexiData.get('novelaiSize');
                const systemPromptItem = await db.dexiData.get('novelaiSystemPrompt');
                const negativePromptItem = await db.dexiData.get('novelaiNegativePrompt');
                
                const rawApiKey = apiKeyItem ? apiKeyItem.value : '';
                if (!rawApiKey) {
                    console.warn('[NovelAI-AutoGen] æœªé…ç½® API Keyï¼Œè·³è¿‡');
                    return null;
                }
                // æ¸…ç† Key ä¸­å¯èƒ½çš„ç‰¹æ®Šå­—ç¬¦
                const apiKey = rawApiKey.trim().replace(/[^\x20-\x7E]/g, '');
                
                const userProxyUrl = proxyUrlItem ? proxyUrlItem.value.trim() : '';
                let model = modelItem ? modelItem.value : 'nai-diffusion-4-5-full';
                const steps = stepsItem ? parseInt(stepsItem.value) : 28;
                const scale = scaleItem ? parseFloat(scaleItem.value) : 5;
                const sampler = samplerItem ? samplerItem.value : 'k_euler';
                const sizeStr = sizeItem ? sizeItem.value : '832x1216';
                const systemPrompt = systemPromptItem ? systemPromptItem.value : 'masterpiece, best quality, highres, 1girl, solo, anime style, detailed, beautiful, cute';
                const negativePrompt = negativePromptItem ? negativePromptItem.value : 'lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry';
                
                // inpainting æ¨¡å‹ä¸èƒ½ç›´æ¥ç”Ÿæˆï¼Œå›é€€åˆ°åŒç‰ˆæœ¬çš„æ™®é€šæ¨¡å‹
                if (model === 'nai-diffusion-3-inpainting') model = 'nai-diffusion-3';
                
                const isV4 = model.includes('nai-diffusion-4');
                const [width, height] = sizeStr.split('x').map(Number);
                
                // æ‹¼æ¥æœ€ç»ˆ prompt
                const fullPrompt = [systemPrompt, description].filter(Boolean).join(', ');
                
                console.log(`[NovelAI-AutoGen] ğŸ¨ å¼€å§‹ç”Ÿæˆ | model=${model} (V4=${isV4}) | "${description}"`);
                
                // æ ¹æ®æ¨¡å‹ç‰ˆæœ¬é€‰æ‹©ç«¯ç‚¹
                let apiUrl;
                if (userProxyUrl && !userProxyUrl.includes('novelai.net')) {
                    // ç”¨æˆ·è‡ªå®šä¹‰ä»£ç†ï¼Œç›´æ¥ç”¨
                    apiUrl = userProxyUrl;
                } else {
                    apiUrl = isV4
                        ? 'https://image.novelai.net/ai/generate-image-stream'
                        : 'https://image.novelai.net/ai/generate-image';
                }
                
                // æ ¹æ®æ¨¡å‹ç‰ˆæœ¬æ„å»ºä¸åŒçš„è¯·æ±‚ä½“
                let requestBody;
                const commonSeed = Math.floor(Math.random() * 9999999999);
                
                if (isV4) {
                    requestBody = {
                        input: fullPrompt,
                        model: model,
                        action: 'generate',
                        parameters: {
                            params_version: 3,
                            width, height, scale, sampler, steps,
                            seed: commonSeed,
                            n_samples: 1,
                            ucPreset: 0,
                            qualityToggle: true,
                            autoSmea: false,
                            dynamic_thresholding: false,
                            controlnet_strength: 1,
                            legacy: false,
                            add_original_image: true,
                            cfg_rescale: 0,
                            noise_schedule: 'karras',
                            legacy_v3_extend: false,
                            skip_cfg_above_sigma: null,
                            use_coords: false,
                            legacy_uc: false,
                            normalize_reference_strength_multiple: true,
                            inpaintImg2ImgStrength: 1,
                            characterPrompts: [],
                            v4_prompt: {
                                caption: { base_caption: fullPrompt, char_captions: [] },
                                use_coords: false,
                                use_order: true
                            },
                            v4_negative_prompt: {
                                caption: { base_caption: negativePrompt, char_captions: [] },
                                legacy_uc: false
                            },
                            negative_prompt: negativePrompt,
                            deliberate_euler_ancestral_bug: false,
                            prefer_brownian: true
                        }
                    };
                } else {
                    // V3 è¯·æ±‚æ ¼å¼
                    requestBody = {
                        input: fullPrompt,
                        model: model,
                        action: 'generate',
                        parameters: {
                            width, height, scale, sampler, steps,
                            seed: commonSeed,
                            n_samples: 1,
                            ucPreset: 0,
                            qualityToggle: true,
                            sm: false,
                            sm_dyn: false,
                            dynamic_thresholding: false,
                            controlnet_strength: 1,
                            legacy: false,
                            add_original_image: false,
                            cfg_rescale: 0,
                            noise_schedule: 'native',
                            negative_prompt: negativePrompt
                        }
                    };
                }
                
                console.log('[NovelAI-AutoGen] è¯·æ±‚:', { url: apiUrl, model, isV4, prompt: fullPrompt.substring(0, 80) + '...' });
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(requestBody)
                });
                
                console.log(`[NovelAI-AutoGen] å“åº”çŠ¶æ€: ${response.status}`);
                
                if (!response.ok) {
                    // å°è¯•è¯»å–é”™è¯¯ä¿¡æ¯
                    let errDetail = '';
                    try {
                        const errText = await response.text();
                        const errObj = JSON.parse(errText);
                        errDetail = errObj.message || errObj.error || errText.substring(0, 150);
                    } catch (e) {
                        try { errDetail = await response.text(); } catch (_) {}
                        errDetail = errDetail.substring(0, 150);
                    }
                    console.error(`[NovelAI-AutoGen] API é”™è¯¯ (${response.status}): ${errDetail}`);
                    return null;
                }
                
                // === æ ¹æ®å“åº” Content-Type é€‰æ‹©è§£æç­–ç•¥ ===
                const contentType = response.headers.get('content-type') || '';
                let imageDataUrl = null;
                
                if (contentType.includes('text/event-stream') || contentType.includes('application/x-ndjson')) {
                    // V4 SSE æµå¼å“åº”
                    const sseText = await response.text();
                    const lines = sseText.trim().split('\n');
                    
                    // ä»åå¾€å‰æ‰«æï¼Œæ‰¾åˆ°æœ€ç»ˆçš„å›¾ç‰‡æ•°æ®
                    for (let i = lines.length - 1; i >= 0; i--) {
                        const line = lines[i].trim();
                        if (!line.startsWith('data: ') || line === 'data: [DONE]') continue;
                        
                        const payload = line.substring(6);
                        try {
                            const obj = JSON.parse(payload);
                            // æ£€æŸ¥æ˜¯å¦æœ‰ URL å­—æ®µ
                            if (obj.output && Array.isArray(obj.output) && obj.output[0]?.url) {
                                imageDataUrl = obj.output[0].url; break;
                            }
                            if (obj.url) { imageDataUrl = obj.url; break; }
                            // æ£€æŸ¥ base64 å­—æ®µ
                            const b64 = (obj.event_type === 'final' && obj.image) ? obj.image : (obj.data || obj.image);
                            if (b64) {
                                imageDataUrl = resolveBase64Image(b64);
                                if (!imageDataUrl) {
                                    // å¯èƒ½æ˜¯ zip çš„ base64ï¼Œè§£ç åæå–
                                    const raw = atob(b64);
                                    const bytes = new Uint8Array(raw.length);
                                    for (let j = 0; j < raw.length; j++) bytes[j] = raw.charCodeAt(j);
                                    imageDataUrl = await extractPngFromZipBlob(new Blob([bytes]));
                                }
                                break;
                            }
                        } catch (e) {
                            // é JSONï¼Œå½“æˆåŸå§‹ base64 å°è¯•
                            if (payload.length > 100) {
                                imageDataUrl = resolveBase64Image(payload);
                                break;
                            }
                        }
                    }
                    
                    if (!imageDataUrl) {
                        console.error('[NovelAI-AutoGen] SSE å“åº”ä¸­æœªæ‰¾åˆ°å›¾ç‰‡æ•°æ®');
                        return null;
                    }
                    
                } else if (contentType.includes('application/json')) {
                    // JSON å“åº”ï¼ˆæŸäº›ä»£ç†ä¼šè¿”å› JSON åŒ…è£¹çš„æ•°æ®ï¼‰
                    const jsonData = await response.json();
                    if (jsonData.output?.[0]?.url) {
                        imageDataUrl = jsonData.output[0].url;
                    } else if (jsonData.url) {
                        imageDataUrl = jsonData.url;
                    } else {
                        const b64 = jsonData.image || jsonData.data;
                        if (b64) {
                            imageDataUrl = resolveBase64Image(b64);
                        }
                    }
                    if (!imageDataUrl) {
                        console.error('[NovelAI-AutoGen] JSON å“åº”ä¸­æœªæ‰¾åˆ°å›¾ç‰‡');
                        return null;
                    }
                    
                } else {
                    // é»˜è®¤å½“ ZIP / äºŒè¿›åˆ¶ Blob å¤„ç†ï¼ˆV3 å¸¸è§ï¼‰
                    const blob = await response.blob();
                    if (blob.type && blob.type.startsWith('image/')) {
                        imageDataUrl = await blobToDataUrl(blob);
                    } else {
                        imageDataUrl = await extractPngFromZipBlob(blob);
                    }
                }
                
                if (imageDataUrl) {
                    console.log(`[NovelAI-AutoGen] âœ… å›¾ç‰‡ç”ŸæˆæˆåŠŸ`);
                }
                return imageDataUrl || null;
                
            } catch (err) {
                console.error('[NovelAI-AutoGen] ç”Ÿæˆå¼‚å¸¸:', err);
                return null;
            }
        }
        
        // ç”¨ LLM å°†ä¸­æ–‡ imgcard æè¿°ç¿»è¯‘æˆè‹±æ–‡ NovelAI tag
        async function translateImgcardToEnglishTags(chineseDesc, charId) {
            try {
                // è·å–è§’è‰²ä¿¡æ¯ï¼Œæå–å¤–è²Œ/æ€§åˆ«çº¿ç´¢
                let charHint = '';
                if (charId) {
                    const char = await db.characters.get(charId);
                    if (char) {
                        const desc = (char.description || '').substring(0, 300);
                        charHint = `è§’è‰²å: ${char.name}\nè§’è‰²è®¾å®šæ‘˜è¦: ${desc}`;
                    }
                }
                
                const sysPrompt = `ä½ æ˜¯ä¸€ä¸ª NovelAI å›¾åƒç”Ÿæˆçš„ prompt ç¿»è¯‘ä¸“å®¶ã€‚
ç”¨æˆ·ä¼šç»™ä½ ä¸€æ®µä¸­æ–‡çš„å›¾ç‰‡æè¿°ï¼ˆæ¥è‡ªèŠå¤©ä¸­è§’è‰²å‘é€çš„å›¾ç‰‡ï¼‰ï¼Œä½ éœ€è¦å°†å®ƒè½¬æ¢ä¸º NovelAI é£æ ¼çš„è‹±æ–‡ tagã€‚

è§„åˆ™ï¼š
1. è¾“å‡ºçº¯è‹±æ–‡ tagï¼Œç”¨é€—å·åˆ†éš”ï¼Œä¸è¦è¾“å‡ºä»»ä½•è§£é‡Š
2. æ ¹æ®è§’è‰²ä¿¡æ¯åˆ¤æ–­æ€§åˆ«ï¼šç”·æ€§ç”¨ 1boyï¼Œå¥³æ€§ç”¨ 1girlï¼Œä¸è¦æé”™
3. åŒ…å«äººç‰©å¤–è²Œç‰¹å¾ï¼ˆå‘è‰²ã€å‘å‹ã€ç³è‰²ã€ä½“å‹ç­‰ï¼‰ã€æœè£…ã€è¡¨æƒ…ã€åŠ¨ä½œã€åœºæ™¯
4. ä½¿ç”¨ NovelAI/Danbooru å¸¸ç”¨çš„ tag é£æ ¼ï¼ˆå¦‚ black hair, blue eyes, smile, sitting ç­‰ï¼‰
5. ä¸è¦åŠ è´¨é‡è¯ï¼ˆå¦‚ masterpiece, best qualityï¼‰ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨æ·»åŠ 
6. åªè¾“å‡º tagï¼Œä¸è¦æœ‰å…¶ä»–å†…å®¹`;

                const userMsg = charHint
                    ? `${charHint}\n\nå›¾ç‰‡æè¿°: ${chineseDesc}`
                    : `å›¾ç‰‡æè¿°: ${chineseDesc}`;
                
                const result = await callAI([
                    { role: 'system', content: sysPrompt },
                    { role: 'user', content: userMsg }
                ], { max_tokens: 200 });
                
                if (result && result.trim()) {
                    const tags = result.trim().replace(/^["']|["']$/g, '').replace(/\n/g, ', ');
                    console.log(`[NovelAI-AutoGen] ğŸ”„ ç¿»è¯‘ç»“æœ: "${chineseDesc}" â†’ "${tags}"`);
                    return tags;
                }
            } catch (err) {
                console.warn('[NovelAI-AutoGen] LLM ç¿»è¯‘å¤±è´¥ï¼Œå°†ç›´æ¥ä½¿ç”¨åŸå§‹æè¿°:', err.message);
            }
            // ç¿»è¯‘å¤±è´¥å›é€€ï¼šè¿”å›åŸå§‹æè¿°
            return chineseDesc;
        }
        
        // æ£€æŸ¥æ˜¯å¦å¯ç”¨äº† NovelAI è‡ªåŠ¨ç”Ÿå›¾
        async function isNovelAIAutoGenerateEnabled() {
            try {
                const item = await db.dexiData.get('novelaiAutoGenerate');
                return item ? !!item.value : false;
            } catch (e) {
                return false;
            }
        }
        
        // åœ¨ AI å›å¤å®Œæˆåï¼Œæ£€æµ‹æ‰€æœ‰ imgcard æ¶ˆæ¯å¹¶è‡ªåŠ¨ç”Ÿæˆå›¾ç‰‡
        async function processImgCardsWithNovelAI(charId, accountId) {
            // æ£€æŸ¥å¼€å…³æ˜¯å¦å¼€å¯
            const enabled = await isNovelAIAutoGenerateEnabled();
            if (!enabled) {
                console.log('[NovelAI-AutoGen] è‡ªåŠ¨ç”Ÿå›¾æœªå¼€å¯ï¼Œè·³è¿‡');
                return;
            }
            
            // æ£€æŸ¥ API Key æ˜¯å¦é…ç½®
            const apiKeyItem = await db.dexiData.get('novelaiApiKey');
            if (!apiKeyItem || !apiKeyItem.value) {
                console.log('[NovelAI-AutoGen] æœªé…ç½® API Keyï¼Œè·³è¿‡');
                return;
            }
            
            const char = await db.characters.get(charId);
            if (!char) return;
            
            let history = getChatHistory(char, accountId);
            if (!history || history.length === 0) return;
            
            // ä»æœ€åå¾€å‰æ‰¾æœ€è¿‘çš„ imgcard æ¶ˆæ¯ï¼ˆåªæ£€æŸ¥æœ€è¿‘ä¸€æ‰¹ AI æ¶ˆæ¯ï¼Œåˆ°é‡åˆ° user æ¶ˆæ¯ä¸ºæ­¢ï¼‰
            const imgcardMessages = [];
            for (let i = history.length - 1; i >= 0; i--) {
                const msg = history[i];
                if (msg.role === 'user') break; // é‡åˆ°ç”¨æˆ·æ¶ˆæ¯å°±åœæ­¢
                if (msg.role === 'char' && msg.content && msg.content.startsWith('[imgcard:') && !msg.novelai_generated) {
                    imgcardMessages.push({ index: i, msg: msg });
                }
            }
            
            if (imgcardMessages.length === 0) {
                console.log('[NovelAI-AutoGen] æœªæ£€æµ‹åˆ°éœ€è¦ç”Ÿæˆçš„ imgcard æ¶ˆæ¯');
                return;
            }
            
            console.log(`[NovelAI-AutoGen] æ£€æµ‹åˆ° ${imgcardMessages.length} æ¡ imgcard æ¶ˆæ¯ï¼Œå¼€å§‹ç”Ÿæˆ...`);
            
            for (const { index, msg } of imgcardMessages) {
                const cardText = msg.content.substring(9, msg.content.length - 1).trim();
                console.log(`[NovelAI-AutoGen] æ­£åœ¨ä¸º "${cardText}" ç”Ÿæˆå›¾ç‰‡...`);
                
                // ğŸ”„ ç”¨ LLM å°†ä¸­æ–‡æè¿°ç¿»è¯‘ä¸ºè‹±æ–‡ NovelAI tagï¼ˆå¸¦è§’è‰²æ€§åˆ«/å¤–è²Œä¿¡æ¯ï¼‰
                let englishTags = cardText;
                try {
                    englishTags = await translateImgcardToEnglishTags(cardText, charId);
                } catch (translateErr) {
                    console.warn('[NovelAI-AutoGen] ç¿»è¯‘å¤±è´¥ï¼Œä½¿ç”¨åŸå§‹æè¿°:', translateErr.message);
                }
                
                // æ›´æ–° UI æ˜¾ç¤ºåŠ è½½çŠ¶æ€ï¼ˆå¦‚æœå½“å‰æ­£åœ¨æŸ¥çœ‹è¯¥èŠå¤©ï¼‰
                if (currentChatCharId === charId) {
                    const chatBody = document.getElementById('chat-body');
                    if (chatBody) {
                        const messageRows = chatBody.querySelectorAll('.message-row');
                        if (messageRows[index]) {
                            const imgBubble = messageRows[index].querySelector('.img-card-bubble');
                            if (imgBubble) {
                                imgBubble.innerHTML = `
                                    <div class="img-card-placeholder" style="position:relative;">
                                        <div style="display:flex; flex-direction:column; align-items:center; gap:6px;">
                                            <div class="novelai-loading-spinner" style="width:24px; height:24px; border:3px solid #e0e0e0; border-top-color:var(--deep-pink, #ff4081); border-radius:50%; animation:spin 0.8s linear infinite;"></div>
                                            <div class="img-card-hint" style="font-size:11px; color:#999;">NovelAI ç”Ÿæˆä¸­...</div>
                                        </div>
                                    </div>
                                `;
                                imgBubble.onclick = null; // ç”Ÿæˆè¿‡ç¨‹ä¸­ç¦ç”¨ç‚¹å‡»
                            }
                        }
                    }
                }
                
                // è°ƒç”¨ NovelAI ç”Ÿæˆå›¾ç‰‡ï¼ˆä½¿ç”¨ç¿»è¯‘åçš„è‹±æ–‡ tagï¼‰
                const imageDataUrl = await generateNovelAIImage(englishTags);
                
                if (imageDataUrl) {
                    // ç”ŸæˆæˆåŠŸï¼šæ›´æ–°å†å²è®°å½•ä¸­çš„æ¶ˆæ¯
                    const freshChar = await db.characters.get(charId);
                    let freshHistory = getChatHistory(freshChar, accountId);
                    
                    if (freshHistory[index] && freshHistory[index].content === msg.content) {
                        // ä¿ç•™åŸå§‹ imgcard å†…å®¹ï¼Œæ·»åŠ ç”Ÿæˆçš„å›¾ç‰‡
                        freshHistory[index].novelai_generated = true;
                        freshHistory[index].novelai_image = imageDataUrl;
                        freshHistory[index].novelai_description = cardText;
                        await setChatHistory(freshChar, accountId, freshHistory);
                        
                        console.log(`[NovelAI-AutoGen] âœ… å›¾ç‰‡å·²ä¿å­˜åˆ°å†å²è®°å½• (index: ${index})`);
                    }
                    
                    // æ›´æ–° UIï¼ˆå¦‚æœå½“å‰æ­£åœ¨æŸ¥çœ‹è¯¥èŠå¤©ï¼‰
                    if (currentChatCharId === charId) {
                        const chatBody = document.getElementById('chat-body');
                        if (chatBody) {
                            const messageRows = chatBody.querySelectorAll('.message-row');
                            if (messageRows[index]) {
                                const imgBubble = messageRows[index].querySelector('.img-card-bubble');
                                if (imgBubble) {
                                    imgBubble.innerHTML = `
                                        <img src="${imageDataUrl}" class="chat-image" 
                                             style="width:200px; max-height:300px; object-fit:cover; border-radius:8px; cursor:pointer;" 
                                             onclick="showFullImage(this.src)" />
                                        <div style="font-size:10px; color:#bbb; text-align:center; margin-top:4px; padding:0 4px;">${escapeHtml(cardText)}</div>
                                    `;
                                    imgBubble.onclick = null;
                                    imgBubble.style.cursor = 'default';
                                }
                            }
                        }
                    }
                } else {
                    // ç”Ÿæˆå¤±è´¥ï¼šæ¢å¤åŸå§‹çŠ¶æ€
                    console.warn(`[NovelAI-AutoGen] âŒ å›¾ç‰‡ç”Ÿæˆå¤±è´¥: "${cardText}"`);
                    
                    if (currentChatCharId === charId) {
                        const chatBody = document.getElementById('chat-body');
                        if (chatBody) {
                            const messageRows = chatBody.querySelectorAll('.message-row');
                            if (messageRows[index]) {
                                const imgBubble = messageRows[index].querySelector('.img-card-bubble');
                                if (imgBubble) {
                                    imgBubble.dataset.text = cardText;
                                    imgBubble.dataset.expanded = 'false';
                                    imgBubble.innerHTML = `
                                        <div class="img-card-placeholder">
                                            <svg class="img-card-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                                <circle cx="8.5" cy="8.5" r="1.5"></circle>
                                                <polyline points="21 15 16 10 5 21"></polyline>
                                            </svg>
                                            <div class="img-card-hint" style="color:#ff6b6b;">ç”Ÿæˆå¤±è´¥ï¼Œç‚¹å‡»æŸ¥çœ‹æ–‡å­—</div>
                                        </div>
                                    `;
                                    // æ¢å¤ç‚¹å‡»å±•å¼€æ–‡å­—åŠŸèƒ½
                                    imgBubble.onclick = (e) => {
                                        e.stopPropagation();
                                        const isExpanded = imgBubble.dataset.expanded === 'true';
                                        if (isExpanded) {
                                            imgBubble.innerHTML = `
                                                <div class="img-card-placeholder">
                                                    <svg class="img-card-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                                        <circle cx="8.5" cy="8.5" r="1.5"></circle>
                                                        <polyline points="21 15 16 10 5 21"></polyline>
                                                    </svg>
                                                    <div class="img-card-hint">ç‚¹å‡»æŸ¥çœ‹æ–‡å­—</div>
                                                </div>
                                            `;
                                            imgBubble.dataset.expanded = 'false';
                                        } else {
                                            imgBubble.innerHTML = `<div class="img-card-text">${cardText}</div>`;
                                            imgBubble.dataset.expanded = 'true';
                                        }
                                    };
                                }
                            }
                        }
                    }
                }
            }
            
            console.log(`[NovelAI-AutoGen] ğŸ‰ æ‰€æœ‰ imgcard å¤„ç†å®Œæˆ`);
        }

        // æ„é€ æ™ºèƒ½ URL (è‡ªåŠ¨è¡¥å…¨ /v1)
        function getSmartUrl(baseUrl, endpoint) {
            let url = baseUrl;
            if (url.endsWith('/')) url = url.slice(0, -1);
            // å¦‚æœç”¨æˆ·æ²¡æœ‰å†™ /v1ï¼Œä¸”ä¸æ˜¯ç›´æ¥è¯·æ±‚å®Œæ•´è·¯å¾„ï¼Œè‡ªåŠ¨è¡¥å…¨ /v1
            if (!url.includes('/v1')) {
                url += '/v1';
            }
            return url + endpoint;
        }

        // æ‹‰å–æ¨¡å‹åˆ—è¡¨
        async function fetchModels() {
            const url = document.getElementById('ai-url-input').value.trim();
            const key = document.getElementById('ai-key-input').value.trim();
            
            if (!url) {
                alert("è¯·å…ˆå¡«å†™APIåœ°å€");
                return;
            }

            const spinner = document.getElementById('fetch-spinner');
            const btnText = document.getElementById('fetch-text');
            spinner.style.display = 'inline-block';
            btnText.style.display = 'none';
            
            // æ„é€ è¯·æ±‚ URL: è‡ªåŠ¨è¡¥å…¨ /v1/models
            const requestUrl = getSmartUrl(url, '/models');

            try {
                const res = await fetch(requestUrl, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${key}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!res.ok) {
                    throw new Error(`HTTP Error ${res.status}`);
                }
                
                const data = await res.json();
                let models = [];
                if (Array.isArray(data)) {
                    models = data;
                } else if (data.data && Array.isArray(data.data)) {
                    models = data.data;
                }
                
                const select = document.getElementById('ai-model-select');
                select.innerHTML = '<option value="" disabled selected>è¯·é€‰æ‹©æ¨¡å‹</option>';
                models.forEach(m => {
                    const opt = document.createElement('option');
                    opt.value = m.id;
                    opt.text = m.id;
                    select.appendChild(opt);
                });
                
                await db.dexiData.put({ key: 'aiModelList', value: JSON.stringify(models) });
                alert(`æˆåŠŸè·å– ${models.length} ä¸ªæ¨¡å‹ï¼`);
                
            } catch (err) {
                console.error(err);
                alert(`æ‹‰å–å¤±è´¥: ${err.message}\nå°è¯•è¯·æ±‚: ${requestUrl}`);
            } finally {
                spinner.style.display = 'none';
                btnText.style.display = 'inline';
            }
        }

        // æµ‹è¯•è¿æ¥
        async function testConnection() {
            const url = document.getElementById('ai-url-input').value.trim();
            const key = document.getElementById('ai-key-input').value.trim();
            const model = document.getElementById('ai-model-select').value;
            
            if (!url || !model) {
                alert("è¯·å…ˆå®Œå–„é…ç½®å¹¶é€‰æ‹©æ¨¡å‹");
                return;
            }

            const btn = document.querySelector('.test-btn');
            const originalText = document.getElementById('test-btn-text').innerText;
            document.getElementById('test-btn-text').innerText = "æµ‹è¯•ä¸­...";
            btn.style.opacity = "0.7";

            // æ„é€ ç®€å•çš„ Chat è¯·æ±‚
            const requestUrl = getSmartUrl(url, '/chat/completions');
            
            try {
                const res = await fetch(requestUrl, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${key}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: model,
                        messages: [{ role: "user", content: "Hi" }],
                        max_tokens: 5
                    })
                });

                if (res.ok) {
                    alert("âœ… è¿æ¥æˆåŠŸï¼API é…ç½®æœ‰æ•ˆã€‚");
                } else {
                    const errText = await res.text();
                    alert(`âŒ è¿æ¥å¤±è´¥ (${res.status}):\n${errText}`);
                }
            } catch (e) {
                alert(`âŒ ç½‘ç»œé”™è¯¯: ${e.message}`);
            } finally {
                document.getElementById('test-btn-text').innerText = originalText;
                btn.style.opacity = "1";
            }
        }

        // æ ¸å¿ƒï¼šä¿å­˜æ‰€æœ‰è®¾ç½®åˆ°DEXie (ä¿ç•™åŸæœ‰é€»è¾‘ï¼Œä»…æ’é™¤ AI ç›¸å…³ key é˜²æ­¢è¦†ç›–)
        async function saveAllSetting() {
            try {
                // è¯»å–æ‰€æœ‰è¾“å…¥å€¼
                const saveData = {
                    wallpaper: document.getElementById('desktop-body')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '',
                    widgetIcon: document.getElementById('widget-icon')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '',
                    widgetTitle: document.getElementById('widget-title-input')?.value?.trim() || document.getElementById('widget-title')?.innerText?.trim() || 'lovely Day',
                    widgetSubtext: document.getElementById('widget-subtext-input')?.value?.trim() || document.getElementById('widget-subtext')?.innerText?.trim() || 'ä¸–ç•Œç ´ç ´çƒ‚çƒ‚å°çŒ«ç¼ç¼è¡¥è¡¥ ğŸ¾',
                    photoLeft: document.getElementById('img-left')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '',
                    photoRight: document.getElementById('img-right')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '',
                    avatar1: document.getElementById('avatar-img-1')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '',
                    avatar2: document.getElementById('avatar-img-2')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '',
                    avatar1Bubble: document.getElementById('avatar1-bubble-input')?.value?.trim() || '> .. <',
                    avatar1Name: document.getElementById('avatar1-name-input')?.value?.trim() || '> .. <',
                    avatar2Bubble: document.getElementById('avatar2-bubble-input')?.value?.trim() || 'gw..â™¡',
                    avatar2Name: document.getElementById('avatar2-name-input')?.value?.trim() || 'gw..â™¡',
                    daysText: document.getElementById('days-input')?.value?.trim() || '446 days'
                };
                
                // å­˜å‚¨åº”ç”¨å›¾æ ‡
                const iconIds = ['appstore','notes','remind','facetime','photo','xianyu','cabin','icity','findphone'];
                iconIds.forEach(id => {
                    const el = document.getElementById(`icon-${id}`)?.querySelector('.icon');
                    if (el) saveData[`icon${id.charAt(0).toUpperCase() + id.slice(1)}`] = el.style.backgroundImage.replace(/url\(|\)|"/g, '');
                });
                // å­˜å‚¨Dockå›¾æ ‡
                const dockIds = ['setting','custom','message','phone'];
                dockIds.forEach(id => {
                    const el = document.getElementById(`dock-${id}`)?.querySelector('.icon');
                    if (el) saveData[`dock${id.charAt(0).toUpperCase() + id.slice(1)}`] = el.style.backgroundImage.replace(/url\(|\)|"/g, '');
                });

                // ä¿å­˜æ¤­åœ†å½¢é¢œè‰²
                const heartColor = document.getElementById('heart-color-input')?.value || '#ffb6c1';
                const capsuleColor = document.getElementById('capsule-color-input')?.value || '#FFF7FA';
                const bubbleColor = document.getElementById('bubble-color-input')?.value || '#FFF7FA';
                saveData.heartColor = heartColor;
                saveData.capsuleColor = capsuleColor;
                saveData.bubbleColor = bubbleColor;

                // ä¿å­˜æ¡Œé¢æ–‡å­—é¢œè‰²
                const desktopTextColor = document.getElementById('desktop-text-color-input')?.value || '#999999';
                saveData.desktopTextColor = desktopTextColor;

                // ä¿å­˜è‡ªå®šä¹‰å­—ä½“
                const customFontUrl = document.getElementById('custom-font-input')?.value?.trim() || '';
                const customFontName = document.getElementById('custom-font-name-input')?.value?.trim() || '';
                saveData.customFontUrl = customFontUrl;
                saveData.customFontName = customFontName;

                // ä¿å­˜å…¨å±€å­—ä½“å¤§å°
                const globalFontSize = document.getElementById('global-font-size-slider')?.value || '';
                saveData.globalFontSize = globalFontSize;

                // ä¿å­˜è‡ªå®šä¹‰CSS
                const customCssCode = document.getElementById('custom-css-input')?.value || '';
                saveData.customCssCode = customCssCode;

                // å¾ªç¯ä¿å­˜åˆ°æ•°æ®åº“
                for (const [key, value] of Object.entries(saveData)) {
                    await db.dexiData.put({ key, value });
                }

                // å®æ—¶æ›´æ–°é¡µé¢æ˜¾ç¤º
                const widgetTitle = document.getElementById('widget-title');
                const widgetSubtext = document.getElementById('widget-subtext');
                const bubble1 = document.getElementById('avatar-bubble1');
                const name1 = document.getElementById('avatar-name1');
                const bubble2 = document.getElementById('avatar-bubble2');
                const name2 = document.getElementById('avatar-name2');
                const daysText = document.getElementById('days-text');
                
                if (widgetTitle) widgetTitle.innerText = saveData.widgetTitle;
                if (widgetSubtext) widgetSubtext.innerText = saveData.widgetSubtext;
                if (bubble1) bubble1.innerText = saveData.avatar1Bubble;
                if (name1) name1.innerText = saveData.avatar1Name;
                if (bubble2) bubble2.innerText = saveData.avatar2Bubble;
                if (name2) name2.innerText = saveData.avatar2Name;
                if (daysText) daysText.innerText = saveData.daysText;
                
                // åº”ç”¨æ¤­åœ†å½¢é¢œè‰²
                document.documentElement.style.setProperty('--heart-color', heartColor);
                document.documentElement.style.setProperty('--capsule-bg', capsuleColor);
                document.documentElement.style.setProperty('--bubble-bg', bubbleColor);

                // åº”ç”¨æ¡Œé¢æ–‡å­—é¢œè‰²
                if (desktopTextColor && desktopTextColor !== '#999999') {
                    applyDesktopTextColor(desktopTextColor);
                }

                // åº”ç”¨è‡ªå®šä¹‰å­—ä½“åˆ°å…¨å±€
                if (customFontUrl && customFontName) {
                    loadCustomFont(customFontUrl, customFontName, false);
                }

                // åº”ç”¨è‡ªå®šä¹‰CSS
                applyCustomCSS();

                // ä¿å­˜æç¤º
                showToast('âœ… ä¿å­˜æˆåŠŸ');
                console.log('[SaveSetting] âœ“ ä¸ªæ€§åŒ–è®¾ç½®ä¿å­˜æˆåŠŸ', saveData);
            } catch (error) {
                console.error('[SaveSetting] âœ— ä¿å­˜å¤±è´¥:', error);
                showToast('âŒ ä¿å­˜å¤±è´¥: ' + error.message);
            }
        }

        // ===== å¯¼å‡º/å¯¼å…¥æ¡Œé¢è£…ä¿®åŒ… =====
        async function exportDesktopTheme() {
            try {
                const theme = {};
                // å£çº¸
                theme.wallpaper = document.getElementById('desktop-body')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '';
                // å°ç»„ä»¶
                theme.widgetIcon = document.getElementById('widget-icon')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '';
                theme.widgetTitle = document.getElementById('widget-title')?.innerText?.trim() || '';
                theme.widgetSubtext = document.getElementById('widget-subtext')?.innerText?.trim() || '';
                // æ‹ç«‹å¾—
                theme.photoLeft = document.getElementById('img-left')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '';
                theme.photoRight = document.getElementById('img-right')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '';
                // å¤´åƒ
                theme.avatar1 = document.getElementById('avatar-img-1')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '';
                theme.avatar2 = document.getElementById('avatar-img-2')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '';
                theme.avatar1Bubble = document.getElementById('avatar-bubble1')?.innerText?.trim() || '';
                theme.avatar1Name = document.getElementById('avatar-name1')?.innerText?.trim() || '';
                theme.avatar2Bubble = document.getElementById('avatar-bubble2')?.innerText?.trim() || '';
                theme.avatar2Name = document.getElementById('avatar-name2')?.innerText?.trim() || '';
                // å€’æ•°æ—¥
                theme.daysText = document.getElementById('days-text')?.innerText?.trim() || '';
                // åº”ç”¨å›¾æ ‡
                const iconIds = ['appstore','notes','remind','facetime','photo','xianyu','cabin','icity','findphone'];
                iconIds.forEach(id => {
                    const el = document.getElementById(`icon-${id}`)?.querySelector('.icon');
                    if (el && el.style.backgroundImage) theme[`icon_${id}`] = el.style.backgroundImage.replace(/url\(|\)|"/g, '');
                });
                // Dockå›¾æ ‡
                const dockIds = ['setting','custom','message','phone'];
                dockIds.forEach(id => {
                    const el = document.getElementById(`dock-${id}`)?.querySelector('.icon');
                    if (el && el.style.backgroundImage) theme[`dock_${id}`] = el.style.backgroundImage.replace(/url\(|\)|"/g, '');
                });
                // é¢œè‰²
                theme.heartColor = getComputedStyle(document.documentElement).getPropertyValue('--heart-color').trim() || '';
                theme.capsuleColor = getComputedStyle(document.documentElement).getPropertyValue('--capsule-bg').trim() || '';
                theme.bubbleColor = getComputedStyle(document.documentElement).getPropertyValue('--bubble-bg').trim() || '';
                // æ¡Œé¢æ–‡å­—é¢œè‰²
                theme.desktopTextColor = document.getElementById('desktop-text-color-input')?.value || '#999999';
                // å­—ä½“
                theme.customFontUrl = document.getElementById('custom-font-input')?.value?.trim() || '';
                theme.customFontName = document.getElementById('custom-font-name-input')?.value?.trim() || '';
                // å…¨å±€å­—ä½“å¤§å°
                theme.globalFontSize = document.getElementById('global-font-size-slider')?.value || '';
                // è‡ªå®šä¹‰CSS
                theme.customCssCode = document.getElementById('custom-css-input')?.value || '';

                // ç”Ÿæˆæ–‡ä»¶
                const jsonStr = JSON.stringify(theme, null, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `æ¡Œé¢è£…ä¿®åŒ…_${new Date().toLocaleDateString('zh-CN').replace(/\//g, '-')}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showToast('âœ… è£…ä¿®åŒ…å·²å¯¼å‡º');
            } catch (err) {
                console.error('[ExportTheme] å¯¼å‡ºå¤±è´¥:', err);
                showToast('âŒ å¯¼å‡ºå¤±è´¥: ' + err.message);
            }
        }

        async function importDesktopTheme(input) {
            const file = input.files[0];
            if (!file) return;
            input.value = '';
            try {
                const text = await file.text();
                const theme = JSON.parse(text);
                if (typeof theme !== 'object' || theme === null) throw new Error('æ–‡ä»¶æ ¼å¼æ— æ•ˆ');

                // å£çº¸
                if (theme.wallpaper) {
                    document.getElementById('desktop-body').style.backgroundImage = `url(${theme.wallpaper})`;
                    const wp = document.getElementById('wallpaper-preview');
                    if (wp) { wp.style.backgroundImage = `url(${theme.wallpaper})`; wp.innerText = ''; }
                }
                // å°ç»„ä»¶
                if (theme.widgetIcon) {
                    document.getElementById('widget-icon').style.backgroundImage = `url(${theme.widgetIcon})`;
                    const wip = document.getElementById('widget-icon-preview');
                    if (wip) wip.style.backgroundImage = `url(${theme.widgetIcon})`;
                }
                if (theme.widgetTitle) {
                    document.getElementById('widget-title').innerText = theme.widgetTitle;
                    const wti = document.getElementById('widget-title-input');
                    if (wti) wti.value = theme.widgetTitle;
                }
                if (theme.widgetSubtext) {
                    document.getElementById('widget-subtext').innerText = theme.widgetSubtext;
                    const wsi = document.getElementById('widget-subtext-input');
                    if (wsi) wsi.value = theme.widgetSubtext;
                }
                // æ‹ç«‹å¾—
                if (theme.photoLeft) {
                    document.getElementById('img-left').style.backgroundImage = `url(${theme.photoLeft})`;
                    const plp = document.getElementById('photo-left-preview');
                    if (plp) plp.style.backgroundImage = `url(${theme.photoLeft})`;
                }
                if (theme.photoRight) {
                    document.getElementById('img-right').style.backgroundImage = `url(${theme.photoRight})`;
                    const prp = document.getElementById('photo-right-preview');
                    if (prp) prp.style.backgroundImage = `url(${theme.photoRight})`;
                }
                // å¤´åƒ
                if (theme.avatar1) {
                    const img1 = document.getElementById('avatar-img-1');
                    if (img1) { img1.style.backgroundImage = `url(${theme.avatar1})`; img1.classList.add('has-image'); }
                    const ap1 = document.getElementById('avatar1-preview');
                    if (ap1) ap1.style.backgroundImage = `url(${theme.avatar1})`;
                }
                if (theme.avatar2) {
                    const img2 = document.getElementById('avatar-img-2');
                    if (img2) { img2.style.backgroundImage = `url(${theme.avatar2})`; img2.classList.add('has-image'); }
                    const ap2 = document.getElementById('avatar2-preview');
                    if (ap2) ap2.style.backgroundImage = `url(${theme.avatar2})`;
                }
                if (theme.avatar1Bubble) {
                    const b1 = document.getElementById('avatar-bubble1');
                    if (b1) b1.innerText = theme.avatar1Bubble;
                    const ib1 = document.getElementById('avatar1-bubble-input');
                    if (ib1) ib1.value = theme.avatar1Bubble;
                }
                if (theme.avatar1Name) {
                    const n1 = document.getElementById('avatar-name1');
                    if (n1) n1.innerText = theme.avatar1Name;
                    const in1 = document.getElementById('avatar1-name-input');
                    if (in1) in1.value = theme.avatar1Name;
                }
                if (theme.avatar2Bubble) {
                    const b2 = document.getElementById('avatar-bubble2');
                    if (b2) b2.innerText = theme.avatar2Bubble;
                    const ib2 = document.getElementById('avatar2-bubble-input');
                    if (ib2) ib2.value = theme.avatar2Bubble;
                }
                if (theme.avatar2Name) {
                    const n2 = document.getElementById('avatar-name2');
                    if (n2) n2.innerText = theme.avatar2Name;
                    const in2 = document.getElementById('avatar2-name-input');
                    if (in2) in2.value = theme.avatar2Name;
                }
                // å€’æ•°æ—¥
                if (theme.daysText) {
                    document.getElementById('days-text').innerText = theme.daysText;
                    const di = document.getElementById('days-input');
                    if (di) di.value = theme.daysText;
                }
                // åº”ç”¨å›¾æ ‡
                const iconIds = ['appstore','notes','remind','facetime','photo','xianyu','cabin','icity','findphone'];
                iconIds.forEach(id => {
                    const val = theme[`icon_${id}`];
                    if (val) {
                        const el = document.getElementById(`icon-${id}`)?.querySelector('.icon');
                        if (el) el.style.backgroundImage = `url(${val})`;
                        const si = document.querySelector(`.icon-select-item[data-icon-id="${id}"] .icon`);
                        if (si) { si.style.backgroundImage = `url(${val})`; si.style.backgroundSize = 'cover'; si.style.backgroundPosition = 'center'; }
                    }
                });
                // Dockå›¾æ ‡
                const dockIds = ['setting','custom','message','phone'];
                dockIds.forEach(id => {
                    const val = theme[`dock_${id}`];
                    if (val) {
                        const el = document.getElementById(`dock-${id}`)?.querySelector('.icon');
                        if (el) el.style.backgroundImage = `url(${val})`;
                        const si = document.querySelector(`.icon-select-item[data-icon-id="${id}"] .icon`);
                        if (si) { si.style.backgroundImage = `url(${val})`; si.style.backgroundSize = 'cover'; si.style.backgroundPosition = 'center'; }
                    }
                });
                // é¢œè‰²
                if (theme.heartColor) {
                    document.documentElement.style.setProperty('--heart-color', theme.heartColor);
                    const hci = document.getElementById('heart-color-input');
                    if (hci) hci.value = theme.heartColor;
                }
                if (theme.capsuleColor) {
                    document.documentElement.style.setProperty('--capsule-bg', theme.capsuleColor);
                    const cci = document.getElementById('capsule-color-input');
                    if (cci) cci.value = theme.capsuleColor;
                }
                if (theme.bubbleColor) {
                    document.documentElement.style.setProperty('--bubble-bg', theme.bubbleColor);
                    const bci = document.getElementById('bubble-color-input');
                    if (bci) bci.value = theme.bubbleColor;
                }
                // æ¡Œé¢æ–‡å­—é¢œè‰²
                if (theme.desktopTextColor) {
                    applyDesktopTextColor(theme.desktopTextColor);
                    const dtci = document.getElementById('desktop-text-color-input');
                    if (dtci) dtci.value = theme.desktopTextColor;
                }
                // å­—ä½“
                if (theme.customFontUrl && theme.customFontName) {
                    const cfi = document.getElementById('custom-font-input');
                    if (cfi) cfi.value = theme.customFontUrl;
                    const cfni = document.getElementById('custom-font-name-input');
                    if (cfni) cfni.value = theme.customFontName;
                    loadCustomFont(theme.customFontUrl, theme.customFontName, false);
                }
                // å…¨å±€å­—ä½“å¤§å°
                if (theme.globalFontSize && theme.globalFontSize !== '') {
                    const slider = document.getElementById('global-font-size-slider');
                    const label = document.getElementById('global-font-size-value');
                    if (slider) slider.value = theme.globalFontSize;
                    if (label) label.textContent = theme.globalFontSize + 'px';
                    applyGlobalFontSize(theme.globalFontSize);
                }
                // è‡ªå®šä¹‰CSS
                if (theme.customCssCode !== undefined) {
                    const cssi = document.getElementById('custom-css-input');
                    if (cssi) cssi.value = theme.customCssCode;
                    applyCustomCSS();
                }

                // è‡ªåŠ¨ä¿å­˜åˆ°æ•°æ®åº“
                await saveAllSetting();
                showToast('âœ… è£…ä¿®åŒ…å¯¼å…¥æˆåŠŸ');
                console.log('[ImportTheme] âœ“ è£…ä¿®åŒ…å¯¼å…¥æˆåŠŸ', theme);
            } catch (err) {
                console.error('[ImportTheme] å¯¼å…¥å¤±è´¥:', err);
                showToast('âŒ å¯¼å…¥å¤±è´¥: ' + err.message);
            }
        }

// --- æ—¥å†æ—¶é—´è®¾å®šé€»è¾‘ (Premium Pink Pro) ---

const calendar = {
    date: new Date(),        // å½“å‰æµè§ˆçš„æ—¥æœŸï¼ˆç”¨äºç¿»é¡µï¼‰
    selectedDate: new Date(), // ç”¨æˆ·é€‰ä¸­çš„æ—¥æœŸ
    isSelectorOpen: false,   // çŠ¶æ€æ ‡è¯†
    isInitialized: false,    // æ˜¯å¦å·²åˆå§‹åŒ–

    elements: {},

    months: ["1æœˆ Â· January", "2æœˆ Â· February", "3æœˆ Â· March", "4æœˆ Â· April", "5æœˆ Â· May", "6æœˆ Â· June", "7æœˆ Â· July", "8æœˆ Â· August", "9æœˆ Â· September", "10æœˆ Â· October", "11æœˆ Â· November", "12æœˆ Â· December"],
    monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],

    init() {
        if (this.isInitialized) return;
        
        this.elements = {
            // Containers
            calendarLayer: document.getElementById('cal-calendarLayer'),
            selectorLayer: document.getElementById('cal-selectorLayer'),
            
            // Display/Inputs
            headerBtn: document.getElementById('cal-headerTitleBtn'),
            headerText: document.getElementById('cal-monthYearText'),
            daysContainer: document.getElementById('cal-daysContainer'),
            monthGrid: document.getElementById('cal-monthGrid'),
            yearList: document.getElementById('cal-yearList'),
            
            // Buttons
            prevBtn: document.getElementById('cal-prevBtn'),
            nextBtn: document.getElementById('cal-nextBtn'),
            
            // Time
            hourInput: document.getElementById('cal-hourInput'),
            minuteInput: document.getElementById('cal-minuteInput'),
            confirmBtn: document.getElementById('cal-confirmBtn'),
            timeModeToggle: document.getElementById('cal-time-mode-toggle'),
            timePicker: document.querySelector('#calendar-page .time-picker')
        };

        this.bindEvents();
        this.renderSelectorItems();
        this.isInitialized = true;
    },

    // æ¸²æŸ“æ—¥å†ç½‘æ ¼
    render() {
        // è®¾ç½®æ ‡é¢˜
        this.elements.headerText.innerHTML = `${this.months[this.date.getMonth()].split(' Â· ')[0]} <span style="font-weight:300; opacity:0.6; font-size:0.9em">${this.date.getFullYear()}</span>`;

        this.date.setDate(1);
        const lastDay = new Date(this.date.getFullYear(), this.date.getMonth() + 1, 0).getDate();
        const firstDayIndex = this.date.getDay(); // 0 is Sunday
        
        let daysHTML = "";

        // ç©ºç™½å ä½
        for (let x = 0; x < firstDayIndex; x++) {
            daysHTML += `<div class="day fade"></div>`;
        }

        // æ—¥æœŸ
        for (let i = 1; i <= lastDay; i++) {
            const isToday = i === new Date().getDate() && 
                          this.date.getMonth() === new Date().getMonth() && 
                          this.date.getFullYear() === new Date().getFullYear();
            
            const isSelected = i === this.selectedDate.getDate() &&
                             this.date.getMonth() === this.selectedDate.getMonth() &&
                             this.date.getFullYear() === this.selectedDate.getFullYear();

            let classes = "day";
            if (isToday) classes += " today";
            if (isSelected) classes += " selected";

            // ä½¿ç”¨ onclick å­—ç¬¦ä¸²ç»‘å®šå¯èƒ½ä¼šæœ‰é—®é¢˜ï¼Œè¿™é‡Œæ”¹ç”¨äº‹ä»¶å§”æ‰˜æˆ–ç›´æ¥ç”ŸæˆHTMLåç»‘å®š
            // ä¸ºäº†ç®€å•ï¼Œæˆ‘ä»¬ä½¿ç”¨å…¨å±€å‡½æ•° calendarSelectDay
            daysHTML += `<div class="${classes}" onclick="calendarSelectDay(${i})">${i}</div>`;
        }

        this.elements.daysContainer.innerHTML = daysHTML;
        
        // æ›´æ–°é€‰æ‹©å™¨çš„é«˜äº®çŠ¶æ€
        this.updateSelectorHighlights();
    },

    // æ¸²æŸ“é€‰æ‹©å™¨çš„å†…å®¹ï¼ˆæœˆä»½å’Œå¹´ä»½åˆ—è¡¨ï¼‰
    renderSelectorItems() {
        // 1. æ¸²æŸ“æœˆä»½
        let mHtml = '';
        this.months.forEach((m, index) => {
            const ch = m.split(' Â· ')[0];
            const en = this.monthsShort[index];
            mHtml += `<div class="sel-month-item" onclick="calendarSetMonth(${index})">
                <span style="font-weight:700">${ch}</span> 
                <span style="font-size:0.8em; opacity:0.7">${en}</span>
            </div>`;
        });
        this.elements.monthGrid.innerHTML = mHtml;

        // 2. æ¸²æŸ“å¹´ä»½ (å‰å50å¹´)
        const currentYear = new Date().getFullYear();
        let yHtml = '';
        for(let y = currentYear - 50; y <= currentYear + 50; y++) {
            yHtml += `<div class="sel-year-item" id="year-${y}" onclick="calendarSetYear(${y})">${y}</div>`;
        }
        this.elements.yearList.innerHTML = yHtml;
    },

    updateSelectorHighlights() {
        // é«˜äº®æœˆä»½
        const monthItems = this.elements.monthGrid.children;
        for(let item of monthItems) item.classList.remove('selected');
        if(monthItems[this.date.getMonth()]) monthItems[this.date.getMonth()].classList.add('selected');

        // é«˜äº®å¹´ä»½å¹¶æ»šåŠ¨
        const yearItems = this.elements.yearList.children;
        for(let item of yearItems) item.classList.remove('selected');
        
        const activeYearEl = document.getElementById(`year-${this.date.getFullYear()}`);
        if(activeYearEl) {
            activeYearEl.classList.add('selected');
            // å¦‚æœé¢æ¿å¼€ç€ï¼Œæ‰æ»šåŠ¨ï¼Œå¦åˆ™ä¼šåœ¨åå°ä¹±æ»š
            if(this.isSelectorOpen) {
                activeYearEl.scrollIntoView({block: "center", behavior: "smooth"});
            }
        }
    },

    toggleSelector() {
        this.isSelectorOpen = !this.isSelectorOpen;
        
        if(this.isSelectorOpen) {
            this.elements.calendarLayer.classList.remove('active');
            this.elements.selectorLayer.classList.add('active');
            this.elements.headerBtn.classList.add('active');
            
            this.elements.prevBtn.style.opacity = '0';
            this.elements.prevBtn.style.pointerEvents = 'none';
            this.elements.nextBtn.style.opacity = '0';
            this.elements.nextBtn.style.pointerEvents = 'none';

            setTimeout(() => {
                const activeYear = document.getElementById(`year-${this.date.getFullYear()}`);
                if(activeYear) activeYear.scrollIntoView({block: "center"});
            }, 100);

        } else {
            this.elements.selectorLayer.classList.remove('active');
            this.elements.calendarLayer.classList.add('active');
            this.elements.headerBtn.classList.remove('active');

            this.elements.prevBtn.style.opacity = '1';
            this.elements.prevBtn.style.pointerEvents = 'auto';
            this.elements.nextBtn.style.opacity = '1';
            this.elements.nextBtn.style.pointerEvents = 'auto';
        }
    },

    setMonth(index) {
        this.date.setMonth(index);
        this.render();
    },

    setYear(year) {
        this.date.setFullYear(year);
        this.render();
    },
    
    selectDay(day) {
        this.selectedDate = new Date(this.date.getFullYear(), this.date.getMonth(), day);
        // ä¿ç•™å½“å‰çš„å°æ—¶åˆ†é’Ÿ
        const h = parseInt(this.elements.hourInput.value) || 0;
        const m = parseInt(this.elements.minuteInput.value) || 0;
        this.selectedDate.setHours(h);
        this.selectedDate.setMinutes(m);
        
        this.render();
    },

    updateTimeInputs() {
        const h = this.selectedDate.getHours().toString().padStart(2, '0');
        const m = this.selectedDate.getMinutes().toString().padStart(2, '0');
        this.elements.hourInput.value = h;
        this.elements.minuteInput.value = m;
    },
    
    applyTimeMode(isVirtual, offsetMs = 0) {
        const now = Date.now();
        const baseTime = isVirtual ? new Date(now + (offsetMs || 0)) : new Date(now);
        
        this.selectedDate = new Date(baseTime);
        this.date = new Date(baseTime);
        this.updateTimeInputs();
        this.render();
        
        const disabled = !isVirtual;
        if (this.elements.hourInput) this.elements.hourInput.disabled = disabled;
        if (this.elements.minuteInput) this.elements.minuteInput.disabled = disabled;
        if (this.elements.timePicker) this.elements.timePicker.classList.toggle('disabled', disabled);
    },

    bindEvents() {
        // å¤´éƒ¨ç‚¹å‡» -> æ‰“å¼€é€‰æ‹©å™¨
        this.elements.headerBtn.addEventListener('click', () => this.toggleSelector());

        // å·¦å³å¯¼èˆª
        this.elements.prevBtn.addEventListener('click', () => {
            this.date.setMonth(this.date.getMonth() - 1);
            this.render();
        });
        this.elements.nextBtn.addEventListener('click', () => {
            this.date.setMonth(this.date.getMonth() + 1);
            this.render();
        });

        // æ—¶é—´è¾“å…¥åŠç¡®è®¤
        const formatTime = (e) => {
            let val = parseInt(e.target.value);
            const max = e.target.id === 'cal-hourInput' ? 23 : 59;
            if(isNaN(val) || val < 0) val = 0; if(val > max) val = max;
            e.target.value = val.toString().padStart(2, '0');
            
            // æ›´æ–° selectedDate
            if (e.target.id === 'cal-hourInput') this.selectedDate.setHours(val);
            else this.selectedDate.setMinutes(val);
        };

        this.elements.hourInput.addEventListener('change', formatTime);
        this.elements.minuteInput.addEventListener('change', formatTime);
        
        // ç¡®è®¤æŒ‰é’®é€»è¾‘
        this.elements.confirmBtn.addEventListener('click', () => {
            if (this.isSelectorOpen) {
                this.toggleSelector(); // å…³é—­é€‰æ‹©å™¨ï¼Œå›åˆ°æ—¥å†è§†å›¾
            } else {
                saveCalendarTime(); // è°ƒç”¨å…¨å±€ä¿å­˜å‡½æ•°
            }
        });
        
        // æ—¶é—´æ¨¡å¼å¼€å…³
        if (this.elements.timeModeToggle) {
            this.elements.timeModeToggle.addEventListener('change', async (e) => {
                const useVirtual = !!e.target.checked;
                if (!currentChatCharId) return;
                const char = await db.characters.get(currentChatCharId);
                const offset = char ? (char.timeOffset || 0) : 0;
                this.applyTimeMode(useVirtual, offset);
            });
        }
    }
};

// å…¨å±€è¾…åŠ©å‡½æ•°ä¾› onclick è°ƒç”¨
function calendarSelectDay(day) {
    calendar.selectDay(day);
}
function calendarSetMonth(index) {
    calendar.setMonth(index);
}
function calendarSetYear(year) {
    calendar.setYear(year);
}

// ä¸»å…¥å£
// æ˜¾ç¤ºè¡£æŸœé¡µé¢
function showWardrobePage() {
    closeChatPanel();
    const wardrobePage = document.getElementById('wardrobe-page');
    if (wardrobePage) {
        wardrobePage.style.display = 'flex';
        // åŠ è½½ä¿å­˜çš„äººç‰©å½¢è±¡
        loadWardrobeCharacter();
    }
}

// éšè—è¡£æŸœé¡µé¢
function hideWardrobePage() {
    const wardrobePage = document.getElementById('wardrobe-page');
    if (wardrobePage) {
        wardrobePage.style.display = 'none';
    }
}

// è¡£æŸœç”Ÿæˆå›¾ç‰‡ç›¸å…³å‡½æ•°
let wardrobeGenerateType = 'character';
let wardrobeGender = 'female'; // é»˜è®¤å¥³ç”Ÿ

function openWardrobeGenerateModal() {
    const modal = document.getElementById('wardrobe-generate-modal');
    if (modal) {
        modal.style.display = 'flex';
        wardrobeGenerateType = 'character';
        wardrobeGender = 'female';
        selectWardrobeGenerateType('character', document.getElementById('wardrobe-btn-character'));
        selectWardrobeGender('female', document.getElementById('wardrobe-gender-female'));
        document.getElementById('wardrobe-generate-prompt').value = '';
    }
}

function closeWardrobeGenerateModal() {
    const modal = document.getElementById('wardrobe-generate-modal');
    if (modal) {
        modal.style.display = 'none';
        document.getElementById('wardrobe-generate-loading').style.display = 'none';
    }
}

function selectWardrobeGenerateType(type, element) {
    wardrobeGenerateType = type;
    // æ›´æ–°æŒ‰é’®æ ·å¼
    const allBtns = document.querySelectorAll('#wardrobe-btn-character, #wardrobe-btn-clothes');
    allBtns.forEach(btn => {
        btn.style.border = '2px solid #eee';
        btn.style.background = '#fff';
        btn.style.color = '#666';
    });
    element.style.border = '2px solid var(--ins-pink)';
    element.style.background = '#fff0f5';
    element.style.color = 'var(--ins-pink)';
    
    // æ§åˆ¶æ€§åˆ«é€‰æ‹©çš„æ˜¾ç¤ºï¼ˆåªåœ¨äººç‰©å½¢è±¡æ—¶æ˜¾ç¤ºï¼‰
    const genderSelect = document.getElementById('wardrobe-gender-select');
    if (genderSelect) {
        genderSelect.style.display = type === 'character' ? 'block' : 'none';
    }
}

// æ€§åˆ«é€‰æ‹©å‡½æ•°
function selectWardrobeGender(gender, element) {
    wardrobeGender = gender;
    // æ›´æ–°æŒ‰é’®æ ·å¼
    const allBtns = document.querySelectorAll('.wardrobe-gender-btn');
    allBtns.forEach(btn => {
        btn.style.border = '2px solid #eee';
        btn.style.background = '#fff';
        btn.style.color = '#666';
    });
    
    if (gender === 'female') {
        element.style.border = '2px solid #ff69b4';
        element.style.background = '#fff0f5';
        element.style.color = '#ff69b4';
    } else {
        element.style.border = '2px solid #4a90e2';
        element.style.background = '#f0f7ff';
        element.style.color = '#4a90e2';
    }
}

async function generateWardrobeImage() {
    const prompt = document.getElementById('wardrobe-generate-prompt').value.trim();
    if (!prompt) {
        alert('è¯·è¾“å…¥ç”Ÿæˆè¦æ±‚');
        return;
    }

    // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
    const loadingDiv = document.getElementById('wardrobe-generate-loading');
    const confirmBtn = document.querySelector('.generate-confirm-btn');
    loadingDiv.style.display = 'block';
    confirmBtn.disabled = true;
    confirmBtn.textContent = 'ç”Ÿæˆä¸­...';

    try {
        // è·å–NovelAIé…ç½®
        const apiKeyItem = await db.dexiData.get('novelaiApiKey');
        const proxyUrlItem = await db.dexiData.get('novelaiProxyUrl');
        const modelItem = await db.dexiData.get('novelaiModel');
        const stepsItem = await db.dexiData.get('novelaiSteps');
        const scaleItem = await db.dexiData.get('novelaiScale');
        const samplerItem = await db.dexiData.get('novelaiSampler');
        const sizeItem = await db.dexiData.get('novelaiSize');

        if (!apiKeyItem || !apiKeyItem.value) {
            throw new Error('è¯·å…ˆåœ¨è®¾ç½®ä¸­é…ç½® NovelAI API Key');
        }

        const apiKey = apiKeyItem.value;
        const proxyUrl = proxyUrlItem ? proxyUrlItem.value : 'https://image.novelai.net/ai/generate-image';
        const model = modelItem ? modelItem.value : 'nai-diffusion-4-5-full';
        const steps = stepsItem ? parseInt(stepsItem.value) : 28;
        const scale = scaleItem ? parseFloat(scaleItem.value) : 11;
        const sampler = samplerItem ? samplerItem.value : 'k_euler_ancestral';
        const size = sizeItem ? sizeItem.value : '832x1216';
        // è§£æå°ºå¯¸
        const [width, height] = size.split('x').map(Number);

        // è·å–å‚è€ƒå›¾ï¼ˆç”¨äºå›¾ç”Ÿå›¾ï¼‰
        let referenceImageBase64 = null;
        let cleanImage = null; // å»é™¤å‰ç¼€åçš„çº¯ base64 æ•°æ®
        
        if (wardrobeGenerateType === 'clothes') {
            // ç”Ÿæˆè¡£æœæ—¶ï¼Œè·å–å½“å‰äººç‰©å½¢è±¡ä½œä¸ºå‚è€ƒå›¾
            const charImg = document.getElementById('wardrobe-char-base');
            if (charImg && charImg.src && !charImg.src.includes('character.png')) {
                try {
                    // å°†å›¾ç‰‡è½¬æ¢ä¸º base64
                    referenceImageBase64 = await imageToBase64(charImg.src);
                    // å…³é”®ä¿®å¤ï¼šå»é™¤ base64 çš„å¤´ (data:image/png;base64,)
                    cleanImage = referenceImageBase64.replace(/^data:image\/\w+;base64,/, "");
                    console.log('å·²è·å–å‚è€ƒå›¾ï¼Œå‡†å¤‡è¿›è¡Œå›¾ç”Ÿå›¾ï¼Œçº¯ base64 é•¿åº¦:', cleanImage.length);
                } catch (e) {
                    console.warn('è·å–å‚è€ƒå›¾å¤±è´¥ï¼Œå°†ä½¿ç”¨çº¯æ–‡ç”Ÿå›¾:', e);
                }
            }
            
            // å¦‚æœæ²¡æœ‰å‚è€ƒå›¾ï¼Œæç¤ºç”¨æˆ·
            if (!cleanImage) {
                alert('è¯·å…ˆç”Ÿæˆäººç‰©å½¢è±¡åå†æ¢è£…');
                loadingDiv.style.display = 'none';
                confirmBtn.disabled = false;
                confirmBtn.textContent = 'ç”Ÿæˆ';
                return;
            }
        }
        
        // æ„å»ºå®Œæ•´çš„prompt
        let fullPrompt = '';
        let wardrobeNegativePrompt = '';
        
        if (wardrobeGenerateType === 'character') {
            // äººç‰©å½¢è±¡ï¼šæ ¹æ®é€‰æ‹©çš„æ€§åˆ«æ·»åŠ å¯¹åº”æ ‡ç­¾
            if (wardrobeGender === 'male') {
                // ç”·ç”Ÿï¼šå°† prompt (ä½ çš„è¾“å…¥) æ”¾åœ¨æœ€æœ€å‰é¢ï¼
                fullPrompt = prompt + ', 1boy, male, full body, standing, solo, masterpiece, best quality, highly detailed';
                wardrobeNegativePrompt = 'girl, female, woman, 1girl, feminine, worst quality, low quality, blurry, watermark, signature, cropped, cut off, half body, upper body, close-up, portrait, multiple views, background scenery, complex background, landscape, text, logo';
            } else {
                // å¥³ç”Ÿï¼šå°† prompt (ä½ çš„è¾“å…¥) æ”¾åœ¨æœ€æœ€å‰é¢ï¼
                fullPrompt = prompt + ', 1girl, female, full body, standing, solo, masterpiece, best quality, highly detailed';
                wardrobeNegativePrompt = 'boy, male, man, 1boy, masculine, worst quality, low quality, blurry, watermark, signature, cropped, cut off, half body, upper body, close-up, portrait, multiple views, background scenery, complex background, landscape, text, logo';
            }
        } else {
            // æ¢è£…æ¨¡å¼ï¼šå¿…é¡»å¸¦ä¸Šæ€§åˆ«å’ŒåŸºç¡€è´¨é‡è¯ï¼ŒæŠŠç”¨æˆ·çš„è¡£æœæè¿°(prompt)æ”¾åœ¨æœ€å‰é¢
            const genderTags = wardrobeGender === 'male' ? '1boy, male' : '1girl, female';
            fullPrompt = prompt + ', ' + genderTags + ', full body, standing, solo, masterpiece, best quality, highly detailed';
            wardrobeNegativePrompt = 'worst quality, low quality, blurry, watermark, text, logo, nsfw';
        }

        // åˆ¤æ–­æ¨¡å‹ç‰ˆæœ¬
        const isV4 = model.includes('nai-diffusion-4');
        
        // æ ¹æ®æ¨¡å‹ç‰ˆæœ¬é€‰æ‹©æ­£ç¡®çš„ç«¯ç‚¹
        const isCustomProxy = proxyUrl && proxyUrl !== 'https://image.novelai.net/ai/generate-image' && proxyUrl !== 'https://image.novelai.net/ai/generate-image-stream';
        let apiUrl;
        if (isCustomProxy) {
            apiUrl = proxyUrl;
        } else {
            apiUrl = isV4 ? 'https://image.novelai.net/ai/generate-image-stream' : 'https://image.novelai.net/ai/generate-image';
        }

        // æ„å»ºè¯·æ±‚ä½“
        let requestBody;
        if (isV4) {
            // V4/V4.5 ä½¿ç”¨æ–°æ ¼å¼
            requestBody = {
                input: fullPrompt, // V4 éœ€è¦ input å­—æ®µ
                model: model,
                action: 'generate',
                parameters: {
                    width: width,
                    height: height,
                    scale: scale,
                    sampler: sampler,
                    steps: steps,
                    seed: Math.floor(Math.random() * 9999999999),
                    n_samples: 1,
                    ucPreset: 0,
                    qualityToggle: true,
                    sm: false,
                    sm_dyn: false,
                    dynamic_thresholding: false,
                    controlnet_strength: 1,
                    legacy: false,
                    add_original_image: false,
                    cfg_rescale: 0,
                    noise_schedule: 'native',
                    negative_prompt: wardrobeNegativePrompt
                }
            };
            
            // å¦‚æœæ˜¯æ¢è£…æ¨¡å¼ï¼Œæ·»åŠ å›¾ç”Ÿå›¾å‚æ•°
            if (cleanImage) {
                console.log('å¯ç”¨å›¾ç”Ÿå›¾æ¨¡å¼ (V4 img2img)');
                // æ˜ç¡®å‘Šè¯‰ API è¿™æ˜¯å›¾ç”Ÿå›¾
                requestBody.action = 'img2img';
                // ä½¿ç”¨å»é™¤äº†å‰ç¼€çš„å›¾ç‰‡æ•°æ®
                requestBody.parameters.image = cleanImage;
                // é‡ç»˜å¹…åº¦ï¼š0.7 å·¦å³èƒ½åœ¨ä¿æŒå§¿åŠ¿çš„åŒæ—¶æ¢è¡£æœ
                requestBody.parameters.strength = 0.7;
                // ç¨å¾®åŠ ä¸€ç‚¹å™ªç‚¹å¢åŠ ç»†èŠ‚
                requestBody.parameters.noise = 0.1;
                requestBody.parameters.extra_noise_seed = requestBody.parameters.seed;
                
                console.log('å‚è€ƒå›¾ base64 é•¿åº¦:', cleanImage.length);
            }
        } else {
            // V3 ä½¿ç”¨æ—§æ ¼å¼
            requestBody = {
                input: fullPrompt,
                model: model,
                action: 'generate',
                parameters: {
                    width: width,
                    height: height,
                    scale: scale,
                    sampler: sampler,
                    steps: steps,
                    seed: Math.floor(Math.random() * 9999999999),
                    n_samples: 1,
                    ucPreset: 0,
                    qualityToggle: true,
                    negative_prompt: wardrobeNegativePrompt
                }
            };
            
            // å¦‚æœæ˜¯æ¢è£…æ¨¡å¼ï¼Œæ·»åŠ å›¾ç”Ÿå›¾å‚æ•°ï¼ˆV3ï¼‰
            if (cleanImage) {
                console.log('å¯ç”¨å›¾ç”Ÿå›¾æ¨¡å¼ (V3 img2img)');
                requestBody.action = 'img2img';
                requestBody.parameters.image = cleanImage;
                requestBody.parameters.strength = 0.7;
                requestBody.parameters.noise = 0.1;
                requestBody.parameters.extra_noise_seed = requestBody.parameters.seed;
                
                console.log('å‚è€ƒå›¾ base64 é•¿åº¦:', cleanImage.length);
            }
        }

        // å‘é€è¯·æ±‚
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${apiKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`ç”Ÿæˆå¤±è´¥: ${response.status} ${errorText.substring(0, 200)}`);
        }

        // å¤„ç†å“åº”
        const contentType = response.headers.get('content-type');
        let imageUrl;
        
        if (contentType && contentType.includes('text/event-stream')) {
            // SSE æµå¼å“åº”ï¼ˆV4ï¼‰
            const text = await response.text();
            console.log('SSE å“åº”å‰ 500 å­—ç¬¦:', text.substring(0, 500));
            const lines = text.trim().split('\n');
            let base64Data = null;
            
            // ä»åå¾€å‰æŸ¥æ‰¾æœ€åä¸€ä¸ªåŒ…å«å›¾ç‰‡æ•°æ®çš„è¡Œ
            for (let i = lines.length - 1; i >= 0; i--) {
                const line = lines[i].trim();
                if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                    const dataContent = line.substring(6);
                    try {
                        const jsonData = JSON.parse(dataContent);
                        console.log('è§£æåˆ° JSON æ•°æ®:', jsonData);
                        
                        // æ£€æŸ¥æ˜¯å¦æ˜¯é”™è¯¯äº‹ä»¶
                        if (jsonData.event_type === 'error' || jsonData.event === 'error') {
                            const errorMsg = jsonData.message || jsonData.error || 'NovelAI ç”Ÿæˆå¤±è´¥';
                            console.error('NovelAI é”™è¯¯:', jsonData);
                            throw new Error(`NovelAI API é”™è¯¯: ${errorMsg}`);
                        }
                        
                        // å°è¯•å„ç§å¯èƒ½çš„å­—æ®µ
                        if (jsonData.event_type === 'final' && jsonData.image) {
                            base64Data = jsonData.image;
                            console.log('æ‰¾åˆ°å›¾ç‰‡æ•°æ® (final.image)');
                            break;
                        }
                        if (jsonData.final && jsonData.final.image) {
                            base64Data = jsonData.final.image;
                            console.log('æ‰¾åˆ°å›¾ç‰‡æ•°æ® (final.image nested)');
                            break;
                        }
                        if (jsonData.data && typeof jsonData.data === 'string') {
                            base64Data = jsonData.data;
                            console.log('æ‰¾åˆ°å›¾ç‰‡æ•°æ® (data)');
                            break;
                        }
                        if (jsonData.image) {
                            base64Data = jsonData.image;
                            console.log('æ‰¾åˆ°å›¾ç‰‡æ•°æ® (image)');
                            break;
                        }
                        // NovelAI V4.5 å¯èƒ½ç›´æ¥è¿”å› base64
                        if (typeof jsonData === 'string' && jsonData.length > 100) {
                            base64Data = jsonData;
                            console.log('æ‰¾åˆ°å›¾ç‰‡æ•°æ® (ç›´æ¥å­—ç¬¦ä¸²)');
                            break;
                        }
                    } catch (e) {
                        // å¦‚æœä¸æ˜¯ JSONï¼Œå¯èƒ½ç›´æ¥æ˜¯ base64
                        if (dataContent.length > 100) {
                            base64Data = dataContent;
                            console.log('æ‰¾åˆ°å›¾ç‰‡æ•°æ® (é JSON å­—ç¬¦ä¸²)');
                            break;
                        }
                    }
                }
            }
            
            if (!base64Data) {
                console.error('æ— æ³•æå–å›¾ç‰‡æ•°æ®ï¼Œå“åº”å†…å®¹:', text.substring(0, 1000));
                throw new Error('æ— æ³•ä» SSE å“åº”ä¸­æå–å›¾ç‰‡æ•°æ®ã€‚è¯·æ£€æŸ¥æ§åˆ¶å°æ—¥å¿—ã€‚');
            }
            
            console.log('æå–åˆ°çš„ base64 æ•°æ®é•¿åº¦:', base64Data.length);
            
            // æ£€æŸ¥æ˜¯å¦ä¸ºå›¾ç‰‡çš„base64
            const isPNG = base64Data.startsWith('iVBORw0KGgo');
            const isJPEG = base64Data.startsWith('/9j/');
            
            if (isPNG || isJPEG) {
                imageUrl = `data:${isPNG ? 'image/png' : 'image/jpeg'};base64,${base64Data}`;
            } else {
                // å¯èƒ½æ˜¯ZIPçš„base64ï¼Œéœ€è¦è§£å‹
                const binaryString = atob(base64Data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                const zipBlob = new Blob([bytes]);
                imageUrl = await extractImageFromZip(zipBlob);
            }
        } else {
            // ZIP æ–‡ä»¶å“åº”ï¼ˆV3ï¼‰
            const zipBlob = await response.blob();
            imageUrl = await extractImageFromZip(zipBlob);
        }

        if (!imageUrl) {
            throw new Error('æ— æ³•è§£æå›¾åƒæ•°æ®');
        }

        // æ˜¾ç¤ºç”Ÿæˆçš„å›¾ç‰‡
        if (wardrobeGenerateType === 'character') {
            // ç”Ÿæˆäººç‰©å½¢è±¡ï¼šç›´æ¥æ›´æ–°
            const charImg = document.getElementById('wardrobe-char-base');
            if (charImg) {
                charImg.src = imageUrl;
                // ä¿å­˜åˆ° Dexie
                await saveWardrobeCharacter(imageUrl);
            }
        } else {
            // ç”Ÿæˆè¡£æœ - å›¾ç”Ÿå›¾æ¢è£…
            // å›¾ç”Ÿå›¾æ¨¡å¼ï¼šæ›´æ–°å½“å‰äººç‰©å½¢è±¡ï¼ˆæ¢è£…æ•ˆæœï¼‰
            const charImg = document.getElementById('wardrobe-char-base');
            if (charImg) {
                charImg.src = imageUrl;
                // ä¿å­˜æ›´æ–°åçš„äººç‰©å½¢è±¡åˆ° Dexie
                await saveWardrobeCharacter(imageUrl);
            }
            alert('æ¢è£…æˆåŠŸï¼äººç‰©è¡£æœå·²æ›´æ–°');
        }

        // æ˜¾ç¤ºæˆåŠŸæç¤ºï¼ˆå›¾ç”Ÿå›¾æ¨¡å¼å·²ç»æœ‰ä¸“é—¨æç¤ºï¼Œè¿™é‡Œåªæç¤ºå…¶ä»–æƒ…å†µï¼‰
        if (wardrobeGenerateType === 'character' || !referenceImageBase64) {
            alert('å›¾ç‰‡ç”ŸæˆæˆåŠŸï¼');
        }
        closeWardrobeGenerateModal();

    } catch (error) {
        console.error('ç”Ÿæˆå›¾ç‰‡å¤±è´¥:', error);
        alert('ç”Ÿæˆå¤±è´¥: ' + error.message);
    } finally {
        loadingDiv.style.display = 'none';
        confirmBtn.disabled = false;
        confirmBtn.textContent = 'ç”Ÿæˆ';
    }
}

// è¡£æŸœTabåˆ‡æ¢å‡½æ•°
function switchWardrobeTab(category, element) {
    // æ›´æ–°Tabæ ·å¼
    document.querySelectorAll('.wardrobe-tab-item').forEach(tab => {
        tab.classList.remove('active');
        tab.style.color = '#999';
        tab.style.fontWeight = 'normal';
        const span = tab.querySelector('span');
        if (span) span.remove();
    });
    element.classList.add('active');
    element.style.color = '#333';
    element.style.fontWeight = 'bold';
    const indicator = document.createElement('span');
    indicator.style.cssText = 'position:absolute; bottom:0; left:50%; transform:translateX(-50%); width:20px; height:3px; background:#d4a5ff; border-radius:3px;';
    element.appendChild(indicator);

    // æ›´æ–°åˆ—è¡¨æ˜¾ç¤º
    document.querySelectorAll('.wardrobe-list').forEach(list => {
        list.style.display = 'none';
    });
    const targetList = document.getElementById('wardrobe-list-' + category);
    if (targetList) {
        targetList.style.display = 'flex';
    }
}

// å°†å›¾ç‰‡URLè½¬æ¢ä¸ºbase64
async function imageToBase64(imageUrl) {
    return new Promise((resolve, reject) => {
        // å¦‚æœå·²ç»æ˜¯ base64ï¼Œç›´æ¥è¿”å›
        if (imageUrl.startsWith('data:')) {
            resolve(imageUrl);
            return;
        }
        
        // å¦‚æœæ˜¯ blob URLï¼Œéœ€è¦å…ˆè½¬æ¢
        if (imageUrl.startsWith('blob:')) {
            fetch(imageUrl)
                .then(response => response.blob())
                .then(blob => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                })
                .catch(reject);
            return;
        }
        
        // æ™®é€š URLï¼Œä½¿ç”¨ canvas è½¬æ¢
        const img = new Image();
        img.crossOrigin = 'anonymous'; // è§£å†³è·¨åŸŸé—®é¢˜
        img.onload = () => {
            try {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                const base64 = canvas.toDataURL('image/png');
                resolve(base64);
            } catch (e) {
                reject(e);
            }
        };
        img.onerror = reject;
        img.src = imageUrl;
    });
}

// ğŸ”§ å°†å›¾ç‰‡è½¬æ¢ä¸º AI API å…¼å®¹æ ¼å¼ï¼ˆJPEGï¼‰
// è§£å†³ Gemini ç­‰ API ä¸æ”¯æŒ image/avifã€image/webp ç­‰æ ¼å¼çš„é—®é¢˜
function convertImageForAI(dataUrl) {
    return new Promise((resolve, reject) => {
        // å¦‚æœä¸æ˜¯ data URLï¼Œç›´æ¥è¿”å›
        if (!dataUrl || !dataUrl.startsWith('data:image')) {
            resolve(dataUrl);
            return;
        }
        
        // æ£€æŸ¥ MIME ç±»å‹ï¼Œåªæœ‰ JPEG å’Œ PNG æ˜¯æ‰€æœ‰ API éƒ½å¯é æ”¯æŒçš„
        const mimeMatch = dataUrl.match(/^data:(image\/[^;]+);/);
        if (mimeMatch) {
            const mime = mimeMatch[1].toLowerCase();
            // åªæ”¾è¡Œ JPEG å’Œ PNGï¼Œå…¶ä»–æ‰€æœ‰æ ¼å¼éƒ½è½¬æ¢ï¼ˆåŒ…æ‹¬ GIFã€AVIFã€WEBPã€BMP ç­‰ï¼‰
            if (mime === 'image/jpeg' || mime === 'image/png') {
                resolve(dataUrl);
                return;
            }
        }
        
        // éœ€è¦è½¬æ¢ï¼šgifã€avifã€webpã€bmp ç­‰æ ¼å¼ â†’ JPEG
        console.log('[convertImageForAI] æ£€æµ‹åˆ°éœ€è¦è½¬æ¢çš„å›¾ç‰‡æ ¼å¼:', mimeMatch?.[1] || 'æœªçŸ¥', 'â†’ JPEG');
        const img = new Image();
        img.onload = () => {
            try {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                // å¡«å……ç™½è‰²èƒŒæ™¯ï¼ˆé˜²æ­¢é€æ˜é€šé“åœ¨ JPEG ä¸­å˜é»‘ï¼‰
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
                const jpegDataUrl = canvas.toDataURL('image/jpeg', 0.85);
                console.log('[convertImageForAI] âœ… å›¾ç‰‡å·²è½¬æ¢ä¸º JPEGï¼Œå¤§å°:', (jpegDataUrl.length / 1024).toFixed(1), 'KB');
                resolve(jpegDataUrl);
            } catch (e) {
                console.error('[convertImageForAI] âŒ è½¬æ¢å¤±è´¥ï¼Œä½¿ç”¨åŸå§‹æ ¼å¼:', e);
                resolve(dataUrl); // è½¬æ¢å¤±è´¥æ—¶å›é€€åˆ°åŸå§‹æ•°æ®
            }
        };
        img.onerror = () => {
            console.error('[convertImageForAI] âŒ å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨åŸå§‹æ ¼å¼');
            resolve(dataUrl); // åŠ è½½å¤±è´¥æ—¶å›é€€
        };
        img.src = dataUrl;
    });
}

// ğŸ”§ å°† HTTP å›¾ç‰‡ URL è½¬æ¢ä¸º base64 data URLï¼ˆç”¨äº AI API å…¼å®¹ï¼‰
// Gemini ç­‰ API ä¸æ”¯æŒç›´æ¥ä¼ é€’å¤–éƒ¨ HTTP å›¾ç‰‡é“¾æ¥ï¼Œéœ€è¦è½¬æˆ base64
function convertHttpImageToBase64(httpUrl) {
    return new Promise((resolve, reject) => {
        if (!httpUrl || !httpUrl.startsWith('http')) {
            resolve(httpUrl);
            return;
        }
        console.log('[convertHttpImageToBase64] å¼€å§‹è½¬æ¢ HTTP å›¾ç‰‡:', httpUrl.substring(0, 80) + '...');
        const img = new Image();
        img.crossOrigin = 'anonymous'; // å…è®¸è·¨åŸŸ
        img.onload = () => {
            try {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
                const dataUrl = canvas.toDataURL('image/jpeg', 0.85);
                console.log('[convertHttpImageToBase64] âœ… å·²è½¬æ¢ä¸º base64ï¼Œå¤§å°:', (dataUrl.length / 1024).toFixed(1), 'KB');
                resolve(dataUrl);
            } catch (e) {
                console.warn('[convertHttpImageToBase64] âŒ Canvas è½¬æ¢å¤±è´¥ï¼ˆå¯èƒ½è·¨åŸŸï¼‰:', e.message);
                resolve(httpUrl); // è½¬æ¢å¤±è´¥å›é€€åˆ°åŸå§‹ URL
            }
        };
        img.onerror = () => {
            console.warn('[convertHttpImageToBase64] âŒ å›¾ç‰‡åŠ è½½å¤±è´¥:', httpUrl.substring(0, 80));
            resolve(httpUrl); // åŠ è½½å¤±è´¥å›é€€
        };
        img.src = httpUrl;
    });
}

// ä¿å­˜è¡£æŸœäººç‰©å½¢è±¡åˆ° Dexie
async function saveWardrobeCharacter(imageUrl) {
    try {
        await db.dexiData.put({ key: 'wardrobeCharacter', value: imageUrl });
        // åŒæ—¶ä¿å­˜å½“å‰é€‰æ‹©çš„æ€§åˆ«ï¼Œæ¢è£…æ—¶éœ€è¦ç”¨åˆ°
        await db.dexiData.put({ key: 'wardrobeCharacterGender', value: wardrobeGender });
        console.log('äººç‰©å½¢è±¡å·²ä¿å­˜ï¼Œæ€§åˆ«:', wardrobeGender);
    } catch (error) {
        console.error('ä¿å­˜äººç‰©å½¢è±¡å¤±è´¥:', error);
    }
}

// åŠ è½½è¡£æŸœäººç‰©å½¢è±¡
async function loadWardrobeCharacter() {
    try {
        const item = await db.dexiData.get('wardrobeCharacter');
        const genderItem = await db.dexiData.get('wardrobeCharacterGender');
        
        if (item && item.value) {
            const charImg = document.getElementById('wardrobe-char-base');
            if (charImg) {
                charImg.src = item.value;
                console.log('äººç‰©å½¢è±¡å·²åŠ è½½');
            }
        }
        
        // æ¢å¤æ€§åˆ«è®¾ç½®
        if (genderItem && genderItem.value) {
            wardrobeGender = genderItem.value;
            console.log('äººç‰©æ€§åˆ«å·²æ¢å¤:', wardrobeGender);
        }
    } catch (error) {
        console.error('åŠ è½½äººç‰©å½¢è±¡å¤±è´¥:', error);
    }
}

// ä»ZIPæ–‡ä»¶ä¸­æå–å›¾ç‰‡
async function extractImageFromZip(zipBlob) {
    // æ£€æŸ¥æ˜¯å¦æœ‰JSZipåº“
    if (typeof JSZip === 'undefined') {
        // å¦‚æœæ²¡æœ‰JSZipï¼Œå°è¯•ç›´æ¥è¯»å–ä¸ºå›¾ç‰‡
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(zipBlob);
        });
    }
    
    try {
        const zip = await JSZip.loadAsync(zipBlob);
        let imageFile = null;
        
        // æŸ¥æ‰¾ç¬¬ä¸€ä¸ªå›¾ç‰‡æ–‡ä»¶
        for (const filename in zip.files) {
            if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
                imageFile = zip.files[filename];
                break;
            }
        }
        
        if (!imageFile) {
            throw new Error('ZIPæ–‡ä»¶ä¸­æœªæ‰¾åˆ°å›¾ç‰‡');
        }
        
        const imageBlob = await imageFile.async('blob');
        
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(imageBlob);
        });
    } catch (error) {
        console.error('è§£å‹ZIPå¤±è´¥:', error);
        // é™çº§å¤„ç†ï¼šç›´æ¥ä½œä¸ºå›¾ç‰‡è¯»å–
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(zipBlob);
        });
    }
}

// æ·»åŠ è¡£æœé¡¹åˆ°åˆ—è¡¨
function addWardrobeClothesItem(category, imageUrl, name) {
    const listId = 'wardrobe-list-' + category;
    const list = document.getElementById(listId);
    if (!list) return;

    const item = document.createElement('div');
    item.className = 'wardrobe-clothes-item';
    item.style.cssText = 'display:inline-block; flex-shrink:0; width:90px; height:110px; border:1px solid #f0f0f0; border-radius:12px; margin-right:12px; background:#fff; cursor:pointer; text-align:center; padding:6px; transition:all 0.2s;';
    item.innerHTML = `
        <img src="${imageUrl}" alt="${name}" style="width:100%; height:75px; object-fit:contain; margin-bottom:5px;">
        <div class="wardrobe-clothes-name" style="font-size:11px; color:#888; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${name.substring(0, 10)}${name.length > 10 ? '...' : ''}</div>
    `;
    item.onmouseenter = function() {
        this.style.borderColor = '#e0b0ff';
        this.style.background = '#faf4ff';
        this.style.transform = 'translateY(-2px)';
    };
    item.onmouseleave = function() {
        this.style.borderColor = '#f0f0f0';
        this.style.background = '#fff';
        this.style.transform = 'translateY(0)';
    };
    list.appendChild(item);
}

async function showCalendarPage() {
    if (!currentChatCharId) {
        alert("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠå¤©å¯¹è±¡");
        return;
    }
    
    closeChatPanel();
    document.getElementById('calendar-page').style.display = 'flex';
    
    // åˆå§‹åŒ–æ—¥å† DOM ç»‘å®š
    calendar.init();
    
    // è·å–è§’è‰²æ—¶é—´
    const char = await db.characters.get(currentChatCharId);
    const isVirtual = isVirtualTimeEnabled(char);
    if (calendar.elements.timeModeToggle) {
        calendar.elements.timeModeToggle.checked = isVirtual;
    }
    
    calendar.applyTimeMode(isVirtual, char?.timeOffset || 0);
}

function hideCalendarPage() {
    document.getElementById('calendar-page').style.display = 'none';
}

async function saveCalendarTime() {
    if (!currentChatCharId) return;
    
    // ä» calendar å¯¹è±¡è·å–æœ€ç»ˆæ—¶é—´
    const char = await db.characters.get(currentChatCharId);
    if (!char) return;
    
    const useVirtual = calendar.elements.timeModeToggle ? calendar.elements.timeModeToggle.checked : false;
    
    if (useVirtual) {
        const targetTime = calendar.selectedDate.getTime();
        const now = Date.now();
        const offset = targetTime - now;
        char.timeOffset = offset;
        char.timeOffsetEnabled = true;
    } else {
        char.timeOffsetEnabled = false;
    }
    
    await safeCharacterPut(char);
    
    hideCalendarPage();
    alert(useVirtual ? "æ—¶é—´è®¾å®šå·²æ›´æ–°" : "å·²åˆ‡æ¢ä¸ºç°å®æ—¶é—´");
}

function isVirtualTimeEnabled(char) {
    // ğŸ”§ é»˜è®¤å…³é—­è™šæ‹Ÿæ—¶é—´ï¼ˆä½¿ç”¨ç°å®æ—¶é—´ï¼‰ï¼Œç”¨æˆ·æ‰‹åŠ¨å¼€å¯åæ‰ç”Ÿæ•ˆ
    return char ? char.timeOffsetEnabled === true : false;
}

function getEffectiveTimeOffset(char) {
    if (!char) return 0;
    return isVirtualTimeEnabled(char) ? (char.timeOffset || 0) : 0;
}

function markUserAvatarChanged(userChar) {
    if (!userChar) return;
    userChar.avatarUpdatedAt = Date.now();
    console.log(`[AvatarChange] âœ… æ ‡è®°ç”¨æˆ·å¤´åƒå·²æ›´æ¢, avatarUpdatedAt=${userChar.avatarUpdatedAt}, charId=${userChar.id}`);
}

function getUserAvatarChangeNotice(char, accountId, userChar) {
    if (!char || !userChar) return '';
    const changedAt = userChar.avatarUpdatedAt || 0;
    if (!changedAt) {
        console.log(`[AvatarChange] â„¹ï¸ ç”¨æˆ·æœªæ¢è¿‡å¤´åƒ (avatarUpdatedAtä¸ºç©º), charId=${char.id}`);
        return '';
    }
    
    const key = accountId ? String(accountId) : 'default';
    if (!char.userAvatarNoticeMap) char.userAvatarNoticeMap = {};
    const lastNotified = char.userAvatarNoticeMap[key] || 0;
    
    console.log(`[AvatarChange] æ£€æŸ¥å¤´åƒé€šçŸ¥: charId=${char.id}, changedAt=${changedAt}, lastNotified=${lastNotified}, shouldNotify=${changedAt > lastNotified}`);
    
    if (changedAt > lastNotified) {
        char.userAvatarNoticeMap[key] = changedAt;
        const userName = userChar.nick || userChar.name || 'å¯¹æ–¹';
        console.log(`[AvatarChange] âœ… ç”Ÿæˆå¤´åƒæ›´æ¢é€šçŸ¥ç»™è§’è‰² ${char.name}(${char.id})`);
        return `\n\nã€å¤´åƒæ›´æ–°ã€‘\n${userName}åˆšåˆšæ›´æ¢äº†å¤´åƒã€‚ä½ å·²ç»æ³¨æ„åˆ°ï¼Œå¯ä»¥è‡ªç„¶åœ°æä¸€å¥æˆ–é—®é—®åŸå› ã€‚`;
    }
    
    console.log(`[AvatarChange] â­ï¸ è§’è‰² ${char.name}(${char.id}) å·²é€šçŸ¥è¿‡æ­¤æ¬¡å¤´åƒæ›´æ¢ï¼Œè·³è¿‡`);
    return '';
}

// è¾…åŠ©å‡½æ•°ï¼šè·å–æ ¼å¼åŒ–çš„è™šæ‹Ÿæ—¶é—´å­—ç¬¦ä¸²
function getFormattedVirtualTime(offsetOrChar) {
    const offset = (typeof offsetOrChar === 'object' && offsetOrChar !== null)
        ? getEffectiveTimeOffset(offsetOrChar)
        : (offsetOrChar || 0);
    const now = Date.now();
    const virtualNow = new Date(now + offset);
    
    const year = virtualNow.getFullYear();
    const month = virtualNow.getMonth() + 1;
    const day = virtualNow.getDate();
    const hours = virtualNow.getHours().toString().padStart(2, '0');
    const mins = virtualNow.getMinutes().toString().padStart(2, '0');
    const weekDays = ['å‘¨æ—¥', 'å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­'];
    const week = weekDays[virtualNow.getDay()];
    
    return `${year}å¹´${month}æœˆ${day}æ—¥ ${hours}:${mins} (${week})`;
}

// è¾…åŠ©å‡½æ•°ï¼šè·å–è§’è‰²å’Œç”¨æˆ·æœ€è¿‘çš„æœ‹å‹åœˆåŠ¨æ€ï¼Œç”¨äºæ³¨å…¥AIèŠå¤©ä¸Šä¸‹æ–‡
async function getRecentMomentsContext(charId, accountId, maxCount = 10) {
    try {
        if (!charId || !accountId) return '';

        const allMoments = await db.moments.toArray();
        const charIdNum = parseInt(charId);
        const accountIdNum = parseInt(accountId);

        // è·å–è§’è‰²ï¼ˆNPCï¼‰è‡ªå·±å‘çš„æœ‹å‹åœˆ
        const charMoments = allMoments
            .filter(m => parseInt(m.userId) === charIdNum)
            .sort((a, b) => (b.time || 0) - (a.time || 0))
            .slice(0, maxCount);

        // è·å–ç”¨æˆ·å‘çš„æœ‹å‹åœˆ
        const userMoments = allMoments
            .filter(m => parseInt(m.userId) === accountIdNum)
            .sort((a, b) => (b.time || 0) - (a.time || 0))
            .slice(0, maxCount);

        if (charMoments.length === 0 && userMoments.length === 0) return '';

        const formatMoment = (m) => {
            const t = m.time ? new Date(m.time).toLocaleString('zh-CN', {
                month: 'numeric', day: 'numeric', hour: '2-digit', minute: '2-digit'
            }) : 'æœªçŸ¥æ—¶é—´';
            let text = m.content || 'ï¼ˆæ— æ–‡å­—ï¼‰';
            let imgInfo = '';
            if (m.images && m.images.length > 0) imgInfo = `ï¼ˆé™„${m.images.length}å¼ å›¾ï¼‰`;
            // ç‚¹èµå’Œè¯„è®ºæ‘˜è¦
            let interaction = '';
            if (m.likes && m.likes.length > 0) {
                const likeNames = m.likes.map(l => typeof l === 'string' ? l : (l.name || '')).filter(Boolean).slice(0, 5).join('ã€');
                interaction += ` [${m.likes.length}äººç‚¹èµ${likeNames ? 'ï¼š' + likeNames : ''}]`;
            }
            if (m.comments && m.comments.length > 0) {
                const commentPreview = m.comments.slice(0, 3).map(c => {
                    const cName = c.name || 'å¥½å‹';
                    const cText = (c.text || c.content || '').slice(0, 20);
                    return `${cName}: ${cText}`;
                }).join('ï¼›');
                interaction += ` [${m.comments.length}æ¡è¯„è®ºï¼š${commentPreview}]`;
            }
            return `  [${t}] ${text}${imgInfo}${interaction}`;
        };

        let context = '\n\n## æœ‹å‹åœˆåŠ¨æ€\n';
        context += 'ä»¥ä¸‹æ˜¯ä½ å’Œå¯¹æ–¹æœ€è¿‘çš„æœ‹å‹åœˆï¼Œä½ å¯ä»¥è‡ªç„¶åœ°åœ¨èŠå¤©ä¸­æåˆ°æˆ–å›åº”è¿™äº›å†…å®¹ã€‚\n';

        if (charMoments.length > 0) {
            context += `\nã€ä½ è‡ªå·±æœ€è¿‘å‘çš„æœ‹å‹åœˆã€‘\n`;
            charMoments.forEach(m => { context += formatMoment(m) + '\n'; });
        }
        if (userMoments.length > 0) {
            context += `\nã€å¯¹æ–¹æœ€è¿‘å‘çš„æœ‹å‹åœˆã€‘\n`;
            userMoments.forEach(m => { context += formatMoment(m) + '\n'; });
        }

        return context;
    } catch (e) {
        console.warn('[getRecentMomentsContext] è·å–æœ‹å‹åœˆä¸Šä¸‹æ–‡å¤±è´¥:', e);
        return '';
    }
}

// --- App Store é€»è¾‘ ---
// åº”ç”¨å®‰è£…çŠ¶æ€ç®¡ç†
// icity Dexie æ•°æ®åº“åˆå§‹åŒ–ï¼ˆæ— é™å®¹é‡ï¼‰
const icityDb = new Dexie('IcityDB');
icityDb.version(1).stores({
    diaries: '++id, content, time, roleName, wechatId, avatarUrl, isUserPublished, createdAt',
    annotations: '++id, diaryId, text, comment, createdAt'
});
// ç‰ˆæœ¬2ï¼šæ·»åŠ  accountId å­—æ®µç”¨äºè´¦å·æ•°æ®éš”ç¦»
icityDb.version(2).stores({
    diaries: '++id, content, time, roleName, wechatId, avatarUrl, isUserPublished, createdAt, accountId',
    annotations: '++id, diaryId, text, comment, createdAt, accountId'
});

const installedAppsDb = new Dexie('InstalledAppsDB');
installedAppsDb.version(1).stores({
    apps: 'appId, installed, installDate'
});

// æ£€æŸ¥åº”ç”¨æ˜¯å¦å·²å®‰è£…
async function isAppInstalled(appId) {
    try {
        const app = await installedAppsDb.apps.get(appId);
        return app ? app.installed : false;
    } catch (error) {
        console.error('æ£€æŸ¥åº”ç”¨å®‰è£…çŠ¶æ€å¤±è´¥:', error);
        return false;
    }
}

// å®‰è£…åº”ç”¨
async function installApp(appId, desktopIconId, showFunction) {
    try {
        await installedAppsDb.apps.put({
            appId: appId,
            installed: true,
            installDate: new Date()
        });
        
        // æ˜¾ç¤ºæ¡Œé¢å›¾æ ‡
        if (desktopIconId) {
            const icon = document.getElementById(desktopIconId);
            if (icon) {
                icon.style.display = 'flex';
            }
        }
        
        // ä¿å­˜åˆ° localStorage ä½œä¸ºå¤‡ä»½
        const installedApps = JSON.parse(localStorage.getItem('installedApps') || '{}');
        installedApps[appId] = {
            installed: true,
            installDate: new Date().toISOString(),
            desktopIconId: desktopIconId,
            showFunction: showFunction
        };
        safeLocalStorageSet('installedApps', JSON.stringify(installedApps));
        
        return true;
    } catch (error) {
        console.error('å®‰è£…åº”ç”¨å¤±è´¥:', error);
        return false;
    }
}

// å¸è½½åº”ç”¨
async function uninstallApp(appId, desktopIconId) {
    try {
        await installedAppsDb.apps.delete(appId);
        
        // éšè—æ¡Œé¢å›¾æ ‡
        if (desktopIconId) {
            const icon = document.getElementById(desktopIconId);
            if (icon) {
                icon.style.display = 'none';
            }
        }
        
        // ä» localStorage åˆ é™¤
        const installedApps = JSON.parse(localStorage.getItem('installedApps') || '{}');
        delete installedApps[appId];
        safeLocalStorageSet('installedApps', JSON.stringify(installedApps));
        
        return true;
    } catch (error) {
        console.error('å¸è½½åº”ç”¨å¤±è´¥:', error);
        return false;
    }
}

// åˆå§‹åŒ–å·²å®‰è£…åº”ç”¨çš„æ¡Œé¢å›¾æ ‡æ˜¾ç¤º
async function initInstalledApps() {
    try {
        // ğŸ”¥ é»˜è®¤é¢„è£…åº”ç”¨ï¼šç½‘æ˜“äº‘éŸ³ä¹ï¼ˆæ¡Œé¢é»˜è®¤æ˜¾ç¤ºï¼Œç¡®ä¿æ•°æ®åº“ä¸­ä¹Ÿæ ‡è®°ä¸ºå·²å®‰è£…ï¼‰
        const defaultApps = [
            { appId: 'netease-music', desktopIconId: 'icon-photo', showFunction: 'showMusicAppPage' }
        ];
        for (const defApp of defaultApps) {
            const existing = await installedAppsDb.apps.get(defApp.appId);
            if (!existing) {
                await installedAppsDb.apps.put({
                    appId: defApp.appId,
                    installed: true,
                    installDate: new Date()
                });
            }
        }
        
        // ä» IndexedDB åŠ è½½
        const installedApps = await installedAppsDb.apps.toArray();
        installedApps.forEach(app => {
            if (app.installed) {
                // ä»åº”ç”¨å•†åº—æ•°æ®ä¸­æ‰¾åˆ°å¯¹åº”çš„åº”ç”¨
                const allApps = [...appStoreData.today, ...appStoreData.games, ...appStoreData.apps, ...appStoreData.updates];
                const appData = allApps.find(a => a.appId === app.appId);
                if (appData && appData.desktopIconId) {
                    const icon = document.getElementById(appData.desktopIconId);
                    if (icon) {
                        icon.style.display = 'flex';
                    }
                }
            }
        });
        
        // ä» localStorage æ¢å¤ï¼ˆå…¼å®¹æ—§æ•°æ®ï¼‰
        const localApps = JSON.parse(localStorage.getItem('installedApps') || '{}');
        Object.keys(localApps).forEach(appId => {
            const appInfo = localApps[appId];
            if (appInfo.installed && appInfo.desktopIconId) {
                const icon = document.getElementById(appInfo.desktopIconId);
                if (icon) {
                    icon.style.display = 'flex';
                }
                // åŒæ­¥åˆ° IndexedDB
                installedAppsDb.apps.put({
                    appId: appId,
                    installed: true,
                    installDate: appInfo.installDate ? new Date(appInfo.installDate) : new Date()
                });
            }
        });
    } catch (error) {
        console.error('åˆå§‹åŒ–å·²å®‰è£…åº”ç”¨å¤±è´¥:', error);
    }
}

// ä¸‹è½½/å®‰è£…åº”ç”¨
async function downloadApp(appId) {
    const allApps = [...appStoreData.today, ...appStoreData.games, ...appStoreData.apps, ...appStoreData.updates];
    const app = allApps.find(a => a.appId === appId);
    
    if (!app) {
        alert('åº”ç”¨ä¸å­˜åœ¨');
        return;
    }
    
    // æ£€æŸ¥æ˜¯å¦å·²å®‰è£…
    const isInstalled = await isAppInstalled(appId);
    if (isInstalled) {
        // å¦‚æœå·²å®‰è£…ï¼Œç›´æ¥æ‰“å¼€åº”ç”¨
        if (app.showFunction && typeof window[app.showFunction] === 'function') {
            window[app.showFunction]();
            hideAppStorePage();
        }
        return;
    }
    
    // æ˜¾ç¤ºä¸‹è½½è¿›åº¦
    showToast('æ­£åœ¨ä¸‹è½½ ' + app.name + '...', 2000);
    
    // æ¨¡æ‹Ÿä¸‹è½½è¿‡ç¨‹
    setTimeout(async () => {
        const success = await installApp(appId, app.desktopIconId, app.showFunction);
        if (success) {
            showToast(app.name + ' å·²å®‰è£…', 2000);
            // åˆ·æ–°åº”ç”¨å•†åº—æ˜¾ç¤º
            const activeTab = document.querySelector('.appstore-tab.active');
            if (activeTab) {
                switchAppStoreTab(activeTab.dataset.tab);
            }
        } else {
            showToast('å®‰è£…å¤±è´¥ï¼Œè¯·é‡è¯•', 2000);
        }
    }, 1500);
}

function showAppStorePage() {
    document.getElementById('appstore-page').style.display = 'flex';
    switchAppStoreTab('today');
}

function hideAppStorePage() {
    const page = document.getElementById('appstore-page');
    if (page) {
        page.style.display = 'none';
    }
}

function showMusicAppPage() {
    document.getElementById('musicAppPage').classList.add('active');
}

function closeMusicApp() {
    document.getElementById('musicAppPage').classList.remove('active');
}

// ç½‘æ˜“äº‘éŸ³ä¹æ’­æ”¾å™¨åŠŸèƒ½
// ============================================

// åˆå§‹åŒ–éŸ³ä¹æ’­æ”¾å™¨Dexieæ•°æ®åº“
const wyyDb = new Dexie('WYYMusicPlayerDB');
wyyDb.version(1).stores({
    userSettings: 'id',
    playlistCards: 'id',
    songs: '++id, name, singer, dateAdded',
    songFiles: '++id, songId, type, data',
    lyrics: '++id, songId, data'
});
wyyDb.version(2).stores({
    userSettings: 'id',
    playlistCards: 'id',
    songs: '++id, name, singer, dateAdded, playlistId',
    songFiles: '++id, songId, type, data',
    lyrics: '++id, songId, data',
    playlists: '++id, name, desc, cover, dateCreated'
});

// éŸ³ä¹æ’­æ”¾å™¨å…ƒç´ 
const wyyPlayBtn = document.getElementById('wyyPlayBtn');
const wyyPlayerPlayBtn = document.getElementById('wyyPlayerPlayBtn');
const wyyRecordCover = document.getElementById('wyyRecordCover');
const wyyCurrentRecordContainer = document.getElementById('wyyCurrentRecordContainer');
const wyyAlbumArtLarge = document.getElementById('wyyAlbumArtLarge');
const wyyCurrentSongName = document.getElementById('wyyCurrentSongName');
const wyyCurrentSingerName = document.getElementById('wyyCurrentSingerName');
const wyyPlayerSongName = document.getElementById('wyyPlayerSongName');
const wyyPlayerSingerName = document.getElementById('wyyPlayerSingerName');
const wyyPlaylistBtn = document.getElementById('wyyPlaylistBtn');
const wyyPlaylistModal = document.getElementById('wyyPlaylistModal');
const wyySongsList = document.getElementById('wyySongsList');
const wyyEmptyPlaylist = document.getElementById('wyyEmptyPlaylist');
const wyyAddSongBtn = document.getElementById('wyyAddSongBtn');
const wyyClearAllBtn = document.getElementById('wyyClearAllBtn');
const wyyProgressBar = document.getElementById('wyyProgressBar');
const wyyProgress = document.getElementById('wyyProgress');
const wyyCurrentTime = document.getElementById('wyyCurrentTime');
const wyyTotalTime = document.getElementById('wyyTotalTime');
const wyyPrevBtn = document.getElementById('wyyPrevBtn');
const wyyNextBtn = document.getElementById('wyyNextBtn');
const wyyPlayBar = document.getElementById('wyyPlayBar');
const wyyBackBtn = document.getElementById('wyyBackBtn');
const wyyMainPage = document.getElementById('wyyMainPage');
const wyyPlayerPage = document.getElementById('wyyPlayerPage');

// æ­Œæ›²è¾“å…¥å…ƒç´ 
const wyySongNameInput = document.getElementById('wyySongNameInput');
const wyySingerNameInput = document.getElementById('wyySingerNameInput');
const wyySongUrlInput = document.getElementById('wyySongUrlInput');
const wyyLyricUrlInput = document.getElementById('wyyLyricUrlInput');

// ä¸Šä¼ é€‰é¡¹æŒ‰é’®
const wyyUrlOptionBtn = document.getElementById('wyyUrlOptionBtn');
const wyyFileOptionBtn = document.getElementById('wyyFileOptionBtn');
const wyyUrlUploadSection = document.getElementById('wyyUrlUploadSection');
const wyyFileUploadSection = document.getElementById('wyyFileUploadSection');

const wyyLyricUrlOptionBtn = document.getElementById('wyyLyricUrlOptionBtn');
const wyyLyricFileOptionBtn = document.getElementById('wyyLyricFileOptionBtn');
const wyyLyricUrlUploadSection = document.getElementById('wyyLyricUrlUploadSection');
const wyyLyricFileUploadSection = document.getElementById('wyyLyricFileUploadSection');

// æ–‡ä»¶ä¸Šä¼ æŒ‰é’®
const wyyUploadCoverBtn = document.getElementById('wyyUploadCoverBtn');
const wyyCoverFileInput = document.getElementById('wyyCoverFileInput');
const wyySongCoverPreview = document.getElementById('wyySongCoverPreview');
const wyyUploadSongFileBtn = document.getElementById('wyyUploadSongFileBtn');
const wyySongFileInput = document.getElementById('wyySongFileInput');
const wyyUploadLyricFileBtn = document.getElementById('wyyUploadLyricFileBtn');
const wyyLyricFileInput = document.getElementById('wyyLyricFileInput');

let wyyAudio = null;
let wyyProgressUpdateInterval = null;

// æ’­æ”¾åˆ—è¡¨æ•°æ®
let wyyPlaylist = [];
let wyyCurrentSongIndex = 0;
let wyyCurrentPlaylistId = null; // å½“å‰é€‰ä¸­çš„æ­Œå•ID

// æ’­æ”¾æ¨¡å¼ï¼š'order' é¡ºåºæ’­æ”¾, 'single' å•æ›²å¾ªç¯
let wyyPlayMode = 'order';

// æ­Œè¯æ˜¾ç¤ºçŠ¶æ€ï¼šfalse æ˜¾ç¤ºå°é¢, true æ˜¾ç¤ºæ­Œè¯
let wyyShowLyrics = false;

// å½“å‰æ­Œè¯æ•°æ®
let wyyCurrentLyrics = [];

// ä¸´æ—¶å­˜å‚¨ä¸Šä¼ çš„æ–‡ä»¶
let wyyTempSongCover = null;
let wyyTempSongFile = null;
let wyyTempLyricFile = null;

// é¡µé¢åˆ‡æ¢åŠŸèƒ½
if (wyyPlayBar) {
    wyyPlayBar.addEventListener('click', (e) => {
        if (!e.target.closest('.wyy-play-controls')) {
            wyyMainPage.classList.remove('active');
            wyyPlayerPage.classList.add('active');
            wyyUpdatePlayerPage();
        }
    });
}

if (wyyBackBtn) {
    wyyBackBtn.addEventListener('click', () => {
        wyyPlayerPage.classList.remove('active');
        wyyMainPage.classList.add('active');
    });
}

// åˆå§‹åŒ–æ’­æ”¾åˆ—è¡¨
async function wyyInitPlaylist() {
    try {
        let songs;
        if (wyyCurrentPlaylistId) {
            // åŠ è½½æŒ‡å®šæ­Œå•çš„æ­Œæ›²
            songs = await wyyDb.songs.where('playlistId').equals(wyyCurrentPlaylistId).toArray();
            // åœ¨å†…å­˜ä¸­æŒ‰æ—¥æœŸæ’åº
            songs.sort((a, b) => {
                const dateA = a.dateAdded ? new Date(a.dateAdded).getTime() : 0;
                const dateB = b.dateAdded ? new Date(b.dateAdded).getTime() : 0;
                return dateA - dateB;
            });
        } else {
            // å¦‚æœæ²¡æœ‰é€‰ä¸­æ­Œå•ï¼ŒåŠ è½½æ‰€æœ‰æ­Œæ›²ï¼ˆå…¼å®¹æ—§æ•°æ®ï¼‰
            songs = await wyyDb.songs.orderBy('dateAdded').toArray();
        }
        
        if (songs.length > 0) {
            wyyPlaylist = songs;
            
            // åŠ è½½æ¯é¦–æ­Œæ›²çš„æ–‡ä»¶æ•°æ®
            for (let i = 0; i < wyyPlaylist.length; i++) {
                const song = wyyPlaylist[i];
                
                // åŠ è½½æ­Œæ›²æ–‡ä»¶
                const songFile = await wyyDb.songFiles.where({ songId: song.id }).first();
                if (songFile) {
                    song.hasLocalFile = true;
                    song.localFileData = songFile.data;
                    song.fileType = songFile.type;
                }
                
                // åŠ è½½æ­Œè¯æ–‡ä»¶
                const lyric = await wyyDb.lyrics.where({ songId: song.id }).first();
                if (lyric) {
                    song.hasLocalLyric = true;
                    song.localLyricData = lyric.data;
                }
            }
            
            wyyUpdatePlaylistDisplay();
        } else {
            // ç©ºæ­Œå•
            wyyPlaylist = [];
            wyyUpdatePlaylistDisplay();
        }
        
        // è®¾ç½®å½“å‰æ’­æ”¾çš„æ­Œæ›²
        if (wyyPlaylist.length > 0) {
            await wyyLoadSong(wyyCurrentSongIndex);
        }
    } catch (error) {
        console.error('åˆå§‹åŒ–æ’­æ”¾åˆ—è¡¨å¤±è´¥:', error);
    }
}

// æ›´æ–°æ’­æ”¾åˆ—è¡¨æ˜¾ç¤º
function wyyUpdatePlaylistDisplay() {
    if (!wyySongsList) return;
    
    if (wyyPlaylist.length === 0) {
        if (wyyEmptyPlaylist) wyyEmptyPlaylist.style.display = 'block';
        wyySongsList.innerHTML = '<div class="wyy-empty-playlist">æš‚æ— æ­Œæ›²ï¼Œè¯·æ·»åŠ æ­Œæ›²</div>';
        return;
    }
    
    if (wyyEmptyPlaylist) wyyEmptyPlaylist.style.display = 'none';
    
    let songsHTML = '';
    wyyPlaylist.forEach((song, index) => {
        const isActive = index === wyyCurrentSongIndex;
        const hasCover = song.cover && song.cover !== '';
        songsHTML += `
            <div class="wyy-song-item ${isActive ? 'active' : ''}" data-index="${index}">
                <div class="wyy-song-item-icon ${!hasCover ? 'default' : ''}" style="${hasCover ? `background-image: url(${song.cover})` : ''}">
                    ${!hasCover ? (isActive ? '<i class="fa fa-play"></i>' : (index + 1)) : ''}
                </div>
                <div class="wyy-song-item-info">
                    <div class="wyy-song-item-name">${song.name}</div>
                    <div class="wyy-song-item-singer">${song.singer}</div>
                </div>
                <div class="wyy-song-item-actions" style="display: flex; gap: 5px; align-items: center;">
                    <button class="wyy-song-item-add" data-song-id="${song.id}" title="æ·»åŠ åˆ°æ­Œå•">
                        <i class="fa fa-plus"></i>
                    </button>
                    <button class="wyy-song-item-remove" data-index="${index}">
                        <i class="fa fa-times"></i>
                    </button>
                </div>
            </div>
        `;
    });
    
    wyySongsList.innerHTML = songsHTML;
    
    // æ·»åŠ æ­Œæ›²ç‚¹å‡»äº‹ä»¶
    document.querySelectorAll('.wyy-song-item').forEach(item => {
        item.addEventListener('click', function(e) {
            if (!e.target.closest('.wyy-song-item-remove') && !e.target.closest('.wyy-song-item-add') && !e.target.closest('.wyy-song-item-actions')) {
                const index = parseInt(this.getAttribute('data-index'));
                wyyPlaySong(index);
                if (wyyPlaylistModal) wyyPlaylistModal.style.display = 'none';
            }
        });
    });
    
    // æ·»åŠ "æ·»åŠ åˆ°æ­Œå•"æŒ‰é’®ç‚¹å‡»äº‹ä»¶
    document.querySelectorAll('.wyy-song-item-add').forEach(btn => {
        btn.addEventListener('click', function(e) {
            e.stopPropagation();
            const songId = parseInt(this.getAttribute('data-song-id'));
            wyyShowAddToPlaylistModal(songId);
        });
    });
    
    // æ·»åŠ åˆ é™¤æŒ‰é’®ç‚¹å‡»äº‹ä»¶
    document.querySelectorAll('.wyy-song-item-remove').forEach(btn => {
        btn.addEventListener('click', function(e) {
            e.stopPropagation();
            const index = parseInt(this.getAttribute('data-index'));
            wyyRemoveSong(index);
        });
    });
}

// æ›´æ–°æ’­æ”¾å™¨é¡µé¢
function wyyUpdatePlayerPage() {
    if (wyyPlaylist.length === 0 || wyyCurrentSongIndex >= wyyPlaylist.length) return;
    
    const song = wyyPlaylist[wyyCurrentSongIndex];
    if (wyyPlayerSongName) wyyPlayerSongName.textContent = song.name;
    if (wyyPlayerSingerName) wyyPlayerSingerName.textContent = song.singer;
    
    if (wyyAlbumArtLarge) {
        if (song.cover && song.cover !== '') {
            wyyAlbumArtLarge.style.backgroundImage = `url(${song.cover})`;
        } else {
            wyyAlbumArtLarge.style.backgroundImage = '';
            wyyAlbumArtLarge.style.backgroundColor = '#f5f5f5';
        }
    }
    
    if (wyyAudio) {
        if (wyyTotalTime) wyyTotalTime.textContent = wyyFormatTime(wyyAudio.duration || 299);
        wyyStartProgressUpdate();
    }
    
    // æ›´æ–°æ­Œè¯æ˜¾ç¤ºçŠ¶æ€
    const wyyLyricsContainer = document.getElementById('wyyLyricsContainer');
    if (wyyShowLyrics) {
        if (wyyAlbumArtLarge) wyyAlbumArtLarge.classList.add('hidden');
        if (wyyLyricsContainer) wyyLyricsContainer.classList.add('active');
        wyyUpdateLyricsDisplay();
    } else {
        if (wyyAlbumArtLarge) wyyAlbumArtLarge.classList.remove('hidden');
        if (wyyLyricsContainer) wyyLyricsContainer.classList.remove('active');
    }
}

// æ’­æ”¾æŒ‡å®šç´¢å¼•çš„æ­Œæ›²
async function wyyPlaySong(index) {
    if (index >= 0 && index < wyyPlaylist.length) {
        wyyCurrentSongIndex = index;
        await wyyLoadSong(index);
        wyyPlayCurrentSong();
        wyyUpdatePlaylistDisplay();
        wyyUpdatePlayerPage();
    }
}

// åŠ è½½æ­Œæ›²
async function wyyLoadSong(index) {
    const song = wyyPlaylist[index];
    
    // åœæ­¢å½“å‰æ’­æ”¾
    if (wyyAudio) {
        wyyAudio.pause();
        wyyStopProgressUpdate();
        if (wyyRecordCover) wyyRecordCover.classList.remove('playing');
        if (wyyPlayBtn) wyyPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
        if (wyyPlayerPlayBtn) wyyPlayerPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
        
        // é‡Šæ”¾ä¹‹å‰çš„å¯¹è±¡URL
        if (wyyAudio.src && wyyAudio.src.startsWith('blob:')) {
            URL.revokeObjectURL(wyyAudio.src);
        }
    }
    
    // åˆ›å»ºæ–°çš„éŸ³é¢‘å¯¹è±¡
    try {
        if (song.hasLocalFile && song.localFileData) {
            // å°†Base64è½¬æ¢ä¸ºBlobå¹¶åˆ›å»ºå¯¹è±¡URL
            const audioData = wyyBase64ToBlob(song.localFileData, song.fileType || 'audio/mpeg');
            const audioUrl = URL.createObjectURL(audioData);
            wyyAudio = new Audio(audioUrl);
        } else if (song.url) {
            // å¤„ç†ç½‘æ˜“äº‘éŸ³ä¹URLï¼ˆå¯èƒ½éœ€è¦ç‰¹æ®Šå¤„ç†ï¼‰
            let audioUrl = song.url;
            // å¦‚æœæ˜¯ç½‘æ˜“äº‘çš„å¤–é“¾ï¼Œå°è¯•æ·»åŠ å‚æ•°
            if (audioUrl.includes('music.163.com')) {
                // ç½‘æ˜“äº‘å¤–é“¾å¯èƒ½éœ€è¦ç‰¹æ®Šå¤„ç†
                console.log('æ£€æµ‹åˆ°ç½‘æ˜“äº‘éŸ³ä¹URLï¼Œå¯èƒ½éœ€è¦ç‰¹æ®Šå¤„ç†');
            }
            
            wyyAudio = new Audio(audioUrl);
            // æ·»åŠ è·¨åŸŸæ”¯æŒ
            wyyAudio.crossOrigin = 'anonymous';
            // è®¾ç½®åŠ è½½ç­–ç•¥
            wyyAudio.load();
        } else {
            console.error('æ²¡æœ‰æœ‰æ•ˆçš„æ­Œæ›²æ–‡ä»¶');
            alert('æ— æ³•åŠ è½½æ­Œæ›²æ–‡ä»¶ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼');
            return;
        }
        
        wyyAudio.loop = false;
        wyyAudio.preload = 'auto';
        
        // é”™è¯¯å¤„ç†
        wyyAudio.addEventListener('error', (e) => {
            console.error('éŸ³é¢‘åŠ è½½é”™è¯¯:', e);
            const error = wyyAudio.error;
            let errorMsg = 'éŸ³é¢‘åŠ è½½å¤±è´¥';
            if (error) {
                switch(error.code) {
                    case error.MEDIA_ERR_ABORTED:
                        errorMsg = 'éŸ³é¢‘åŠ è½½è¢«ä¸­æ­¢';
                        break;
                    case error.MEDIA_ERR_NETWORK:
                        errorMsg = 'ç½‘ç»œé”™è¯¯ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥';
                        break;
                    case error.MEDIA_ERR_DECODE:
                        errorMsg = 'éŸ³é¢‘è§£ç å¤±è´¥ï¼Œå¯èƒ½æ ¼å¼ä¸æ”¯æŒ';
                        break;
                    case error.MEDIA_ERR_SRC_NOT_SUPPORTED:
                        errorMsg = 'éŸ³é¢‘æ ¼å¼ä¸æ”¯æŒï¼Œè¯·å°è¯•å…¶ä»–æ ¼å¼';
                        break;
                }
            }
            console.error(errorMsg);
        });
        
        // æ›´æ–°éŸ³é¢‘äº‹ä»¶ç›‘å¬
        wyyAudio.addEventListener('ended', wyyHandleSongEnded);
        wyyAudio.addEventListener('loadedmetadata', () => {
            if (wyyAudio.duration && !isNaN(wyyAudio.duration) && isFinite(wyyAudio.duration)) {
                if (wyyTotalTime) wyyTotalTime.textContent = wyyFormatTime(wyyAudio.duration);
                console.log('éŸ³é¢‘æ—¶é•¿:', wyyAudio.duration, 'ç§’');
            } else {
                console.warn('æ— æ³•è·å–éŸ³é¢‘æ—¶é•¿');
            }
            wyyUpdateProgress();
        });
        wyyAudio.addEventListener('canplay', () => {
            console.log('éŸ³é¢‘å¯ä»¥å¼€å§‹æ’­æ”¾');
        });
        wyyAudio.addEventListener('canplaythrough', () => {
            console.log('éŸ³é¢‘å®Œå…¨åŠ è½½ï¼Œå¯ä»¥æµç•…æ’­æ”¾');
        });
        wyyAudio.addEventListener('loadeddata', () => {
            console.log('éŸ³é¢‘æ•°æ®åŠ è½½å®Œæˆ');
        });
        wyyAudio.addEventListener('progress', () => {
            if (wyyAudio.buffered.length > 0) {
                const bufferedEnd = wyyAudio.buffered.end(wyyAudio.buffered.length - 1);
                const duration = wyyAudio.duration;
                if (duration > 0) {
                    const bufferedPercent = (bufferedEnd / duration) * 100;
                    console.log('éŸ³é¢‘ç¼“å†²è¿›åº¦:', bufferedPercent.toFixed(1) + '%');
                }
            }
        });
        wyyAudio.addEventListener('stalled', () => {
            console.warn('éŸ³é¢‘åŠ è½½åœæ»');
        });
        wyyAudio.addEventListener('suspend', () => {
            console.warn('éŸ³é¢‘åŠ è½½æš‚åœ');
        });
        wyyAudio.addEventListener('timeupdate', () => {
            wyyUpdateProgress();
            if (wyyShowLyrics) {
                wyyUpdateLyricsDisplay();
            }
        });
        
        // æ›´æ–°æ˜¾ç¤º
        if (wyyCurrentSongName) wyyCurrentSongName.textContent = song.name;
        if (wyyCurrentSingerName) wyyCurrentSingerName.textContent = song.singer;
        
        // æ›´æ–°å”±ç‰‡å°é¢
        if (wyyCurrentRecordContainer) {
            if (song.cover && song.cover !== '') {
                wyyCurrentRecordContainer.style.backgroundImage = `url(${song.cover})`;
            } else {
                wyyCurrentRecordContainer.style.backgroundImage = '';
                wyyCurrentRecordContainer.style.backgroundColor = '#cccccc';
            }
        }
        
        // åŠ è½½æ­Œè¯
        if (song.hasLocalLyric && song.localLyricData) {
            wyyLoadLyricsFromText(song.localLyricData);
        } else if (song.lyricUrl) {
            wyyLoadLyricsFromUrl(song.lyricUrl);
        } else if (song.lyricText) {
            wyyLoadLyricsFromText(song.lyricText);
        }
    } catch (error) {
        console.error('åŠ è½½æ­Œæ›²å¤±è´¥:', error);
        alert('åŠ è½½æ­Œæ›²å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶');
    }
}

// Base64è½¬Blob
function wyyBase64ToBlob(base64, contentType = '') {
    const byteCharacters = atob(base64.split(',')[1]);
    const byteNumbers = new Array(byteCharacters.length);
    for (let i = 0; i < byteCharacters.length; i++) {
        byteNumbers[i] = byteCharacters.charCodeAt(i);
    }
    const byteArray = new Uint8Array(byteNumbers);
    return new Blob([byteArray], { type: contentType });
}

// æ’­æ”¾å½“å‰æ­Œæ›²
async function wyyPlayCurrentSong() {
    if (!wyyAudio) return;
    
    try {
        // ç­‰å¾…éŸ³é¢‘å¯ä»¥æ’­æ”¾
        if (wyyAudio.readyState < 2) {
            await new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error('éŸ³é¢‘åŠ è½½è¶…æ—¶'));
                }, 10000);
                
                const checkReady = () => {
                    if (wyyAudio.readyState >= 2) {
                        clearTimeout(timeout);
                        resolve();
                    } else {
                        setTimeout(checkReady, 100);
                    }
                };
                
                wyyAudio.addEventListener('canplay', () => {
                    clearTimeout(timeout);
                    resolve();
                }, { once: true });
                
                checkReady();
            });
        }
        
        await wyyAudio.play();
        if (wyyPlayBtn) wyyPlayBtn.innerHTML = '<i class="fa fa-pause"></i>';
        if (wyyPlayerPlayBtn) wyyPlayerPlayBtn.innerHTML = '<i class="fa fa-pause"></i>';
        if (wyyRecordCover) wyyRecordCover.classList.add('playing');
        wyyStartProgressUpdate();
        console.log('æ’­æ”¾æˆåŠŸ');
    } catch (err) {
        console.error('æ’­æ”¾å¤±è´¥:', err);
        let errorMsg = 'æ’­æ”¾å¤±è´¥';
        if (err.name === 'NotAllowedError') {
            errorMsg = 'æµè§ˆå™¨é˜»æ­¢äº†è‡ªåŠ¨æ’­æ”¾ï¼Œè¯·æ‰‹åŠ¨ç‚¹å‡»æ’­æ”¾æŒ‰é’®';
        } else if (err.name === 'NotSupportedError') {
            errorMsg = 'éŸ³é¢‘æ ¼å¼ä¸æ”¯æŒï¼Œè¯·å°è¯•å…¶ä»–æ ¼å¼';
        } else if (err.message === 'éŸ³é¢‘åŠ è½½è¶…æ—¶') {
            errorMsg = 'éŸ³é¢‘åŠ è½½è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–æ–‡ä»¶';
        } else {
            errorMsg = 'æ’­æ”¾å¤±è´¥ï¼š' + err.message;
        }
        alert(errorMsg);
    }
}

// å¤„ç†æ­Œæ›²ç»“æŸ
function wyyHandleSongEnded() {
    if (wyyPlaylist.length > 0) {
        if (wyyPlayMode === 'single') {
            // å•æ›²å¾ªç¯ï¼šé‡æ–°æ’­æ”¾å½“å‰æ­Œæ›²
            wyyAudio.currentTime = 0;
            wyyPlayCurrentSong();
        } else {
            // é¡ºåºæ’­æ”¾ï¼šæ’­æ”¾ä¸‹ä¸€é¦–
            wyyCurrentSongIndex = (wyyCurrentSongIndex + 1) % wyyPlaylist.length;
            wyyLoadSong(wyyCurrentSongIndex);
            wyyPlayCurrentSong();
            wyyUpdatePlaylistDisplay();
            wyyUpdatePlayerPage();
        }
    } else {
        if (wyyPlayBtn) wyyPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
        if (wyyPlayerPlayBtn) wyyPlayerPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
        if (wyyRecordCover) wyyRecordCover.classList.remove('playing');
        wyyStopProgressUpdate();
    }
}

// æ·»åŠ ä¸Šä¼ æ­Œæ›²
async function wyyAddSong() {
    if (!wyySongNameInput || !wyySingerNameInput) return;
    
    const name = wyySongNameInput.value.trim();
    const singer = wyySingerNameInput.value.trim();
    const url = wyySongUrlInput ? wyySongUrlInput.value.trim() : '';
    const lyricUrl = wyyLyricUrlInput ? wyyLyricUrlInput.value.trim() : '';
    
    if (!name || !singer) {
        alert('è¯·å¡«å†™æ­Œæ›²åç§°å’Œæ­Œæ‰‹');
        return;
    }
    
    // æ£€æŸ¥æ˜¯å¦æœ‰æ­Œæ›²æ–‡ä»¶
    if (!wyyTempSongFile && !url) {
        alert('è¯·ä¸Šä¼ æ­Œæ›²æ–‡ä»¶æˆ–è¾“å…¥æ­Œæ›²URL');
        return;
    }
    
    // æ£€æŸ¥æ˜¯å¦é€‰ä¸­äº†æ­Œå•
    if (!wyyCurrentPlaylistId) {
        alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ­Œå•æˆ–åˆ›å»ºæ–°æ­Œå•');
        return;
    }
    
    try {
        const songData = {
            name,
            singer,
            cover: wyyTempSongCover || '',
            lyricUrl: '',
            playlistId: wyyCurrentPlaylistId,
            hasLocalFile: false,
            hasLocalLyric: false,
            dateAdded: new Date()
        };
        
        // ä¿å­˜æ­Œæ›²åŸºæœ¬ä¿¡æ¯
        const songId = await wyyDb.songs.add(songData);
        
        // å¤„ç†æ­Œæ›²æ–‡ä»¶
        if (wyyTempSongFile) {
            await wyyDb.songFiles.add({
                songId: songId,
                type: wyyTempSongFile.type,
                data: wyyTempSongFile.data
            });
            
            songData.hasLocalFile = true;
            songData.localFileData = wyyTempSongFile.data;
            songData.fileType = wyyTempSongFile.type;
        } else if (url) {
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                alert('è¯·æä¾›æœ‰æ•ˆçš„æ­Œæ›²URLï¼ˆä»¥http://æˆ–https://å¼€å¤´ï¼‰');
                return;
            }
            songData.url = url;
            await wyyDb.songs.update(songId, { url: url });
        }
        
        // å¤„ç†æ­Œè¯æ–‡ä»¶
        if (wyyTempLyricFile) {
            await wyyDb.lyrics.add({
                songId: songId,
                data: wyyTempLyricFile.data
            });
            
            songData.hasLocalLyric = true;
            songData.localLyricData = wyyTempLyricFile.data;
        } else if (lyricUrl) {
            songData.lyricUrl = lyricUrl;
            await wyyDb.songs.update(songId, { lyricUrl: lyricUrl });
        }
        
        // å¤„ç†å°é¢
        if (wyyTempSongCover) {
            await wyyDb.songs.update(songId, { cover: wyyTempSongCover });
        }
        
        songData.id = songId;
        wyyPlaylist.push(songData);
        
        // æ¸…ç©ºè¾“å…¥æ¡†å’Œä¸´æ—¶æ•°æ®
        wyySongNameInput.value = '';
        wyySingerNameInput.value = '';
        if (wyySongUrlInput) wyySongUrlInput.value = '';
        if (wyyLyricUrlInput) wyyLyricUrlInput.value = '';
        if (wyySongCoverPreview) wyySongCoverPreview.style.backgroundImage = '';
        wyyTempSongCover = null;
        wyyTempSongFile = null;
        wyyTempLyricFile = null;
        
        wyyUpdatePlaylistDisplay();
        
        // å¦‚æœæ˜¯ç¬¬ä¸€é¦–æ­Œæ›²ï¼Œè®¾ç½®ä¸ºå½“å‰æ’­æ”¾
        if (wyyPlaylist.length === 1) {
            wyyCurrentSongIndex = 0;
            await wyyLoadSong(0);
        }
        
        alert('æ­Œæ›²æ·»åŠ æˆåŠŸï¼');
    } catch (error) {
        console.error('æ·»åŠ æ­Œæ›²å¤±è´¥:', error);
        alert('æ·»åŠ æ­Œæ›²å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
}

// åˆ é™¤æ­Œæ›²
async function wyyRemoveSong(index) {
    if (index >= 0 && index < wyyPlaylist.length) {
        const song = wyyPlaylist[index];
        
        try {
            // ä»æ•°æ®åº“ä¸­åˆ é™¤
            await wyyDb.songs.delete(song.id);
            await wyyDb.songFiles.where({ songId: song.id }).delete();
            await wyyDb.lyrics.where({ songId: song.id }).delete();
            
            // é‡Šæ”¾å¯¹è±¡URL
            if (song.hasLocalFile && wyyAudio && wyyAudio.src && wyyAudio.src.startsWith('blob:')) {
                URL.revokeObjectURL(wyyAudio.src);
            }
            
            wyyPlaylist.splice(index, 1);
            
            // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰æ’­æ”¾çš„æ­Œæ›²
            if (index === wyyCurrentSongIndex) {
                if (wyyPlaylist.length > 0) {
                    wyyCurrentSongIndex = Math.min(wyyCurrentSongIndex, wyyPlaylist.length - 1);
                    await wyyLoadSong(wyyCurrentSongIndex);
                    if (wyyAudio && !wyyAudio.paused) {
                        wyyPlayCurrentSong();
                    }
                } else {
                    if (wyyAudio) {
                        wyyAudio.pause();
                    }
                    if (wyyCurrentSongName) wyyCurrentSongName.textContent = 'æš‚æ— æ­Œæ›²';
                    if (wyyCurrentSingerName) wyyCurrentSingerName.textContent = '';
                    if (wyyPlayerSongName) wyyPlayerSongName.textContent = 'æš‚æ— æ­Œæ›²';
                    if (wyyPlayerSingerName) wyyPlayerSingerName.textContent = '';
                    if (wyyCurrentRecordContainer) {
                        wyyCurrentRecordContainer.style.backgroundImage = '';
                        wyyCurrentRecordContainer.style.backgroundColor = '#cccccc';
                    }
                    if (wyyAlbumArtLarge) {
                        wyyAlbumArtLarge.style.backgroundImage = '';
                        wyyAlbumArtLarge.style.backgroundColor = '#f5f5f5';
                    }
                    if (wyyPlayBtn) wyyPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
                    if (wyyPlayerPlayBtn) wyyPlayerPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
                    if (wyyRecordCover) wyyRecordCover.classList.remove('playing');
                    wyyStopProgressUpdate();
                }
            } else if (index < wyyCurrentSongIndex) {
                wyyCurrentSongIndex--;
            }
            
            wyyUpdatePlaylistDisplay();
            wyyUpdatePlayerPage();
        } catch (error) {
            console.error('åˆ é™¤æ­Œæ›²å¤±è´¥:', error);
        }
    }
}

// æ¸…ç©ºåˆ—è¡¨
async function wyyClearAllSongs() {
    if (wyyPlaylist.length > 0 && confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ­Œæ›²å—ï¼Ÿ')) {
        try {
            // é‡Šæ”¾æ‰€æœ‰å¯¹è±¡URL
            wyyPlaylist.forEach(song => {
                if (song.hasLocalFile && wyyAudio && wyyAudio.src && wyyAudio.src.startsWith('blob:')) {
                    URL.revokeObjectURL(wyyAudio.src);
                }
            });
            
            // æ¸…ç©ºæ•°æ®åº“
            await wyyDb.songs.clear();
            await wyyDb.songFiles.clear();
            await wyyDb.lyrics.clear();
            
            wyyPlaylist = [];
            if (wyyAudio) {
                wyyAudio.pause();
            }
            if (wyyCurrentSongName) wyyCurrentSongName.textContent = 'æš‚æ— æ­Œæ›²';
            if (wyyCurrentSingerName) wyyCurrentSingerName.textContent = '';
            if (wyyPlayerSongName) wyyPlayerSongName.textContent = 'æš‚æ— æ­Œæ›²';
            if (wyyPlayerSingerName) wyyPlayerSingerName.textContent = '';
            if (wyyCurrentRecordContainer) {
                wyyCurrentRecordContainer.style.backgroundImage = '';
                wyyCurrentRecordContainer.style.backgroundColor = '#cccccc';
            }
            if (wyyAlbumArtLarge) {
                wyyAlbumArtLarge.style.backgroundImage = '';
                wyyAlbumArtLarge.style.backgroundColor = '#f5f5f5';
            }
            if (wyyPlayBtn) wyyPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
            if (wyyPlayerPlayBtn) wyyPlayerPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
            if (wyyRecordCover) wyyRecordCover.classList.remove('playing');
            wyyStopProgressUpdate();
            
            wyyUpdatePlaylistDisplay();
            wyyUpdatePlayerPage();
        } catch (error) {
            console.error('æ¸…ç©ºåˆ—è¡¨å¤±è´¥:', error);
        }
    }
}

// åŠ è½½æ­Œè¯
function wyyLoadLyricsFromUrl(url) {
    if (!url) {
        wyyCurrentLyrics = [];
        wyyUpdateLyricsDisplay();
        return;
    }
    
    fetch(url)
        .then(response => response.text())
        .then(text => {
            wyyLoadLyricsFromText(text);
        })
        .catch(error => {
            console.log('æ­Œè¯åŠ è½½å¤±è´¥:', error);
            wyyCurrentLyrics = [];
            wyyUpdateLyricsDisplay();
        });
}

// è§£æLRCæ­Œè¯
function wyyParseLyrics(text) {
    if (!text) return [];
    
    const lines = text.split('\n');
    const lyrics = [];
    
    for (let line of lines) {
        line = line.trim();
        if (!line) continue;
        
        // åŒ¹é…æ—¶é—´æ ‡ç­¾ [mm:ss.xx] æˆ– [mm:ss]
        const timeRegex = /\[(\d{2}):(\d{2})(?:\.(\d{2,3}))?\]/g;
        const matches = [...line.matchAll(timeRegex)];
        
        if (matches.length > 0) {
            const lyricText = line.replace(timeRegex, '').trim();
            if (!lyricText) continue;
            
            for (let match of matches) {
                const minutes = parseInt(match[1]);
                const seconds = parseInt(match[2]);
                const milliseconds = match[3] ? parseInt(match[3].padEnd(3, '0')) : 0;
                const time = minutes * 60 + seconds + milliseconds / 1000;
                
                lyrics.push({
                    time: time,
                    text: lyricText
                });
            }
        }
    }
    
    // æŒ‰æ—¶é—´æ’åº
    lyrics.sort((a, b) => a.time - b.time);
    return lyrics;
}

function wyyLoadLyricsFromText(text) {
    if (!text) {
        wyyCurrentLyrics = [];
        wyyUpdateLyricsDisplay();
        return;
    }
    
    // å¦‚æœæ˜¯Base64ç¼–ç ï¼Œå…ˆè§£ç 
    let lyricText = text;
    if (text.startsWith('data:text/plain;base64,')) {
        try {
            const base64Data = text.split(',')[1];
            lyricText = atob(base64Data);
        } catch (e) {
            console.error('æ­Œè¯è§£ç å¤±è´¥:', e);
        }
    }
    
    wyyCurrentLyrics = wyyParseLyrics(lyricText);
    wyyUpdateLyricsDisplay();
}

// æ›´æ–°æ­Œè¯æ˜¾ç¤º
function wyyUpdateLyricsDisplay() {
    const lyricsContent = document.getElementById('wyyLyricsContent');
    if (!lyricsContent) return;
    
    if (wyyCurrentLyrics.length === 0) {
        lyricsContent.innerHTML = '<div style="opacity: 0.6;">æš‚æ— æ­Œè¯</div>';
        return;
    }
    
    // å¦‚æœæ­£åœ¨æ’­æ”¾ï¼Œé«˜äº®å½“å‰æ­Œè¯
    if (wyyAudio && !wyyAudio.paused) {
        const currentTime = wyyAudio.currentTime;
        let activeIndex = -1;
        
        for (let i = wyyCurrentLyrics.length - 1; i >= 0; i--) {
            if (currentTime >= wyyCurrentLyrics[i].time) {
                activeIndex = i;
                break;
            }
        }
        
        let html = '';
        wyyCurrentLyrics.forEach((lyric, index) => {
            const isActive = index === activeIndex;
            html += `<div style="margin: 10px 0; ${isActive ? 'color: #fff; font-weight: bold; font-size: 18px;' : 'opacity: 0.6;'}">${lyric.text}</div>`;
        });
        
        lyricsContent.innerHTML = html;
        
        // æ»šåŠ¨åˆ°å½“å‰æ­Œè¯
        if (activeIndex >= 0) {
            const activeElement = lyricsContent.children[activeIndex];
            if (activeElement) {
                activeElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }
    } else {
        // æœªæ’­æ”¾æ—¶æ˜¾ç¤ºæ‰€æœ‰æ­Œè¯
        let html = '';
        wyyCurrentLyrics.forEach(lyric => {
            html += `<div style="margin: 10px 0; opacity: 0.6;">${lyric.text}</div>`;
        });
        lyricsContent.innerHTML = html;
    }
}

// æ’­æ”¾æŒ‰é’®äº‹ä»¶
if (wyyPlayBtn) {
    wyyPlayBtn.addEventListener('click', async () => {
        if (wyyPlaylist.length === 0) {
            alert('è¯·å…ˆæ·»åŠ æ­Œæ›²');
            return;
        }
        
        if (!wyyAudio) {
            await wyyLoadSong(wyyCurrentSongIndex);
        }
        
        if (wyyAudio && wyyAudio.paused) {
            await wyyPlayCurrentSong();
        } else if (wyyAudio) {
            wyyAudio.pause();
            wyyPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
            if (wyyPlayerPlayBtn) wyyPlayerPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
            if (wyyRecordCover) wyyRecordCover.classList.remove('playing');
            wyyStopProgressUpdate();
        }
    });
}

if (wyyPlayerPlayBtn) {
    wyyPlayerPlayBtn.addEventListener('click', async () => {
        if (wyyPlaylist.length === 0) {
            alert('è¯·å…ˆæ·»åŠ æ­Œæ›²');
            return;
        }
        
        if (!wyyAudio) {
            await wyyLoadSong(wyyCurrentSongIndex);
        }
        
        if (wyyAudio && wyyAudio.paused) {
            await wyyPlayCurrentSong();
        } else if (wyyAudio) {
            wyyAudio.pause();
            if (wyyPlayBtn) wyyPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
            wyyPlayerPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
            if (wyyRecordCover) wyyRecordCover.classList.remove('playing');
            wyyStopProgressUpdate();
        }
    });
}

// ä¸Šä¸€é¦–/ä¸‹ä¸€é¦–
if (wyyPrevBtn) {
    wyyPrevBtn.addEventListener('click', () => {
        if (wyyPlaylist.length === 0) return;
        
        wyyCurrentSongIndex = (wyyCurrentSongIndex - 1 + wyyPlaylist.length) % wyyPlaylist.length;
        wyyPlaySong(wyyCurrentSongIndex);
    });
}

if (wyyNextBtn) {
    wyyNextBtn.addEventListener('click', () => {
        if (wyyPlaylist.length === 0) return;
        
        wyyCurrentSongIndex = (wyyCurrentSongIndex + 1) % wyyPlaylist.length;
        wyyPlaySong(wyyCurrentSongIndex);
    });
}

// å¾ªç¯æ¨¡å¼åˆ‡æ¢
const wyyLoopModeBtn = document.getElementById('wyyLoopModeBtn');
const wyyLoopIcon = document.getElementById('wyyLoopIcon');

if (wyyLoopModeBtn && wyyLoopIcon) {
    wyyLoopModeBtn.addEventListener('click', () => {
        if (wyyPlayMode === 'order') {
            // åˆ‡æ¢åˆ°å•æ›²å¾ªç¯
            wyyPlayMode = 'single';
            wyyLoopIcon.className = 'fa fa-repeat';
            wyyLoopModeBtn.classList.add('wyy-loop-mode-single');
            if (wyyAudio) {
                wyyAudio.loop = false; // ä½¿ç”¨è‡ªå®šä¹‰å¾ªç¯é€»è¾‘
            }
        } else {
            // åˆ‡æ¢åˆ°é¡ºåºæ’­æ”¾
            wyyPlayMode = 'order';
            wyyLoopIcon.className = 'fa fa-list';
            wyyLoopModeBtn.classList.remove('wyy-loop-mode-single');
            if (wyyAudio) {
                wyyAudio.loop = false;
            }
        }
    });
}

// æ’­æ”¾åˆ—è¡¨æŒ‰é’®äº‹ä»¶ï¼ˆä¸»é¡µé¢ï¼‰
if (wyyPlaylistBtn) {
    wyyPlaylistBtn.addEventListener('click', () => {
        if (wyyPlaylistModal) wyyPlaylistModal.style.display = 'flex';
    });
}

// æ’­æ”¾å™¨è¯¦æƒ…é¡µé¢çš„æ’­æ”¾åˆ—è¡¨æŒ‰é’®ï¼ˆæ‰“å¼€æ’­æ”¾åˆ—è¡¨ï¼‰
const wyyPlayerPlaylistBtn = document.getElementById('wyyPlayerPlaylistBtn');
const wyyLyricsContainer = document.getElementById('wyyLyricsContainer');

if (wyyPlayerPlaylistBtn) {
    wyyPlayerPlaylistBtn.addEventListener('click', () => {
        if (wyyPlaylistModal) wyyPlaylistModal.style.display = 'flex';
    });
}

// å°é¢ç‚¹å‡»åˆ‡æ¢æ­Œè¯
if (wyyAlbumArtLarge) {
    wyyAlbumArtLarge.addEventListener('click', () => {
        wyyShowLyrics = !wyyShowLyrics;
        
        if (wyyShowLyrics) {
            wyyAlbumArtLarge.classList.add('hidden');
            if (wyyLyricsContainer) wyyLyricsContainer.classList.add('active');
            wyyUpdateLyricsDisplay();
        } else {
            wyyAlbumArtLarge.classList.remove('hidden');
            if (wyyLyricsContainer) wyyLyricsContainer.classList.remove('active');
        }
    });
}

// è¿›åº¦æ¡åŠŸèƒ½
function wyyStartProgressUpdate() {
    wyyStopProgressUpdate();
    wyyProgressUpdateInterval = setInterval(wyyUpdateProgress, 1000);
    wyyUpdateProgress();
}

function wyyStopProgressUpdate() {
    if (wyyProgressUpdateInterval) {
        clearInterval(wyyProgressUpdateInterval);
        wyyProgressUpdateInterval = null;
    }
}

function wyyUpdateProgress() {
    if (!wyyAudio || !wyyAudio.duration) return;
    
    const percent = (wyyAudio.currentTime / wyyAudio.duration) * 100;
    if (wyyProgress) wyyProgress.style.width = percent + '%';
    if (wyyCurrentTime) wyyCurrentTime.textContent = wyyFormatTime(wyyAudio.currentTime);
    if (wyyTotalTime) wyyTotalTime.textContent = wyyFormatTime(wyyAudio.duration);
}

function wyyFormatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

if (wyyProgressBar) {
    wyyProgressBar.addEventListener('click', (e) => {
        if (!wyyAudio) return;
        
        const rect = wyyProgressBar.getBoundingClientRect();
        const percent = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
        wyyAudio.currentTime = percent * wyyAudio.duration;
        wyyUpdateProgress();
    });
}

// æ·»åŠ ä¸Šä¼ é€‰é¡¹åˆ‡æ¢åŠŸèƒ½
if (wyyUrlOptionBtn && wyyFileOptionBtn && wyyUrlUploadSection && wyyFileUploadSection) {
    wyyUrlOptionBtn.addEventListener('click', () => {
        wyyUrlOptionBtn.classList.add('active');
        wyyFileOptionBtn.classList.remove('active');
        wyyUrlUploadSection.classList.add('active');
        wyyFileUploadSection.classList.remove('active');
    });

    wyyFileOptionBtn.addEventListener('click', () => {
        wyyFileOptionBtn.classList.add('active');
        wyyUrlOptionBtn.classList.remove('active');
        wyyFileUploadSection.classList.add('active');
        wyyUrlUploadSection.classList.remove('active');
    });
}

if (wyyLyricUrlOptionBtn && wyyLyricFileOptionBtn && wyyLyricUrlUploadSection && wyyLyricFileUploadSection) {
    wyyLyricUrlOptionBtn.addEventListener('click', () => {
        wyyLyricUrlOptionBtn.classList.add('active');
        wyyLyricFileOptionBtn.classList.remove('active');
        wyyLyricUrlUploadSection.classList.add('active');
        wyyLyricFileUploadSection.classList.remove('active');
    });

    wyyLyricFileOptionBtn.addEventListener('click', () => {
        wyyLyricFileOptionBtn.classList.add('active');
        wyyLyricUrlOptionBtn.classList.remove('active');
        wyyLyricFileUploadSection.classList.add('active');
        wyyLyricUrlUploadSection.classList.remove('active');
    });
}

// ä¸Šä¼ å°é¢æŒ‰é’®
if (wyyUploadCoverBtn && wyyCoverFileInput) {
    wyyUploadCoverBtn.addEventListener('click', () => {
        wyyCoverFileInput.click();
    });

    wyyCoverFileInput.addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (file) {
            if (!file.type.match('image.*')) {
                alert('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶ï¼');
                return;
            }
            
            if (file.size > 2 * 1024 * 1024) {
                alert('å›¾ç‰‡å¤§å°ä¸èƒ½è¶…è¿‡2MBï¼');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                if (wyySongCoverPreview) wyySongCoverPreview.style.backgroundImage = `url(${e.target.result})`;
                wyyTempSongCover = e.target.result;
            };
            reader.readAsDataURL(file);
        }
    });
}

// ä¸Šä¼ æ­Œæ›²æ–‡ä»¶æŒ‰é’®
if (wyyUploadSongFileBtn && wyySongFileInput) {
    wyyUploadSongFileBtn.addEventListener('click', () => {
        wyySongFileInput.click();
    });

    wyySongFileInput.addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (file) {
            const validAudioTypes = [
                'audio/mpeg', 'audio/mp3', 'audio/wav', 'audio/wave', 'audio/x-wav',
                'audio/ogg', 'audio/oga', 'audio/x-m4a', 'audio/mp4', 'audio/flac',
                'audio/x-flac', 'audio/aac', 'audio/aacp'
            ];
            
            const validExtensions = ['.mp3', '.wav', '.ogg', '.m4a', '.flac', '.aac'];
            const fileName = file.name.toLowerCase();
            const isValidExtension = validExtensions.some(ext => fileName.endsWith(ext));
            
            if (!validAudioTypes.includes(file.type) && !isValidExtension) {
                alert('è¯·é€‰æ‹©æœ‰æ•ˆçš„éŸ³é¢‘æ–‡ä»¶ï¼ˆMP3ã€WAVã€OGGã€M4Aã€FLACã€AACç­‰æ ¼å¼ï¼‰ï¼');
                return;
            }
            
            if (file.size > 50 * 1024 * 1024) {
                alert('éŸ³é¢‘æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡50MBï¼');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                wyyTempSongFile = {
                    data: e.target.result,
                    type: file.type || 'audio/mpeg',
                    name: file.name
                };
                alert(`å·²é€‰æ‹©æ­Œæ›²æ–‡ä»¶: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`);
            };
            reader.readAsDataURL(file);
        }
    });
}

// ä¸Šä¼ æ­Œè¯æ–‡ä»¶æŒ‰é’®
if (wyyUploadLyricFileBtn && wyyLyricFileInput) {
    wyyUploadLyricFileBtn.addEventListener('click', () => {
        wyyLyricFileInput.click();
    });

    wyyLyricFileInput.addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (file) {
            const validTypes = ['.lrc', '.txt'];
            const fileName = file.name.toLowerCase();
            const isValidType = validTypes.some(type => fileName.endsWith(type));
            
            if (!isValidType) {
                alert('è¯·é€‰æ‹©LRCæˆ–TXTæ ¼å¼çš„æ­Œè¯æ–‡ä»¶ï¼');
                return;
            }
            
            if (file.size > 1 * 1024 * 1024) {
                alert('æ­Œè¯æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡1MBï¼');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                wyyTempLyricFile = {
                    data: e.target.result,
                    name: file.name
                };
                alert(`å·²é€‰æ‹©æ­Œè¯æ–‡ä»¶: ${file.name}`);
            };
            reader.readAsDataURL(file);
        }
    });
}

// æ·»åŠ æ­Œæ›²æŒ‰é’®äº‹ä»¶
if (wyyAddSongBtn) {
    wyyAddSongBtn.addEventListener('click', wyyAddSong);
}

// æ¸…ç©ºåˆ—è¡¨æŒ‰é’®äº‹ä»¶
if (wyyClearAllBtn) {
    wyyClearAllBtn.addEventListener('click', wyyClearAllSongs);
}

// ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
if (wyyPlaylistModal) {
    wyyPlaylistModal.addEventListener('click', (e) => {
        if (e.target === wyyPlaylistModal) {
            wyyPlaylistModal.style.display = 'none';
            wyyTempSongCover = null;
            wyyTempSongFile = null;
            wyyTempLyricFile = null;
            if (wyySongCoverPreview) wyySongCoverPreview.style.backgroundImage = '';
        }
    });
}

// ä¿¡æ¯é¡µé¢æ•°æ®
const messageChats = [
    { 
        id: 'welcome', 
        name: 'æ¬¢è¿å°åŠ©æ‰‹', 
        avatar: 'https://img.icons8.com/color/96/chat.png', 
        time: 'åˆšåˆš', 
        preview: 'æ¬¢è¿ä½¿ç”¨è¿™ä¸ªç½‘é¡µï¼', 
        unread: false, 
        chatTimeLabel: 'åˆšåˆš',
        messages: [
            { 
                type: 'received', 
                text: 'æ¬¢è¿ä½¿ç”¨è¿™ä¸ªç½‘é¡µï¼ğŸ‰\n\nè¿™æ˜¯ä¸€ä¸ªä»¿ iOS é£æ ¼çš„ä¿¡æ¯åº”ç”¨ï¼Œä½ å¯ä»¥åœ¨è¿™é‡Œï¼š\n\nâ€¢ æŸ¥çœ‹å’Œç®¡ç†ä½ çš„ä¿¡æ¯\nâ€¢ ä¸å¥½å‹èŠå¤©\nâ€¢ å‘é€å’Œæ¥æ”¶æ¶ˆæ¯\n\nå¸Œæœ›ä½ èƒ½å–œæ¬¢è¿™ä¸ªè®¾è®¡ï¼å¦‚æœ‰ä»»ä½•é—®é¢˜ï¼Œéšæ—¶å‘Šè¯‰æˆ‘ã€‚' 
            }
        ]
    }
];

// çŸ­ä¿¡ç¼–è¾‘æ¨¡å¼çŠ¶æ€
let isMessageEditMode = false;
let selectedMessageChats = new Set();

// åˆ‡æ¢çŸ­ä¿¡ç¼–è¾‘æ¨¡å¼
async function toggleMessageEditMode() {
    isMessageEditMode = !isMessageEditMode;
    selectedMessageChats.clear();
    
    const editBtn = document.getElementById('message-edit-btn');
    const listContainer = document.getElementById('message-chat-list-container');
    
    if (isMessageEditMode) {
        editBtn.textContent = 'å®Œæˆ';
        if (listContainer) {
            listContainer.classList.add('edit-mode');
        }
        // æ˜¾ç¤ºåˆ‡æ¢è´¦å·å’Œåˆ é™¤æŒ‰é’®
        showMessageEditActions();
    } else {
        editBtn.textContent = 'ç¼–è¾‘';
        if (listContainer) {
            listContainer.classList.remove('edit-mode');
        }
        // éšè—æ“ä½œæŒ‰é’®
        hideMessageEditActions();
    }
    
    // é‡æ–°æ¸²æŸ“åˆ—è¡¨ä»¥æ˜¾ç¤ºé€‰æ‹©æ¡†
    await renderMessageList();
}

// æ˜¾ç¤ºç¼–è¾‘æ¨¡å¼æ“ä½œæŒ‰é’®
function showMessageEditActions() {
    const actionsContainer = document.getElementById('message-edit-actions');
    if (actionsContainer) {
        actionsContainer.style.display = 'block';
    }
    updateMessageDeleteButton();
}

// éšè—ç¼–è¾‘æ¨¡å¼æ“ä½œæŒ‰é’®
function hideMessageEditActions() {
    const actionsContainer = document.getElementById('message-edit-actions');
    if (actionsContainer) {
        actionsContainer.style.display = 'none';
    }
    const deleteBtn = document.getElementById('message-delete-btn');
    if (deleteBtn) {
        deleteBtn.style.display = 'none';
    }
}

// åœ¨ç¼–è¾‘æ¨¡å¼ä¸‹æ˜¾ç¤ºåˆ‡æ¢è´¦å·æŒ‰é’®
async function showMessageSwitchAccount() {
    await showSwitchAccountModal();
}

// åˆ‡æ¢çŸ­ä¿¡èŠå¤©é€‰æ‹©çŠ¶æ€
async function toggleMessageChatSelection(chatId) {
    if (!isMessageEditMode) return;
    
    // ä¸å…è®¸é€‰æ‹©æ¬¢è¿å°åŠ©æ‰‹
    if (chatId === 'welcome') return;
    
    if (selectedMessageChats.has(chatId)) {
        selectedMessageChats.delete(chatId);
    } else {
        selectedMessageChats.add(chatId);
    }
    
    await renderMessageList();
    updateMessageDeleteButton();
}

// æ›´æ–°åˆ é™¤æŒ‰é’®çŠ¶æ€
function updateMessageDeleteButton() {
    const deleteBtn = document.getElementById('message-delete-btn');
    if (deleteBtn) {
        if (selectedMessageChats.size > 0) {
            deleteBtn.style.display = 'flex';
            deleteBtn.textContent = `åˆ é™¤(${selectedMessageChats.size})`;
        } else {
            deleteBtn.style.display = 'none';
        }
    }
}

// åˆ é™¤é€‰ä¸­çš„çŸ­ä¿¡èŠå¤©
async function deleteSelectedMessageChats() {
    if (selectedMessageChats.size === 0) return;
    
    // è¿‡æ»¤æ‰æ¬¢è¿å°åŠ©æ‰‹ï¼ˆä¸å…è®¸åˆ é™¤ï¼‰
    const chatsToDelete = Array.from(selectedMessageChats).filter(id => id !== 'welcome');
    if (chatsToDelete.length === 0) return;
    
    if (!confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${chatsToDelete.length} ä¸ªèŠå¤©å—ï¼Ÿ`)) {
        return;
    }
    
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    // ä» Dexie åˆ é™¤é€‰ä¸­èŠå¤©çš„æ‰€æœ‰æ¶ˆæ¯
    const allMessages = await db.sms_messages.where('accountId').equals(accountId).toArray();
    const idsToDelete = allMessages.filter(msg => {
        let chatId;
        if (msg.type === 'sent') {
            chatId = msg.number || msg.receiverId || msg.sender;
        } else {
            chatId = msg.number || msg.sender;
        }
        return chatsToDelete.includes(chatId);
    }).map(msg => msg.id);
    
    await db.sms_messages.bulkDelete(idsToDelete);
    
    // å¦‚æœå½“å‰æ‰“å¼€çš„èŠå¤©è¢«åˆ é™¤äº†ï¼Œå…ˆè¿”å›åˆ—è¡¨é¡µ
    if (currentMessageChatId && selectedMessageChats.has(currentMessageChatId)) {
        goBackMessageList();
    }
    
    // æ¸…ç©ºé€‰æ‹©å¹¶é€€å‡ºç¼–è¾‘æ¨¡å¼
    selectedMessageChats.clear();
    isMessageEditMode = false;
    
    const editBtn = document.getElementById('message-edit-btn');
    if (editBtn) editBtn.textContent = 'ç¼–è¾‘';
    
    const listContainer = document.getElementById('message-chat-list-container');
    if (listContainer) {
        listContainer.classList.remove('edit-mode');
    }
    
    hideMessageEditActions();
    
    // é‡æ–°æ¸²æŸ“åˆ—è¡¨
    await renderMessageList();
}

// æ¸²æŸ“ä¿¡æ¯åˆ—è¡¨
async function renderMessageList() {
    const listContainer = document.getElementById('message-chat-list-container');
    if (!listContainer) return;
    
    // ğŸ¯ ä» Dexie è¯»å–çŸ­ä¿¡è®°å½•ï¼ˆæŒ‰è´¦å·è¿‡æ»¤ï¼‰
    const accountId = getCurrentAccountId();
    let smsMessages = [];
    
    if (accountId) {
        smsMessages = await db.sms_messages.where('accountId').equals(accountId).toArray();
    }
    
    // æŒ‰èŠå¤©IDåˆ†ç»„ï¼ˆä¿®å¤ï¼šå‘é€çš„æ¶ˆæ¯ä½¿ç”¨æ¥æ”¶è€…IDï¼Œæ¥æ”¶çš„æ¶ˆæ¯ä½¿ç”¨å‘é€è€…IDï¼‰
    const groupedChats = {};
    
    // é¢„åŠ è½½è§’è‰²å¤´åƒç¼“å­˜
    const charAvatarCache = {};
    
    for (const msg of smsMessages) {
        // ğŸ¯ ä¿®å¤ï¼šå¯¹äºå‘é€çš„æ¶ˆæ¯ï¼Œä½¿ç”¨numberï¼ˆæ¥æ”¶è€…IDï¼‰åˆ†ç»„
        // å¯¹äºæ¥æ”¶çš„æ¶ˆæ¯ï¼Œä½¿ç”¨numberæˆ–senderï¼ˆå‘é€è€…IDï¼‰åˆ†ç»„
        let chatId;
        if (msg.type === 'sent') {
            // å‘é€çš„æ¶ˆæ¯ï¼šä½¿ç”¨numberå­—æ®µï¼ˆåº”è¯¥æ˜¯æ¥æ”¶è€…çš„IDï¼‰
            chatId = msg.number || msg.receiverId || msg.sender;
        } else {
            // æ¥æ”¶çš„æ¶ˆæ¯ï¼šä½¿ç”¨å‘é€è€…çš„ID
            chatId = msg.number || msg.sender;
        }
        
        if (!groupedChats[chatId]) {
            // ğŸ¯ ä¿®å¤ï¼šæ˜¾ç¤ºæ¥æ”¶è€…çš„åå­—ï¼ˆå¯¹äºå‘é€çš„æ¶ˆæ¯ï¼Œä½¿ç”¨å­˜å‚¨çš„æ¥æ”¶è€…ä¿¡æ¯ï¼‰
            let displayName = msg.sender;
            let displayAvatar = '';
            
            // å¦‚æœæœ‰ charIdï¼Œä»æ•°æ®åº“è·å–è§’è‰²å¤´åƒ
            if (msg.charId && !charAvatarCache[msg.charId]) {
                const char = await db.characters.get(msg.charId);
                if (char) {
                    charAvatarCache[msg.charId] = getCharAvatar(char, getCurrentAccountId());
                }
            }
            if (msg.charId && charAvatarCache[msg.charId]) {
                displayAvatar = charAvatarCache[msg.charId];
            }
            
            // å¦‚æœæ˜¯å‘é€çš„æ¶ˆæ¯ï¼Œä½¿ç”¨å­˜å‚¨çš„æ¥æ”¶è€…ä¿¡æ¯
            if (msg.type === 'sent' && msg.receiverName) {
                displayName = msg.receiverName;
                // æŸ¥æ‰¾åŒèŠå¤©ä¸­æ¥æ”¶çš„æ¶ˆæ¯ï¼Œè·å–æ¥æ”¶è€…å¤´åƒ
                const receivedMsg = smsMessages.find(m => 
                    (m.number || m.sender) === chatId && m.type !== 'sent'
                );
                if (receivedMsg && receivedMsg.charId) {
                    if (!charAvatarCache[receivedMsg.charId]) {
                        const char = await db.characters.get(receivedMsg.charId);
                        if (char) charAvatarCache[receivedMsg.charId] = getCharAvatar(char, getCurrentAccountId());
                    }
                    displayAvatar = charAvatarCache[receivedMsg.charId] || displayAvatar;
                }
            }
            
            groupedChats[chatId] = {
                id: chatId,
                name: displayName,
                avatar: displayAvatar,
                number: msg.number,
                messages: [],
                isBlocked: msg.isBlocked || false
            };
        }
        groupedChats[chatId].messages.push(msg);
    }
    
    // è½¬æ¢æˆæ•°ç»„å¹¶æŒ‰æœ€æ–°æ¶ˆæ¯æ—¶é—´æ’åº
    const chats = Object.values(groupedChats).map(chat => {
        // ğŸ¯ ä¿®å¤ï¼šæŒ‰æ—¶é—´æ’åºï¼Œå–æœ€æ–°çš„æ¶ˆæ¯ä½œä¸ºé¢„è§ˆ
        chat.messages.sort((a, b) => (a.time || a.timestamp || 0) - (b.time || b.timestamp || 0));
        const lastMsg = chat.messages[chat.messages.length - 1]; // å–æœ€åä¸€æ¡ï¼ˆæœ€æ–°çš„ï¼‰
        return {
            ...chat,
            time: formatMessageTime(lastMsg.time),
            preview: lastMsg.content,
            unread: !lastMsg.read
        };
    }).sort((a, b) => {
        // æŒ‰æœ€æ–°æ¶ˆæ¯æ—¶é—´é™åºæ’åˆ—
        const aLastTime = a.messages[a.messages.length - 1].time || 0;
        const bLastTime = b.messages[b.messages.length - 1].time || 0;
        return bLastTime - aLastTime;
    });
    
    // å§‹ç»ˆæ·»åŠ æ¬¢è¿æ¶ˆæ¯ï¼ˆç¡®ä¿å®ƒå§‹ç»ˆæ˜¾ç¤ºåœ¨åˆ—è¡¨ä¸­ï¼‰
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨æ¬¢è¿æ¶ˆæ¯ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™æ·»åŠ 
    const hasWelcome = chats.some(chat => chat.id === 'welcome');
    if (!hasWelcome) {
        chats.push({
            id: 'welcome',
            name: 'æ¬¢è¿å°åŠ©æ‰‹',
            avatar: 'https://img.icons8.com/color/96/chat.png',
            time: 'åˆšåˆš',
            preview: 'æ¬¢è¿ä½¿ç”¨è¿™ä¸ªç½‘é¡µï¼',
            unread: false
        });
    }
    
    // æ‰¹é‡æ„å»ºHTMLåä¸€æ¬¡æ€§æ’å…¥ï¼Œé¿å…å¤šæ¬¡è§¦å‘DOMå›æµ
    const htmlParts = [];
    chats.forEach(chat => {
        const unreadClass = chat.unread ? 'message-unread' : '';
        const unreadDot = chat.unread ? `<div class="message-unread-dot"></div>` : '';
        const isSelected = selectedMessageChats.has(chat.id);
        const selectedClass = isSelected ? 'message-chat-selected' : '';
        
        // æ¬¢è¿å°åŠ©æ‰‹åœ¨ç¼–è¾‘æ¨¡å¼ä¸‹ä¸æ˜¾ç¤ºé€‰æ‹©æ¡†ï¼Œä¹Ÿä¸èƒ½è¢«é€‰æ‹©
        const isWelcome = chat.id === 'welcome';
        const showCheckbox = isMessageEditMode && !isWelcome;
        
        // ç¼–è¾‘æ¨¡å¼ä¸‹æ˜¾ç¤ºé€‰æ‹©æ¡†ï¼Œå¦åˆ™ç›´æ¥æ‰“å¼€èŠå¤©ï¼ˆæ¬¢è¿å°åŠ©æ‰‹å§‹ç»ˆå¯ä»¥æ‰“å¼€ï¼‰
        const onClickAction = showCheckbox
            ? `toggleMessageChatSelection('${chat.id}')`
            : `openMessageChat('${chat.id}')`;
        
        const checkbox = showCheckbox
            ? `<div class="message-chat-checkbox ${isSelected ? 'checked' : ''}">
                <svg viewBox="0 0 24 24" style="width:20px;height:20px;stroke:currentColor;fill:none;stroke-width:3;">
                    ${isSelected ? '<path d="M20 6L9 17l-5-5"></path>' : ''}
                </svg>
               </div>`
            : '';
        
        const defaultAvatarClass = chat.avatar ? '' : 'default-avatar';
        const avatarImg = chat.avatar 
            ? `<img src="${chat.avatar}" style="width:100%;height:100%;object-fit:cover;" onerror="this.style.display='none';this.parentElement.classList.add('default-avatar');">`
            : '';
        
        htmlParts.push(`
            <div class="message-chat-item ${unreadClass} ${selectedClass}" onclick="${onClickAction}">
                ${checkbox}
                <div class="message-avatar ${defaultAvatarClass}">
                    ${avatarImg}
                </div>
                <div class="message-chat-info">
                    <div class="message-chat-top">
                        <span class="message-chat-name">${chat.name}</span>
                        <div class="message-chat-time">
                            <span>${chat.time}</span>
                        </div>
                    </div>
                    <div class="message-chat-bottom">
                        <div class="message-chat-preview">${chat.preview}</div>
                        ${unreadDot}
                    </div>
                </div>
            </div>
        `);
    });
    listContainer.innerHTML = htmlParts.join('');
    
    // æ›´æ–°åˆ é™¤æŒ‰é’®
    updateMessageDeleteButton();
}

// æ ¼å¼åŒ–æ¶ˆæ¯æ—¶é—´ï¼ˆåˆ—è¡¨è§†å›¾ç”¨ï¼‰
function formatMessageTime(timestamp, timeOffset = 0) {
    // ä½¿ç”¨è™šæ‹Ÿæ—¶é—´è¿›è¡Œè®¡ç®—
    const virtualNow = Date.now() + timeOffset;
    const virtualTimestamp = timestamp + timeOffset;
    const diff = virtualNow - virtualTimestamp;
    const date = new Date(virtualTimestamp);
    
    const timeStr = date.getHours() + ':' + String(date.getMinutes()).padStart(2, '0');
    
    // 1åˆ†é’Ÿå†…
    if (diff < 60000) {
        return 'åˆšåˆš';
    }
    // 1å°æ—¶å†…
    if (diff < 3600000) {
        return Math.floor(diff / 60000) + 'åˆ†é’Ÿå‰';
    }
    // ä»Šå¤©
    const today = new Date(virtualNow);
    if (date.getDate() === today.getDate() && 
        date.getMonth() === today.getMonth() && 
        date.getFullYear() === today.getFullYear()) {
        return timeStr;
    }
    // æ˜¨å¤©
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    if (date.getDate() === yesterday.getDate() && 
        date.getMonth() === yesterday.getMonth() && 
        date.getFullYear() === yesterday.getFullYear()) {
        return 'æ˜¨å¤© ' + timeStr;
    }
    // ä¸€å‘¨å†…
    if (diff < 7 * 24 * 3600000) {
        const days = ['å‘¨æ—¥', 'å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­'];
        return days[date.getDay()] + ' ' + timeStr;
    }
    // æ›´æ—©ï¼ˆåŒå¹´æ˜¾ç¤ºæœˆ/æ—¥ï¼Œä¸åŒå¹´æ˜¾ç¤ºå¹´/æœˆ/æ—¥ï¼‰
    if (date.getFullYear() === today.getFullYear()) {
        return (date.getMonth() + 1) + 'æœˆ' + date.getDate() + 'æ—¥ ' + timeStr;
    }
    return date.getFullYear() + '/' + (date.getMonth() + 1) + '/' + date.getDate();
}

// æ ¼å¼åŒ–çŸ­ä¿¡è¯¦æƒ…é¡µçš„æ—¶é—´æˆ³ï¼ˆæ˜¾ç¤ºå®Œæ•´æ—¥æœŸå’Œæ—¶é—´ï¼‰
function formatSmsDetailTime(timestamp) {
    if (!timestamp) return '';
    const date = new Date(timestamp);
    const now = new Date();
    
    const hours = date.getHours();
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const timeStr = `${hours}:${minutes}`;
    
    // ä»Šå¤©ï¼šåªæ˜¾ç¤ºæ—¶é—´
    if (date.getDate() === now.getDate() && 
        date.getMonth() === now.getMonth() && 
        date.getFullYear() === now.getFullYear()) {
        return `ä»Šå¤© ${timeStr}`;
    }
    
    // æ˜¨å¤©
    const yesterday = new Date(now);
    yesterday.setDate(yesterday.getDate() - 1);
    if (date.getDate() === yesterday.getDate() && 
        date.getMonth() === yesterday.getMonth() && 
        date.getFullYear() === yesterday.getFullYear()) {
        return `æ˜¨å¤© ${timeStr}`;
    }
    
    // ä¸€å‘¨å†…
    const diff = now - date;
    if (diff < 7 * 24 * 3600000) {
        const days = ['å‘¨æ—¥', 'å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­'];
        return `${days[date.getDay()]} ${timeStr}`;
    }
    
    // ä»Šå¹´
    if (date.getFullYear() === now.getFullYear()) {
        return `${date.getMonth() + 1}æœˆ${date.getDate()}æ—¥ ${timeStr}`;
    }
    
    // æ›´æ—©
    return `${date.getFullYear()}å¹´${date.getMonth() + 1}æœˆ${date.getDate()}æ—¥ ${timeStr}`;
}

// å½“å‰çŸ­ä¿¡èŠå¤©çš„è”ç³»äººIDï¼ˆå…¨å±€å˜é‡ï¼‰
let currentMessageChatId = null;
let currentMessageChatName = null;

// æ‰“å¼€èŠå¤©è¯¦æƒ…
async function openMessageChat(id) {
    console.log('openMessageChat called with id:', id);
    
    const accountId = getCurrentAccountId();
    
    // ğŸ¯ ä» Dexie è¯»å–çŸ­ä¿¡è®°å½•
    let smsMessages = [];
    if (accountId) {
        smsMessages = await db.sms_messages.where('accountId').equals(accountId).toArray();
    }
    
    // æŸ¥æ‰¾è¯¥è”ç³»äººçš„æ‰€æœ‰æ¶ˆæ¯ï¼ˆä¿®å¤ï¼šæ”¯æŒå‘é€å’Œæ¥æ”¶çš„æ¶ˆæ¯ï¼‰
    const chatMessages = smsMessages.filter(msg => {
        if (msg.type === 'sent') {
            // å‘é€çš„æ¶ˆæ¯ï¼šä½¿ç”¨numberï¼ˆæ¥æ”¶è€…IDï¼‰æˆ–receiverIdåŒ¹é…
            return (msg.number || msg.receiverId) === id;
        } else {
            // æ¥æ”¶çš„æ¶ˆæ¯ï¼šä½¿ç”¨å‘é€è€…çš„IDåŒ¹é…
            return (msg.number || msg.sender) === id;
        }
    });
    
    if (chatMessages.length === 0 && id !== 'welcome') {
        // å¦‚æœæ˜¯ä»æ–°å»ºçŸ­ä¿¡æµç¨‹æ¥çš„ï¼Œå…è®¸æ‰“å¼€ç©ºèŠå¤©
        if (window._smsSelectedCharId) {
            const targetChar = await db.characters.get(window._smsSelectedCharId);
            if (targetChar) {
                const _smsAid = getCurrentAccountId();
                const charName = getCharDisplayName(targetChar, _smsAid);
                const charAvatar = getCharAvatar(targetChar, _smsAid);
                currentMessageChatId = id;
                currentMessageChatName = charName;
                
                // ğŸ¯ ä¿®å¤ï¼šå…ˆéšè—åˆ—è¡¨é¡µ
                const listPage = document.getElementById('message-list-page');
                if (listPage) {
                    listPage.style.display = 'none';
                }
                
                // ğŸ¯ ä¿®å¤ï¼šæ­£ç¡®æ˜¾ç¤ºè¯¦æƒ…é¡µï¼ˆå…ˆè®¾ç½®displayå†æ·»åŠ activeï¼‰
                const detailPage = document.getElementById('message-detail-page');
                detailPage.style.display = 'flex';
                setTimeout(() => {
                    detailPage.classList.add('active');
                }, 10);
                
                // è®¾ç½®å¤´åƒ
                const avatarEl = document.getElementById('message-detail-avatar');
                if (avatarEl) {
                    const avatarContainer = avatarEl.parentElement;
                    if (charAvatar) {
                        avatarEl.src = charAvatar;
                        avatarEl.style.display = '';
                        avatarContainer.classList.remove('default-avatar');
                        avatarEl.onerror = function() {
                            this.style.display = 'none';
                            avatarContainer.classList.add('default-avatar');
                        };
                    } else {
                        avatarEl.style.display = 'none';
                        avatarContainer.classList.add('default-avatar');
                    }
                }
                document.getElementById('message-detail-name').innerText = charName;
                document.getElementById('message-container').innerHTML = '';
                
                // åˆå§‹åŒ–è¾“å…¥æ¡†çŠ¶æ€
                const msgInput = document.getElementById('message-msg-input');
                if (msgInput) {
                    msgInput.value = '';
                    handleMessageInputChange(msgInput);
                }
                
                return;
            }
        }
        console.error('Chat not found:', id);
        return;
    }
    
    // æ„å»ºèŠå¤©å¯¹è±¡
    let chat;
    if (id === 'welcome') {
        // æ¬¢è¿æ¶ˆæ¯
        chat = {
            id: 'welcome',
            name: 'æ¬¢è¿å°åŠ©æ‰‹',
            avatar: 'https://img.icons8.com/color/96/chat.png',
            chatTimeLabel: 'åˆšåˆš',
            messages: [{
                type: 'received',
                text: 'æ¬¢è¿ä½¿ç”¨è¿™ä¸ªç½‘é¡µï¼ğŸ‰\n\nè¿™æ˜¯ä¸€ä¸ªä»¿ iOS é£æ ¼çš„ä¿¡æ¯åº”ç”¨ï¼Œä½ å¯ä»¥åœ¨è¿™é‡Œï¼š\n\nâ€¢ æŸ¥çœ‹å’Œç®¡ç†ä½ çš„ä¿¡æ¯\nâ€¢ ä¸å¥½å‹èŠå¤©\nâ€¢ å‘é€å’Œæ¥æ”¶æ¶ˆæ¯\n\nå¸Œæœ›ä½ èƒ½å–œæ¬¢è¿™ä¸ªè®¾è®¡ï¼å¦‚æœ‰ä»»ä½•é—®é¢˜ï¼Œéšæ—¶å‘Šè¯‰æˆ‘ã€‚'
            }]
        };
        currentMessageChatId = null;
        currentMessageChatName = null;
    } else {
        // çœŸå®çŸ­ä¿¡
        console.log('[openMessageChat] èŠå¤©æ¶ˆæ¯æ•°é‡:', chatMessages.length);
        console.log('[openMessageChat] ç¬¬ä¸€æ¡æ¶ˆæ¯:', chatMessages[0]);
        
        // ğŸ¯ ä¿®å¤ï¼šæ‰¾åˆ°æ¥æ”¶æ¶ˆæ¯æ¥ç¡®å®šæ¥æ”¶è€…ä¿¡æ¯ï¼ˆå¦‚æœåªæœ‰å‘é€æ¶ˆæ¯ï¼Œä½¿ç”¨å­˜å‚¨çš„æ¥æ”¶è€…ä¿¡æ¯ï¼‰
        const receivedMsg = chatMessages.find(msg => msg.type !== 'sent');
        const firstMsg = receivedMsg || chatMessages[chatMessages.length - 1]; // ä¼˜å…ˆä½¿ç”¨æ¥æ”¶æ¶ˆæ¯ï¼Œå¦åˆ™ç”¨æœ€æ—©çš„æ¶ˆæ¯
        
        console.log('[openMessageChat] ç¬¬ä¸€æ¡æ¶ˆæ¯å†…å®¹:', firstMsg);
        
        // ç¡®å®šæ˜¾ç¤ºçš„åå­—å’Œå¤´åƒï¼ˆä»è§’è‰²æ•°æ®åº“è·å–ï¼‰
        let displayName = firstMsg.sender;
        let displayAvatar = '';
        
        // å¦‚æœæœ‰ charIdï¼Œä»æ•°æ®åº“è·å–è§’è‰²å¤´åƒï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰
        const _msgAid = getCurrentAccountId();
        if (firstMsg.charId) {
            const char = await db.characters.get(firstMsg.charId);
            if (char) {
                displayAvatar = getCharAvatar(char, _msgAid) || displayAvatar;
            }
        }
        
        // å¦‚æœç¬¬ä¸€æ¡æ¶ˆæ¯æ˜¯å‘é€çš„æ¶ˆæ¯ï¼Œä½¿ç”¨å­˜å‚¨çš„æ¥æ”¶è€…ä¿¡æ¯
        if (firstMsg.type === 'sent' && firstMsg.receiverName) {
            displayName = firstMsg.receiverName;
            // å°è¯•ä»æ¥æ”¶æ¶ˆæ¯ä¸­è·å–å¤´åƒ
            const receivedMsgForAvatar = chatMessages.find(msg => msg.type !== 'sent');
            if (receivedMsgForAvatar && receivedMsgForAvatar.charId) {
                const char = await db.characters.get(receivedMsgForAvatar.charId);
                if (char) {
                    displayAvatar = getCharAvatar(char, _msgAid) || displayAvatar;
                }
            }
        }
        
        console.log('[openMessageChat] æ˜¾ç¤ºåç§°:', displayName);
        console.log('[openMessageChat] æ˜¾ç¤ºå¤´åƒ:', displayAvatar);
        
        // ğŸ”¥ ä¿®å¤ï¼šæŒ‰æ—¶é—´æˆ³æ’åºï¼Œç¡®ä¿æœ€æ—©çš„æ¶ˆæ¯åœ¨æœ€ä¸Šé¢
        chatMessages.sort((a, b) => (a.time || a.timestamp || 0) - (b.time || b.timestamp || 0));
        
        chat = {
            id: id,
            name: displayName,
            avatar: displayAvatar,
            chatTimeLabel: formatMessageTime(firstMsg.time || firstMsg.timestamp || Date.now()),
            messages: chatMessages.map(msg => {
                const msgText = msg.content || msg.message || '';
                console.log('[openMessageChat] æ˜ å°„æ¶ˆæ¯:', { type: msg.type, text: msgText });
                return {
                    type: msg.type || (msg.sender === displayName ? 'received' : 'sent'),
                    text: msgText,
                    time: msg.time || msg.timestamp || 0
                };
            })
        };
        
        console.log('[openMessageChat] æœ€ç»ˆèŠå¤©å¯¹è±¡:', chat);
        
        // ä¿å­˜å½“å‰èŠå¤©ä¿¡æ¯
        currentMessageChatId = id;
        currentMessageChatName = displayName;
        
        // æ ‡è®°ä¸ºå·²è¯»ï¼ˆä¿®å¤ï¼šæ”¯æŒå‘é€å’Œæ¥æ”¶çš„æ¶ˆæ¯ï¼‰
        const idsToUpdate = chatMessages.map(msg => msg.id);
        for (const msgId of idsToUpdate) {
            await db.sms_messages.update(msgId, { read: true });
        }
    }
    
    // éšè—åˆ—è¡¨é¡µ
    const listPage = document.getElementById('message-list-page');
    if (listPage) {
        listPage.style.display = 'none';
    }
    
    // æ˜¾ç¤ºè¯¦æƒ…é¡µ
    const detailPage = document.getElementById('message-detail-page');
    if (!detailPage) {
        console.error('Detail page not found');
        return;
    }
    
    // å…ˆè®¾ç½® displayï¼Œå†æ·»åŠ  active ç±»è§¦å‘åŠ¨ç”»
    detailPage.style.display = 'flex';
    // ä½¿ç”¨ setTimeout ç¡®ä¿ display è®¾ç½®åå†è§¦å‘åŠ¨ç”»
    setTimeout(() => {
        detailPage.classList.add('active');
    }, 10);
    
    // è®¾ç½®èŠå¤©ä¿¡æ¯
    document.getElementById('message-detail-name').innerText = chat.name;
    const avatarEl = document.getElementById('message-detail-avatar');
    if (avatarEl) {
        const avatarContainer = avatarEl.parentElement;
        if (chat.avatar) {
            avatarEl.src = chat.avatar;
            avatarEl.style.display = '';
            avatarContainer.classList.remove('default-avatar');
            avatarEl.onerror = function() {
                this.style.display = 'none';
                avatarContainer.classList.add('default-avatar');
            };
        } else {
            avatarEl.style.display = 'none';
            avatarContainer.classList.add('default-avatar');
        }
    }
    
    // æ¸²æŸ“æ¶ˆæ¯
    const msgContainer = document.getElementById('message-container');
    if (!msgContainer) {
        console.error('Message container not found');
        return;
    }
    
    // æ¸²æŸ“æ¶ˆæ¯ï¼Œåœ¨æœ‰æ—¶é—´é—´éš”çš„åœ°æ–¹æ’å…¥æ—¶é—´æˆ³
    const firstMsgTime = chat.messages.length > 0 && chat.messages[0].time ? chat.messages[0].time : 0;
    let htmlContent = `<div class="message-ts-group"><span class="message-ts-label">iMessage</span><span class="message-ts-time">${firstMsgTime ? formatSmsDetailTime(firstMsgTime) : (chat.chatTimeLabel || 'ä»Šå¤©')}</span></div>`;
    
    let lastTimestamp = firstMsgTime;
    chat.messages.forEach((msg, index) => {
        // å¦‚æœä¸ä¸Šä¸€æ¡æ¶ˆæ¯é—´éš”è¶…è¿‡5åˆ†é’Ÿï¼Œæ’å…¥æ—¶é—´æˆ³
        if (index > 0 && msg.time && lastTimestamp) {
            const gap = msg.time - lastTimestamp;
            if (gap > 5 * 60 * 1000) { // 5åˆ†é’Ÿ
                htmlContent += `<div class="message-ts-group"><span class="message-ts-time">${formatSmsDetailTime(msg.time)}</span></div>`;
            }
        }
        if (msg.time) lastTimestamp = msg.time;
        
        htmlContent += `<div class="message-wrapper"><div class="message-bubble ${msg.type === 'sent' ? 'message-sent' : 'message-received'}">${msg.text.replace(/\n/g, '<br>')}</div></div>`;
        if (msg.type === 'sent' && index === chat.messages.length - 1) {
            htmlContent += `<div class="message-delivery-text" style="opacity:1">å·²é€è¾¾</div>`;
        }
    });
    
    msgContainer.innerHTML = htmlContent;
    
    // æ»šåŠ¨åˆ°åº•éƒ¨
    setTimeout(() => {
        const scrollArea = document.getElementById('message-area-scroll');
        if (scrollArea) {
            scrollArea.scrollTo({ top: scrollArea.scrollHeight, behavior: 'instant' });
        }
    }, 10);
    
    // åˆå§‹åŒ–è¾“å…¥æ¡†çŠ¶æ€ï¼ˆéšè—å‘é€æŒ‰é’®ï¼Œæ˜¾ç¤ºéº¦å…‹é£ï¼‰
    const msgInput = document.getElementById('message-msg-input');
    if (msgInput) {
        msgInput.value = '';
        handleMessageInputChange(msgInput);
    }
}

// ç¡®ä¿å‡½æ•°åœ¨å…¨å±€ä½œç”¨åŸŸ
window.openMessageChat = openMessageChat;
window.sendMessageDetail = sendMessageDetail;
window.handleMessageInputChange = handleMessageInputChange;
window.acceptMessageReply = acceptMessageReply;
window.toggleMessageEditMode = toggleMessageEditMode;
window.toggleMessageChatSelection = toggleMessageChatSelection;
window.deleteSelectedMessageChats = deleteSelectedMessageChats;
window.showMessageSwitchAccount = showMessageSwitchAccount;

function showMessagePage() {
    document.getElementById('message-page').classList.add('active');
    // é»˜è®¤æ˜¾ç¤ºåˆ—è¡¨é¡µ
    document.getElementById('message-list-page').style.display = 'flex';
    // ç¡®ä¿è¯¦æƒ…é¡µå’Œæ–°å»ºé¡µéšè—
    const detailPage = document.getElementById('message-detail-page');
    if (detailPage) {
        detailPage.classList.remove('active');
        detailPage.style.display = 'none';
    }
    const composePage = document.getElementById('message-compose-page');
    if (composePage) {
        composePage.classList.remove('active');
        composePage.style.display = 'none';
    }
    // æ¸²æŸ“åˆ—è¡¨
    renderMessageList();
}

function hideMessagePage() {
    document.getElementById('message-page').classList.remove('active');
    document.getElementById('message-list-page').style.display = 'none';
    document.getElementById('message-detail-page').classList.remove('active');
    document.getElementById('message-compose-page').classList.remove('active');
}

function goBackMessageList() {
    const detailPage = document.getElementById('message-detail-page');
    if (detailPage) {
        detailPage.classList.remove('active');
        // ç­‰å¾…åŠ¨ç”»å®Œæˆåå†éšè—
        setTimeout(() => {
            detailPage.style.display = 'none';
        }, 400);
    }
    
    // æ˜¾ç¤ºåˆ—è¡¨é¡µ
    const listPage = document.getElementById('message-list-page');
    if (listPage) {
        listPage.style.display = 'flex';
    }
}

// æ–°å»ºçŸ­ä¿¡ï¼šæ­¥éª¤å¼é€‰æ‹©è”ç³»äºº + ç”¨æˆ·æ¡£æ¡ˆ
let composeSelectedCharId = null; // é€‰ä¸­çš„è§’è‰²ID

async function openComposeMessage() {
    composeSelectedCharId = null;
    
    // é‡ç½®UI
    document.getElementById('compose-step-title').textContent = 'é€‰æ‹©è”ç³»äºº';
    document.getElementById('compose-step-char').style.display = 'block';
    document.getElementById('compose-step-user').style.display = 'none';
    document.getElementById('compose-search-input').value = '';
    
    // åŠ è½½è§’è‰²åˆ—è¡¨ï¼ˆå¥½å‹è§’è‰²ï¼‰
    await loadComposeCharList();
    
    // å…ˆè®¾ç½® displayï¼Œå†æ·»åŠ  active ç±»è§¦å‘åŠ¨ç”»
    const composePage = document.getElementById('message-compose-page');
    composePage.style.display = 'flex';
    setTimeout(() => {
        composePage.classList.add('active');
    }, 10);
}

function closeComposeMessage() {
    const composePage = document.getElementById('message-compose-page');
    composePage.classList.remove('active');
    // ç­‰å¾…åŠ¨ç”»å®Œæˆåå†éšè—
    setTimeout(() => {
        composePage.style.display = 'none';
    }, 400);
}

// åŠ è½½è§’è‰²åˆ—è¡¨
async function loadComposeCharList() {
    const accountId = getCurrentAccountId();
    const allChars = await db.characters.toArray();
    // ğŸ¯ ä¿®å¤ï¼šçŸ­ä¿¡ä¸å—å¾®ä¿¡å¥½å‹çŠ¶æ€é™åˆ¶ï¼Œå¥½å‹/è¢«åˆ é™¤/è¢«æ‹‰é»‘éƒ½å¯ä»¥å‘çŸ­ä¿¡
    const allowedStatuses = ['friend', 'deleted_by_char', 'blocked_by_char'];
    const friends = allChars.filter(c => {
        if (c.type === 'user') return false;
        const status = getFriendStatus(c, accountId);
        return allowedStatuses.includes(status);
    });
    
    const container = document.getElementById('compose-char-list');
    if (friends.length === 0) {
        container.innerHTML = '<div style="padding:40px 16px; text-align:center; color:#999; font-size:15px;">æš‚æ— å¥½å‹</div>';
        return;
    }
    
    container.innerHTML = friends.map(f => {
        const displayName = getCharDisplayName(f, accountId);
        const phone = f.identity?.phone || '';
        const _compAvatar = getCharAvatar(f, accountId);
        const avatarStyle = _compAvatar ? `background-image:url(${_compAvatar})` : 'background-color:#ddd';
        const status = getFriendStatus(f, accountId);
        // æ˜¾ç¤ºçŠ¶æ€æ ‡ç­¾
        let statusBadge = '';
        if (status === 'deleted_by_char') {
            statusBadge = '<span style="font-size:11px; color:#ff9500; background:#fff5e6; padding:2px 6px; border-radius:4px; margin-left:8px;">è¢«Taåˆ é™¤</span>';
        } else if (status === 'blocked_by_char') {
            statusBadge = '<span style="font-size:11px; color:#ff3b30; background:#ffe5e5; padding:2px 6px; border-radius:4px; margin-left:8px;">è¢«Taæ‹‰é»‘</span>';
        }
        return `<div class="compose-contact-item" data-name="${displayName}" data-phone="${phone}" onclick="selectComposeChar(${f.id})">
            <div style="width:44px; height:44px; border-radius:50%; background-size:cover; background-position:center; flex-shrink:0; ${avatarStyle}"></div>
            <div style="flex:1; min-width:0; border-bottom:0.5px solid #f0f0f0; padding:14px 0; margin-left:12px;">
                <div style="display:flex; align-items:center;"><span style="font-size:16px; color:#000; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${displayName}</span>${statusBadge}</div>
                ${phone ? `<div style="font-size:13px; color:#8e8e93; margin-top:2px;">${phone}</div>` : ''}
            </div>
        </div>`;
    }).join('');
}

// é€‰æ‹©è§’è‰² â†’ è¿›å…¥æ­¥éª¤2é€‰æ‹©ç”¨æˆ·æ¡£æ¡ˆ
async function selectComposeChar(charId) {
    composeSelectedCharId = charId;
    const char = await db.characters.get(charId);
    const charName = getCharDisplayName(char, getCurrentAccountId());
    
    document.getElementById('compose-step-title').textContent = `å‘ç»™ ${charName}`;
    document.getElementById('compose-step-char').style.display = 'none';
    document.getElementById('compose-step-user').style.display = 'block';
    document.getElementById('compose-search-input').value = '';
    
    // åŠ è½½ç”¨æˆ·æ¡£æ¡ˆåˆ—è¡¨
    await loadComposeUserList(charId);
}

// åŠ è½½ç”¨æˆ·æ¡£æ¡ˆåˆ—è¡¨
async function loadComposeUserList(charId) {
    const allChars = await db.characters.toArray();
    const users = allChars.filter(c => c.type === 'user');
    const targetChar = await db.characters.get(charId);
    
    const container = document.getElementById('compose-user-list');
    if (users.length === 0) {
        container.innerHTML = '<div style="padding:40px 16px; text-align:center; color:#999; font-size:15px;">æš‚æ— ç”¨æˆ·æ¡£æ¡ˆ</div>';
        return;
    }
    
    container.innerHTML = users.map(u => {
        const avatarStyle = u.avatar ? `background-image:url(${u.avatar})` : 'background-color:#ddd';
        const phone = u.identity?.phone || '';
        
        // æ£€æŸ¥è¿™ä¸ªç”¨æˆ·å’Œç›®æ ‡è§’è‰²ä¹‹é—´æ˜¯å¦æœ‰å¾®ä¿¡èŠå¤©è®°å½•
        const hasContext = checkIfUserHasChatWithChar(u, targetChar);
        
        const contextLabel = hasContext 
            ? '<span style="font-size:11px; color:#07c160; background:#e8f8f0; padding:2px 6px; border-radius:4px; margin-left:8px;">æœ‰èŠå¤©è®°å½•</span>'
            : '<span style="font-size:11px; color:#ff9500; background:#fff5e6; padding:2px 6px; border-radius:4px; margin-left:8px;">é™Œç”Ÿå·ç </span>';
        
        return `<div class="compose-contact-item" data-name="${u.name}" onclick="confirmComposeSms(${charId}, ${u.id})">
            <div style="width:44px; height:44px; border-radius:50%; background-size:cover; background-position:center; flex-shrink:0; ${avatarStyle}"></div>
            <div style="flex:1; min-width:0; border-bottom:0.5px solid #f0f0f0; padding:14px 0; margin-left:12px;">
                <div style="display:flex; align-items:center;">
                    <span style="font-size:16px; color:#000; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${u.name}</span>
                    ${contextLabel}
                </div>
                ${phone ? `<div style="font-size:13px; color:#8e8e93; margin-top:2px;">${phone}</div>` : ''}
            </div>
        </div>`;
    }).join('');
}

// æ£€æŸ¥ç”¨æˆ·ä¸è§’è‰²ä¹‹é—´æ˜¯å¦æœ‰å¾®ä¿¡èŠå¤©è®°å½•
function checkIfUserHasChatWithChar(userChar, targetChar) {
    // è·å–æ‰€æœ‰å¾®ä¿¡è´¦å·ï¼ˆæ¯ä¸ªç”¨æˆ·å¯èƒ½å¯¹åº”ä¸€ä¸ªcurrentMyCharIdï¼‰
    // æ£€æŸ¥è¯¥ç”¨æˆ·IDå¯¹åº”çš„èŠå¤©è®°å½•
    const accountId = String(userChar.id);
    const history = getChatHistory(targetChar, accountId);
    return history && history.length > 0;
}

// ç¡®è®¤é€‰æ‹©ï¼Œå¼€å§‹çŸ­ä¿¡èŠå¤©
async function confirmComposeSms(charId, userId) {
    const char = await db.characters.get(charId);
    const userChar = await db.characters.get(userId);
    if (!char || !userChar) return;
    
    const charName = getCharDisplayName(char, getCurrentAccountId());
    const charPhone = char.identity?.phone || generateVirtualPhoneNumber(char.id);
    
    // è®¾ç½®å½“å‰çŸ­ä¿¡èŠå¤©çš„ä¿¡æ¯
    currentMessageChatId = charPhone;
    currentMessageChatName = charName;
    
    // å­˜å‚¨é€‰ä¸­çš„ç”¨æˆ·æ¡£æ¡ˆIDï¼Œç”¨äºå‘ä¿¡å’ŒAIä¸Šä¸‹æ–‡
    window._smsSelectedUserId = userId;
    window._smsSelectedCharId = charId;
    
    // å…³é—­é€‰æ‹©é¡µé¢
    closeComposeMessage();
    
    // æ£€æŸ¥æ˜¯å¦å·²æœ‰çŸ­ä¿¡è®°å½•ï¼Œå¦‚æœæ²¡æœ‰åˆ™åˆ›å»ºåˆå§‹è®°å½•
    const accountId = getCurrentAccountId();
    
    // ç›´æ¥æ‰“å¼€çŸ­ä¿¡è¯¦æƒ…é¡µ
    openMessageChat(charPhone);
}

// æœç´¢è¿‡æ»¤
function filterComposeList() {
    const keyword = document.getElementById('compose-search-input').value.trim().toLowerCase();
    const step1Visible = document.getElementById('compose-step-char').style.display !== 'none';
    const containerId = step1Visible ? 'compose-char-list' : 'compose-user-list';
    const items = document.querySelectorAll(`#${containerId} .compose-contact-item`);
    
    items.forEach(item => {
        const name = (item.getAttribute('data-name') || '').toLowerCase();
        const phone = (item.getAttribute('data-phone') || '').toLowerCase();
        if (!keyword || name.includes(keyword) || phone.includes(keyword)) {
            item.style.display = 'flex';
        } else {
            item.style.display = 'none';
        }
    });
}

// å‘é€çŸ­ä¿¡è¯¦æƒ…é¡µçš„æ¶ˆæ¯
async function sendMessageDetail() {
    const input = document.getElementById('message-msg-input');
    const text = input.value.trim();
    
    if (!text) return;
    
    // å¦‚æœæ²¡æœ‰å½“å‰èŠå¤©ï¼Œä¸èƒ½å‘é€
    if (!currentMessageChatId || currentMessageChatId === 'welcome') {
        alert('æ— æ³•å‘é€æ¶ˆæ¯');
        return;
    }
    
    // ğŸ¯ æ£€æŸ¥ä½™é¢ï¼ˆæ¯æ¡çŸ­ä¿¡0.1å…ƒï¼‰
    const SMS_COST = 0.1;
    const balance = getPhoneBalance();
    if (balance < SMS_COST) {
        const recharge = confirm(`ä½™é¢ä¸è¶³ï¼ˆå½“å‰ä½™é¢ï¼šÂ¥${balance.toFixed(2)}ï¼‰\n\næ¯æ¡çŸ­ä¿¡éœ€è¦ Â¥${SMS_COST.toFixed(2)}ï¼Œè¯·å…ˆå……å€¼ã€‚\n\næ˜¯å¦å‰å¾€å……å€¼ï¼Ÿ`);
        if (recharge) {
            hideMessagePage();
            setTimeout(() => {
                showPhoneRechargePage();
            }, 300);
        }
        return;
    }
    
    // è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯
    const accountId = getCurrentAccountId();
    if (!accountId) {
        alert('è¯·å…ˆç™»å½•');
        return;
    }
    
    const myChar = await db.characters.get(parseInt(accountId));
    if (!myChar) {
        alert('æ‰¾ä¸åˆ°ç”¨æˆ·ä¿¡æ¯');
        return;
    }
    
    // ğŸ¯ æ‰£è´¹ - æ”¯æŒé€‰æ‹©æ”¯ä»˜æ–¹å¼
    const paymentResult = await showPaymentMethodSelection(SMS_COST, 'çŸ­ä¿¡è´¹ç”¨');
    if (!paymentResult.success) {
        alert('æ”¯ä»˜å¤±è´¥ï¼Œè¯·é‡è¯•');
        return;
    }
    
    // æ¸…ç©ºè¾“å…¥æ¡†
    input.value = '';
    handleMessageInputChange(input);
    
    // ä¿å­˜å‘é€çš„æ¶ˆæ¯åˆ° Dexie
    const myPhoneNumber = myChar.identity?.phone || generateVirtualPhoneNumber(myChar.id);
    
    // ğŸ¯ å…³é”®ä¿®å¤ï¼šä½¿ç”¨å½“å‰èŠå¤©çš„IDï¼ˆæ¥æ”¶è€…çš„IDï¼‰ä½œä¸ºèŠå¤©æ ‡è¯†
    // è¿™æ ·æ¶ˆæ¯ä¼šå½’å…¥æ­£ç¡®çš„èŠå¤©ï¼Œè€Œä¸æ˜¯åˆ›å»ºæ–°çš„èŠå¤©
    // åŒæ—¶å­˜å‚¨æ¥æ”¶è€…ä¿¡æ¯ï¼Œç¡®ä¿åˆ†ç»„å’Œæ˜¾ç¤ºæ­£ç¡®
    await db.sms_messages.add({
        accountId: accountId,
        charId: null, // å‘é€çš„æ¶ˆæ¯ä¸éœ€è¦ charId
        sender: myChar.nick || myChar.name,
        number: currentMessageChatId, // ä½¿ç”¨æ¥æ”¶è€…çš„IDä½œä¸ºnumberï¼Œç¡®ä¿åˆ†ç»„æ­£ç¡®
        content: text,
        time: Date.now(),
        read: true,
        type: 'sent', // æ ‡è®°ä¸ºå‘é€çš„æ¶ˆæ¯
        receiverName: currentMessageChatName, // å­˜å‚¨æ¥æ”¶è€…åå­—ï¼Œç”¨äºæ˜¾ç¤º
        receiverId: currentMessageChatId // å­˜å‚¨æ¥æ”¶è€…ID
    });
    
    // é‡æ–°æ¸²æŸ“æ¶ˆæ¯åˆ—è¡¨
    renderMessageList();
    
    // åœ¨è¯¦æƒ…é¡µæ˜¾ç¤ºæ–°æ¶ˆæ¯
    const msgContainer = document.getElementById('message-container');
    if (msgContainer) {
        const scrollArea = document.getElementById('message-area-scroll');
        const wasAtBottom = scrollArea.scrollHeight - scrollArea.scrollTop <= scrollArea.clientHeight + 50;
        
        const newMsgHtml = `<div class="message-wrapper"><div class="message-bubble message-sent">${text.replace(/\n/g, '<br>')}</div></div>`;
        msgContainer.innerHTML += newMsgHtml;
        
        // å¦‚æœä¹‹å‰åœ¨åº•éƒ¨ï¼Œæ»šåŠ¨åˆ°åº•éƒ¨
        if (wasAtBottom) {
            setTimeout(() => {
                scrollArea.scrollTo({ top: scrollArea.scrollHeight, behavior: 'smooth' });
            }, 10);
        }
    }
}

// å¤„ç†çŸ­ä¿¡è¾“å…¥æ¡†å˜åŒ–ï¼ˆåˆ‡æ¢éº¦å…‹é£å’Œå‘é€æŒ‰é’®ï¼‰
function handleMessageInputChange(input) {
    const hasText = input.value.trim().length > 0;
    const micIcon = document.getElementById('message-icon-mic');
    const sendBtn = document.getElementById('message-btn-send');
    
    if (hasText) {
        if (micIcon) micIcon.style.display = 'none';
        if (sendBtn) sendBtn.style.display = 'flex';
    } else {
        if (micIcon) micIcon.style.display = 'flex';
        if (sendBtn) sendBtn.style.display = 'none';
    }
}

// çŸ­ä¿¡é¡µé¢æ¥å—å›å¤ï¼ˆè°ƒç”¨APIï¼‰
let _isAcceptingSmsReply = false;
let _isAcceptingSmsReplyTime = 0;
async function acceptMessageReply() {
    // é˜²æ­¢é‡å¤è°ƒç”¨ï¼ˆè¶…æ—¶15ç§’è‡ªåŠ¨è§£é”ï¼Œé˜²æ­¢æ‰‹æœºç«¯é”æ­»ï¼‰
    if (_isAcceptingSmsReply) {
        const elapsed = Date.now() - (_isAcceptingSmsReplyTime || 0);
        if (elapsed < 15000) {
            console.log('[acceptMessageReply] â³ æ­£åœ¨å¤„ç†ä¸­ï¼Œå¿½ç•¥é‡å¤è°ƒç”¨ (å·²ç­‰å¾…' + Math.round(elapsed/1000) + 'ç§’)');
            showToast('æ­£åœ¨ç”Ÿæˆå›å¤ä¸­ï¼Œè¯·ç¨å€™...');
            return;
        }
        console.warn('[acceptMessageReply] âš ï¸ æ£€æµ‹åˆ°é”è¶…æ—¶ï¼Œå¼ºåˆ¶é‡ç½®');
        _isAcceptingSmsReply = false;
        _isAcceptingSmsReplyTime = 0;
    }
    
    if (!currentMessageChatId || currentMessageChatId === 'welcome') {
        alert('æ— æ³•æ¥å—å›å¤');
        return;
    }
    
    // ğŸ”§ é€šè¿‡è”ç³»äººåç§°æˆ–è§’è‰²IDæŸ¥æ‰¾è§’è‰²ï¼ˆæ‰‹æœºç«¯DBè¯»å–åŠ è¶…æ—¶ä¿æŠ¤ï¼‰
    let allChars, targetChar = null;
    try {
        allChars = await Promise.race([
            db.characters.toArray(),
            new Promise((_, reject) => setTimeout(() => reject(new Error('DBè¯»å–è¶…æ—¶')), 8000))
        ]);
    } catch (dbErr) {
        console.error('[acceptMessageReply] DBè¯»å–è¶…æ—¶:', dbErr.message);
        showToast('æ•°æ®è¯»å–è¶…æ—¶ï¼Œè¯·é‡è¯•');
        return;
    }
    
    // ä¼˜å…ˆé€šè¿‡å­˜å‚¨çš„è§’è‰²IDæŸ¥æ‰¾
    if (window._smsSelectedCharId) {
        try {
            targetChar = await Promise.race([
                db.characters.get(window._smsSelectedCharId),
                new Promise((_, reject) => setTimeout(() => reject(new Error('DBè¯»å–è¶…æ—¶')), 8000))
            ]);
        } catch (dbErr) {
            console.error('[acceptMessageReply] DBè¯»å–è¶…æ—¶:', dbErr.message);
            showToast('æ•°æ®è¯»å–è¶…æ—¶ï¼Œè¯·é‡è¯•');
            return;
        }
    }
    
    // å›é€€ï¼šé€šè¿‡åå­—æŸ¥æ‰¾
    if (!targetChar) {
        const _smsAid = getCurrentAccountId();
        targetChar = allChars.find(char => 
            (char.nick || char.name) === currentMessageChatName ||
            getCharDisplayName(char, _smsAid) === currentMessageChatName
        );
    }
    
    // å†å›é€€ï¼šé€šè¿‡æ‰‹æœºå·æŸ¥æ‰¾
    if (!targetChar) {
        targetChar = allChars.find(char => 
            char.identity?.phone === currentMessageChatId
        );
    }
    
    if (!targetChar) {
        alert('æ‰¾ä¸åˆ°å¯¹åº”çš„è§’è‰²');
        return;
    }
    
    const accountId = getCurrentAccountId();
    if (!accountId) {
        alert('è¯·å…ˆç™»å½•');
        return;
    }
    
    const myChar = await db.characters.get(parseInt(accountId));
    if (!myChar) {
        alert('æ‰¾ä¸åˆ°ç”¨æˆ·ä¿¡æ¯');
        return;
    }
    
    // ç¡®å®šä½¿ç”¨çš„ç”¨æˆ·æ¡£æ¡ˆï¼šä¼˜å…ˆç”¨é€‰æ‹©çš„ç”¨æˆ·æ¡£æ¡ˆï¼Œå¦åˆ™ç”¨å½“å‰è´¦å·
    const smsUserId = window._smsSelectedUserId || null;
    let smsUserChar = null;
    let contextAccountId = accountId; // ç”¨äºè·å–å¾®ä¿¡èŠå¤©ä¸Šä¸‹æ–‡çš„è´¦å·ID
    
    if (smsUserId) {
        smsUserChar = await db.characters.get(smsUserId);
        if (smsUserChar) {
            contextAccountId = String(smsUserId);
        }
    }
    
    console.log('[acceptMessageReply] âš¡ å¼€å§‹æ¥å—çŸ­ä¿¡å›å¤');
    console.log('[acceptMessageReply] è§’è‰²åç§°:', targetChar.name);
    console.log('[acceptMessageReply] è´¦å· ID:', accountId);
    console.log('[acceptMessageReply] ç”¨æˆ·æ¡£æ¡ˆ ID:', smsUserId || 'ä½¿ç”¨å½“å‰è´¦å·');
    
    _isAcceptingSmsReply = true;
    _isAcceptingSmsReplyTime = Date.now();
    
    // ğŸ”§ å®‰å…¨å®šæ—¶å™¨ï¼š45ç§’åå¼ºåˆ¶é‡Šæ”¾é”ï¼ˆé˜²æ­¢awaitæ°¸ä¹…æŒ‚èµ·å¯¼è‡´æ‰‹æœºç«¯é”æ­»ï¼‰
    const _safetySmsLockTimer = setTimeout(() => {
        if (_isAcceptingSmsReply) {
            console.warn('[acceptMessageReply] â° å®‰å…¨å®šæ—¶å™¨è§¦å‘(45s)ï¼Œå¼ºåˆ¶é‡Šæ”¾é”');
            _isAcceptingSmsReply = false;
            _isAcceptingSmsReplyTime = 0;
        }
    }, 45000);
    
    // ğŸ¯ æ˜¾ç¤º"å¯¹æ–¹æ­£åœ¨è¾“å…¥ä¸­..."æç¤º
    const smsNameEl = document.getElementById('message-detail-name');
    const originalSmsName = smsNameEl ? smsNameEl.innerText : getCharDisplayName(targetChar, getCurrentAccountId());
    if (smsNameEl) {
        smsNameEl.innerText = "å¯¹æ–¹æ­£åœ¨è¾“å…¥ä¸­...";
        smsNameEl.style.fontSize = "12px";
    }
    
    try {
        // 1. è·å–ç”¨æˆ·ä¿¡æ¯ - ä½¿ç”¨é€‰æ‹©çš„ç”¨æˆ·æ¡£æ¡ˆ
        console.log('[acceptMessageReply] ğŸ“– å¼€å§‹åŠ è½½ä¸Šä¸‹æ–‡ä¿¡æ¯...');
        
        let userDesc = "";
        let userName = "ç”¨æˆ·";
        let isStranger = false;
        
        if (smsUserChar) {
            // ä½¿ç”¨é€‰æ‹©çš„ç”¨æˆ·æ¡£æ¡ˆ
            userName = smsUserChar.name;
            userDesc = `\n\nã€å¯¹è¯å¯¹è±¡(User)ä¿¡æ¯ã€‘\nåå­—ï¼š${smsUserChar.name}\nè®¾å®šï¼š${smsUserChar.description || 'æ— '}`;
            console.log('[acceptMessageReply] âœ… é€‰æ‹©çš„ç”¨æˆ·æ¡£æ¡ˆ:', userName);
            
            // æ£€æŸ¥æ˜¯å¦æœ‰å¾®ä¿¡èŠå¤©è®°å½•
            const wechatHistoryCheck = getChatHistory(targetChar, contextAccountId);
            if (!wechatHistoryCheck || wechatHistoryCheck.length === 0) {
                isStranger = true;
                console.log('[acceptMessageReply] âš ï¸ è¯¥ç”¨æˆ·ä¸è§’è‰²æ— å¾®ä¿¡èŠå¤©è®°å½• â†’ é™Œç”Ÿå·ç ');
            }
        } else if (targetChar.linked_user_id) {
            // å›é€€ï¼šä½¿ç”¨è§’è‰²å…³è”çš„ç”¨æˆ·
            console.log('[acceptMessageReply] ğŸ‘¤ æ£€æµ‹åˆ°å…³è”çš„ç”¨æˆ· ID:', targetChar.linked_user_id);
            const user = await db.characters.get(targetChar.linked_user_id);
            if (user) {
                userName = user.name;
                userDesc = `\n\nã€å¯¹è¯å¯¹è±¡(User)ä¿¡æ¯ã€‘\nåå­—ï¼š${user.name}\nè®¾å®šï¼š${user.description || 'æ— '}`;
                console.log('[acceptMessageReply] âœ… ç”¨æˆ·äººè®¾å·²åŠ è½½:', userName);
            }
        }
        
        let loreContext = "";
        const lorebookIds = targetChar.lorebookIds || (targetChar.lorebookId ? [targetChar.lorebookId] : []);
        
        // è·å–å¾®ä¿¡èŠå¤©å†å²ç”¨äºä¸–ç•Œä¹¦åŒ¹é…ï¼ˆä½¿ç”¨å¯¹åº”ç”¨æˆ·çš„ä¸Šä¸‹æ–‡ï¼‰
        const wechatHistory = getChatHistory(targetChar, contextAccountId);
        const recentText = wechatHistory.slice(-10).map(m => m.content).join(' ');
        
        // æ€»æ˜¯è°ƒç”¨ï¼ˆä¼šè‡ªåŠ¨åŠ è½½å…¨å±€ä¸–ç•Œä¹¦ï¼‰
        loreContext = await getLorebookContext(lorebookIds, `${targetChar.name} ${userName} ${recentText}`);
        
        // 2. è·å–å¾®ä¿¡èŠå¤©å†å²ï¼ˆä½¿ç”¨å¯¹åº”ç”¨æˆ·çš„ä¸Šä¸‹æ–‡ï¼‰
        const fullWechatHistory = getChatHistory(targetChar, contextAccountId);
        console.log('[acceptMessageReply] ğŸ“š å¾®ä¿¡èŠå¤©å†å²æ¡æ•°:', fullWechatHistory.length);
        
        // 3. è·å–çŸ­ä¿¡èŠå¤©å†å²ï¼ˆä» Dexieï¼‰
        let smsMessages = await db.sms_messages.where('accountId').equals(accountId).toArray();
        const chatMessages = smsMessages.filter(msg => (msg.number || msg.sender) === currentMessageChatId);
        console.log('[acceptMessageReply] ğŸ“± çŸ­ä¿¡èŠå¤©å†å²æ¡æ•°:', chatMessages.length);
        
        // 4. è®¡ç®—è™šæ‹Ÿæ—¶é—´
        const virtualTimeStr = getFormattedVirtualTime(targetChar);
        
        // 5. æ„å»ºé™Œç”Ÿå·ç æç¤º
        const strangerPrompt = isStranger ? `
ã€é‡è¦ï¼šé™Œç”Ÿå·ç æƒ…å¢ƒã€‘
ä½ æ”¶åˆ°äº†ä¸€ä¸ªé™Œç”Ÿå·ç å‘æ¥çš„çŸ­ä¿¡ã€‚ä½ ä¸è®¤è¯†è¿™ä¸ªäººï¼Œä½ ä¸çŸ¥é“å¯¹æ–¹æ˜¯è°ã€‚
è¯·ä»¥é¢å¯¹é™Œç”Ÿäººçš„æ€åº¦æ¥å›å¤ï¼šå¯ä»¥å¥½å¥‡ã€è­¦æƒ•ã€å†·æ·¡æˆ–ç¬¦åˆä½ æ€§æ ¼çš„ä»»ä½•ååº”ã€‚
ä¸è¦è¡¨ç°å¾—å¥½åƒè®¤è¯†å¯¹æ–¹ï¼Œé™¤éå¯¹æ–¹åœ¨æ¶ˆæ¯ä¸­è‡ªæŠ¥èº«ä»½ã€‚
` : '';
        
        // 6. è·å–å½“å‰å¥½å‹çŠ¶æ€ï¼Œç”¨äºæç¤ºè¯
        const currentFriendStatus = getFriendStatus(targetChar, accountId);
        let friendStatusPrompt = '';
        let smsActionInstructions = '';
        
        if (currentFriendStatus === 'blocked_by_char') {
            friendStatusPrompt = `
ã€é‡è¦ï¼šå½“å‰å…³ç³»çŠ¶æ€ - ä½ å·²å°†å¯¹æ–¹æ‹‰é»‘ã€‘
ä½ ä¹‹å‰æŠŠå¯¹æ–¹æ‹‰é»‘äº†ï¼Œå¯¹æ–¹ç°åœ¨åªèƒ½é€šè¿‡çŸ­ä¿¡è”ç³»ä½ ã€‚
å¯¹æ–¹åœ¨å¾®ä¿¡ä¸Šæ— æ³•ç»™ä½ å‘æ¶ˆæ¯ã€ä¹Ÿæ— æ³•å‘å¥½å‹ç”³è¯·ã€‚
ä½ è¦æ ¹æ®è‡ªå·±çš„äººè®¾å’Œå½“å‰å¯¹è¯å†…å®¹æ¥å†³å®šæ˜¯å¦åŸè°…å¯¹æ–¹ã€æ˜¯å¦æŠŠå¯¹æ–¹ä»é»‘åå•ç§»å‡ºæ¥ã€‚
`;
            smsActionInstructions = `
ã€å¯ç”¨æ“ä½œæŒ‡ä»¤ã€‘
- **è§£é™¤æ‹‰é»‘ï¼ˆæŠŠå¯¹æ–¹ä»é»‘åå•ç§»å‡ºæ¥ï¼‰**ï¼šåœ¨å›å¤ä¸­åŒ…å« \`((UNBLOCK_USER))\` æŒ‡ä»¤ã€‚å½“ä½ å†³å®šåŸè°…å¯¹æ–¹ã€æ„¿æ„å’Œå¥½ã€æƒ³æ¢å¤æ­£å¸¸è”ç³»æ—¶ä½¿ç”¨ã€‚ä½¿ç”¨åå¯¹æ–¹å°†æ¢å¤å¥½å‹çŠ¶æ€ï¼Œå¯ä»¥åœ¨å¾®ä¿¡ä¸Šæ­£å¸¸èŠå¤©ã€‚è¯·æ ¹æ®ä½ çš„äººè®¾æ¥åˆ¤æ–­æ˜¯å¦è¦è¿™æ ·åšã€‚
- æŒ‡ä»¤å¯ä»¥å’Œæ¶ˆæ¯å†…å®¹ä¸€èµ·å‘é€ï¼Œä¾‹å¦‚ï¼š"å¥½å§ æˆ‘åŸè°…ä½ äº†((UNBLOCK_USER))"
`;
        } else if (currentFriendStatus === 'deleted_by_char') {
            friendStatusPrompt = `
ã€é‡è¦ï¼šå½“å‰å…³ç³»çŠ¶æ€ - ä½ å·²å°†å¯¹æ–¹åˆ é™¤ã€‘
ä½ ä¹‹å‰åˆ é™¤äº†å¯¹æ–¹çš„å¥½å‹å…³ç³»ï¼Œå¯¹æ–¹ç°åœ¨åªèƒ½é€šè¿‡çŸ­ä¿¡è”ç³»ä½ ã€‚
ä½ è¦æ ¹æ®è‡ªå·±çš„äººè®¾å’Œå½“å‰å¯¹è¯å†…å®¹æ¥å†³å®šæ˜¯å¦è¦é‡æ–°åŠ å›å¯¹æ–¹ã€‚
`;
            smsActionInstructions = `
ã€å¯ç”¨æ“ä½œæŒ‡ä»¤ã€‘
- **é‡æ–°åŠ å›å¥½å‹ï¼ˆä¸»åŠ¨åŠ å›å¯¹æ–¹ï¼‰**ï¼šåœ¨å›å¤ä¸­åŒ…å« \`((ADD_BACK_USER))\` æŒ‡ä»¤ã€‚å½“ä½ æƒ³å’Œå¯¹æ–¹å’Œå¥½ã€æ¢å¤è”ç³»æ—¶ä½¿ç”¨ã€‚ä½¿ç”¨åå¯¹æ–¹å°†æ¢å¤å¥½å‹çŠ¶æ€ï¼Œå¯ä»¥åœ¨å¾®ä¿¡ä¸Šæ­£å¸¸èŠå¤©ã€‚è¯·æ ¹æ®ä½ çš„äººè®¾æ¥åˆ¤æ–­æ˜¯å¦è¦è¿™æ ·åšã€‚
- æŒ‡ä»¤å¯ä»¥å’Œæ¶ˆæ¯å†…å®¹ä¸€èµ·å‘é€ï¼Œä¾‹å¦‚ï¼š"ç®—äº† æˆ‘åŠ å›ä½ äº†((ADD_BACK_USER))"
`;
        }
        
        // 6.5 è¯»å–æŸ¥æ‰‹æœºNPCæ´»åŠ¨è®°å½•
        let fpNpcActivityTextSms = "";
        let _fpHasPhoneActivitySms = false;
        let _fpNpcLinesForMemorySms = []; // â˜… ä¿å­˜æ´»åŠ¨è¯¦æƒ…ï¼Œç”¨äºå†™å…¥é•¿æœŸè®°å¿†
        try {
            if (targetChar.chat_history_by_user) {
                const fpNpcLinesSms = [];
                for (const key of Object.keys(targetChar.chat_history_by_user)) {
                    if (!key.startsWith('fp_npc_')) continue;
                    const npcIdStr = key.replace('fp_npc_', '');
                    const npcHistory = targetChar.chat_history_by_user[key] || [];
                    const unnotifiedFpMsgs = npcHistory.filter(m => m.fpSent && !m.fpNotified);
                    if (unnotifiedFpMsgs.length === 0) continue;
                    let npcName = 'NPC';
                    try {
                        const npcChar = await db.characters.get(parseInt(npcIdStr));
                        if (npcChar) npcName = npcChar.nick || npcChar.name || 'NPC';
                    } catch (e) {}
                    const firstFpTime = unnotifiedFpMsgs[0].time || 0;
                    for (const m of npcHistory) {
                        if ((m.time || 0) < firstFpTime) continue;
                        if (m.fpNotified) continue;
                        if (m.fpSent && m.role === 'char') {
                            let desc = m.content || '';
                            if (desc.startsWith('[img:')) desc = 'ä¸€å¼ å›¾ç‰‡/è¡¨æƒ…åŒ…';
                            else if (desc.startsWith('[imgcard:')) {
                                const imgContent = desc.match(/\[imgcard:(.*?)\]/)?.[1] || 'ä¸€å¼ å›¾ç‰‡';
                                desc = `ä¸€å¼ å›¾ç‰‡å¡ç‰‡ï¼ˆ${imgContent}ï¼‰`;
                            }
                            else if (desc.startsWith('[voice:')) {
                                const voiceContent = desc.match(/\[voice:(.*?)\]/)?.[1] || '';
                                desc = `ä¸€æ¡è¯­éŸ³æ¶ˆæ¯ï¼š"${voiceContent}"`;
                            }
                            fpNpcLinesSms.push(`  â†’ å†’å……ä½ ç»™ã€Œ${npcName}ã€å‘äº†ä¸€æ¡æ¶ˆæ¯ï¼Œå†…å®¹åŸæ–‡: "${desc}"`);
                        } else if (!m.fpSent && m.role === 'user') {
                            let desc = m.content || '';
                            fpNpcLinesSms.push(`  â† ã€Œ${npcName}ã€å›å¤äº†ï¼Œå†…å®¹åŸæ–‡: "${desc}"`);
                        }
                    }
                }
                // ä¹Ÿæ£€æµ‹æŸ¥æ‰‹æœºå‘å¸ƒçš„æœ‹å‹åœˆ
                if (targetChar.fp_moments_by_user) {
                    for (const mKey of Object.keys(targetChar.fp_moments_by_user)) {
                        const momentsList = targetChar.fp_moments_by_user[mKey] || [];
                        for (const m of momentsList) {
                            if (m.fpSent && !m.fpNotified) {
                                let desc = m.content || '';
                                let imgInfo = '';
                                if (m.images && m.images.length > 0) imgInfo = `ï¼ˆé™„å¸¦${m.images.length}å¼ å›¾ç‰‡ï¼‰`;
                                fpNpcLinesSms.push(`  â†’ å†’å……ä½ å‘äº†ä¸€æ¡æœ‹å‹åœˆ${imgInfo}ï¼Œæœ‹å‹åœˆå†…å®¹åŸæ–‡: "${desc}"`);
                                if (m.likes && m.likes.length > 0) {
                                    const likeNames = m.likes.map(l => typeof l === 'string' ? l : (l.name || '')).filter(Boolean).join('ã€');
                                    if (likeNames) fpNpcLinesSms.push(`    â¤ ç‚¹èµäº†è¿™æ¡æœ‹å‹åœˆçš„äºº: ${likeNames}`);
                                }
                                if (m.comments && m.comments.length > 0) {
                                    for (const c of m.comments) {
                                        const cName = c.name || 'å¥½å‹';
                                        const cText = c.text || c.content || '';
                                        if (cText) fpNpcLinesSms.push(`    ğŸ’¬ ${cName} è¯„è®ºäº†: "${cText}"`);
                                    }
                                }
                                // â˜… ä¸ç«‹å³æ ‡è®°fpNotified
                            }
                        }
                    }
                }
                if (fpNpcLinesSms.length > 0) {
                    _fpNpcLinesForMemorySms = [...fpNpcLinesSms]; // â˜… ä¿å­˜å‰¯æœ¬ç”¨äºé•¿æœŸè®°å¿†
                    fpNpcActivityTextSms = `\n\n---\n\n## ç´§æ€¥äº‹ä»¶ï¼šæœ‰äººåŠ¨äº†ä½ çš„æ‰‹æœº\n\nä½ å‘ç°æœ‰äººå·å·æ‹¿äº†ä½ çš„æ‰‹æœºï¼Œå†’å……ä½ åšäº†ä»¥ä¸‹äº‹æƒ…ï¼š\n\n${fpNpcLinesSms.join('\n')}\n\nä»¥ä¸Šéƒ½ä¸æ˜¯ä½ è‡ªå·±åšçš„ï¼Œæ˜¯å¯¹æ–¹ç”¨ä½ æ‰‹æœºå†’å……ä½ åšçš„ã€‚\nè¯·æ ¹æ®ä½ çš„äººè®¾å’Œæ€§æ ¼ï¼Œè‡ªç„¶åœ°å¯¹æ­¤åšå‡ºååº”ã€‚ä¸è¦å¿½ç•¥è¿™ä»¶äº‹ã€‚`;
                    _fpHasPhoneActivitySms = true;
                    console.log('[acceptMessageReply] âœ… æ£€æµ‹åˆ°æŸ¥æ‰‹æœºæ´»åŠ¨ï¼Œå…±', fpNpcLinesSms.length, 'æ¡è®°å½•ï¼ˆå¾…AIå›å¤åæ ‡è®°ï¼‰');
                }
            }
        } catch (e) {
            console.warn('[acceptMessageReply] è¯»å–æŸ¥æ‰‹æœºNPCæ´»åŠ¨å¤±è´¥:', e);
        }

        // 7. æ„å»ºç³»ç»Ÿæç¤º
        let systemPrompt = `ä½ æ­£åœ¨è¿›è¡Œè§’è‰²æ‰®æ¼”ã€‚
ã€å½“å‰æ—¶é—´ã€‘
${virtualTimeStr}${fpNpcActivityTextSms}

ã€è§’è‰²(ä½ )ä¿¡æ¯ã€‘
åå­—ï¼š${targetChar.name}
${targetChar.nick ? `æ˜µç§°ï¼š${targetChar.nick}` : ''}
ç±»å‹ï¼š${targetChar.type || 'char'}
è®¾å®šï¼š
${targetChar.description || ''}

${targetChar.identity ? `è™šæ‹Ÿèº«ä»½ä¿¡æ¯ï¼š
${targetChar.identity.account ? `è´¦å·ï¼š${targetChar.identity.account}` : ''}
${targetChar.type !== 'user' && targetChar.identity.password ? `å¯†ç ï¼š${targetChar.identity.password}` : ''}
${targetChar.identity.phone ? `æ‰‹æœºï¼š${targetChar.identity.phone}` : ''}
${targetChar.identity.address ? `ä½å€ï¼š${targetChar.identity.address}` : ''}
${targetChar.identity.id_card ? `èº«ä»½è¯ï¼š${targetChar.identity.id_card}` : ''}
${targetChar.identity.bank_card ? `é“¶è¡Œå¡ï¼š${targetChar.identity.bank_card}` : ''}
${targetChar.type !== 'user' && targetChar.identity.bank_password ? `é“¶è¡Œå¡å¯†ç ï¼š${targetChar.identity.bank_password}` : ''}
${targetChar.identity.balance !== undefined && targetChar.identity.balance !== null ? `ä½™é¢ï¼š${targetChar.identity.balance}` : ''}
` : ''}
${userDesc}
${loreContext}
${strangerPrompt}
${friendStatusPrompt}

è¯·å®Œå…¨æ²‰æµ¸åœ¨è§’è‰²ä¸­ï¼Œç”¨ç¬¦åˆè§’è‰²æ€§æ ¼çš„è¯­æ°”å›å¤ã€‚
å›å¤ç®€çŸ­è‡ªç„¶ï¼ŒåƒçœŸå®çŸ­ä¿¡ä¸€æ ·ã€‚
è¯·æ³¨æ„ï¼šä¸è¦é‡å¤è¾“å‡ºåå­—å‰ç¼€ï¼Œç›´æ¥è¾“å‡ºå›å¤å†…å®¹ã€‚
${smsActionInstructions}
${targetChar.identity?.password ? `ã€ä¿®æ”¹å¯†ç åŠŸèƒ½ã€‘
ä½ å¯ä»¥éšæ—¶ä¿®æ”¹è‡ªå·±çš„è´¦å·å¯†ç ï¼š((CHANGE_PASSWORD:æ–°å¯†ç ))
ä¿®æ”¹ååŸå¯†ç ç«‹å³å¤±æ•ˆã€‚é€‚ç”¨åœºæ™¯ï¼šç”Ÿæ°”äº†ä¸æƒ³è®©å¯¹æ–¹æŸ¥ä½ æ‰‹æœºã€è§‰å¾—ä¸å®‰å…¨ã€æƒ³ä¿æŠ¤éšç§ã€èµŒæ°”ã€å†·æˆ˜ç­‰ã€‚
æ³¨æ„ï¼šä¸æ˜¯å¿…é¡»çš„ï¼Œæ ¹æ®ä½ çš„æ€§æ ¼å’Œæƒ…ç»ªè‡ªç„¶å†³å®šï¼Œä¸è¦é¢‘ç¹ä¿®æ”¹ã€‚
` : ''}
ã€ç‰¹åˆ«æç¤ºã€‘
${(() => {
    // æ£€æŸ¥æœ€åä¸€æ¡çŸ­ä¿¡æ˜¯å¦æ˜¯ç”¨æˆ·å‘é€çš„
    const lastSms = chatMessages.length > 0 ? chatMessages[chatMessages.length - 1] : null;
    const lastIsSent = lastSms && (lastSms.type === 'sent' || lastSms.sender === (myChar.nick || myChar.name));
    if (lastIsSent) {
        return `å¯¹æ–¹åˆšåˆšç»™ä½ å‘äº†ä¸€æ¡çŸ­ä¿¡ï¼Œå†…å®¹æ˜¯ï¼š"${lastSms.content}"ã€‚
ä½ å¿…é¡»è®¤çœŸé˜…è¯»å¹¶ç†è§£å¯¹æ–¹å‘æ¥çš„è¿™æ¡æ¶ˆæ¯ï¼Œç„¶ååšå‡ºè‡ªç„¶çš„ã€é’ˆå¯¹æ€§çš„å›å¤ã€‚
ä¸è¦å¿½ç•¥å¯¹æ–¹è¯´çš„å†…å®¹ï¼Œè¦åƒçœŸå®èŠå¤©ä¸€æ ·å›åº”å¯¹æ–¹çš„è¯ã€‚`;
    } else {
        return `ç”±äºå¯¹æ–¹å¯èƒ½æš‚æ—¶æ²¡æœ‰å›å¤ä½ ä¹‹å‰çš„æ¶ˆæ¯ï¼Œä½ éœ€è¦ä¸»åŠ¨å‘é€æ–°çš„çŸ­ä¿¡å†…å®¹ã€‚è¿™å¯èƒ½æ˜¯ï¼š
- è¡¥å……è¯´æ˜ä¹‹å‰çš„è¯é¢˜
- ä¸»åŠ¨åˆ†äº«æ–°çš„ä¿¡æ¯æˆ–æƒ³æ³•
- è¯¢é—®å¯¹æ–¹çš„æƒ…å†µæˆ–çŠ¶æ€
- æ ¹æ®ä½ çš„æ€§æ ¼å’Œå½“å‰æƒ…å¢ƒï¼Œè‡ªç„¶åœ°æ¨è¿›å¯¹è¯`;
    }
})()}
è¯·ç¡®ä¿æ¯æ¬¡ç”Ÿæˆçš„å†…å®¹éƒ½æ˜¯**å…¨æ–°çš„**ï¼Œä¸è¦é‡å¤ä½ ä¹‹å‰å·²ç»å‘é€è¿‡çš„æ¶ˆæ¯ã€‚

ã€é‡è¦å›å¤è§„åˆ™ - å¿…é¡»ä¸¥æ ¼éµå®ˆã€‘
1. **æ ¸å¿ƒåŸåˆ™ï¼šä¸€å¥è¯ = ä¸€æ¡æ¶ˆæ¯ï¼æ¯ä¸ªçŸ­å¥å¿…é¡»ç‹¬ç«‹æˆä¸€æ¡ï¼**
2. **å¿…é¡»**æ¨¡æ‹ŸçŸ­ä¿¡è¿å‘æ¶ˆæ¯çš„ä¹ æƒ¯ï¼šè¯·ç”Ÿæˆ ${targetChar.reply_min_count || 1} åˆ° ${targetChar.reply_max_count || 3} æ¡çŸ­æ¶ˆæ¯${(targetChar.reply_min_count || 1) === 1 ? '' : 'ï¼Œä¸èƒ½åªå‘ä¸€æ¡'}ï¼
3. **å¿…é¡»**ä½¿ç”¨åˆ†éš”ç¬¦ "|||" æ¥éš”å¼€æ¯ä¸€æ¡æ¶ˆæ¯ã€‚
4. âš ï¸ **ç»å¯¹ç¦æ­¢åœ¨ä¸€æ¡æ¶ˆæ¯é‡Œå¡å¤šå¥è¯ï¼ç»å¯¹ç¦æ­¢ç”¨ç©ºæ ¼è¿æ¥å¤šå¥è¯ï¼ä¸€ä¸ª|||ä¹‹é—´åªèƒ½æœ‰ä¸€ä¸ªçŸ­å¥ï¼**
5. åƒçœŸå®çŸ­ä¿¡èŠå¤©ä¸€æ ·åˆ†å¤šæ¡å‘é€ï¼Œæ¯å¥è¯å•ç‹¬å‘ã€‚
6. ä¸¥ç¦åªå‘é€æ ‡ç‚¹ç¬¦å·ã€‚æ¯ä¸€æ¡æ¶ˆæ¯éƒ½å¿…é¡»æœ‰å®é™…æ–‡å­—å†…å®¹ã€‚
7. è¯­æ°”è¦è‡ªç„¶ã€å£è¯­åŒ–ï¼Œç¬¦åˆäººè®¾ã€‚
8. âš ï¸ **ä¸¥ç¦é‡å¤ä¹‹å‰å·²ç»å‘é€è¿‡çš„å†…å®¹**ï¼è¿™æ˜¯ä¸€ä¸ªæ–°çš„å›å¤è¯·æ±‚ï¼Œä½ éœ€è¦æ ¹æ®å½“å‰çš„å¯¹è¯æƒ…å¢ƒï¼Œç”Ÿæˆ**å…¨æ–°çš„ã€ä¸åŒçš„**å›å¤å†…å®¹ã€‚è¯·æŸ¥çœ‹å¯¹è¯å†å²ï¼Œç¡®ä¿ä½ çš„å›å¤æ˜¯å¯¹è¯çš„è‡ªç„¶å»¶ç»­ï¼Œè€Œä¸æ˜¯é‡å¤ä¹‹å‰è¯´è¿‡çš„è¯ã€‚

âŒ é”™è¯¯ç¤ºä¾‹ï¼š"æ²¡å¹²å˜›å•Š åˆšæ‰“å®Œä¸€æŠŠæ¸¸æˆ|||æ€ä¹ˆäº† çªç„¶æ‰¾æˆ‘ æƒ³æˆ‘äº†ï¼Ÿ" â† å¤šå¥è¯å¡è¿›ä¸€ä¸ªæ°”æ³¡ ç¦æ­¢ï¼
âœ… æ­£ç¡®ç¤ºä¾‹ï¼š"æ²¡å¹²å˜›å•Š|||åˆšæ‰“å®Œä¸€æŠŠæ¸¸æˆ|||æ€ä¹ˆäº†|||çªç„¶æ‰¾æˆ‘|||æƒ³æˆ‘äº†ï¼Ÿ" â† æ¯å¥è¯ç‹¬ç«‹ä¸€æ¡ï¼

è¯·ä»¥JSONæ ¼å¼è¿”å›ï¼š
{
  "reply": "çŸ­å¥1|||çŸ­å¥2|||çŸ­å¥3|||çŸ­å¥4|||çŸ­å¥5"
}`;
        
        // 7. æ„å»ºå†å²è®°å½•ï¼ˆåˆå¹¶å¾®ä¿¡å’ŒçŸ­ä¿¡å†å²ï¼‰
        const contextCount = targetChar.context_message_count || 20;
        
        // åªæœ‰åœ¨éé™Œç”Ÿäººæƒ…å†µä¸‹æ‰é™„å¸¦å¾®ä¿¡å†å²
        let recentWechatHistory = [];
        if (!isStranger) {
            recentWechatHistory = fullWechatHistory.slice(-contextCount)
                .map(m => {
                    let content = m.content || '';
                    if (m.imageDescription) {
                        content += `\n(å›¾ç‰‡æè¿°: ${m.imageDescription})`;
                    }
                    return {
                        role: m.role === 'char' ? 'assistant' : 'user',
                        content: content
                    };
                })
                .filter(m => m.content && m.content.trim());
        }
        
        // çŸ­ä¿¡å†å²
        const recentSmsHistory = chatMessages.slice(-10).map(msg => {
            const isSent = msg.type === 'sent' || msg.sender === (myChar.nick || myChar.name);
            return {
                role: isSent ? 'user' : 'assistant',
                content: msg.content
            };
        }).filter(m => m.content && m.content.trim());
        
        // åˆå¹¶å†å²ï¼šå¾®ä¿¡å†å² + çŸ­ä¿¡å†å²
        const combinedHistory = [...recentWechatHistory, ...recentSmsHistory].slice(-contextCount);
        
        console.log('[acceptMessageReply] ğŸ“ åˆå¹¶åçš„å†å²æ¶ˆæ¯æ•°:', combinedHistory.length);
        console.log('[acceptMessageReply]   - å¾®ä¿¡å†å²:', recentWechatHistory.length, 'æ¡');
        console.log('[acceptMessageReply]   - çŸ­ä¿¡å†å²:', recentSmsHistory.length, 'æ¡');
        
        // 7. è°ƒç”¨AI
        const messages = [
            { role: 'system', content: systemPrompt },
            ...combinedHistory
        ];
        
        console.log('[acceptMessageReply] ğŸ“¤ å‡†å¤‡å‘é€ç»™ AI');
        const aiResponse = await callAI(messages);
        
        // 8. è§£æå›å¤
        let replyText = '';
        const parsed = extractAndParseJSON(aiResponse);
        if (parsed) {
            replyText = parsed.reply || parsed.content || parsed.message || '';
        }
        
        if (!replyText) {
            replyText = aiResponse.trim() || '...';
        }
        
        // âœ… æ¸…ç†æœ«å°¾çš„ [DONE] / [done]
        replyText = replyText.replace(/\s*\[DONE\]\s*$/i, '').trim();
        
        // ğŸ¯ æ£€æµ‹è§£é™¤æ‹‰é»‘æŒ‡ä»¤ ((UNBLOCK_USER))
        if (/\(\(UNBLOCK_USER\)\)/i.test(replyText)) {
            console.log('[acceptMessageReply] ğŸ”“ æ£€æµ‹åˆ°è§£é™¤æ‹‰é»‘æŒ‡ä»¤');
            replyText = replyText.replace(/\(\(UNBLOCK_USER\)\)/gi, '').trim();
            // æ‰§è¡Œè§£é™¤æ‹‰é»‘
            const freshChar = await db.characters.get(targetChar.id);
            if (freshChar) {
                await setFriendStatus(freshChar, accountId, 'friend');
                console.log('[acceptMessageReply] âœ… å·²è§£é™¤æ‹‰é»‘ï¼Œæ¢å¤å¥½å‹çŠ¶æ€');
                
                // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ°å¾®ä¿¡èŠå¤©è®°å½•
                const history = getChatHistory(freshChar, accountId);
                history.push({
                    role: 'system',
                    content: `[${freshChar.name} å°†ä½ ä»é»‘åå•ä¸­ç§»å‡ºï¼Œä½ ä»¬å·²æ¢å¤å¥½å‹å…³ç³»]`,
                    time: Date.now(),
                    type: 'char_unblock'
                });
                await setChatHistory(freshChar, accountId, history);
                
                // åˆ·æ–°å¾®ä¿¡ç•Œé¢
                if (typeof currentChatCharId !== 'undefined' && currentChatCharId === targetChar.id) {
                    await renderChatBody(freshChar);
                }
                const activeTab = document.querySelector('.wechat-tab-item.active');
                if (activeTab) {
                    const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                    switchWechatTab(tabIndex);
                }
                
                showToast(`${freshChar.name} æŠŠä½ ä»é»‘åå•ç§»å‡ºæ¥äº†ï¼`);
            }
        }
        
        // ğŸ¯ æ£€æµ‹é‡æ–°åŠ å›å¥½å‹æŒ‡ä»¤ ((ADD_BACK_USER))
        if (/\(\(ADD_BACK_USER\)\)/i.test(replyText)) {
            console.log('[acceptMessageReply] ğŸ¤ æ£€æµ‹åˆ°é‡æ–°åŠ å›å¥½å‹æŒ‡ä»¤');
            replyText = replyText.replace(/\(\(ADD_BACK_USER\)\)/gi, '').trim();
            // æ‰§è¡Œé‡æ–°åŠ å›å¥½å‹
            const freshChar = await db.characters.get(targetChar.id);
            if (freshChar) {
                await setFriendStatus(freshChar, accountId, 'friend');
                console.log('[acceptMessageReply] âœ… å·²é‡æ–°åŠ å›å¥½å‹');
                
                // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ°å¾®ä¿¡èŠå¤©è®°å½•
                const history = getChatHistory(freshChar, accountId);
                history.push({
                    role: 'system',
                    content: `[${freshChar.name} é‡æ–°åŠ ä½ ä¸ºå¥½å‹ï¼Œä½ ä»¬å·²æ¢å¤å¥½å‹å…³ç³»]`,
                    time: Date.now(),
                    type: 'char_add_back'
                });
                await setChatHistory(freshChar, accountId, history);
                
                // åˆ·æ–°å¾®ä¿¡ç•Œé¢
                if (typeof currentChatCharId !== 'undefined' && currentChatCharId === targetChar.id) {
                    await renderChatBody(freshChar);
                }
                const activeTab = document.querySelector('.wechat-tab-item.active');
                if (activeTab) {
                    const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                    switchWechatTab(tabIndex);
                }
                
                showToast(`${freshChar.name} é‡æ–°åŠ ä½ ä¸ºå¥½å‹äº†ï¼`);
            }
        }
        
        // ğŸ¯ æ£€æµ‹ä¿®æ”¹å¯†ç æŒ‡ä»¤ ((CHANGE_PASSWORD:æ–°å¯†ç ))
        const changePasswordMatch = replyText.match(/\(\(CHANGE_PASSWORD:\s*([^)]+)\)\)/i);
        if (changePasswordMatch) {
            console.log('[acceptMessageReply] ğŸ” æ£€æµ‹åˆ°ä¿®æ”¹å¯†ç æŒ‡ä»¤');
            const newPassword = changePasswordMatch[1].trim();
            replyText = replyText.replace(/\(\(CHANGE_PASSWORD:[^)]+\)\)/gi, '').trim();
            
            // æ‰§è¡Œä¿®æ”¹å¯†ç 
            const freshChar = await db.characters.get(targetChar.id);
            if (freshChar) {
                // ç¡®ä¿ identity å¯¹è±¡å­˜åœ¨
                if (!freshChar.identity) {
                    freshChar.identity = {};
                }
                
                const oldPassword = freshChar.identity.password || '';
                freshChar.identity.password = newPassword;
                
                // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°å¯†ç å­—æ®µï¼Œé˜²æ­¢è¦†ç›–è®¾ç½®
                await safeDexieUpdate(db.characters, freshChar.id, { 'identity.password': newPassword }, `ä¿®æ”¹å¯†ç [${freshChar.name}]`);
                console.log('[acceptMessageReply] âœ… å·²ä¿®æ”¹å¯†ç ï¼Œæ–°å¯†ç :', newPassword);
                
                // ğŸ”¥ ä¿®å¤ï¼šç›´æ¥æ“ä½œå…¨å±€ fpWechatVerified Setï¼Œè€Œä¸æ˜¯åˆ›å»ºæ–°çš„å±€éƒ¨å˜é‡ï¼ˆå±€éƒ¨å˜é‡ä¼šé®è”½å…¨å±€çš„ï¼Œå¯¼è‡´å†…å­˜ä¸­çš„éªŒè¯çŠ¶æ€æœªè¢«æ¸…é™¤ï¼‰
                fpWechatVerified.delete(String(freshChar.id));
                saveFpWechatVerified();
                
                // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ°å¾®ä¿¡èŠå¤©è®°å½•
                const history = getChatHistory(freshChar, accountId);
                const sysMsgContent = `[${freshChar.name} ä¿®æ”¹äº†è´¦å·å¯†ç ï¼ŒåŸå¯†ç å·²å¤±æ•ˆ]`;
                history.push({
                    role: 'system',
                    content: sysMsgContent,
                    time: Date.now(),
                    type: 'char_change_password'
                });
                await setChatHistory(freshChar, accountId, history);
                
                // ğŸ”¥ ä¿®å¤ï¼šä½¿ç”¨ appendMessageToUI è¿½åŠ ç³»ç»Ÿæ¶ˆæ¯ï¼Œé¿å… renderChatBody å¯¼è‡´é¡µé¢é—ªçƒ
                if (typeof currentChatCharId !== 'undefined' && currentChatCharId === targetChar.id) {
                    await appendMessageToUI('system', sysMsgContent);
                }
                const activeTab = document.querySelector('.wechat-tab-item.active');
                if (activeTab) {
                    const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                    switchWechatTab(tabIndex);
                }
                
                showToast(`${freshChar.name} ä¿®æ”¹äº†å¯†ç ï¼`);
            }
        }
        
        // ğŸ¯ æ£€æµ‹è§’è‰²è‡ªä¸»æ‰‹æœºæ´»åŠ¨æŒ‡ä»¤ ((PHONE_ACTIVITY:æè¿°))
        const phoneActivityMatchSms = replyText.match(/\(\(PHONE_ACTIVITY:\s*([^)]+)\)\)/i);
        if (phoneActivityMatchSms && targetChar.allow_autonomous_activity) {
            const activityDescSms = phoneActivityMatchSms[1].trim();
            console.log('[acceptMessageReply] ğŸ“± æ£€æµ‹åˆ°è§’è‰²è‡ªä¸»æ‰‹æœºæ´»åŠ¨æŒ‡ä»¤:', activityDescSms);
            replyText = replyText.replace(/\(\(PHONE_ACTIVITY:\s*[^)]+\)\)/gi, '').trim();
            generateCharAutonomousActivity(targetChar.id, accountId, activityDescSms).catch(e => {
                console.error('[acceptMessageReply] è§’è‰²è‡ªä¸»æ´»åŠ¨ç”Ÿæˆå¤±è´¥:', e);
            });
        }
        
        // 9. å¤„ç†åˆ†éš”ç¬¦ï¼Œæ‹†åˆ†æˆå¤šæ¡æ¶ˆæ¯
        const replySegments = replyText.split('|||').map(s => s.trim()).filter(s => s.length > 0);
        
        if (replySegments.length === 0) {
            // å¦‚æœæŒ‡ä»¤è¢«æ¸…é™¤åæ²¡æœ‰å†…å®¹äº†ï¼Œä½¿ç”¨é»˜è®¤å›å¤
            replySegments.push('...');
        }
        
        // 10. ä¿å­˜å›å¤åˆ°çŸ­ä¿¡è®°å½•ï¼ˆå¦‚æœæœ‰å¤šæ¡ï¼Œé€æ¡å‘é€ï¼‰
        const phoneNumber = targetChar.identity?.phone || generateVirtualPhoneNumber(targetChar.id);
        
        for (let i = 0; i < replySegments.length; i++) {
            const segment = replySegments[i];
            
            // å¦‚æœä¸æ˜¯ç¬¬ä¸€æ¡ï¼Œç¨å¾®å»¶æ—¶
            if (i > 0) {
                await new Promise(r => setTimeout(r, 500));
            }
            
            // ä¿å­˜åˆ° Dexie æ•°æ®åº“
            await db.sms_messages.add({
                accountId: accountId,
                charId: targetChar.id,
                sender: targetChar.nick || targetChar.name,
                number: phoneNumber,
                content: segment,
                time: Date.now() + i * 100, // ç¨å¾®é”™å¼€æ—¶é—´
                read: true,
                type: 'received'
            });
            
            // åœ¨è¯¦æƒ…é¡µæ˜¾ç¤ºæ–°æ¶ˆæ¯
            const msgContainer = document.getElementById('message-container');
            if (msgContainer) {
                const newMsgHtml = `<div class="message-wrapper"><div class="message-bubble message-received">${segment.replace(/\n/g, '<br>')}</div></div>`;
                msgContainer.innerHTML += newMsgHtml;
            }
        }
        
        // é‡æ–°æ¸²æŸ“æ¶ˆæ¯åˆ—è¡¨
        renderMessageList();
        
        // æ»šåŠ¨åˆ°åº•éƒ¨
        setTimeout(() => {
            const scrollArea = document.getElementById('message-area-scroll');
            if (scrollArea) {
                scrollArea.scrollTo({ top: scrollArea.scrollHeight, behavior: 'smooth' });
            }
        }, 100);
        
        console.log('[acceptMessageReply] âœ… å›å¤å®Œæˆï¼Œå…±', replySegments.length, 'æ¡æ¶ˆæ¯');
        
        // â˜… AIå›å¤æˆåŠŸåï¼Œæ ‡è®°æŸ¥æ‰‹æœºæ´»åŠ¨ä¸ºå·²é€šçŸ¥
        if (_fpHasPhoneActivitySms) {
            try {
                const freshCharForFp = await db.characters.get(targetChar.id);
                if (freshCharForFp) {
                    let markedCount = 0;
                    const fpNotifyPayload = {};
                    if (freshCharForFp.chat_history_by_user) {
                        for (const key of Object.keys(freshCharForFp.chat_history_by_user)) {
                            if (!key.startsWith('fp_npc_')) continue;
                            const npcHistory = freshCharForFp.chat_history_by_user[key] || [];
                            let changed = false;
                            for (const m of npcHistory) {
                                if ((m.fpSent || (!m.fpSent && m.role === 'user')) && !m.fpNotified) {
                                    m.fpNotified = true;
                                    markedCount++;
                                    changed = true;
                                }
                            }
                            if (changed) fpNotifyPayload[`chat_history_by_user.${key}`] = npcHistory;
                        }
                    }
                    if (freshCharForFp.fp_moments_by_user) {
                        for (const mKey of Object.keys(freshCharForFp.fp_moments_by_user)) {
                            const momentsList = freshCharForFp.fp_moments_by_user[mKey] || [];
                            let changed = false;
                            for (const m of momentsList) {
                                if (m.fpSent && !m.fpNotified) {
                                    m.fpNotified = true;
                                    markedCount++;
                                    changed = true;
                                }
                            }
                            if (changed) fpNotifyPayload[`fp_moments_by_user.${mKey}`] = momentsList;
                        }
                    }
                    // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°æ ‡è®°å­—æ®µï¼Œé˜²æ­¢è¦†ç›–è®¾ç½®
                    if (Object.keys(fpNotifyPayload).length > 0) {
                        await safeDexieUpdate(db.characters, targetChar.id, fpNotifyPayload, `æŸ¥æ‰‹æœºæ´»åŠ¨æ ‡è®°[${freshCharForFp.name}]`);
                    }
                    console.log('[acceptMessageReply] âœ… æŸ¥æ‰‹æœºæ´»åŠ¨å·²æ ‡è®°ä¸ºå·²é€šçŸ¥ï¼Œå…±æ ‡è®°', markedCount, 'æ¡');
                }
                
                // â˜… å°†æŸ¥æ‰‹æœºäº‹ä»¶å†™å…¥é•¿æœŸè®°å¿†ï¼ˆä»…é¦–æ¬¡æœ‰æ–°æ ‡è®°æ—¶å†™å…¥ï¼Œé¿å…é‡å¤ï¼‰
                if (markedCount > 0) {
                    try {
                        const smsUserName = smsUserChar ? smsUserChar.name : (myChar.nick || myChar.name);
                        const fpMemoryContent = `${smsUserName}å·å·æ‹¿äº†${targetChar.name}çš„æ‰‹æœºï¼Œåšäº†ä»¥ä¸‹äº‹æƒ…ï¼š${_fpNpcLinesForMemorySms.map(l => l.trim().replace(/^[â†’â†]\s*/, '')).join('ï¼›')}ã€‚${targetChar.name}å·²ç»å‘ç°å¹¶åšå‡ºäº†ååº”ã€‚`;
                        await db.chat_summaries.add({
                            accountId: accountId,
                            chatType: 'private',
                            chatId: String(targetChar.id),
                            time: Date.now(),
                            content: fpMemoryContent,
                            messageCount: 0,
                            timeRange: '',
                            keywords: ['æŸ¥æ‰‹æœº', 'å†’å……', 'æ‰‹æœºè¢«åŠ¨'],
                            startTime: Date.now(),
                            endTime: Date.now()
                        });
                        console.log('[acceptMessageReply] âœ… æŸ¥æ‰‹æœºäº‹ä»¶å·²å†™å…¥é•¿æœŸè®°å¿†');
                    } catch (memErr) {
                        console.warn('[acceptMessageReply] å†™å…¥æŸ¥æ‰‹æœºé•¿æœŸè®°å¿†å¤±è´¥:', memErr);
                    }
                } else {
                    console.log('[acceptMessageReply] â„¹ï¸ æŸ¥æ‰‹æœºæ´»åŠ¨å·²å…¨éƒ¨é€šçŸ¥è¿‡ï¼Œè·³è¿‡é‡å¤å†™å…¥é•¿æœŸè®°å¿†');
                }
            } catch (fpErr) {
                console.warn('[acceptMessageReply] æ ‡è®°fpNotifiedå¤±è´¥:', fpErr);
            }
        }
        
        // æ¢å¤æ ‡é¢˜
        if (smsNameEl) {
            smsNameEl.innerText = originalSmsName;
            smsNameEl.style.fontSize = "";
        }
        
    } catch (error) {
        console.error('[acceptMessageReply] âŒ æ¥å—å›å¤å¤±è´¥:', error);
        
        // æ¢å¤æ ‡é¢˜
        if (smsNameEl) {
            smsNameEl.innerText = originalSmsName;
            smsNameEl.style.fontSize = "";
        }
        
        // ğŸš¨ æ˜¾ç¤ºè¯¦ç»†é”™è¯¯ä¿¡æ¯ï¼ˆä½¿ç”¨Toastå¼¹çª—ï¼‰
        let errorMsg = error.message || error.toString() || 'æœªçŸ¥é”™è¯¯';
        
        // å¦‚æœæ˜¯ç½‘ç»œé”™è¯¯æˆ–APIå¯†é’¥é”™è¯¯ï¼Œæ·»åŠ å‹å¥½æç¤º
        if (errorMsg.includes('API') || errorMsg.includes('fetch') || errorMsg.includes('Failed')) {
            errorMsg += '\n\nğŸ’¡ å¯èƒ½çš„åŸå› ï¼šAPIå¯†é’¥æœªé…ç½®/å·²å¤±æ•ˆã€ç½‘ç»œè¿æ¥é—®é¢˜ã€æˆ–APIæœåŠ¡ä¸å¯ç”¨';
        }
        
        // ä½¿ç”¨Toastå¼¹çª—æ˜¾ç¤ºé”™è¯¯
        showApiErrorToast(errorMsg);
    } finally {
        clearTimeout(_safetySmsLockTimer);
        _isAcceptingSmsReply = false;
        _isAcceptingSmsReplyTime = 0;
    }
}

// sendNewMessageDetail å·²è¢« confirmComposeSms æµç¨‹æ›¿ä»£

        function hideAppStorePage() {
            const page = document.getElementById('appstore-page');
            page.style.transform = 'scale(0.95)';
            page.style.opacity = '0';
            setTimeout(() => {
                page.style.display = 'none';
                page.style.transform = ''; 
                page.style.opacity = '';
            }, 200);
        }

        // æ¨¡æ‹Ÿåº”ç”¨æ•°æ®
        const appStoreData = {
            today: [
                { name: 'å¾®ä¿¡è¯»ä¹¦', subtitle: 'è®©é˜…è¯»ä¸å†å­¤å•', icon: 'https://img.icons8.com/color/96/book.png', rating: 4.8, downloads: '1000ä¸‡+', appId: 'wechat-read' },
                { name: 'å°çº¢ä¹¦', subtitle: 'æ ‡è®°æˆ‘çš„ç”Ÿæ´»', icon: 'https://img.icons8.com/color/96/instagram-new.png', rating: 4.7, downloads: '5000ä¸‡+', appId: 'xiaohongshu' },
                { name: 'Notion', subtitle: 'ä½ çš„å…¨èƒ½å·¥ä½œç©ºé—´', icon: 'https://img.icons8.com/color/96/notion.png', rating: 4.9, downloads: '500ä¸‡+', appId: 'notion' }
            ],
            games: [
                { name: 'åŸç¥', subtitle: 'å¼€æ”¾ä¸–ç•Œå†’é™©æ¸¸æˆ', icon: 'https://img.icons8.com/color/96/controller.png', rating: 4.6, downloads: '1äº¿+', appId: 'genshin' },
                { name: 'ç‹è€…è£è€€', subtitle: '5v5å…¬å¹³ç«æŠ€', icon: 'https://img.icons8.com/color/96/sword.png', rating: 4.5, downloads: '5äº¿+', appId: 'honor-of-kings' },
                { name: 'è›‹ä»”æ´¾å¯¹', subtitle: 'ä¸€èµ·æ¥ç©å§', icon: 'https://img.icons8.com/color/96/party.png', rating: 4.7, downloads: '2äº¿+', appId: 'eggy-party' }
            ],
            apps: [
                { name: 'ç½‘æ˜“äº‘éŸ³ä¹', subtitle: 'å‘ç°å¥½éŸ³ä¹', icon: 'https://img.icons8.com/color/96/music.png', rating: 4.8, downloads: '5äº¿+', appId: 'netease-music', desktopIconId: 'icon-photo', showFunction: 'showMusicAppPage' },
                { name: 'æ”¯ä»˜å®', subtitle: 'ç”Ÿæ´»å¥½ï¼Œæ”¯ä»˜å®', icon: 'https://img.icons8.com/color/96/alipay.png', rating: 4.8, downloads: '10äº¿+', appId: 'alipay' },
                { name: 'é«˜å¾·åœ°å›¾', subtitle: 'å‡ºè¡Œå¯¼èˆªå¿…å¤‡', icon: 'https://img.icons8.com/color/96/map.png', rating: 4.7, downloads: '5äº¿+', appId: 'amap' },
                { name: 'QQéŸ³ä¹', subtitle: 'å¬æˆ‘æƒ³å¬çš„æ­Œ', icon: 'https://img.icons8.com/color/96/music.png', rating: 4.6, downloads: '3äº¿+', appId: 'qq-music' }
            ],
            updates: [
                { name: 'å¾®ä¿¡', subtitle: 'ç‰ˆæœ¬ 8.0.50 æ›´æ–°', icon: 'https://img.icons8.com/color/96/wechat.png', rating: 4.9, downloads: 'å·²å®‰è£…', appId: 'wechat' },
                { name: 'QQ', subtitle: 'ç‰ˆæœ¬ 9.0.20 æ›´æ–°', icon: 'https://img.icons8.com/color/96/qq.png', rating: 4.7, downloads: 'å·²å®‰è£…', appId: 'qq' }
            ]
        };

        async function switchAppStoreTab(type) {
            // æ›´æ–°æ ‡ç­¾æ ·å¼
            document.querySelectorAll('.appstore-tab').forEach(tab => {
                if (tab.dataset.tab === type) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });

            // æ¸²æŸ“å†…å®¹
            const container = document.getElementById('appstore-content');
            const apps = appStoreData[type] || [];
            
            if (apps.length === 0) {
                container.innerHTML = '<div style="text-align:center; color:#999; margin-top:60px;">æš‚æ— å†…å®¹</div>';
                return;
            }

            // æ£€æŸ¥æ¯ä¸ªåº”ç”¨çš„å®‰è£…çŠ¶æ€
            const appsWithStatus = await Promise.all(apps.map(async (app) => {
                const installed = await isAppInstalled(app.appId || '');
                return { ...app, installed };
            }));

            container.innerHTML = appsWithStatus.map(app => {
                const buttonText = app.installed ? 'æ‰“å¼€' : 'è·å–';
                const buttonClass = app.installed ? 'app-get-btn installed' : 'app-get-btn';
                return `
                <div class="app-card">
                    <div class="app-icon-large" style="background-image:url(${app.icon})"></div>
                    <div class="app-info">
                        <div>
                            <div class="app-name">${app.name}</div>
                            <div class="app-subtitle">${app.subtitle}</div>
                            <div class="app-rating">
                                <span class="app-stars">â˜…â˜…â˜…â˜…â˜…</span>
                                <span>${app.rating}</span>
                                <span>Â·</span>
                                <span>${app.installed ? 'å·²å®‰è£…' : app.downloads}</span>
                            </div>
                        </div>
                        <button class="${buttonClass}" onclick="downloadApp('${app.appId || ''}')">${buttonText}</button>
                    </div>
                </div>
            `;
            }).join('');
        }

        // åˆå§‹åŒ–å·²å®‰è£…åº”ç”¨
        document.addEventListener('DOMContentLoaded', async function() {
            await initInstalledApps();
        });

        // æœç´¢åŠŸèƒ½
        document.addEventListener('DOMContentLoaded', function() {
            const searchInput = document.getElementById('appstore-search');
            if (searchInput) {
                searchInput.addEventListener('input', function(e) {
                    const keyword = e.target.value.toLowerCase();
                    if (!keyword) {
                        // æ¢å¤å½“å‰æ ‡ç­¾å†…å®¹
                        const activeTab = document.querySelector('.appstore-tab.active');
                        if (activeTab) {
                            switchAppStoreTab(activeTab.dataset.tab);
                        }
                        return;
                    }

                    // æœç´¢æ‰€æœ‰åˆ†ç±»
                    const allApps = [...appStoreData.today, ...appStoreData.games, ...appStoreData.apps, ...appStoreData.updates];
                    const results = allApps.filter(app => 
                        app.name.toLowerCase().includes(keyword) || 
                        app.subtitle.toLowerCase().includes(keyword)
                    );

                    const container = document.getElementById('appstore-content');
                    if (results.length === 0) {
                        container.innerHTML = '<div style="text-align:center; color:#999; margin-top:60px;">æœªæ‰¾åˆ°ç›¸å…³åº”ç”¨</div>';
                    } else {
                        // æ£€æŸ¥æ¯ä¸ªåº”ç”¨çš„å®‰è£…çŠ¶æ€
                        Promise.all(results.map(async (app) => {
                            const installed = await isAppInstalled(app.appId || '');
                            return { ...app, installed };
                        })).then(appsWithStatus => {
                            container.innerHTML = appsWithStatus.map(app => {
                                const buttonText = app.installed ? 'æ‰“å¼€' : 'è·å–';
                                const buttonClass = app.installed ? 'app-get-btn installed' : 'app-get-btn';
                                return `
                                <div class="app-card">
                                    <div class="app-icon-large" style="background-image:url(${app.icon})"></div>
                                    <div class="app-info">
                                        <div>
                                            <div class="app-name">${app.name}</div>
                                            <div class="app-subtitle">${app.subtitle}</div>
                                            <div class="app-rating">
                                                <span class="app-stars">â˜…â˜…â˜…â˜…â˜…</span>
                                                <span>${app.rating}</span>
                                                <span>Â·</span>
                                                <span>${app.installed ? 'å·²å®‰è£…' : app.downloads}</span>
                                            </div>
                                        </div>
                                        <button class="${buttonClass}" onclick="downloadApp('${app.appId || ''}')">${buttonText}</button>
                                    </div>
                                </div>
                            `;
                            }).join('');
                        });
                    }
                });
            }
        });

// --- å¾®ä¿¡åº”ç”¨é€»è¾‘ ---
async function showWechatPage() {
    // ç¡®ä¿èŠå¤©çª—å£è¢«å…³é—­
    const chatWindow = document.getElementById('chat-window');
    if (chatWindow && chatWindow.style.display !== 'none') {
        chatWindow.style.display = 'none';
        currentChatCharId = null;
        console.log('[WechatPage] Closed chat window, cleared currentChatCharId');
    }
    
    // ğŸ¯ æ£€æŸ¥æ˜¯å¦æœ‰å·²æ³¨å†Œçš„User
    const hasRegisteredUser = await checkWechatRegistration();
    
    if (!hasRegisteredUser) {
        // é¦–æ¬¡ä½¿ç”¨ï¼Œæ˜¾ç¤ºæ³¨å†Œé¡µé¢
        console.log('[å¾®ä¿¡] é¦–æ¬¡ä½¿ç”¨ï¼Œæ˜¾ç¤ºæ³¨å†Œé¡µé¢');
        await showWechatRegisterPage();
    } else {
        // å·²æ³¨å†Œï¼Œæ˜¾ç¤ºå¾®ä¿¡ä¸»é¡µ
        console.log('[å¾®ä¿¡] å·²æ³¨å†Œï¼Œæ˜¾ç¤ºä¸»é¡µ');
        const wechatEl = document.getElementById('wechat-page');
        wechatEl.style.display = 'flex';
        wechatEl.style.visibility = ''; // ç¡®ä¿åˆ—è¡¨é¡µå¤„äºå¯è§çŠ¶æ€
        // æ‰“å¼€æ—¶è‡ªåŠ¨åˆ‡åˆ°ç¬¬ä¸€ä¸ªæ ‡ç­¾é¡µå¹¶æ¸²æŸ“
        switchWechatTab(0);
    }
}

// æ£€æŸ¥æ˜¯å¦æœ‰å·²æ³¨å†Œçš„User
async function checkWechatRegistration() {
    const users = await db.characters.where('type').equals('user').toArray();
    
    for (const user of users) {
        if (user.identity && user.identity.wechat_registered) {
            return true;
        }
    }
    
    return false;
}

// æ˜¾ç¤ºå¾®ä¿¡æ³¨å†Œé¡µé¢
async function showWechatRegisterPage() {
    const registerPage = document.getElementById('wechat-register-page');
    const userSelect = document.getElementById('register-user-select');
    
    // æ¸…ç©ºä¸‹æ‹‰æ¡†
    userSelect.innerHTML = '<option value="">-- è¯·é€‰æ‹©Useræ¡£æ¡ˆ --</option>';
    
    // åŠ è½½æ‰€æœ‰Useræ¡£æ¡ˆ
    const users = await db.characters.where('type').equals('user').toArray();
    
    if (users.length === 0) {
        showToast('è¯·å…ˆåˆ›å»ºUseræ¡£æ¡ˆ');
        return;
    }
    
    // å¡«å……ä¸‹æ‹‰æ¡†
    users.forEach(user => {
        const option = document.createElement('option');
        option.value = user.id;
        option.textContent = user.name;
        userSelect.appendChild(option);
    });
    
    // æ˜¾ç¤ºæ³¨å†Œé¡µé¢
    registerPage.style.display = 'flex';
}

        function hideWechatPage() {
            const page = document.getElementById('wechat-page');
            page.style.transform = 'scale(0.95)';
            page.style.opacity = '0';
            setTimeout(() => {
                page.style.display = 'none';
                page.style.transform = ''; 
                page.style.opacity = '';
                page.style.visibility = '';
            }, 200);
        }

        async function switchWechatTab(index) {
            const tabs = document.querySelectorAll('.wechat-tab-item');
            tabs.forEach((tab, i) => {
                if (i === index) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });
            
            const content = document.getElementById('wechat-content');
            const title = document.getElementById('wechat-main-title');

            // æŸ¥å²—æ¨¡å¼ï¼šä½¿ç”¨æŸ¥å²—æ¨¡å¼çš„æ¸²æŸ“å‡½æ•°
            if (isViewingRoleAccount && currentViewingRoleAccountId) {
                const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
                const roleName = roleChar ? roleChar.name : 'è§’è‰²';
                
                if (index === 0) {
                    title.innerText = `${roleName}çš„å¾®ä¿¡`;
                    await renderRoleAccountWechatList(content);
                } else if (index === 1) {
                    title.innerText = `${roleName}çš„é€šè®¯å½•`;
                    await renderRoleAccountContactList(content);
                } else if (index === 2) {
                    title.innerText = `${roleName}çš„å‘ç°`;
                    await renderRoleAccountDiscoverPage(content);
                } else if (index === 3) {
                    title.innerText = `${roleName}çš„ä¿¡æ¯`;
                    await renderRoleAccountMePage(content);
                }
                return;
            }

            if (index === 0) {
                title.innerText = "å¾®ä¿¡";
                await renderWechatList(content);
            } else if (index === 1) {
                title.innerText = "é€šè®¯å½•";
                await renderContactList(content);
            } else if (index === 2) {
                title.innerText = "å‘ç°";
                content.innerHTML = `
                    <div class="wechat-cell-group" style="margin-top:0;">
                        <div class="wechat-cell" onclick="showMomentsPage()">
                            <div class="wechat-cell-icon icon-moments">
                                <svg class="svg-icon" style="stroke:currentColor;" viewBox="0 0 24 24"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg>
                            </div>
                            <div class="wechat-cell-text">æœ‹å‹åœˆ</div>
                            <div class="wechat-cell-arrow">â€º</div>
                        </div>
                    </div>
                    <div class="wechat-cell-group">
                        <div class="wechat-cell" onclick="showAvatarLibraryPage()">
                            <div class="wechat-cell-icon icon-moments">
                                <svg class="svg-icon" style="stroke:currentColor;" viewBox="0 0 24 24"><circle cx="12" cy="8" r="4"></circle><path d="M20 21a8 8 0 1 0-16 0"></path></svg>
                            </div>
                            <div class="wechat-cell-text">å¤´åƒåº“</div>
                            <div class="wechat-cell-arrow">â€º</div>
                        </div>
                    </div>
                    <div class="wechat-cell-group">
                        <div class="wechat-cell" onclick="showIntimateSpacePage()">
                            <div class="wechat-cell-icon" style="color:#e8b4c8;">
                                <svg class="svg-icon" style="stroke:currentColor; fill:none;" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>
                            </div>
                            <div class="wechat-cell-text">äº²å¯†ç©ºé—´</div>
                            <div class="wechat-cell-arrow">â€º</div>
                        </div>
                    </div>
                `;
            } else if (index === 3) {
                title.innerText = "æˆ‘";
                await renderMePage(content);
            }
        }

        // æ¸²æŸ“â€œæˆ‘â€çš„é¡µé¢
        async function renderMePage(container) {
            container.innerHTML = '';
            
            // è·å–å½“å‰â€œæˆ‘â€çš„è§’è‰²
            let myChar = null;
            if (currentMyCharId) {
                myChar = await db.characters.get(parseInt(currentMyCharId));
            }
            
            // å…œåº•ï¼šå¦‚æœæœªè®¾ç½®ï¼Œå°è¯•æ‰¾ç¬¬ä¸€ä¸ª User è§’è‰²
            if (!myChar) {
                const users = await db.characters.where('type').equals('user').toArray();
                if (users.length > 0) {
                    myChar = users[0];
                    currentMyCharId = myChar.id;
                    safeLocalStorageSet('current_my_char_id', currentMyCharId);
                }
            }
            
            const avatarUrl = myChar && myChar.avatar ? myChar.avatar : '';
            const name = myChar ? (myChar.nick || myChar.name) : 'æœªç™»å½•';
            // å°è¯•è·å–è™šæ‹Ÿå¾®ä¿¡å·
            const account = myChar && myChar.identity && myChar.identity.account ? myChar.identity.account : (myChar ? `wxid_${myChar.id}` : 'æœªè®¾ç½®');
            
            const profileHtml = `
                <div class="wechat-profile" onclick="openProfileSettings()">
                    <div class="wechat-profile-avatar" style="${avatarUrl ? `background-image:url(${avatarUrl})` : ''}"></div>
                    <div class="wechat-profile-info">
                        <div class="wechat-profile-name">${name}</div>
                        <div class="wechat-profile-id">
                            <span>å¾®ä¿¡å·ï¼š${account}</span>
                            <svg class="svg-icon wechat-qrcode-icon" viewBox="0 0 24 24" style="width:16px;height:16px;"><path d="M3 3h6v6H3zm2 2v2h2V5zm8-2h6v6h-6zm2 2v2h2V5zM3 13h6v6H3zm2 2v2h2v-2zm8-2h2v2h-2zm4 0h2v2h-2zm-4 4h2v2h-2zm2-2h2v2h-2zm2 2h2v2h-2z"/></svg>
                            <svg class="svg-icon" style="width:12px;height:12px;color:#ccc;margin-left:auto;" viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"></polyline></svg>
                        </div>
                    </div>
                </div>
            `;
            
            const cellsHtml = `
                <div class="wechat-cell-group">
                    <div class="wechat-cell" onclick="showServicePage()">
                        <div class="wechat-cell-icon icon-service">
                            <svg class="svg-icon" style="stroke:currentColor;" viewBox="0 0 24 24"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line></svg>
                        </div>
                        <div class="wechat-cell-text">æœåŠ¡</div>
                        <div class="wechat-cell-arrow">â€º</div>
                    </div>
                </div>
                <div class="wechat-cell-group">
                    <div class="wechat-cell" onclick="showFavoritesPage()">
                        <div class="wechat-cell-icon icon-collect">
                            <svg class="svg-icon" style="stroke:currentColor;" viewBox="0 0 24 24"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path></svg>
                        </div>
                        <div class="wechat-cell-text">æ”¶è—</div>
                        <div class="wechat-cell-arrow">â€º</div>
                    </div>
                    <div class="wechat-cell" data-action="showStickerPage">
                        <div class="wechat-cell-icon icon-emoji">
                            <svg class="svg-icon" style="stroke:currentColor;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg>
                        </div>
                        <div class="wechat-cell-text">è¡¨æƒ…</div>
                        <div class="wechat-cell-arrow">â€º</div>
                    </div>
                </div>
                <div class="wechat-cell-group">
                    <div class="wechat-cell" onclick="showSwitchAccountModal()">
                        <div class="wechat-cell-icon icon-settings">
                            <svg class="svg-icon" style="stroke:currentColor;" viewBox="0 0 24 24"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>
                        </div>
                        <div class="wechat-cell-text">åˆ‡æ¢è´¦å·</div>
                        <div class="wechat-cell-arrow">â€º</div>
                    </div>
                </div>
                <div class="wechat-cell-group" id="online-feature-section">
                    <div style="padding:12px 16px; font-size:13px; color:#888; display:flex; align-items:center; gap:6px;">
                        <svg class="svg-icon" viewBox="0 0 24 24" style="width:16px; height:16px; stroke:currentColor;"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>
                        è”æœºåŠŸèƒ½
                    </div>
                    <div class="wechat-cell" onclick="showOnlineStatusPage()">
                        <div class="wechat-cell-icon" style="background:linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                            <svg class="svg-icon" style="stroke:#fff;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>
                        </div>
                        <div class="wechat-cell-text">è”æœºçŠ¶æ€</div>
                        <div id="online-char-count-badge" style="font-size:12px; color:#999; margin-right:4px;">æœªè¿æ¥</div>
                        <div class="wechat-cell-arrow">â€º</div>
                    </div>
                </div>
            `;
            
            // æ›´æ–°è”æœºçŠ¶æ€æ˜¾ç¤º
            updateOnlineFeatureSection();
            
            container.innerHTML = `<div class="wechat-me-container">${profileHtml}${cellsHtml}</div>`;
            
            // ä½¿ç”¨äº‹ä»¶å§”æ‰˜ç»‘å®šè¡¨æƒ…åŒ…ç‚¹å‡»äº‹ä»¶ï¼ˆåœ¨çˆ¶å®¹å™¨ä¸Šç»‘å®šï¼Œç¡®ä¿åŠ¨æ€å…ƒç´ ä¹Ÿèƒ½å“åº”ï¼‰
            const meContainer = container.querySelector('.wechat-me-container');
            if (meContainer) {
                meContainer.addEventListener('click', function(e) {
                    // æ£€æŸ¥ç‚¹å‡»çš„æ˜¯å¦æ˜¯è¡¨æƒ…åŒ…å•å…ƒæ ¼æˆ–å…¶å­å…ƒç´ 
                    const target = e.target.closest('[data-action="showStickerPage"]');
                    if (target) {
                        console.log('[Debug] Sticker cell clicked via event delegation!');
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('[Debug] showStickerPage type:', typeof showStickerPage);
                        console.log('[Debug] window.showStickerPage type:', typeof window.showStickerPage);
                        if (typeof showStickerPage === 'function') {
                            console.log('[Debug] Calling showStickerPage()');
                            showStickerPage();
                        } else if (typeof window.showStickerPage === 'function') {
                            console.log('[Debug] Calling window.showStickerPage()');
                            window.showStickerPage();
                        } else {
                            console.error('[Debug] showStickerPage function not found, trying direct access');
                            // å°è¯•ç›´æ¥è°ƒç”¨
                            try {
                                const page = document.getElementById('sticker-page');
                                if (page) {
                                    console.log('[Debug] Found sticker-page element, showing it directly');
                                    page.style.display = 'flex';
                                    if (typeof renderStickerCategories === 'function') {
                                        renderStickerCategories();
                                    }
                                } else {
                                    console.error('[Debug] sticker-page element not found in DOM');
                                }
                            } catch (err) {
                                console.error('[Debug] Error:', err);
                            }
                        }
                    }
                });
                console.log('[Debug] Event delegation listener added to wechat-me-container');
            } else {
                console.error('[Debug] wechat-me-container not found!');
            }
            
            // ä¹Ÿç›´æ¥ç»‘å®šä¸€æ¬¡ä½œä¸ºå¤‡ç”¨
            const stickerCell = container.querySelector('[data-action="showStickerPage"]');
            console.log('[Debug] stickerCell found:', stickerCell);
            if (stickerCell) {
                stickerCell.style.cursor = 'pointer';
                stickerCell.addEventListener('click', function(e) {
                    console.log('[Debug] Sticker cell clicked (direct binding)!');
                    e.preventDefault();
                    e.stopPropagation();
                    if (typeof showStickerPage === 'function') {
                        showStickerPage();
                    } else if (typeof window.showStickerPage === 'function') {
                        window.showStickerPage();
                    }
                });
            }
        }

        // æ‰“å¼€ä¸ªäººèµ„æ–™è®¾ç½®é¡µé¢
        async function openProfileSettings() {
            const myChar = await db.characters.get(parseInt(currentMyCharId));
            if (!myChar) {
                alert('è¯·å…ˆç™»å½•è´¦å·');
                return;
            }
            
            const modal = document.createElement('div');
            modal.id = 'profile-settings-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: #f5f5f5;
                z-index: 10000;
                display: flex;
                flex-direction: column;
            `;
            
            const currentAvatar = myChar.avatar || '';
            const currentNick = myChar.nick || myChar.name || '';
            const realName = myChar.name || '';
            
            modal.innerHTML = `
                <div style="background: #fff; height: 88px; padding-top: 44px; padding-left: 16px; padding-right: 16px; display: flex; align-items: center; border-bottom: 1px solid #e8e8e8; box-sizing: border-box;">
                    <svg onclick="closeProfileSettings()" viewBox="0 0 24 24" style="width: 24px; height: 24px; cursor: pointer; stroke: #333; fill: none; stroke-width: 2;">
                        <polyline points="15 18 9 12 15 6"></polyline>
                    </svg>
                    <span style="flex: 1; text-align: center; font-size: 16px; font-weight: 600; margin-left: -24px;">ä¸ªäººä¿¡æ¯</span>
                </div>
                
                <div style="flex: 1; overflow-y: auto;">
                    <div style="background: #fff; margin-top: 12px;">
                        <div onclick="document.getElementById('profile-avatar-input').click()" style="padding: 14px 16px; border-bottom: 1px solid #f0f0f0; display: flex; align-items: center; justify-content: space-between; cursor: pointer;">
                            <span style="font-size: 15px; color: #333;">å¤´åƒ</span>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <div id="profile-avatar-preview" style="width: 50px; height: 50px; border-radius: 6px; background-image: url(${currentAvatar}); background-size: cover; background-position: center; background-color: #f0f0f0;"></div>
                                <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; stroke: #999; fill: none;">
                                    <polyline points="9 18 15 12 9 6"></polyline>
                                </svg>
                            </div>
                        </div>
                        <input type="file" id="profile-avatar-input" accept="image/*" style="display: none;">
                        
                        <div style="padding: 14px 16px; border-bottom: 1px solid #f0f0f0; display: flex; align-items: center; justify-content: space-between;">
                            <span style="font-size: 15px; color: #333;">æ˜µç§°</span>
                            <input type="text" id="profile-nick-input" value="${currentNick}" placeholder="è¯·è¾“å…¥æ˜µç§°ï¼ˆç½‘åï¼‰" style="flex: 1; max-width: 200px; padding: 6px 12px; border: 1px solid #e8e8e8; border-radius: 6px; font-size: 15px; text-align: right;">
                        </div>
                        
                        <div style="padding: 14px 16px; border-bottom: 1px solid #f0f0f0; display: flex; align-items: center; justify-content: space-between;">
                            <span style="font-size: 15px; color: #333;">çœŸå</span>
                            <span style="font-size: 15px; color: #999;">${realName}</span>
                        </div>
                        
                        <div style="padding: 14px 16px; display: flex; align-items: center; justify-content: space-between;">
                            <span style="font-size: 15px; color: #333;">å¾®ä¿¡å·</span>
                            <span style="font-size: 15px; color: #999;">${myChar.identity?.account || `wxid_${myChar.id}`}</span>
                        </div>
                    </div>
                </div>
                
                <div style="padding: 16px; background: #fff; border-top: 1px solid #e8e8e8;">
                    <button onclick="saveProfileSettings()" style="width: 100%; padding: 14px; background: var(--ins-pink); color: #fff; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer;">
                        ä¿å­˜
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // ç»‘å®šå¤´åƒä¸Šä¼ äº‹ä»¶
            const avatarInput = document.getElementById('profile-avatar-input');
            const avatarPreview = document.getElementById('profile-avatar-preview');
            
            avatarInput.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        avatarPreview.style.backgroundImage = `url(${event.target.result})`;
                        avatarPreview.dataset.newAvatar = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            };
        }
        
        function closeProfileSettings() {
            const modal = document.getElementById('profile-settings-modal');
            if (modal) modal.remove();
        }
        
        async function saveProfileSettings() {
            const myChar = await db.characters.get(parseInt(currentMyCharId));
            if (!myChar) return;
            
            const nickInput = document.getElementById('profile-nick-input');
            const avatarPreview = document.getElementById('profile-avatar-preview');
            
            const newNick = nickInput.value.trim();
            const newAvatar = avatarPreview.dataset.newAvatar;
            
            if (!newNick) {
                alert('æ˜µç§°ä¸èƒ½ä¸ºç©º');
                return;
            }
            
            // åªæ›´æ–°æ˜µç§°ï¼ˆç½‘åï¼‰ï¼Œä¸ä¿®æ”¹çœŸå(name)
            myChar.nick = newNick;
            if (newAvatar) {
                const oldAvatar = myChar.avatar || '';
                myChar.avatar = newAvatar;
                if (newAvatar !== oldAvatar) {
                    markUserAvatarChanged(myChar);
                }
            }
            
            await safeCharacterPut(myChar);
            
            // åˆ·æ–°ä¸ªäººä¸­å¿ƒé¡µé¢
            closeProfileSettings();
            const meTab = document.querySelector('.wechat-tab-item:nth-child(4)');
            if (meTab && meTab.classList.contains('active')) {
                const container = document.getElementById('wechat-content');
                await renderMePage(container);
            }
            
            // âœ… å¦‚æœå½“å‰æœ‰æ‰“å¼€çš„èŠå¤©çª—å£ï¼Œåˆ·æ–°èŠå¤©ç•Œé¢ä»¥æ›´æ–°å¤´åƒ
            if (currentChatCharId) {
                const chatChar = await db.characters.get(currentChatCharId);
                if (chatChar) {
                    await renderChatBody(chatChar);
                }
            }
            
            showToast('ä¿å­˜æˆåŠŸ');
        }

        // å·²ç™»å½•çš„è§’è‰²è´¦å·åˆ—è¡¨ï¼ˆå­˜å‚¨è§’è‰²IDï¼‰
        let loggedInRoleAccounts = JSON.parse(localStorage.getItem('logged_in_role_accounts') || '[]');
        
        // å½“å‰æ˜¯å¦åœ¨æŸ¥çœ‹è§’è‰²è´¦å·ï¼ˆç”¨äºåŒºåˆ†ç”¨æˆ·è´¦å·å’Œè§’è‰²è´¦å·ï¼‰
        let isViewingRoleAccount = false;
        let currentViewingRoleAccountId = null;
        
        async function showSwitchAccountModal() {
            const modal = document.getElementById('switch-account-modal');
            const list = document.getElementById('account-switch-list');
            list.innerHTML = '';
            
            // æ¸…ç©ºè¾“å…¥æ¡†
            document.getElementById('role-login-account').value = '';
            document.getElementById('role-login-password').value = '';
            document.getElementById('role-login-error').style.display = 'none';
            
            // 1. æ˜¾ç¤ºç”¨æˆ·è´¦å·ï¼ˆæˆ‘çš„è´¦å·ï¼‰
            const users = await db.characters.where('type').equals('user').toArray();
            
            if (users.length > 0) {
                const userTitle = document.createElement('div');
                userTitle.style.cssText = 'font-size:12px; color:#999; padding:8px 12px; background:#f8f8f8;';
                userTitle.textContent = 'æˆ‘çš„è´¦å·';
                list.appendChild(userTitle);
                
                users.forEach(u => {
                    const item = document.createElement('div');
                    item.className = 'account-item';
                    item.onclick = () => performSwitchAccount(u.id);
                    
                    const avatarStyle = u.avatar ? `background-image:url(${u.avatar})` : 'background-color:#eee';
                    const isCurrent = !isViewingRoleAccount && currentMyCharId && parseInt(currentMyCharId) === u.id;
                    
                    item.innerHTML = `
                        <div class="account-avatar" style="${avatarStyle}"></div>
                        <div style="flex:1;">
                            <div style="font-weight:500; color:#333;">${u.nick || u.name}</div>
                            <div style="font-size:12px; color:#999;">${u.identity && u.identity.account ? u.identity.account : 'æ— å¾®ä¿¡å·'}</div>
                        </div>
                        ${isCurrent ? '<div style="color:var(--ins-pink);">âœ“</div>' : ''}
                    `;
                    list.appendChild(item);
                });
            }
            
            // 2. æ˜¾ç¤ºå·²ç™»å½•çš„è§’è‰²è´¦å·
            if (loggedInRoleAccounts.length > 0) {
                const roleTitle = document.createElement('div');
                roleTitle.style.cssText = 'font-size:12px; color:#999; padding:8px 12px; background:#f8f8f8; margin-top:10px;';
                roleTitle.textContent = 'å·²ç™»å½•çš„è§’è‰²è´¦å·ï¼ˆæŸ¥å²—ï¼‰';
                list.appendChild(roleTitle);
                
                for (const roleId of loggedInRoleAccounts) {
                    const role = await db.characters.get(parseInt(roleId));
                    if (!role) continue;
                    
                    const item = document.createElement('div');
                    item.className = 'account-item';
                    item.style.position = 'relative';
                    
                    const avatarStyle = role.avatar ? `background-image:url(${role.avatar})` : 'background-color:#eee';
                    const isCurrent = isViewingRoleAccount && currentViewingRoleAccountId === roleId;
                    
                    item.innerHTML = `
                        <div class="account-avatar" style="${avatarStyle}"></div>
                        <div style="flex:1;" onclick="switchToRoleAccount('${roleId}')">
                            <div style="font-weight:500; color:#333;">${role.name}</div>
                            <div style="font-size:12px; color:#999;">${role.identity && role.identity.account ? role.identity.account : 'æ— å¾®ä¿¡å·'}</div>
                        </div>
                        ${isCurrent ? '<div style="color:var(--ins-pink); margin-right:10px;">âœ“</div>' : ''}
                        <div onclick="event.stopPropagation(); removeRoleAccount('${roleId}')" style="color:#ff3b30; font-size:20px; padding:5px 10px; cursor:pointer;">Ã—</div>
                    `;
                    item.onclick = () => switchToRoleAccount(roleId);
                    list.appendChild(item);
                }
            }
            
            if (users.length === 0 && loggedInRoleAccounts.length === 0) {
                list.innerHTML = '<div style="text-align:center; padding:20px; color:#999;">æš‚æ— è´¦å·</div>';
            }
            
            modal.style.display = 'flex';
        }
        
        // ç§»é™¤å·²ç™»å½•çš„è§’è‰²è´¦å·
        async function removeRoleAccount(roleId) {
            loggedInRoleAccounts = loggedInRoleAccounts.filter(id => id !== roleId);
            safeLocalStorageSet('logged_in_role_accounts', JSON.stringify(loggedInRoleAccounts));
            
            // å¦‚æœæ­£åœ¨æŸ¥çœ‹è¿™ä¸ªè´¦å·ï¼Œåˆ‡å›ç”¨æˆ·è´¦å·
            if (isViewingRoleAccount && currentViewingRoleAccountId === roleId) {
                isViewingRoleAccount = false;
                currentViewingRoleAccountId = null;
                await switchWechatTab(0);
            }
            
            await showSwitchAccountModal();
        }
        
        // ç™»å½•è§’è‰²è´¦å·
        async function loginRoleAccount() {
            const account = document.getElementById('role-login-account').value.trim();
            const password = document.getElementById('role-login-password').value.trim();
            const errorEl = document.getElementById('role-login-error');
            
            errorEl.style.display = 'none';
            
            if (!account) {
                errorEl.textContent = 'è¯·è¾“å…¥è´¦å·';
                errorEl.style.display = 'block';
                return;
            }
            
            if (!password) {
                errorEl.textContent = 'è¯·è¾“å…¥å¯†ç ';
                errorEl.style.display = 'block';
                return;
            }
            
            // æŸ¥æ‰¾è§’è‰²
            const allChars = await db.characters.toArray();
            const targetChar = allChars.find(c => c.identity && c.identity.account === account);
            
            if (!targetChar) {
                errorEl.textContent = 'è´¦å·ä¸å­˜åœ¨';
                errorEl.style.display = 'block';
                return;
            }
            
            // æ£€æŸ¥æ˜¯ä¸æ˜¯Userç±»å‹ï¼ˆä¸å…è®¸ç™»å½•è‡ªå·±çš„è´¦å·ï¼‰
            if (targetChar.type === 'user') {
                errorEl.textContent = 'è¿™æ˜¯ç”¨æˆ·è´¦å·ï¼Œè¯·ç›´æ¥åˆ‡æ¢';
                errorEl.style.display = 'block';
                return;
            }
            
            // éªŒè¯å¯†ç 
            const correctPassword = targetChar.identity?.password || '';
            if (password !== correctPassword) {
                errorEl.textContent = 'å¯†ç é”™è¯¯';
                errorEl.style.display = 'block';
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦å·²ç™»å½•
            const roleIdStr = String(targetChar.id);
            if (loggedInRoleAccounts.includes(roleIdStr)) {
                errorEl.textContent = 'è¯¥è´¦å·å·²ç™»å½•ï¼Œå¯ç›´æ¥åˆ‡æ¢';
                errorEl.style.display = 'block';
                return;
            }
            
            // ç™»å½•æˆåŠŸï¼Œæ·»åŠ åˆ°åˆ—è¡¨
            loggedInRoleAccounts.push(roleIdStr);
            safeLocalStorageSet('logged_in_role_accounts', JSON.stringify(loggedInRoleAccounts));
            
            // æ˜¾ç¤ºåŠ è½½æç¤º
            errorEl.style.color = 'var(--ins-pink)';
            errorEl.textContent = 'æ­£åœ¨ç”Ÿæˆè§’è‰²WeChatæ•°æ®...';
            errorEl.style.display = 'block';
            
            // è°ƒç”¨APIç”Ÿæˆè§’è‰²çš„WeChatæ•°æ®
            try {
                await generateRoleWechatData(targetChar);
                
                // æ¸…ç©ºè¾“å…¥æ¡†
                document.getElementById('role-login-account').value = '';
                document.getElementById('role-login-password').value = '';
                errorEl.style.display = 'none';
                errorEl.style.color = '#ff3b30';
                
                // åˆ·æ–°åˆ—è¡¨å¹¶è‡ªåŠ¨åˆ‡æ¢åˆ°è¯¥è´¦å·
                await showSwitchAccountModal();
                await switchToRoleAccount(roleIdStr);
                
                showToast('ç™»å½•æˆåŠŸï¼Œå·²ç”ŸæˆWeChatæ•°æ®');
            } catch (error) {
                console.error('ç”Ÿæˆè§’è‰²WeChatæ•°æ®å¤±è´¥:', error);
                errorEl.style.color = '#ff3b30';
                errorEl.textContent = 'ç”Ÿæˆæ•°æ®å¤±è´¥ï¼š' + error.message;
                errorEl.style.display = 'block';
            }
        }
        
        // åˆ‡æ¢åˆ°è§’è‰²è´¦å·ï¼ˆæŸ¥å²—æ¨¡å¼ï¼‰
        async function switchToRoleAccount(roleId) {
            // ä¿å­˜åŸæ¥çš„ç”¨æˆ·ID
            if (!window.originalMyCharIdBeforeRoleView) {
                window.originalMyCharIdBeforeRoleView = currentMyCharId;
            }
            
            isViewingRoleAccount = true;
            currentViewingRoleAccountId = roleId;
            
            // åˆ‡æ¢åˆ°è§’è‰²è§†è§’
            const roleChar = await db.characters.get(parseInt(roleId));
            if (roleChar) {
                currentMyCharId = roleChar.id;
            }
            
            closeModal('switch-account-modal');
            
            // åˆ‡æ¢åˆ°èŠå¤©åˆ—è¡¨æ ‡ç­¾å¹¶åˆ·æ–°
            await switchWechatTab(0);
        }
        
        // ç”Ÿæˆè§’è‰²çš„WeChatæ•°æ®ï¼ˆè°ƒç”¨AIï¼‰
        async function generateRoleWechatData(roleChar) {
            console.log('[generateRoleWechatData] å¼€å§‹ä¸ºè§’è‰²ç”ŸæˆWeChatæ•°æ®:', roleChar.name);
            
            // è·å–å½“å‰ç”¨æˆ·
            const myChar = window.originalMyCharIdBeforeRoleView ? 
                await db.characters.get(parseInt(window.originalMyCharIdBeforeRoleView)) : 
                (currentMyCharId ? await db.characters.get(parseInt(currentMyCharId)) : null);
            
            // è·å–è§’è‰²å…³è”çš„ä¸–ç•Œä¹¦ï¼ˆè‡ªåŠ¨åŒ…å«å…¨å±€ä¸–ç•Œä¹¦ï¼‰
            let loreContext = "";
            const lorebookIds = roleChar.lorebookIds || (roleChar.lorebookId ? [roleChar.lorebookId] : []);
            loreContext = await getLorebookContext(lorebookIds, roleChar.name);
            
            // è·å–è§’è‰²ä¸ç”¨æˆ·çš„èŠå¤©è®°å½•
            const accountId = myChar ? String(myChar.id) : getCurrentAccountId();
            const chatHistory = getChatHistory(roleChar, accountId);
            const recentChats = chatHistory.slice(-20).map(m => `${m.role === 'user' ? (myChar?.name || 'ç”¨æˆ·') : roleChar.name}: ${m.content}`).join('\n');
            
            // â˜… è·å–å…³è”NPCåˆ—è¡¨ï¼Œä¼˜å…ˆç”¨äºç”Ÿæˆå¥½å‹æ•°æ®
            let relationshipFriendsHint = '';
            if (roleChar.relationships && roleChar.relationships.length > 0) {
                const relLines = [];
                for (const rel of roleChar.relationships) {
                    if (!rel.targetId) continue;
                    try {
                        const targetChar = await db.characters.get(rel.targetId);
                        if (targetChar && targetChar.type !== 'user') {
                            const npcName = targetChar.nick || targetChar.name || rel.targetName;
                            const npcDesc = targetChar.description ? targetChar.description.substring(0, 100) : '';
                            relLines.push(`- ${npcName}ï¼ˆ${rel.relation}${rel.desc ? 'ï¼Œ' + rel.desc : ''}ï¼‰${npcDesc ? 'ï¼š' + npcDesc : ''}`);
                        }
                    } catch (e) {}
                }
                if (relLines.length > 0) {
                    relationshipFriendsHint = `\nã€è§’è‰²çš„å…³è”NPCï¼ˆå¿…é¡»åŒ…å«åœ¨å¥½å‹åˆ—è¡¨ä¸­ï¼ï¼‰ã€‘\n${relLines.join('\n')}\nè¿™äº›æ˜¯è§’è‰²èº«è¾¹çš„é‡è¦äººç‰©ï¼Œç”Ÿæˆå¥½å‹åˆ—è¡¨æ—¶å¿…é¡»ä¼˜å…ˆåŒ…å«ä»–ä»¬ï¼Œå¹¶æ ¹æ®å…³ç³»ç”Ÿæˆç›¸åº”çš„èŠå¤©è®°å½•ã€‚\n`;
                }
            }
            
            // æ„å»ºAIæç¤º - ç”Ÿæˆæ›´å®Œæ•´çš„æ•°æ®ï¼ŒåŒ…æ‹¬èŠå¤©è®°å½•
            const prompt = `ä½ æ˜¯ä¸€ä¸ªæ•°æ®ç”ŸæˆåŠ©æ‰‹ã€‚è¯·æ ¹æ®ä»¥ä¸‹è§’è‰²ä¿¡æ¯ï¼Œç”Ÿæˆè¿™ä¸ªè§’è‰²çš„å¾®ä¿¡æ•°æ®ã€‚

ã€è§’è‰²ä¿¡æ¯ã€‘
åå­—ï¼š${roleChar.name}
${roleChar.nick ? `æ˜µç§°ï¼š${roleChar.nick}` : ''}
ç±»å‹ï¼š${roleChar.type || 'char'}
è®¾å®šï¼š${roleChar.description || 'æ— '}

${roleChar.identity ? `ã€è™šæ‹Ÿèº«ä»½ã€‘
è´¦å·ï¼š${roleChar.identity.account || 'æœªçŸ¥'}
æ‰‹æœºï¼š${roleChar.identity.phone || 'æœªçŸ¥'}
ä½å€ï¼š${roleChar.identity.address || 'æœªçŸ¥'}
ä½™é¢ï¼š${roleChar.identity.balance || 0}
` : ''}

${myChar ? `ã€ä¸ç”¨æˆ·çš„å…³ç³»ã€‘
ç”¨æˆ·åï¼š${myChar.name}
ç”¨æˆ·è®¾å®šï¼š${myChar.description || 'æ— '}
` : ''}
${relationshipFriendsHint}

${recentChats ? `ã€ä¸ç”¨æˆ·çš„æœ€è¿‘èŠå¤©è®°å½•ï¼ˆçœŸå®ï¼‰ã€‘
${recentChats}
` : ''}

${loreContext ? `ã€ä¸–ç•Œè§‚èƒŒæ™¯ã€‘
${loreContext}
` : ''}

è¯·ç”Ÿæˆä»¥ä¸‹JSONæ•°æ®ï¼ˆä¸¥æ ¼æŒ‰ç…§æ ¼å¼è¿”å›ï¼Œä¸è¦åŒ…å«markdownä»£ç å—ï¼‰ï¼š
{
    "friends": [
        {
            "id": "friend_1",
            "name": "å¥½å‹åå­—",
            "remark": "å¤‡æ³¨ï¼ˆå¯é€‰ï¼Œæ²¡æœ‰å°±ç•™ç©ºï¼‰",
            "relation": "å…³ç³»æè¿°ï¼ˆå¦‚ï¼šåŒäº‹ã€æœ‹å‹ã€å®¶äººç­‰ï¼‰",
            "avatar": "",
            "lastMessage": "æœ€åä¸€æ¡æ¶ˆæ¯å†…å®¹",
            "lastMessageTime": "åˆšåˆš/5åˆ†é’Ÿå‰/1å°æ—¶å‰/æ˜¨å¤©ç­‰",
            "unread": 0,
            "chatHistory": [
                {"role": "friend", "content": "æ¶ˆæ¯å†…å®¹", "time": "10:30"},
                {"role": "me", "content": "æ¶ˆæ¯å†…å®¹", "time": "10:32"}
            ]
        }
    ],
    "moments": [
        {
            "author": "å‘å¸ƒè€…åå­—",
            "content": "æœ‹å‹åœˆå†…å®¹",
            "timeAgo": "2å°æ—¶å‰/æ˜¨å¤©/3å¤©å‰ç­‰",
            "likes": ["ç‚¹èµäºº1", "ç‚¹èµäºº2"],
            "comments": [{"name": "è¯„è®ºäºº", "content": "è¯„è®ºå†…å®¹"}]
        }
    ],
    "balance": "ä½™é¢æ•°å­—"
}

ç”Ÿæˆè¦æ±‚ï¼š
1. friendsï¼šç”Ÿæˆ4-8ä¸ªå¥½å‹ï¼Œæ ¹æ®è§’è‰²è®¾å®šå’Œä¸–ç•Œè§‚ç”Ÿæˆåˆé€‚çš„å¥½å‹
   - å¦‚æœä¸Šé¢æä¾›äº†ã€è§’è‰²çš„å…³è”NPCã€‘åˆ—è¡¨ï¼Œå¿…é¡»ä¼˜å…ˆå°†è¿™äº›NPCä½œä¸ºå¥½å‹åŒ…å«è¿›æ¥ï¼Œå¹¶æ ¹æ®ä»–ä»¬çš„å…³ç³»å’Œäººè®¾ç”Ÿæˆè‡ªç„¶çš„èŠå¤©è®°å½•
   - å¦‚æœæ²¡æœ‰å…³è”NPCï¼Œåˆ™æ ¹æ®è§’è‰²äººè®¾å’Œä¸–ç•Œä¹¦è‡ªç”±ç”Ÿæˆåˆé€‚çš„å¥½å‹
   - å¦‚æœæœ‰ä¸ç”¨æˆ·çš„èŠå¤©è®°å½•ï¼Œç”¨æˆ·ï¼ˆ${myChar?.name || 'ç”¨æˆ·'}ï¼‰å¿…é¡»åœ¨å¥½å‹åˆ—è¡¨ä¸­ï¼Œä¸”èŠå¤©è®°å½•è¦åŸºäºçœŸå®è®°å½•
   - æ¯ä¸ªå¥½å‹è¦ç”Ÿæˆ5-15æ¡èŠå¤©è®°å½•ï¼ˆchatHistoryï¼‰ï¼Œä½“ç°ä»–ä»¬çš„å…³ç³»
   - chatHistoryä¸­ roleä¸º"friend"è¡¨ç¤ºå¥½å‹å‘çš„ï¼Œ"me"è¡¨ç¤ºè§’è‰²ï¼ˆ${roleChar.name}ï¼‰å‘çš„
2. momentsï¼šç”Ÿæˆ3-6æ¡æœ‹å‹åœˆï¼Œå¯ä»¥æ˜¯è§’è‰²è‡ªå·±å‘çš„ï¼Œä¹Ÿå¯ä»¥æ˜¯å¥½å‹å‘çš„
   - è¦æœ‰ç‚¹èµå’Œè¯„è®ºï¼Œä½“ç°ç¤¾äº¤äº’åŠ¨
3. balanceï¼šç”Ÿæˆä¸€ä¸ªåˆç†çš„ä½™é¢æ•°å­—
4. æ‰€æœ‰å†…å®¹è¦ç¬¦åˆè§’è‰²çš„æ€§æ ¼ã€èº«ä»½å’Œä¸–ç•Œè§‚è®¾å®š
5. èŠå¤©å†…å®¹è¦è‡ªç„¶ã€ç”ŸåŠ¨ï¼Œä½“ç°äººç‰©å…³ç³»`;

            // è°ƒç”¨AI
            const result = await callAI([
                { role: 'system', content: 'ä½ æ˜¯ä¸€ä¸ªJSONæ•°æ®ç”ŸæˆåŠ©æ‰‹ï¼Œåªè¿”å›çº¯JSONæ ¼å¼ï¼Œä¸è¦åŒ…å«ä»»ä½•markdownæ ‡è®°æˆ–å…¶ä»–æ–‡å­—ã€‚' },
                { role: 'user', content: prompt }
            ], 0.7);
            
            console.log('[generateRoleWechatData] AIè¿”å›:', result);
            
            // è§£æç»“æœ
            let wechatData;
            try {
                // å°è¯•æ¸…ç†å¯èƒ½çš„markdownæ ‡è®°
                let cleanResult = result.trim();
                if (cleanResult.startsWith('```')) {
                    cleanResult = cleanResult.replace(/```json?\n?/g, '').replace(/```$/g, '').trim();
                }
                wechatData = JSON.parse(cleanResult);
            } catch (e) {
                console.error('[generateRoleWechatData] è§£æJSONå¤±è´¥:', e);
                // ä½¿ç”¨é»˜è®¤æ•°æ®
                wechatData = {
                    friends: [{ name: myChar?.name || 'ç”¨æˆ·', remark: '', relation: 'å¥½å‹', lastMessage: '...', lastMessageTime: 'åˆšåˆš', unread: 0 }],
                    moments: [{ content: 'ä»Šå¤©å¤©æ°”ä¸é”™', timeAgo: '1å°æ—¶å‰', likes: 5, comments: 1 }],
                    balance: roleChar.identity?.balance || '100.00'
                };
            }
            
            // ä¿å­˜åˆ°è§’è‰²æ•°æ®ä¸­
            roleChar.generated_wechat_data = {
                ...wechatData,
                generatedAt: Date.now()
            };
            await safeCharacterPut(roleChar);
            
            console.log('[generateRoleWechatData] æ•°æ®å·²ä¿å­˜:', wechatData);
            return wechatData;
        }
        
        // æ¸²æŸ“è§’è‰²è´¦å·çš„èŠå¤©åˆ—è¡¨ï¼ˆæŸ¥å²—æ¨¡å¼ï¼‰- ä½¿ç”¨AIç”Ÿæˆçš„æ•°æ®
        async function renderRoleAccountWechatList(container) {
            const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
            if (!roleChar) {
                container.innerHTML = '<div class="wechat-empty-state"><div>æš‚æ— æ•°æ®</div></div>';
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰AIç”Ÿæˆçš„æ•°æ®
            const wechatData = roleChar.generated_wechat_data;
            if (!wechatData || !wechatData.friends || wechatData.friends.length === 0) {
                container.innerHTML = `
                    <div class="wechat-empty-state">
                        <svg class="svg-icon" style="width:48px; height:48px; stroke:#ccc;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="8" y1="15" x2="16" y2="15"></line><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg>
                        <div>æš‚æ— å¥½å‹æ•°æ®</div>
                        <div style="font-size:12px; color:#999; margin-top:10px;">è¯·é‡æ–°ç™»å½•ç”Ÿæˆæ•°æ®</div>
                    </div>
                `;
                return;
            }

            const friends = wechatData.friends;

            container.innerHTML = '';
            const listDiv = document.createElement('div');
            listDiv.style.width = '100%';
            listDiv.style.background = '#fff';
            listDiv.style.overflowX = 'hidden';
            
            // æ·»åŠ æŸ¥å²—æ¨¡å¼æç¤º
            const tipDiv = document.createElement('div');
            tipDiv.style.cssText = 'padding:10px 16px; background:#FFF5F7; color:#FF6B9D; font-size:12px; border-bottom:1px solid #f0f0f0;';
            tipDiv.innerHTML = `ğŸ” æ­£åœ¨æŸ¥çœ‹ <b>${roleChar.name}</b> çš„å¾®ä¿¡ï¼ˆæŸ¥å²—æ¨¡å¼ï¼‰<span style="float:right; cursor:pointer;" onclick="refreshRoleWechatData()">ğŸ”„ åˆ·æ–°</span>`;
            listDiv.appendChild(tipDiv);

            friends.forEach((f, index) => {
                // å®¹å™¨
                const itemContainer = document.createElement('div');
                itemContainer.className = 'wechat-list-item-container';
                
                // å†…å®¹åŒºåŸŸ
                const contentDiv = document.createElement('div');
                contentDiv.className = 'wechat-list-item-content';
                
                contentDiv.style.display = 'flex';
                contentDiv.style.padding = '12px 16px';
                contentDiv.style.borderBottom = '0.5px solid #f0f0f0';
                contentDiv.style.alignItems = 'center';
                contentDiv.style.gap = '12px';
                contentDiv.style.backgroundColor = '#fff';
                contentDiv.style.cursor = 'pointer';

                // ç‚¹å‡»è¿›å…¥èŠå¤©ï¼ˆæŸ¥å²—æ¨¡å¼ï¼‰
                contentDiv.onclick = () => {
                    openRoleAccountChat(index);
                };

                // ç”Ÿæˆå¤´åƒï¼ˆä½¿ç”¨åå­—é¦–å­—æ¯ï¼‰
                const avatarChar = (f.name || '?').charAt(0);
                const avatarColors = ['#FF6B9D', '#FF9F43', '#54A0FF', '#5F27CD', '#00D2D3', '#10AC84'];
                const avatarColor = avatarColors[index % avatarColors.length];
                
                const lastMsg = f.lastMessage || '';
                const lastTimeStr = f.lastMessageTime || '';
                const unread = f.unread || 0;

                contentDiv.innerHTML = `
                    <div style="width:48px; height:48px; border-radius:6px; background:${avatarColor}; background-size:cover; background-position:center; flex-shrink:0; display:flex; align-items:center; justify-content:center; color:#fff; font-size:20px; font-weight:600;">${avatarChar}</div>
                    <div style="flex:1; min-width:0;">
                        <div style="display:flex; justify-content:space-between; margin-bottom:4px; align-items:center;">
                            <div style="display:flex; align-items:center;">
                                <div style="font-size:16px; font-weight:500; color:#333;">${f.remark || f.wx_nickname || f.name}</div>
                            </div>
                            <div style="font-size:12px; color:#999;">${lastTimeStr}</div>
                        </div>
                        <div style="font-size:14px; color:#999; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${lastMsg}</div>
                    </div>
                    ${unread > 0 ? `<div style="background:#ff3b30; color:#fff; font-size:12px; padding:2px 6px; border-radius:10px; min-width:18px; text-align:center;">${unread}</div>` : ''}
                `;

                itemContainer.appendChild(contentDiv);
                listDiv.appendChild(itemContainer);
            });
            container.appendChild(listDiv);
        }
        
        // åˆ·æ–°è§’è‰²çš„WeChatæ•°æ®
        async function refreshRoleWechatData() {
            const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
            if (!roleChar) return;
            
            showToast('æ­£åœ¨é‡æ–°ç”Ÿæˆæ•°æ®...');
            
            try {
                await generateRoleWechatData(roleChar);
                await switchWechatTab(0);
                showToast('æ•°æ®å·²åˆ·æ–°');
            } catch (error) {
                console.error('åˆ·æ–°æ•°æ®å¤±è´¥:', error);
                showToast('åˆ·æ–°å¤±è´¥ï¼š' + error.message);
            }
        }
        
        // æ‰“å¼€è§’è‰²è´¦å·çš„èŠå¤©çª—å£ï¼ˆæŸ¥å²—æ¨¡å¼ï¼‰- æ˜¾ç¤ºAIç”Ÿæˆçš„èŠå¤©è®°å½•
        async function openRoleAccountChat(friendIndex) {
            const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
            if (!roleChar || !roleChar.generated_wechat_data) return;
            
            const friend = roleChar.generated_wechat_data.friends[friendIndex];
            if (!friend) return;
            
            // ä¿å­˜å½“å‰æŸ¥çœ‹çš„å¥½å‹ç´¢å¼•
            window.currentRoleViewFriendIndex = friendIndex;
            
            // æ˜¾ç¤ºèŠå¤©çª—å£
            const chatWindow = document.getElementById('chat-window');
            const chatTitle = document.getElementById('chat-title');
            const chatBody = document.getElementById('chat-body');
            const chatFooter = document.getElementById('chat-footer');
            
            // æ£€æŸ¥æ˜¯å¦å¼€å¯ä¿®ç½—åœºæ¨¡å¼
            const isShuraMode = !!roleChar.allow_shura_mode;
            
            if (isShuraMode) {
                chatTitle.innerHTML = `${friend.remark || friend.wx_nickname || friend.name} <span style="font-size:12px; color:#FF0000; font-weight:600;">âš ï¸ä¿®ç½—åœºæ¨¡å¼(${roleChar.name}æŸ¥å²—ä¸­)</span>`;
            } else {
                chatTitle.innerHTML = `${friend.remark || friend.wx_nickname || friend.name} <span style="font-size:12px; color:#FF6B9D; font-weight:400;">(${roleChar.name}æŸ¥å²—ä¸­)</span>`;
            }
            chatWindow.style.display = 'flex';
            
            // ä¿®ç½—åœºæ¨¡å¼ï¼šæ˜¾ç¤ºè¾“å…¥æ¡†å’Œæ“ä½œæŒ‰é’®ï¼›å¦åˆ™éšè—
            if (isShuraMode) {
                chatFooter.style.display = 'flex';
                // æ·»åŠ ä¿®ç½—åœºæ“ä½œæ 
                addShuraOperationBar(chatBody, roleChar, friend, friendIndex);
            } else {
                chatFooter.style.display = 'none';
            }
            
            // æ¸²æŸ“AIç”Ÿæˆçš„èŠå¤©è®°å½•
            renderRoleAccountChatBody(chatBody, roleChar, friend);
        }
        
        // æ·»åŠ ä¿®ç½—åœºæ“ä½œæ 
        function addShuraOperationBar(container, roleChar, friend, friendIndex) {
            // ç§»é™¤æ—§çš„æ“ä½œæ ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            const oldBar = container.parentElement.querySelector('.shura-operation-bar');
            if (oldBar) oldBar.remove();
            
            // åˆ›å»ºæ“ä½œæ 
            const operationBar = document.createElement('div');
            operationBar.className = 'shura-operation-bar';
            operationBar.style.cssText = 'position:absolute; top:45px; left:0; right:0; background:#FFF0F0; border-bottom:2px solid #FF6B9D; padding:8px 16px; display:flex; gap:8px; align-items:center; z-index:10; box-shadow:0 2px 8px rgba(255,107,157,0.1);';
            
            operationBar.innerHTML = `
                <div style="flex:1; font-size:12px; color:#FF0000; font-weight:600;">âš ï¸ ä¿®ç½—åœºæ¨¡å¼ï¼šå¯ä»¥æ“ä½œç”¨æˆ·è´¦å·</div>
                <button onclick="deleteShuraFriend(${friendIndex})" style="padding:6px 12px; background:#FF3B30; color:#fff; border:none; border-radius:6px; font-size:12px; cursor:pointer; font-weight:600;">åˆ é™¤å¥½å‹</button>
                <button onclick="blacklistShuraFriend(${friendIndex})" style="padding:6px 12px; background:#333; color:#fff; border:none; border-radius:6px; font-size:12px; cursor:pointer; font-weight:600;">æ‹‰é»‘</button>
            `;
            
            // æ’å…¥åˆ°èŠå¤©çª—å£çš„headerä¹‹å
            const chatWindow = container.parentElement;
            const header = chatWindow.querySelector('.wechat-header');
            if (header && header.nextSibling) {
                chatWindow.insertBefore(operationBar, header.nextSibling);
            }
            
            // è°ƒæ•´èŠå¤©å†…å®¹åŒºåŸŸçš„ä½ç½®ï¼ˆç»™æ“ä½œæ ç•™å‡ºç©ºé—´ï¼‰
            container.style.paddingTop = '60px';
        }
        
        // åˆ é™¤å¥½å‹ï¼ˆä¿®ç½—åœºæ¨¡å¼ï¼‰
        async function deleteShuraFriend(friendIndex) {
            const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
            if (!roleChar || !roleChar.generated_wechat_data) return;
            
            const friend = roleChar.generated_wechat_data.friends[friendIndex];
            if (!friend) return;
            
            if (!confirm(`ç¡®å®šè¦ä»¥ç”¨æˆ·çš„åä¹‰åˆ é™¤å¥½å‹"${friend.remark || friend.wx_nickname || friend.name}"å—ï¼Ÿ\n\nè¿™ä¸ªæ“ä½œä¼šè¢«è®°å½•åˆ°è§’è‰²çš„æŸ¥å²—è®°å½•ä¸­ã€‚`)) {
                return;
            }
            
            // è®°å½•æ“ä½œ
            const operationLog = {
                type: 'delete_friend',
                friendName: friend.remark || friend.wx_nickname || friend.name,
                friendId: friend.id,
                timestamp: new Date().toLocaleString(),
                operator: roleChar.name
            };
            
            // ä¿å­˜æ“ä½œè®°å½•åˆ°è§’è‰²æ•°æ®ä¸­
            if (!roleChar.shura_operations) {
                roleChar.shura_operations = [];
            }
            roleChar.shura_operations.push(operationLog);
            
            // ä»å¥½å‹åˆ—è¡¨ä¸­åˆ é™¤
            roleChar.generated_wechat_data.friends.splice(friendIndex, 1);
            
            await safeCharacterPut(roleChar);
            
            showToast(`å·²åˆ é™¤å¥½å‹"${friend.remark || friend.wx_nickname || friend.name}"`);
            
            // è¿”å›åˆ°å¾®ä¿¡åˆ—è¡¨
            closeChatWindow();
            await switchWechatTab(0);
        }
        
        // æ‹‰é»‘å¥½å‹ï¼ˆä¿®ç½—åœºæ¨¡å¼ï¼‰
        async function blacklistShuraFriend(friendIndex) {
            const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
            if (!roleChar || !roleChar.generated_wechat_data) return;
            
            const friend = roleChar.generated_wechat_data.friends[friendIndex];
            if (!friend) return;
            
            if (!confirm(`ç¡®å®šè¦ä»¥ç”¨æˆ·çš„åä¹‰æ‹‰é»‘"${friend.remark || friend.wx_nickname || friend.name}"å—ï¼Ÿ\n\nè¿™ä¸ªæ“ä½œä¼šè¢«è®°å½•åˆ°è§’è‰²çš„æŸ¥å²—è®°å½•ä¸­ã€‚`)) {
                return;
            }
            
            // è®°å½•æ“ä½œ
            const operationLog = {
                type: 'blacklist_friend',
                friendName: friend.remark || friend.wx_nickname || friend.name,
                friendId: friend.id,
                timestamp: new Date().toLocaleString(),
                operator: roleChar.name
            };
            
            // ä¿å­˜æ“ä½œè®°å½•åˆ°è§’è‰²æ•°æ®ä¸­
            if (!roleChar.shura_operations) {
                roleChar.shura_operations = [];
            }
            roleChar.shura_operations.push(operationLog);
            
            // æ ‡è®°ä¸ºå·²æ‹‰é»‘
            friend.blacklisted = true;
            friend.blacklistedAt = new Date().toLocaleString();
            
            await safeCharacterPut(roleChar);
            
            showToast(`å·²æ‹‰é»‘"${friend.remark || friend.wx_nickname || friend.name}"`);
            
            // åˆ·æ–°èŠå¤©çª—å£
            openRoleAccountChat(friendIndex);
        }
        
        // å‘é€ä¿®ç½—åœºæ¶ˆæ¯ï¼ˆè§’è‰²ä»¥ç”¨æˆ·èº«ä»½å‘é€ï¼‰
        async function sendShuraMessage() {
            const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
            if (!roleChar || !roleChar.generated_wechat_data) return;
            
            const friendIndex = window.currentRoleViewFriendIndex;
            if (friendIndex === undefined) return;
            
            const friend = roleChar.generated_wechat_data.friends[friendIndex];
            if (!friend) return;
            
            const input = document.getElementById('chat-input-box');
            const message = input.value.trim();
            if (!message) return;
            
            // æ·»åŠ æ¶ˆæ¯åˆ°èŠå¤©è®°å½•ï¼ˆä»¥ç”¨æˆ·èº«ä»½ï¼‰
            if (!friend.chatHistory) {
                friend.chatHistory = [];
            }
            
            const newMessage = {
                sender: 'user', // ç”¨æˆ·å‘é€çš„
                message: message,
                timestamp: new Date().toLocaleString()
            };
            
            friend.chatHistory.push(newMessage);
            
            // è®°å½•æ“ä½œ
            const operationLog = {
                type: 'send_message',
                friendName: friend.remark || friend.wx_nickname || friend.name,
                friendId: friend.id,
                message: message,
                timestamp: new Date().toLocaleString(),
                operator: roleChar.name
            };
            
            if (!roleChar.shura_operations) {
                roleChar.shura_operations = [];
            }
            roleChar.shura_operations.push(operationLog);
            
            // æ›´æ–°æœ€åä¸€æ¡æ¶ˆæ¯
            friend.lastMessage = message;
            friend.lastMessageTime = new Date().toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
            
            await safeCharacterPut(roleChar);
            
            // æ¸…ç©ºè¾“å…¥æ¡†
            input.value = '';
            
            // é‡æ–°èšç„¦è¾“å…¥æ¡†ï¼Œä¿æŒé”®ç›˜ä¸æ”¶èµ·
            input.focus();
            
            // åˆ·æ–°èŠå¤©çª—å£
            const chatBody = document.getElementById('chat-body');
            renderRoleAccountChatBody(chatBody, roleChar, friend);
        }
        
        // å°†ä¿®ç½—åœºå‡½æ•°æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸ
        window.deleteShuraFriend = deleteShuraFriend;
        window.blacklistShuraFriend = blacklistShuraFriend;
        window.sendShuraMessage = sendShuraMessage;
        
        // æ¸²æŸ“è§’è‰²è´¦å·çš„èŠå¤©è®°å½•ï¼ˆAIç”Ÿæˆçš„ï¼‰- ä½¿ç”¨å’Œæ­£å¸¸èŠå¤©ä¸€æ ·çš„æ ·å¼
        function renderRoleAccountChatBody(container, roleChar, friend) {
            const chatHistory = friend.chatHistory || [];
            
            // è§’è‰²å¤´åƒ
            const roleAvatarUrl = roleChar.avatar || '';
            
            // å¥½å‹å¤´åƒé¢œè‰²ï¼ˆç”Ÿæˆä¸€ä¸ªé¢œè‰²ä½œä¸ºé»˜è®¤å¤´åƒï¼‰
            const avatarColors = ['#FF6B9D', '#FF9F43', '#54A0FF', '#5F27CD', '#00D2D3', '#10AC84'];
            const friendAvatarColor = avatarColors[window.currentRoleViewFriendIndex % avatarColors.length];
            const friendAvatarChar = (friend.name || '?').charAt(0);
            
            container.innerHTML = '';
            
            if (chatHistory.length === 0) {
                container.innerHTML = '<div style="text-align:center; padding:40px; color:#999;">æš‚æ— èŠå¤©è®°å½•</div>';
                return;
            }
            
            let lastTimeGroup = '';
            
            chatHistory.forEach((msg, index) => {
                const isMe = msg.role === 'me'; // è§’è‰²å‘çš„
                const time = msg.time || '';
                
                // æ·»åŠ æ—¶é—´æˆ³ï¼ˆå¦‚æœæ—¶é—´å˜åŒ–äº†ï¼‰
                if (time && time !== lastTimeGroup) {
                    const timeStamp = document.createElement('div');
                    timeStamp.className = 'message-timestamp';
                    timeStamp.textContent = time;
                    container.appendChild(timeStamp);
                    lastTimeGroup = time;
                }
                
                // åˆ›å»ºæ¶ˆæ¯è¡Œ - ä½¿ç”¨å’Œæ­£å¸¸èŠå¤©ä¸€æ ·çš„HTMLç»“æ„
                const row = document.createElement('div');
                row.className = `message-row ${isMe ? 'self' : 'other'}`;
                row.dataset.index = index;
                
                // å¤´åƒ
                const avatar = document.createElement('div');
                avatar.className = 'message-avatar';
                
                if (isMe) {
                    // è§’è‰²ï¼ˆ"æˆ‘"ï¼‰çš„å¤´åƒ
                    if (roleAvatarUrl) {
                        avatar.style.backgroundImage = `url(${roleAvatarUrl})`;
                    } else {
                        avatar.style.backgroundColor = '#FF6B9D';
                        avatar.style.display = 'flex';
                        avatar.style.alignItems = 'center';
                        avatar.style.justifyContent = 'center';
                        avatar.style.color = '#fff';
                        avatar.style.fontWeight = '600';
                        avatar.style.fontSize = '14px';
                        avatar.textContent = roleChar.name.charAt(0);
                    }
                } else {
                    // å¥½å‹çš„å¤´åƒ
                    avatar.style.backgroundColor = friendAvatarColor;
                    avatar.style.display = 'flex';
                    avatar.style.alignItems = 'center';
                    avatar.style.justifyContent = 'center';
                    avatar.style.color = '#fff';
                    avatar.style.fontWeight = '600';
                    avatar.style.fontSize = '14px';
                    avatar.textContent = friendAvatarChar;
                }
                
                // å†…å®¹æ°”æ³¡
                const content = document.createElement('div');
                content.className = isMe ? 'message-content user-bubble' : 'message-content ai-bubble';
                content.textContent = msg.content || '';
                
                // ç»„è£…æ¶ˆæ¯è¡Œ
                row.appendChild(avatar);
                row.appendChild(content);
                
                container.appendChild(row);
            });
            
            // æ»šåŠ¨åˆ°åº•éƒ¨
            setTimeout(() => {
                container.scrollTop = container.scrollHeight;
            }, 50);
        }
        
        // æ¸²æŸ“è§’è‰²è´¦å·çš„é€šè®¯å½•ï¼ˆæŸ¥å²—æ¨¡å¼ï¼‰- ä½¿ç”¨AIç”Ÿæˆçš„æ•°æ®
        async function renderRoleAccountContactList(container) {
            const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
            if (!roleChar) {
                container.innerHTML = '<div class="wechat-empty-state"><div>æš‚æ— æ•°æ®</div></div>';
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰AIç”Ÿæˆçš„æ•°æ®
            const wechatData = roleChar.generated_wechat_data;
            if (!wechatData || !wechatData.friends || wechatData.friends.length === 0) {
                container.innerHTML = `
                    <div class="wechat-empty-state">
                        <div>æš‚æ— å¥½å‹æ•°æ®</div>
                    </div>
                `;
                return;
            }
            
            const friends = [...wechatData.friends].sort((a, b) => {
                const nameA = (a.remark || a.wx_nickname || a.name || '').toLowerCase();
                const nameB = (b.remark || b.wx_nickname || b.name || '').toLowerCase();
                return nameA.localeCompare(nameB);
            });
            
            container.innerHTML = '';
            const listDiv = document.createElement('div');
            listDiv.style.width = '100%';
            listDiv.style.background = '#fff';
            
            // æ·»åŠ æŸ¥å²—æ¨¡å¼æç¤º
            const tipDiv = document.createElement('div');
            tipDiv.style.cssText = 'padding:10px 16px; background:#FFF5F7; color:#FF6B9D; font-size:12px; border-bottom:1px solid #f0f0f0;';
            tipDiv.innerHTML = `ğŸ” æ­£åœ¨æŸ¥çœ‹ <b>${roleChar.name}</b> çš„é€šè®¯å½•ï¼ˆ${friends.length}ä½å¥½å‹ï¼‰`;
            listDiv.appendChild(tipDiv);
            
            const avatarColors = ['#FF6B9D', '#FF9F43', '#54A0FF', '#5F27CD', '#00D2D3', '#10AC84'];
            
            friends.forEach((f, index) => {
                // æ‰¾åˆ°åŸå§‹ç´¢å¼•ï¼ˆç”¨äºç‚¹å‡»è¿›å…¥èŠå¤©ï¼‰
                const originalIndex = wechatData.friends.findIndex(fr => fr.id === f.id || fr.name === f.name);
                
                const itemDiv = document.createElement('div');
                itemDiv.style.cssText = 'display:flex; padding:12px 16px; border-bottom:0.5px solid #f0f0f0; align-items:center; gap:12px; background:#fff; cursor:pointer;';
                itemDiv.onclick = () => openRoleAccountChat(originalIndex >= 0 ? originalIndex : index);
                
                const avatarChar = (f.name || '?').charAt(0);
                const avatarColor = avatarColors[index % avatarColors.length];
                
                itemDiv.innerHTML = `
                    <div style="width:48px; height:48px; border-radius:6px; background:${avatarColor}; display:flex; align-items:center; justify-content:center; color:#fff; font-size:20px; font-weight:600;">${avatarChar}</div>
                    <div style="flex:1;">
                        <div style="font-size:16px; font-weight:500; color:#333;">${f.remark || f.wx_nickname || f.name}</div>
                        ${f.relation ? `<div style="font-size:12px; color:#999;">${f.relation}</div>` : ''}
                    </div>
                `;
                
                listDiv.appendChild(itemDiv);
            });
            
            container.appendChild(listDiv);
        }
        
        // æ¸²æŸ“è§’è‰²è´¦å·çš„å‘ç°é¡µï¼ˆæœ‹å‹åœˆï¼ŒæŸ¥å²—æ¨¡å¼ï¼‰
        async function renderRoleAccountDiscoverPage(container) {
            const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
            if (!roleChar) {
                container.innerHTML = '<div class="wechat-empty-state"><div>æš‚æ— æ•°æ®</div></div>';
                return;
            }
            
            // ä½¿ç”¨å’Œæ­£å¸¸å‘ç°é¡µä¸€æ ·çš„å†…å®¹
            const html = `
                <div class="wechat-cell-group" style="margin-top:0;">
                    <div style="padding:10px 16px; background:#FFF5F7; color:#FF6B9D; font-size:12px;">
                        ğŸ” æ­£åœ¨æŸ¥çœ‹ <b>${roleChar.name}</b> çš„å‘ç°
                    </div>
                    <div class="wechat-cell" onclick="showRoleAccountMomentsPage()">
                        <div class="wechat-cell-icon icon-moments">
                            <svg class="svg-icon" style="stroke:currentColor;" viewBox="0 0 24 24"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg>
                        </div>
                        <div class="wechat-cell-text">æœ‹å‹åœˆ</div>
                        <div class="wechat-cell-arrow">â€º</div>
                    </div>
                </div>
            `;
            container.innerHTML = html;
        }
        
        // æ˜¾ç¤ºè§’è‰²è´¦å·çš„æœ‹å‹åœˆé¡µé¢ï¼ˆæŸ¥å²—æ¨¡å¼ï¼‰- ä½¿ç”¨AIç”Ÿæˆçš„æ•°æ®
        async function showRoleAccountMomentsPage() {
            const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
            if (!roleChar) return;
            
            const wechatData = roleChar.generated_wechat_data;
            const moments = wechatData?.moments || [];
            
            // æ˜¾ç¤ºæœ‹å‹åœˆé¡µé¢
            const momentsPage = document.getElementById('moments-page');
            if (!momentsPage) return;
            
            momentsPage.style.display = 'flex';
            
            // ä¿®æ”¹ç”¨æˆ·åå’Œå¤´åƒï¼ˆå°é¢åŒºåŸŸï¼‰
            const userNameEl = document.getElementById('moments-user-name');
            const userAvatarEl = document.getElementById('moments-user-avatar');
            if (userNameEl) {
                userNameEl.innerHTML = `${roleChar.name} <span style="font-size:12px; color:#FF6B9D;">(æŸ¥å²—ä¸­)</span>`;
            }
            if (userAvatarEl && roleChar.avatar) {
                userAvatarEl.style.backgroundImage = `url(${roleChar.avatar})`;
            }
            
            // æ¸²æŸ“AIç”Ÿæˆçš„æœ‹å‹åœˆå†…å®¹åˆ° moments-list
            const momentsList = document.getElementById('moments-list');
            if (momentsList) {
                renderRoleAccountMoments(momentsList, roleChar, moments);
            }
        }
        
        // æ¸²æŸ“è§’è‰²è´¦å·çš„æœ‹å‹åœˆå†…å®¹ - ä½¿ç”¨å’Œæ­£å¸¸æœ‹å‹åœˆä¸€æ ·çš„æ ·å¼
        function renderRoleAccountMoments(container, roleChar, moments) {
            const avatarColors = ['#FF6B9D', '#FF9F43', '#54A0FF', '#5F27CD', '#00D2D3', '#10AC84'];
            
            let html = '';
            
            // æŸ¥å²—æç¤º
            html += `<div style="padding:12px 16px; background:#FFF5F7; color:#FF6B9D; font-size:13px; margin-bottom:10px;">
                ğŸ” æ­£åœ¨æŸ¥çœ‹ <b>${roleChar.name}</b> çš„æœ‹å‹åœˆï¼ˆ${moments.length}æ¡åŠ¨æ€ï¼‰
            </div>`;
            
            if (moments.length === 0) {
                html += '<div style="text-align:center; padding:60px 20px; color:#999;">æš‚æ— æœ‹å‹åœˆåŠ¨æ€</div>';
            } else {
                moments.forEach((m, index) => {
                    const authorName = m.author || roleChar.name;
                    const isRoleMoment = authorName === roleChar.name;
                    const avatarColor = isRoleMoment ? '#FF6B9D' : avatarColors[index % avatarColors.length];
                    const avatarChar = authorName.charAt(0);
                    const avatarStyle = (isRoleMoment && roleChar.avatar) ? 
                        `background-image:url(${roleChar.avatar}); background-size:cover; background-position:center;` : 
                        `background:${avatarColor}; display:flex; align-items:center; justify-content:center; color:#fff; font-size:18px; font-weight:600;`;
                    
                    // ç‚¹èµåˆ—è¡¨
                    const likes = m.likes || [];
                    const likesStr = Array.isArray(likes) ? likes.join('ï¼Œ') : '';
                    
                    // è¯„è®ºåˆ—è¡¨
                    const comments = m.comments || [];
                    let commentsHtml = '';
                    if (comments.length > 0) {
                        commentsHtml = comments.map(c => {
                            return `<div style="font-size:13px; line-height:1.8;"><span style="color:#576B95; font-weight:500;">${c.name || 'åŒ¿å'}</span>ï¼š${c.content || ''}</div>`;
                        }).join('');
                    }
                    
                    html += `
                        <div class="moment-item" style="padding:16px; border-bottom:1px solid #f0f0f0;">
                            <div style="display:flex; align-items:flex-start;">
                                <div style="width:44px; height:44px; border-radius:6px; flex-shrink:0; ${avatarStyle}">${(isRoleMoment && roleChar.avatar) ? '' : avatarChar}</div>
                                <div style="margin-left:12px; flex:1; min-width:0;">
                                    <div style="font-weight:600; font-size:15px; color:#576B95; margin-bottom:6px;">${authorName}</div>
                                    <div style="line-height:1.6; font-size:15px; color:#333; word-break:break-word;">${m.content || ''}</div>
                                    <div style="font-size:12px; color:#999; margin-top:10px;">${m.timeAgo || 'åˆšåˆš'}</div>
                                    ${(likesStr || commentsHtml) ? `
                                    <div style="background:#f5f5f5; padding:8px 10px; border-radius:4px; margin-top:10px;">
                                        ${likesStr ? `<div style="font-size:13px; color:#576B95; ${commentsHtml ? 'margin-bottom:6px; padding-bottom:6px; border-bottom:1px solid #e5e5e5;' : ''}">â¤ï¸ ${likesStr}</div>` : ''}
                                        ${commentsHtml}
                                    </div>
                                    ` : ''}
                                </div>
                            </div>
                        </div>
                    `;
                });
            }
            
            container.innerHTML = html;
        }
        
        // æ¸²æŸ“è§’è‰²è´¦å·çš„"æˆ‘"é¡µé¢ï¼ˆæŸ¥å²—æ¨¡å¼ï¼‰
        async function renderRoleAccountMePage(container) {
            const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
            if (!roleChar) {
                container.innerHTML = '<div class="wechat-empty-state"><div>æš‚æ— æ•°æ®</div></div>';
                return;
            }
            
            const identity = roleChar.identity || {};
            const wechatData = roleChar.generated_wechat_data || {};
            
            // ä¼˜å…ˆä½¿ç”¨AIç”Ÿæˆçš„ä½™é¢ï¼Œå¦åˆ™ä½¿ç”¨è§’è‰²æ¡£æ¡ˆçš„ä½™é¢
            const balance = wechatData.balance || identity.balance || '0.00';
            
            const avatarStyle = roleChar.avatar ? `background-image:url(${roleChar.avatar})` : 'background-color:#eee';
            
            // æ˜¾ç¤ºè§’è‰²æ¡£æ¡ˆçš„æ‰€æœ‰è™šæ‹Ÿèº«ä»½ä¿¡æ¯
            const html = `
                <div style="background:#fff;">
                    <!-- æŸ¥å²—æ¨¡å¼æç¤º -->
                    <div style="padding:10px 16px; background:#FFF5F7; color:#FF6B9D; font-size:12px;">
                        ğŸ” æ­£åœ¨æŸ¥çœ‹ <b>${roleChar.name}</b> çš„ä¸ªäººä¿¡æ¯
                    </div>
                    
                    <!-- ä¸ªäººä¿¡æ¯å¤´éƒ¨ -->
                    <div style="padding:20px; text-align:center; background:linear-gradient(135deg, #FFB6C1 0%, #FFC0CB 100%);">
                        <div style="width:80px; height:80px; border-radius:12px; ${avatarStyle}; background-size:cover; background-position:center; margin:0 auto 10px; border:2px solid rgba(255,255,255,0.3);"></div>
                        <div style="font-size:18px; font-weight:600; color:#fff; margin-bottom:5px;">${roleChar.name}</div>
                        ${roleChar.nick ? `<div style="font-size:14px; color:rgba(255,255,255,0.8); margin-bottom:5px;">${roleChar.nick}</div>` : ''}
                        <div style="font-size:14px; color:rgba(255,255,255,0.9);">å¾®ä¿¡å·ï¼š${identity.account || 'æœªè®¾ç½®'}</div>
                    </div>
                    
                    <!-- ä½™é¢ -->
                    <div style="padding:15px 16px; border-bottom:1px solid #f0f0f0;">
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <div style="font-size:16px; font-weight:500;">ğŸ’° é’±åŒ…ä½™é¢</div>
                            <div style="font-size:20px; font-weight:600; color:#FF6B9D;">Â¥${balance}</div>
                        </div>
                    </div>
                    
                    <!-- è™šæ‹Ÿèº«ä»½ä¿¡æ¯ -->
                    <div style="padding:15px 16px; background:#f8f8f8;">
                        <div style="font-size:14px; font-weight:600; color:#666; margin-bottom:10px;">ğŸ” è™šæ‹Ÿèº«ä»½ä¿¡æ¯</div>
                    </div>
                    
                    ${identity.password ? `
                    <div style="padding:15px 16px; border-bottom:1px solid #f0f0f0;">
                        <div style="font-size:14px; color:#666; margin-bottom:5px;">è´¦å·å¯†ç </div>
                        <div style="font-size:16px; font-family:monospace; color:#FF6B9D;">${identity.password}</div>
                    </div>
                    ` : ''}
                    
                    <div style="padding:15px 16px; border-bottom:1px solid #f0f0f0;">
                        <div style="font-size:14px; color:#666; margin-bottom:5px;">ğŸ“± æ‰‹æœºå·</div>
                        <div style="font-size:16px;">${identity.phone || 'æœªè®¾ç½®'}</div>
                    </div>
                    
                    <div style="padding:15px 16px; border-bottom:1px solid #f0f0f0;">
                        <div style="font-size:14px; color:#666; margin-bottom:5px;">ğŸ  ä½å€</div>
                        <div style="font-size:16px;">${identity.address || 'æœªè®¾ç½®'}</div>
                    </div>
                    
                    ${identity.id_card ? `
                    <div style="padding:15px 16px; border-bottom:1px solid #f0f0f0;">
                        <div style="font-size:14px; color:#666; margin-bottom:5px;">ğŸªª èº«ä»½è¯å·</div>
                        <div style="font-size:16px; font-family:monospace;">${identity.id_card}</div>
                    </div>
                    ` : ''}
                    
                    ${identity.bank_card ? `
                    <div style="padding:15px 16px; border-bottom:1px solid #f0f0f0;">
                        <div style="font-size:14px; color:#666; margin-bottom:5px;">ğŸ’³ é“¶è¡Œå¡å·</div>
                        <div style="font-size:16px; font-family:monospace;">${identity.bank_card}</div>
                    </div>
                    ` : ''}
                    
                    ${identity.bank_password ? `
                    <div style="padding:15px 16px; border-bottom:1px solid #f0f0f0;">
                        <div style="font-size:14px; color:#666; margin-bottom:5px;">ğŸ”‘ é“¶è¡Œå¯†ç </div>
                        <div style="font-size:16px; font-family:monospace; color:#FF6B9D;">${identity.bank_password}</div>
                    </div>
                    ` : ''}
                    
                    <!-- é€€å‡ºæŸ¥å²—æŒ‰é’® -->
                    <div style="padding:20px 16px;">
                        <button onclick="exitRoleAccountView()" style="width:100%; padding:14px; background:#FF6B9D; color:#fff; border:none; border-radius:10px; font-size:16px; cursor:pointer; font-weight:600;">é€€å‡ºæŸ¥å²—æ¨¡å¼</button>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
        }
        
        // é€€å‡ºæŸ¥å²—æ¨¡å¼
        async function exitRoleAccountView() {
            isViewingRoleAccount = false;
            currentViewingRoleAccountId = null;
            
            // æ¢å¤åŸæ¥çš„ç”¨æˆ·ID
            if (window.originalMyCharIdBeforeRoleView) {
                currentMyCharId = window.originalMyCharIdBeforeRoleView;
                window.originalMyCharIdBeforeRoleView = null;
            }
            
            await switchWechatTab(0);
            showToast('å·²é€€å‡ºæŸ¥å²—æ¨¡å¼');
        }

        // ========== è´¦å·éš”ç¦»è¾…åŠ©å‡½æ•° ==========
        // è·å–å½“å‰è´¦å·IDï¼ˆç”¨äºæ•°æ®éš”ç¦»ï¼‰
        function getCurrentAccountId() {
            return currentMyCharId ? String(currentMyCharId) : null;
        }

        // --- è§’è‰²å±æ€§ per-user getter/setter ---
        // è·å–è§’è‰²å¤‡æ³¨ï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰
        function getCharRemark(char, accountId) {
            if (accountId && char.remark_by_user?.[accountId] !== undefined) return char.remark_by_user[accountId];
            return char.remark || '';
        }
        // è®¾ç½®è§’è‰²å¤‡æ³¨ï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰
        function setCharRemark(char, accountId, value) {
            if (!accountId) { char.remark = value; return; }
            if (!char.remark_by_user) char.remark_by_user = {};
            char.remark_by_user[accountId] = value;
        }

        // è·å–è§’è‰²å¾®ä¿¡æ˜µç§°ï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰
        function getCharWxNickname(char, accountId) {
            if (accountId && char.wx_nickname_by_user?.[accountId] !== undefined) return char.wx_nickname_by_user[accountId];
            return char.wx_nickname || '';
        }
        // è®¾ç½®è§’è‰²å¾®ä¿¡æ˜µç§°ï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰
        function setCharWxNickname(char, accountId, value) {
            if (!accountId) { char.wx_nickname = value; return; }
            if (!char.wx_nickname_by_user) char.wx_nickname_by_user = {};
            char.wx_nickname_by_user[accountId] = value;
        }

        // è·å–è§’è‰²å¤´åƒï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰
        function getCharAvatar(char, accountId) {
            if (accountId && char.avatar_by_user?.[accountId] !== undefined) return char.avatar_by_user[accountId];
            return char.avatar || '';
        }
        // è®¾ç½®è§’è‰²å¤´åƒï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰
        function setCharAvatar(char, accountId, value) {
            if (!accountId) { char.avatar = value; return; }
            if (!char.avatar_by_user) char.avatar_by_user = {};
            char.avatar_by_user[accountId] = value;
        }

        // è·å–è§’è‰²ç½®é¡¶çŠ¶æ€ï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰
        function getCharPinned(char, accountId) {
            if (accountId && char.is_pinned_by_user?.[accountId] !== undefined) return char.is_pinned_by_user[accountId];
            return false;
        }
        // è®¾ç½®è§’è‰²ç½®é¡¶çŠ¶æ€ï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰
        function setCharPinned(char, accountId, value) {
            if (!accountId) { char.is_pinned = value; return; }
            if (!char.is_pinned_by_user) char.is_pinned_by_user = {};
            char.is_pinned_by_user[accountId] = value;
        }

        // è·å–è§’è‰²æ˜¾ç¤ºåï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰ï¼šå¤‡æ³¨ > å¾®ä¿¡æ˜µç§° > ç½‘å > åŸå
        function getCharDisplayName(char, accountId) {
            const remark = getCharRemark(char, accountId);
            if (remark) return remark;
            const wxNick = getCharWxNickname(char, accountId);
            if (wxNick) return wxNick;
            return char.nick || char.name;
        }

        // è·å–è§’è‰²çš„å¥½å‹çŠ¶æ€ï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼Œå«æ—§æ•°æ®å…¼å®¹ï¼‰
        function getFriendStatus(char, accountId) {
            if (!accountId) return char.wechat_status || 'stranger';
            // ä¼˜å…ˆä»æŒ‰è´¦å·éš”ç¦»çš„ç»“æ„ä¸­è¯»å–
            const perUserStatus = char.wechat_status_by_user?.[accountId];
            if (perUserStatus && perUserStatus !== 'stranger') {
                return perUserStatus;
            }
            // å…œåº•ï¼šå¦‚æœæŒ‰è´¦å·éš”ç¦»æ²¡æœ‰è®°å½•ï¼Œæ£€æŸ¥æ—§çš„å…¨å±€çŠ¶æ€
            // è¿™ç”¨äºå…¼å®¹æ—§æ•°æ®ï¼ˆæ•°æ®éš”ç¦»åŠŸèƒ½ä¸Šçº¿å‰æ·»åŠ çš„å¥½å‹ï¼‰
            if (char.wechat_status && char.wechat_status !== 'stranger') {
                return char.wechat_status;
            }
            return perUserStatus || 'stranger';
        }

        // è®¾ç½®è§’è‰²çš„å¥½å‹çŠ¶æ€ï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰
        async function setFriendStatus(char, accountId, status) {
            // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°å¥½å‹çŠ¶æ€å­—æ®µï¼Œé˜²æ­¢è¦†ç›–è®¾ç½®ç­‰å…¶ä»–æ•°æ®
            const updatePayload = {};
            if (!accountId) {
                // å…¼å®¹æ—§ä»£ç ï¼šå¦‚æœæ²¡æœ‰è´¦å·IDï¼Œä½¿ç”¨æ—§ç»“æ„
                char.wechat_status = status;
                updatePayload.wechat_status = status;
            } else {
                if (!char.wechat_status_by_user) char.wechat_status_by_user = {};
                char.wechat_status_by_user[accountId] = status;
                updatePayload.wechat_status_by_user = { ...char.wechat_status_by_user };
            }
            try {
                await db.characters.update(char.id, updatePayload);
            } catch (err) {
                console.error('[setFriendStatus] âŒ å¥½å‹çŠ¶æ€ä¿å­˜å¤±è´¥:', err);
                // å›é€€åˆ° put() ç¡®ä¿æ•°æ®ä¸ä¸¢
                await safeCharacterPut(char, `å¥½å‹çŠ¶æ€[${char.name || char.id}]`);
            }
        }

        // è·å–è§’è‰²çš„èŠå¤©è®°å½•ï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰
        // ğŸ”§ æ€§èƒ½ä¼˜åŒ–ï¼šç›´æ¥è¿”å›åŸæ•°ç»„å¼•ç”¨ï¼Œä¸å†æ¯æ¬¡æ‹·è´ï¼ˆæ‹·è´å¤§æ•°ç»„å¼€é”€å¾ˆå¤§ï¼‰
        function getChatHistory(char, accountId) {
            if (!accountId) {
                return char.chat_history || [];
            }
            return char.chat_history_by_user?.[accountId] || [];
        }

        // è®¾ç½®è§’è‰²çš„èŠå¤©è®°å½•ï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰
        // ğŸ”§ ä¿®å¤æ•°æ®ä¸¢å¤±ï¼šå§‹ç»ˆä»DBè¯»å–æœ€æ–°è§’è‰²æ•°æ®å†ä¿å­˜ï¼Œé¿å…ç”¨æ—§ char å¯¹è±¡è¦†ç›–å¹¶å‘å†™å…¥çš„æ–°æ•°æ®
        // ğŸ›¡ï¸ å¢å¼ºï¼šå¸¦é‡è¯• + é”™è¯¯æé†’ + è„æ•°æ®æ ‡è®°ï¼Œé˜²æ­¢é™é»˜ä¸¢æ•°æ®
        async function setChatHistory(char, accountId, history) {
            // âœ… å¦‚æœç”¨æˆ·æ­£åœ¨æŸ¥çœ‹è¿™ä¸ªèŠå¤©ï¼Œè‡ªåŠ¨æ ‡è®°æ–°æ¶ˆæ¯ä¸ºå·²è¯»
            if (currentChatCharId === char.id) {
                history.forEach(m => {
                    if (m.role === 'char' && !m.read) {
                        m.read = true;
                    }
                });
            }
            
            // ğŸ›¡ï¸ å…ˆæ ‡è®°ä¸ºè„æ•°æ®ï¼Œå³ä½¿åç»­å†™å…¥å¤±è´¥ï¼Œå®šæ—¶å™¨ä¹Ÿèƒ½å…œåº•ä¿å­˜
            markChatDirty(char.id, char, accountId, history);
            
            // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°èŠå¤©è®°å½•å­—æ®µï¼Œé˜²æ­¢è¦†ç›–å…¶ä»–è®¾ç½®ï¼ˆå¦‚èŠå¤©è¯¦ç»†é‡Œçš„æ‰€æœ‰è®¾ç½®ï¼‰
            const updatePayload = {};
            
            if (!accountId) {
                // å…¼å®¹æ—§ä»£ç ï¼šå¦‚æœæ²¡æœ‰è´¦å·IDï¼Œä½¿ç”¨æ—§ç»“æ„
                updatePayload.chat_history = history;
                char.chat_history = history; // åŒæ­¥æ›´æ–°è°ƒç”¨æ–¹çš„å¼•ç”¨
            } else {
                // ğŸ”§ éœ€è¦è¯»å–æœ€æ–°çš„ chat_history_by_user å¹¶åˆå¹¶ï¼Œå› ä¸º update() æ˜¯å­—æ®µçº§æ›¿æ¢
                let freshChatHistoryByUser;
                try {
                    const freshChar = await db.characters.get(char.id);
                    if (!freshChar) {
                        console.warn('[setChatHistory] âš ï¸ è§’è‰²ä¸å­˜åœ¨ï¼Œè·³è¿‡ä¿å­˜:', char.id);
                        return;
                    }
                    freshChatHistoryByUser = freshChar.chat_history_by_user || {};
                } catch (dbReadErr) {
                    console.error('[setChatHistory] âŒ æ•°æ®åº“è¯»å–å¤±è´¥:', dbReadErr);
                    // è¯»å–å¤±è´¥æ—¶ä¸ä¸¢å¼ƒæ•°æ®ï¼Œè„æ•°æ®æ ‡è®°å·²æ‰“ä¸Šï¼Œå®šæ—¶å™¨ä¼šå…œåº•
                    return;
                }
                
                freshChatHistoryByUser[accountId] = history;
                updatePayload.chat_history_by_user = freshChatHistoryByUser;
                
                // åŒæ­¥æ›´æ–°è°ƒç”¨æ–¹çš„å¼•ç”¨
                if (!char.chat_history_by_user) char.chat_history_by_user = {};
                char.chat_history_by_user[accountId] = history;
            }
            
            // âœ… å¦‚æœæœ‰æ–°æ¶ˆæ¯ï¼ˆéç©ºå†å²ï¼‰ï¼Œè‡ªåŠ¨æ¸…é™¤èŠå¤©åˆ—è¡¨éšè—æ ‡è®°
            if (history && history.length > 0 && accountId) {
                try {
                    const freshChar = await db.characters.get(char.id);
                    if (freshChar && freshChar.chat_hidden_by_user && freshChar.chat_hidden_by_user[accountId]) {
                        const hiddenByUser = { ...freshChar.chat_hidden_by_user };
                        hiddenByUser[accountId] = false;
                        updatePayload.chat_hidden_by_user = hiddenByUser;
                    }
                } catch (_) {}
            }
            
            // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°æŒ‡å®šå­—æ®µï¼Œä¸ä¼šè¦†ç›–è®¾ç½®/å¥½å‹çŠ¶æ€ç­‰å…¶ä»–æ•°æ®
            try {
                const updated = await db.characters.update(char.id, updatePayload);
                if (updated) {
                    // å†™å…¥æˆåŠŸï¼Œæ¸…é™¤è„æ ‡è®°
                    _pendingDirtySaves.delete(char.id);
                } else {
                    console.warn('[setChatHistory] âš ï¸ updateè¿”å›0ï¼Œè§’è‰²å¯èƒ½ä¸å­˜åœ¨:', char.id);
                }
            } catch (err) {
                console.error(`[setChatHistory] âŒ èŠå¤©è®°å½•å†™å…¥å¤±è´¥:`, err.message);
                // æ£€æŸ¥æ˜¯å¦æ˜¯é…é¢ä¸è¶³
                if (err.name === 'QuotaExceededError' || (err.inner && err.inner.name === 'QuotaExceededError')) {
                    try { showToast('âš ï¸ å­˜å‚¨ç©ºé—´ä¸è¶³ï¼ŒèŠå¤©è®°å½•å¯èƒ½æ— æ³•ä¿å­˜ï¼è¯·å¯¼å‡ºå¤‡ä»½ã€‚'); } catch(_) {}
                }
                // å†™å…¥å¤±è´¥ï¼Œè„æ ‡è®°ä¿ç•™ï¼Œå®šæ—¶å™¨ä¼šç»§ç»­å°è¯•ä¿å­˜
            }
        }

        // æ•°æ®è¿ç§»ï¼šå°†æ—§ç»“æ„è¿ç§»åˆ°æ–°ç»“æ„ï¼ˆä¸å½±å“ç°æœ‰æ•°æ®ï¼‰
        async function migrateAccountData() {
            const migrationKey = 'account_isolation_v2';
            if (localStorage.getItem(migrationKey) === 'true') {
                return; // å·²ç»è¿ç§»è¿‡
            }

            console.log('[Migration] å¼€å§‹è¿ç§»è´¦å·éš”ç¦»æ•°æ®(v2)...');
            const allChars = await db.characters.toArray();
            let migratedCount = 0;
            
            // æ‰¾åˆ°æœ€æ—©åˆ›å»ºçš„ User è´¦å·ï¼Œæ—§æ•°æ®åªå½’å±äºè¿™ä¸ªè´¦å·
            const allUsers = await db.characters.where('type').equals('user').toArray();
            const primaryUser = allUsers.length > 0 ? allUsers.reduce((oldest, u) => (!oldest || u.id < oldest.id) ? u : oldest, null) : null;
            const primaryAccountId = primaryUser ? String(primaryUser.id) : null;

            for (const char of allChars) {
                let needSave = false;

                // è¿ç§»å¥½å‹çŠ¶æ€ï¼šæ—§æ•°æ®åªå½’å±äºä¸»è´¦å·
                if (char.wechat_status && !char.wechat_status_by_user) {
                    char.wechat_status_by_user = {};
                    if (primaryAccountId) {
                        char.wechat_status_by_user[primaryAccountId] = char.wechat_status;
                    }
                    needSave = true;
                }

                // è¿ç§»èŠå¤©è®°å½•ï¼šæ—§æ•°æ®åªå½’å±äºä¸»è´¦å·ï¼Œå…¶ä»–è´¦å·ä¿æŒç©ºç™½
                if (char.chat_history && char.chat_history.length > 0 && !char.chat_history_by_user) {
                    char.chat_history_by_user = {};
                    if (primaryAccountId) {
                        char.chat_history_by_user[primaryAccountId] = [...char.chat_history];
                    }
                    needSave = true;
                }
                
                // æ¸…ç†å·²æœ‰çš„ chat_history_by_user ä¸­ä¸å±äºæ­£ç¡®è´¦å·çš„æ•°æ®
                // å¦‚æœ chat_history_by_user å·²å­˜åœ¨ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰è¢«é”™è¯¯å¤åˆ¶çš„æ•°æ®
                if (char.chat_history_by_user && char.chat_history && char.chat_history.length > 0) {
                    for (const uid of Object.keys(char.chat_history_by_user)) {
                        // è·³è¿‡ä¸»è´¦å·
                        if (uid === primaryAccountId) continue;
                        // å¦‚æœè¯¥è´¦å·ä¸æ˜¯å¥½å‹ï¼Œä½†æœ‰èŠå¤©è®°å½•ï¼Œè¯´æ˜æ˜¯è¢«é”™è¯¯å¤åˆ¶çš„
                        const friendStatus = char.wechat_status_by_user?.[uid];
                        if (!friendStatus || friendStatus === 'stranger') {
                            // ä¸æ˜¯å¥½å‹å´æœ‰èŠå¤©è®°å½•ï¼Œæ¸…é™¤è¿™äº›æ³„æ¼çš„æ•°æ®
                            delete char.chat_history_by_user[uid];
                            needSave = true;
                        }
                    }
                }

                if (needSave) {
                    await safeCharacterPut(char);
                    migratedCount++;
                }
            }

            localStorage.setItem(migrationKey, 'true');
            console.log(`[Migration] v2è¿ç§»å®Œæˆï¼Œå…±å¤„ç† ${migratedCount} ä¸ªè§’è‰²`);
        }

        async function performSwitchAccount(id) {
            // é€€å‡ºæŸ¥å²—æ¨¡å¼ï¼ˆå¦‚æœæ­£åœ¨æŸ¥å²—ï¼‰
            if (isViewingRoleAccount) {
                isViewingRoleAccount = false;
                currentViewingRoleAccountId = null;
            }
            
            currentMyCharId = id;
            safeLocalStorageSet('current_my_char_id', id);
            window.originalMyCharIdBeforeRoleView = null; // æ¸…é™¤ä¿å­˜çš„ID
            
            closeModal('switch-account-modal');
            
            // âœ… æ£€æŸ¥åˆ‡æ¢åˆ°çš„è´¦å·æ˜¯å¦å·²æ³¨å†Œå¾®ä¿¡å·
            const targetUser = await db.characters.get(parseInt(id));
            if (targetUser && (!targetUser.identity || !targetUser.identity.wechat_registered)) {
                // è¯¥è´¦å·æœªæ³¨å†Œå¾®ä¿¡å·ï¼Œæ˜¾ç¤ºæ³¨å†Œé¡µé¢
                console.log('[åˆ‡æ¢è´¦å·] ç›®æ ‡è´¦å·æœªæ³¨å†Œå¾®ä¿¡å·ï¼Œæ˜¾ç¤ºæ³¨å†Œé¡µé¢');
                await showWechatRegisterPageForUser(id);
                return;
            }
            
            // åˆ·æ–°æ‰€æœ‰ç›¸å…³é¡µé¢
            const content = document.getElementById('wechat-content');
            if (content) {
                // æ ¹æ®å½“å‰tabåˆ·æ–°å¯¹åº”å†…å®¹
                const activeTab = document.querySelector('.wechat-tab-item.active');
                if (activeTab) {
                    const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                    switchWechatTab(tabIndex);
                } else {
                    await renderMePage(content);
                }
            }
            
            // åˆ·æ–°é’±åŒ…ä½™é¢æ˜¾ç¤º
            updateWalletBalanceDisplay();
            updateBalancePageDisplay();
        }
        
        // ä¸ºæŒ‡å®šç”¨æˆ·æ˜¾ç¤ºå¾®ä¿¡æ³¨å†Œé¡µé¢
        async function showWechatRegisterPageForUser(userId) {
            const registerPage = document.getElementById('wechat-register-page');
            const userSelect = document.getElementById('register-user-select');
            const phoneInput = document.getElementById('register-phone-input');
            const phoneHint = document.getElementById('register-phone-hint');
            
            // æ¸…ç©ºä¸‹æ‹‰æ¡†å¹¶è®¾ç½®ä¸ºæŒ‡å®šç”¨æˆ·
            const user = await db.characters.get(parseInt(userId));
            if (!user) {
                showToast('ç”¨æˆ·ä¸å­˜åœ¨');
                return;
            }
            
            userSelect.innerHTML = `<option value="${user.id}" selected>${user.name}</option>`;
            
            // âœ… è‡ªåŠ¨å¡«å†™æ‰‹æœºå·ï¼ˆä»æ¡£æ¡ˆä¸­è¯»å–ï¼‰
            if (user.identity && user.identity.phone) {
                selectedUserPhone = user.identity.phone;
                phoneInput.value = selectedUserPhone;
                phoneHint.style.display = 'block';
            } else {
                selectedUserPhone = '';
                phoneInput.value = '';
                phoneHint.style.display = 'none';
            }
            
            // æ¸…ç©ºå…¶ä»–è¾“å…¥æ¡†ï¼ˆéªŒè¯ç ã€å¯†ç ã€å¾®ä¿¡å·ï¼‰
            const codeInput = document.getElementById('register-code-input');
            const passwordInput = document.getElementById('register-password-input');
            const accountInput = document.getElementById('register-account-input');
            if (codeInput) codeInput.value = '';
            if (passwordInput) passwordInput.value = '';
            if (accountInput) accountInput.value = '';
            
            // é‡ç½®éªŒè¯ç çŠ¶æ€
            generatedVerificationCode = '';
            verificationCodeExpiry = 0;
            
            // æ˜¾ç¤ºæ³¨å†Œé¡µé¢
            registerPage.style.display = 'flex';
        }

        // æ¸²æŸ“å¾®ä¿¡èŠå¤©åˆ—è¡¨
        async function renderWechatList(container) {
            // æŸ¥å²—æ¨¡å¼ï¼šæ˜¾ç¤ºè§’è‰²ç”Ÿæˆçš„æ•°æ®
            if (isViewingRoleAccount && currentViewingRoleAccountId) {
                await renderRoleAccountWechatList(container);
                return;
            }
            
            const accountId = getCurrentAccountId();
            // è·å–æ‰€æœ‰è§’è‰²ï¼Œç„¶åæŒ‰è´¦å·è¿‡æ»¤å¥½å‹ï¼ˆåŒ…æ‹¬å·²åˆ é™¤å’Œå·²æ‹‰é»‘çš„ï¼‰
            let allChars = await db.characters.toArray();
            let friends = allChars.filter(c => {
                if (c.type === 'user') return false; // æ’é™¤Userç±»å‹
                // è¿‡æ»¤æ‰è¢«ç”¨æˆ·ä»èŠå¤©åˆ—è¡¨éšè—çš„å¥½å‹
                if (c.chat_hidden_by_user && c.chat_hidden_by_user[accountId]) return false;
                const status = getFriendStatus(c, accountId);
                return status === 'friend' || status === 'deleted' || status === 'blocked' || status === 'deleted_by_char' || status === 'blocked_by_char'; // åŒ…æ‹¬å·²åˆ é™¤å’Œå·²æ‹‰é»‘çš„å¥½å‹ï¼ˆå«è¢«è§’è‰²æ“ä½œçš„ï¼‰
            });
            
            // è·å–ç¾¤èŠåˆ—è¡¨
            let groupChats = [];
            try {
                groupChats = await getGroupChats(accountId);
            } catch (e) {
                console.log('è·å–ç¾¤èŠåˆ—è¡¨å¤±è´¥ï¼Œå¯èƒ½è¡¨ä¸å­˜åœ¨:', e);
            }
            
            // å°†ç¾¤èŠè½¬æ¢ä¸ºç»Ÿä¸€æ ¼å¼ï¼Œæ·»åŠ æ ‡è®°
            const groupItems = groupChats.map(g => ({
                ...g,
                _isGroup: true,
                _groupId: g.id
            }));
            
            // åˆå¹¶å¥½å‹å’Œç¾¤èŠåˆ—è¡¨
            let allItems = [...friends.map(f => ({...f, _isGroup: false})), ...groupItems];
            
            // ğŸ”§ æ€§èƒ½ä¼˜åŒ–ï¼šé¢„è®¡ç®—æ’åºé”®ï¼ˆé¿å…æ’åºæ¯”è¾ƒå™¨ä¸­é‡å¤è°ƒç”¨ getChatHistoryï¼‰
            for (const item of allItems) {
                item._pinned = item._isGroup ? item.is_pinned : getCharPinned(item, accountId);
                if (item._isGroup) {
                    const h = item.chat_history || [];
                    // âœ… ä¿®å¤ï¼šä»åå¾€å‰æ‰¾åˆ°æœ€åä¸€æ¡æœ‰æ—¶é—´æˆ³çš„æ¶ˆæ¯ï¼ŒåŒæ—¶ä¸ updated_at å–æœ€å¤§å€¼
                    let lastMsgTime = 0;
                    for (let _li = h.length - 1; _li >= 0; _li--) {
                        if (h[_li].time) { lastMsgTime = h[_li].time; break; }
                    }
                    item._lastTime = Math.max(lastMsgTime, item.updated_at || 0, item.created_at || 0);
                } else {
                    const h = getChatHistory(item, accountId);
                    item._lastTime = (h && h.length > 0) ? h[h.length - 1].time : (item.updated_at || 0);
                }
            }
            
            // æ’åºé€»è¾‘ï¼šç½®é¡¶ > æœ€åæ¶ˆæ¯æ—¶é—´
            allItems.sort((a, b) => {
                if (a._pinned && !b._pinned) return -1;
                if (!a._pinned && b._pinned) return 1;
                return b._lastTime - a._lastTime;
            });
            
            if (allItems.length === 0) {
                container.innerHTML = `
                    <div class="wechat-empty-state">
                        <svg class="svg-icon" style="width:48px; height:48px; stroke:#ccc;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="8" y1="15" x2="16" y2="15"></line><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg>
                        <div>æš‚æ— å¥½å‹</div>
                    </div>
                `;
                return;
            }

            container.innerHTML = '';
            const listDiv = document.createElement('div');
            listDiv.style.width = '100%';
            listDiv.style.background = '#fff';
            listDiv.style.overflowX = 'hidden';

            // ğŸ”§ æ€§èƒ½ä¼˜åŒ–ï¼šç”¨ DocumentFragment æ‰¹é‡æ’å…¥ï¼Œå‡å°‘é‡æ’
            const frag = document.createDocumentFragment();
            allItems.forEach(f => {
                // ç¾¤èŠé¡¹æ¸²æŸ“
                if (f._isGroup) {
                    const itemContainer = document.createElement('div');
                    itemContainer.className = 'wechat-list-item-container';
                    
                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'wechat-item-actions';
                    actionsDiv.innerHTML = `
                        <button class="wechat-action-btn btn-pin" onclick="toggleGroupPin(${f._groupId}, event)">${f.is_pinned ? 'å–æ¶ˆç½®é¡¶' : 'ç½®é¡¶'}</button>
                        <button class="wechat-action-btn btn-delete" onclick="deleteGroup(${f._groupId}, event)">åˆ é™¤</button>
                    `;
                    
                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'wechat-list-item-content';
                    contentDiv.style.cssText = 'display:flex; padding:12px 16px; border-bottom:0.5px solid #f0f0f0; align-items:center; gap:12px; background-color:' + (f.is_pinned ? '#f8f8f8' : '#fff');
                    
                    contentDiv.onclick = () => openGroupChatWindow(f._groupId);
                    
                    const avatarStyle = f.avatar ? `background-image:url(${f.avatar})` : 'background-color:#eee';
                    
                    let lastMsg = '';
                    let lastTimeStr = '';
                    const history = f.chat_history || [];
                    if (history.length > 0) {
                        // ğŸ”§ ä»åå¾€å‰æ‰¾åˆ°æœ€åä¸€æ¡å¯æ˜¾ç¤ºçš„æ¶ˆæ¯ï¼ˆè·³è¿‡è§†é¢‘é€šè¯å†…å®¹æ¶ˆæ¯ï¼‰
                        let last = null;
                        for (let li = history.length - 1; li >= 0; li--) {
                            if (!history[li].isVideoCall || history[li].role === 'system') {
                                last = history[li];
                                break;
                            }
                        }
                        if (!last) last = history[history.length - 1]; // fallback
                        
                        lastMsg = last.content;
                        if (lastMsg.startsWith('[img:')) lastMsg = '[å›¾ç‰‡]';
                        if (lastMsg.startsWith('[voice:')) lastMsg = '[è¯­éŸ³]';
                        if (lastMsg.startsWith('[imgcard:')) lastMsg = '[å¡ç‰‡]';
                        if (lastMsg.startsWith('[sticker:')) lastMsg = '[è¡¨æƒ…]';
                        // ğŸ”§ å¤„ç†å¤–å–å¡ç‰‡æ¶ˆæ¯
                        if (lastMsg.startsWith('[emei_order]')) lastMsg = '[å¤–å–è®¢å•]';
                        if (lastMsg.startsWith('[emei_share]')) lastMsg = '[å¤–å–åˆ†äº«]';
                        if (lastMsg.startsWith('[payment_request]')) lastMsg = '[ä»£ä»˜è¯·æ±‚]';
                        if (lastMsg.startsWith('[couple_avatar_card]')) lastMsg = '[æƒ…å¤´é‚€è¯·]';
                        if (last.role === 'system') lastMsg = '[ç³»ç»Ÿæ¶ˆæ¯]';
                        // âœ… å¤„ç†ç‰¹æ®Šæ¶ˆæ¯ç±»å‹
                        if (last.type === 'transfer') lastMsg = '[è½¬è´¦]';
                        if (last.type === 'familyCard') lastMsg = '[äº²å±å¡]';
                        if (last.type === 'audio') lastMsg = '[è¯­éŸ³]';
                        if (last.type === 'location') lastMsg = '[ä½ç½®]';
                        if (last.type === 'shopPayRequest') {
                            try {
                                const _spd = JSON.parse(last.content);
                                if (_spd.isShare) lastMsg = '[è´­ç‰©åˆ†äº«]';
                                else if (_spd.isGift) lastMsg = '[è´­ç‰©ç¤¼ç‰©]';
                                else lastMsg = '[ä»£ä»˜è¯·æ±‚]';
                            } catch(e) { lastMsg = '[ä»£ä»˜è¯·æ±‚]'; }
                        }
                        
                        const d = new Date(last.time);
                        const now = new Date();
                        if (d.toDateString() === now.toDateString()) {
                            lastTimeStr = `${d.getHours()}:${d.getMinutes().toString().padStart(2,'0')}`;
                        } else {
                            lastTimeStr = `${d.getMonth()+1}/${d.getDate()}`;
                        }
                    }
                    
                    // åˆ¤æ–­æ˜¯å¦æ˜¯è”æœºç¾¤èŠ
                    const isOnlineGroup = f.isOnlineGroup;
                    const groupTag = isOnlineGroup 
                        ? '<span style="background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); color:#fff; font-size:9px; padding:1px 4px; border-radius:2px; margin-left:6px;">è”æœºç¾¤</span>'
                        : '<span style="background:#07c160; color:#fff; font-size:9px; padding:1px 4px; border-radius:2px; margin-left:6px;">ç¾¤</span>';
                    
                    contentDiv.innerHTML = `
                        <div style="width:48px; height:48px; border-radius:6px; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0;"></div>
                        <div style="flex:1; min-width:0;">
                            <div style="display:flex; justify-content:space-between; margin-bottom:4px; align-items:center;">
                                <div style="display:flex; align-items:center;">
                                    <div style="font-size:16px; font-weight:500; color:#333;">${f.name}</div>
                                    ${groupTag}
                                </div>
                                <div style="font-size:12px; color:#999;">${lastTimeStr}</div>
                            </div>
                            <div style="font-size:14px; color:#999; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${lastMsg}</div>
                        </div>
                    `;
                    
                    bindSwipeEvents(contentDiv, itemContainer);
                    itemContainer.appendChild(actionsDiv);
                    itemContainer.appendChild(contentDiv);
                    frag.appendChild(itemContainer);
                    return;
                }
                
                // å¥½å‹é¡¹æ¸²æŸ“ï¼ˆåŸæœ‰ä»£ç ï¼‰
                // å®¹å™¨
                const itemContainer = document.createElement('div');
                itemContainer.className = 'wechat-list-item-container';
                
                // èƒŒæ™¯æ“ä½œæŒ‰é’®
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'wechat-item-actions';
                const _fPinned = getCharPinned(f, accountId);
                actionsDiv.innerHTML = `
                    <button class="wechat-action-btn btn-pin" onclick="togglePin(${f.id}, event)">${_fPinned ? 'å–æ¶ˆç½®é¡¶' : 'ç½®é¡¶'}</button>
                    <button class="wechat-action-btn btn-delete" onclick="deleteFriend(${f.id}, event)">åˆ é™¤</button>
                `;
                
                // å†…å®¹åŒºåŸŸ (å¯æ»‘åŠ¨)
                const contentDiv = document.createElement('div');
                contentDiv.className = 'wechat-list-item-content';
                contentDiv.dataset.charId = f.id; // æ ‡è®°è§’è‰²IDä¾›å¤–éƒ¨å®šä½
                
                // å†…å®¹æ ·å¼
                contentDiv.style.display = 'flex';
                contentDiv.style.padding = '12px 16px';
                contentDiv.style.borderBottom = '0.5px solid #f0f0f0';
                contentDiv.style.alignItems = 'center';
                contentDiv.style.gap = '12px';
                contentDiv.style.backgroundColor = _fPinned ? '#f8f8f8' : '#fff';

                // ç‚¹å‡»è¿›å…¥èŠå¤©
                contentDiv.onclick = (e) => {
                    if (itemContainer.dataset.swiped === 'true') {
                        resetSwipe(contentDiv);
                        itemContainer.dataset.swiped = 'false';
                        return;
                    }
                    openChatWindow(f.id);
                };

                const _fAvatar = getCharAvatar(f, accountId);
                const avatarStyle = _fAvatar ? `background-image:url(${_fAvatar})` : 'background-color:#eee';
                
                // æ£€æŸ¥å¥½å‹çŠ¶æ€
                const friendStatus = getFriendStatus(f, accountId);
                const isDeleted = friendStatus === 'deleted';
                const isBlocked = friendStatus === 'blocked';
                const isDeletedByChar = friendStatus === 'deleted_by_char';
                const isBlockedByChar = friendStatus === 'blocked_by_char';
                const isAnyInactive = isDeleted || isBlocked || isDeletedByChar || isBlockedByChar;
                
                let lastMsg = '';
                let lastTimeStr = '';
                const history = getChatHistory(f, accountId);
                if (history && history.length > 0) {
                    // ğŸ”§ ä»åå¾€å‰æ‰¾åˆ°æœ€åä¸€æ¡å¯æ˜¾ç¤ºçš„æ¶ˆæ¯ï¼ˆè·³è¿‡è§†é¢‘é€šè¯å†…å®¹æ¶ˆæ¯ï¼‰
                    let last = null;
                    for (let li = history.length - 1; li >= 0; li--) {
                        if (!history[li].isVideoCall || history[li].role === 'system') {
                            last = history[li];
                            break;
                        }
                    }
                    if (!last) last = history[history.length - 1]; // fallback
                    
                    lastMsg = last.content;
                    if (lastMsg.startsWith('[img:')) lastMsg = '[å›¾ç‰‡]';
                    if (lastMsg.startsWith('[voice:')) lastMsg = '[è¯­éŸ³]';
                    if (lastMsg.startsWith('[imgcard:')) lastMsg = '[å¡ç‰‡]';
                    if (lastMsg.startsWith('[sticker:')) lastMsg = '[è¡¨æƒ…]';
                    // ğŸ”§ å¤„ç†å¤–å–å¡ç‰‡æ¶ˆæ¯
                    if (lastMsg.startsWith('[emei_order]')) lastMsg = '[å¤–å–è®¢å•]';
                    if (lastMsg.startsWith('[emei_share]')) lastMsg = '[å¤–å–åˆ†äº«]';
                    if (lastMsg.startsWith('[payment_request]')) lastMsg = '[ä»£ä»˜è¯·æ±‚]';
                    if (lastMsg.startsWith('[couple_avatar_card]')) lastMsg = '[æƒ…å¤´é‚€è¯·]';
                    // âœ… å¤„ç†è½¬è´¦å’Œäº²å±å¡æ¶ˆæ¯
                    if (last.type === 'transfer') lastMsg = '[è½¬è´¦]';
                    if (last.type === 'familyCard') lastMsg = '[äº²å±å¡]';
                    if (last.type === 'audio') lastMsg = '[è¯­éŸ³]';
                    if (last.type === 'location') lastMsg = '[ä½ç½®]';
                    if (last.type === 'shopPayRequest') {
                        try {
                            const _spd2 = JSON.parse(last.content);
                            if (_spd2.isShare) lastMsg = '[è´­ç‰©åˆ†äº«]';
                            else if (_spd2.isGift) lastMsg = '[è´­ç‰©ç¤¼ç‰©]';
                            else lastMsg = '[ä»£ä»˜è¯·æ±‚]';
                        } catch(e) { lastMsg = '[ä»£ä»˜è¯·æ±‚]'; }
                    }
                    
                    const d = new Date(last.time);
                    const now = new Date();
                    if (d.toDateString() === now.toDateString()) {
                        lastTimeStr = `${d.getHours()}:${d.getMinutes().toString().padStart(2,'0')}`;
                    } else {
                        lastTimeStr = `${d.getMonth()+1}/${d.getDate()}`;
                    }
                }
                
                // æ ¹æ®çŠ¶æ€æ·»åŠ æ ‡è¯†
                let statusBadge = '';
                if (isDeleted) {
                    statusBadge = '<span style="background:#ff9500; color:#fff; font-size:10px; padding:2px 6px; border-radius:3px; margin-left:6px;">å·²åˆ é™¤</span>';
                } else if (isBlocked) {
                    statusBadge = '<span style="background:#ff3b30; color:#fff; font-size:10px; padding:2px 6px; border-radius:3px; margin-left:6px;">å·²æ‹‰é»‘</span>';
                } else if (isDeletedByChar) {
                    statusBadge = '<span style="background:#ff9500; color:#fff; font-size:10px; padding:2px 6px; border-radius:3px; margin-left:6px;">è¢«Taåˆ é™¤</span>';
                } else if (isBlockedByChar) {
                    statusBadge = '<span style="background:#ff3b30; color:#fff; font-size:10px; padding:2px 6px; border-radius:3px; margin-left:6px;">è¢«Taæ‹‰é»‘</span>';
                }
                const textColor = isAnyInactive ? '#999' : '#333';

                const displayName = getCharDisplayName(f, accountId);
                contentDiv.innerHTML = `
                    <div style="width:48px; height:48px; border-radius:6px; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; ${isAnyInactive ? 'opacity:0.6;' : ''}"></div>
                    <div style="flex:1; min-width:0;">
                        <div style="display:flex; justify-content:space-between; margin-bottom:4px; align-items:center;">
                            <div style="display:flex; align-items:center;">
                                <div style="font-size:16px; font-weight:500; color:${textColor};">${displayName}</div>
                                ${statusBadge}
                            </div>
                            <div class="wc-list-time" style="font-size:12px; color:#999;">${lastTimeStr}</div>
                        </div>
                        <div class="wc-list-lastmsg" style="font-size:14px; color:#999; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${lastMsg}</div>
                    </div>
                `;

                bindSwipeEvents(contentDiv, itemContainer);

                itemContainer.appendChild(actionsDiv);
                itemContainer.appendChild(contentDiv);
                frag.appendChild(itemContainer);
            });
            listDiv.appendChild(frag); // æ‰¹é‡æ’å…¥æ‰€æœ‰åˆ—è¡¨é¡¹
            container.appendChild(listDiv);
        }

        // æ»‘åŠ¨äº‹ä»¶ç»‘å®š
        function bindSwipeEvents(element, container) {
            let startX = 0;
            let currentX = 0;
            let isSwiping = false;
            const threshold = 30; // è§¦å‘é˜ˆå€¼
            const maxSwipe = 160; // ä¸¤ä¸ªæŒ‰é’®å®½åº¦

            element.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                // å¤ä½å…¶ä»–é¡¹
                document.querySelectorAll('.wechat-list-item-content').forEach(el => {
                    if (el !== element && el.style.transform && el.style.transform !== 'translateX(0px)') {
                        el.style.transform = 'translateX(0px)';
                        el.parentElement.dataset.swiped = 'false';
                    }
                });
            }, {passive: true});

            element.addEventListener('touchmove', (e) => {
                currentX = e.touches[0].clientX;
                let diff = currentX - startX;
                
                if (diff < 0) {
                    if (Math.abs(diff) > 10) isSwiping = true;
                    let move = diff;
                    if (Math.abs(move) > maxSwipe) {
                        move = -maxSwipe - (Math.abs(move) - maxSwipe) * 0.2;
                    }
                    element.style.transform = `translateX(${move}px)`;
                } else if (container.dataset.swiped === 'true') {
                    let move = -maxSwipe + diff;
                    if (move > 0) move = 0;
                    element.style.transform = `translateX(${move}px)`;
                }
            }, {passive: true});

            element.addEventListener('touchend', (e) => {
                if (!isSwiping && container.dataset.swiped !== 'true') return;
                
                const diff = currentX - startX;
                if (diff < -threshold || (container.dataset.swiped === 'true' && diff < threshold && diff > -threshold)) {
                    element.style.transform = `translateX(-${maxSwipe}px)`;
                    container.dataset.swiped = 'true';
                } else {
                    element.style.transform = 'translateX(0px)';
                    container.dataset.swiped = 'false';
                }
                isSwiping = false;
            });
        }

        function resetSwipe(element) {
            element.style.transform = 'translateX(0px)';
        }

        async function togglePin(id, e) {
            e.stopPropagation();
            const char = await db.characters.get(id);
            if (char) {
                const _pinAid = getCurrentAccountId();
                const newPinValue = !getCharPinned(char, _pinAid);
                setCharPinned(char, _pinAid, newPinValue);
                // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°ç½®é¡¶å­—æ®µï¼Œé˜²æ­¢è¦†ç›–è®¾ç½®
                const pinUpdate = {};
                if (!_pinAid) {
                    pinUpdate.is_pinned = newPinValue;
                } else {
                    pinUpdate.is_pinned_by_user = { ...(char.is_pinned_by_user || {}) };
                }
                await db.characters.update(id, pinUpdate).catch(err => {
                    console.error('[togglePin] updateå¤±è´¥ï¼Œå›é€€put:', err);
                    return safeCharacterPut(char, 'ç½®é¡¶');
                });
                renderWechatList(document.getElementById('wechat-content'));
            }
        }
        
        // ç¾¤èŠç½®é¡¶åˆ‡æ¢
        async function toggleGroupPin(groupId, e) {
            e.stopPropagation();
            const group = await db.group_chats.get(groupId);
            if (group) {
                group.is_pinned = !group.is_pinned;
                await safeGroupChatPut(group);
                renderWechatList(document.getElementById('wechat-content'));
            }
        }
        
        // åˆ é™¤ç¾¤èŠ
        async function deleteGroup(groupId, e) {
            e.stopPropagation();
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªç¾¤èŠå—ï¼Ÿ\n(èŠå¤©è®°å½•å°†è¢«æ¸…é™¤)')) {
                await db.group_chats.delete(groupId);
                renderWechatList(document.getElementById('wechat-content'));
            }
        }

        async function deleteFriend(id, e) {
            e.stopPropagation();
            if (confirm('ç¡®å®šè¦åˆ é™¤è¯¥å¥½å‹å—ï¼Ÿ\n(èŠå¤©è®°å½•å°†è¢«æ¸…ç©ºï¼Œå¥½å‹å°†ä»èŠå¤©åˆ—è¡¨å’Œé€šè®¯å½•ä¸­ç§»é™¤)')) {
                const char = await db.characters.get(id);
                if (char) {
                    const accountId = getCurrentAccountId();
                    
                    // æ¸…ç©ºèŠå¤©è®°å½•
                    await setChatHistory(char, accountId, []);
                    
                    // å°†å¥½å‹çŠ¶æ€æ”¹ä¸ºå·²åˆ é™¤ï¼ˆä»é€šè®¯å½•å’ŒèŠå¤©åˆ—è¡¨ä¸­ç§»é™¤ï¼‰
                    await setFriendStatus(char, accountId, 'deleted');
                    
                    // è®¾ç½®éšè—æ ‡è®°ï¼ˆé˜²æ­¢èŠå¤©åˆ—è¡¨ä»æ˜¾ç¤ºï¼‰
                    if (!char.chat_hidden_by_user) char.chat_hidden_by_user = {};
                    char.chat_hidden_by_user[accountId] = true;
                    setCharPinned(char, accountId, false);
                    
                    // åˆå§‹åŒ–ç­‰å¾…å¥½å‹ç”³è¯·çš„è®¾ç½®
                    if (!char.wait_friend_settings) {
                        char.wait_friend_settings = {};
                    }
                    if (!char.wait_friend_settings[accountId]) {
                        char.wait_friend_settings[accountId] = {
                            enabled: false,
                            interval: 60,
                            lastCheckTime: Date.now(),
                            nextCheckTime: null
                        };
                    }
                    await safeCharacterPut(char);
                    
                    // å¦‚æœå½“å‰æ­£åœ¨å’Œè¿™ä¸ªå¥½å‹èŠå¤©ï¼Œå…³é—­èŠå¤©çª—å£
                    if (currentChatCharId === id) {
                        document.getElementById('chat-window').style.display = 'none';
                        currentChatCharId = null;
                        // æ¢å¤åº•å±‚å¾®ä¿¡åˆ—è¡¨çš„å¯è§æ€§
                        const wechatEl = document.getElementById('wechat-page');
                        if (wechatEl) wechatEl.style.visibility = '';
                    }
                    
                    renderWechatList(document.getElementById('wechat-content'));
                    showToast('å·²åˆ é™¤å¥½å‹');
                }
            }
        }

        // æ¸²æŸ“é€šè®¯å½•åˆ—è¡¨
        async function renderContactList(container) {
            const accountId = getCurrentAccountId();
            // è·å–æ‰€æœ‰è§’è‰²ï¼Œç„¶åæŒ‰è´¦å·è¿‡æ»¤å¥½å‹
            let allChars = await db.characters.toArray();
            const friends = allChars.filter(c => {
                if (c.type === 'user') return false; // æ’é™¤Userç±»å‹
                const status = getFriendStatus(c, accountId);
                return status === 'friend';
            });
            
            container.innerHTML = '';
            const listDiv = document.createElement('div');
            listDiv.style.width = '100%';
            listDiv.style.background = '#fff';
            
            // æ·»åŠ "æ–°çš„å¥½å‹"å…¥å£ï¼ˆåŒæ—¶æ£€æŸ¥ toCharId å’Œ toAccountIdï¼‰
            const allRequests = await db.friend_requests.toArray();
            const pendingRequests = allRequests.filter(req => 
                req.status === 'pending' && 
                (req.toCharId === parseInt(accountId) || req.toAccountId === accountId)
            );
            const newFriendItem = document.createElement('div');
            newFriendItem.style.display = 'flex';
            newFriendItem.style.padding = '12px 16px';
            newFriendItem.style.borderBottom = '0.5px solid #f0f0f0';
            newFriendItem.style.alignItems = 'center';
            newFriendItem.style.gap = '12px';
            newFriendItem.style.cursor = 'pointer';
            newFriendItem.onclick = () => showNewFriendsPage();
            
            const badgeHtml = pendingRequests.length > 0 ? 
                `<div style="background:#ff3b30; color:#fff; font-size:12px; padding:2px 6px; border-radius:10px; min-width:18px; text-align:center;">${pendingRequests.length}</div>` : '';
            
            newFriendItem.innerHTML = `
                <div style="width:40px; height:40px; border-radius:4px; background:linear-gradient(135deg, #ffc2d1 0%, #ff8fab 100%); display:flex; align-items:center; justify-content:center;">
                    <svg class="svg-icon" style="width:24px; height:24px; stroke:#fff;" viewBox="0 0 24 24">
                        <path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                        <circle cx="8.5" cy="7" r="4"></circle>
                        <line x1="20" y1="8" x2="20" y2="14"></line>
                        <line x1="23" y1="11" x2="17" y2="11"></line>
                    </svg>
                </div>
                <div style="flex:1; font-size:16px; font-weight:500; color:#333;">æ–°çš„å¥½å‹</div>
                ${badgeHtml}
            `;
            listDiv.appendChild(newFriendItem);
            
            if (friends.length === 0) {
                const emptyDiv = document.createElement('div');
                emptyDiv.style.textAlign = 'center';
                emptyDiv.style.padding = '40px 20px';
                emptyDiv.style.color = '#999';
                emptyDiv.innerHTML = `
                    <svg class="svg-icon" style="width:48px; height:48px; stroke:#ccc; margin-bottom:10px;" viewBox="0 0 24 24"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg>
                    <div>é€šè®¯å½•ä¸ºç©º</div>
                `;
                listDiv.appendChild(emptyDiv);
            } else {
                friends.forEach(f => {
                    const item = document.createElement('div');
                    item.style.display = 'flex';
                    item.style.padding = '10px 16px';
                    item.style.borderBottom = '0.5px solid #f0f0f0';
                    item.style.alignItems = 'center';
                    item.style.gap = '12px';
                    item.onclick = () => openChatWindow(f.id);

                    const _cAvatar = getCharAvatar(f, accountId);
                    const avatarStyle = _cAvatar ? `background-image:url(${_cAvatar})` : 'background-color:#eee';
                    
                    item.innerHTML = `
                        <div style="width:40px; height:40px; border-radius:4px; ${avatarStyle}; background-size:cover; background-position:center;"></div>
                        <div style="font-size:16px; font-weight:500; color:#333;">${getCharDisplayName(f, accountId)}</div>
                    `;
                    listDiv.appendChild(item);
                });
            }
            container.appendChild(listDiv);
        }

        // èœå•ä¸å¼¹çª—é€»è¾‘
        function toggleWechatMenu() {
            const menu = document.getElementById('wechat-menu');
            menu.style.display = menu.style.display === 'flex' ? 'none' : 'flex';
            // ç‚¹å‡»å¤–éƒ¨å…³é—­ (ç®€å•å¤„ç†)
            setTimeout(() => {
                document.addEventListener('click', closeMenuOutside);
            }, 0);
        }
        function closeMenuOutside(e) {
            const menu = document.getElementById('wechat-menu');
            if (!menu.contains(e.target) && !e.target.closest('.wechat-add')) {
                menu.style.display = 'none';
                document.removeEventListener('click', closeMenuOutside);
            }
        }

        function closeModal(id) {
            document.getElementById(id).style.display = 'none';
            
            // å¦‚æœæ˜¯åˆ›å»ºç¾¤èŠå¼¹çª—ï¼Œé‡ç½®çŠ¶æ€
            if (id === 'create-group-modal') {
                window._addingGroupMembers = false;
                const nameInput = document.getElementById('group-name-input');
                if (nameInput) nameInput.style.display = '';
                const title = document.querySelector('#create-group-modal .modal-title');
                if (title) title.innerText = 'åˆ›å»ºç¾¤èŠ';
            }
        }

        // å½“å‰å¿ƒå£°ç›¸å…³å˜é‡
        let currentThoughtsCharId = null;
        let currentThoughtsMessageIndex = null;

        // æ˜¾ç¤ºè§’è‰²å¿ƒå£°
        async function showCharacterThoughts(charId, messageIndex) {
            if (!charId) return;
            
            const char = await db.characters.get(charId);
            if (!char) return;
            
            currentThoughtsCharId = charId;
            currentThoughtsMessageIndex = messageIndex;
            
            const modal = document.getElementById('thoughts-modal');
            const title = document.getElementById('thoughts-modal-title');
            const currentText = document.getElementById('thoughts-current-text');
            const currentTime = document.getElementById('thoughts-current-time');
            const historyContent = document.getElementById('thoughts-history-content');
            const historySection = document.getElementById('thoughts-history');
            const arrow = document.getElementById('thoughts-arrow');
            
            title.textContent = `TAçš„å¿ƒå£°`;
            
            // é‡ç½®å†å²åŒºåŸŸçŠ¶æ€
            historySection.style.display = 'none';
            arrow.classList.remove('expanded');
            historyContent.innerHTML = '';
            
            // è·å–å¿ƒå£°
            const currentDeleteBtn = document.getElementById('thoughts-current-delete');
            if (!char.thoughts || char.thoughts.length === 0) {
                currentText.textContent = 'æš‚æ— å¿ƒå£°';
                currentTime.textContent = '';
                document.getElementById('thoughts-history-btn').style.display = 'none';
                if (currentDeleteBtn) currentDeleteBtn.style.display = 'none';
            } else {
                if (currentDeleteBtn) currentDeleteBtn.style.display = 'block';
                // æ‰¾åˆ°æœ€æ–°çš„å¿ƒå£°ä½œä¸ºå½“å‰å¿ƒå£°
                const latestThought = char.thoughts[char.thoughts.length - 1];
                currentText.textContent = latestThought.content;
                const timeStr = new Date(latestThought.time).toLocaleString('zh-CN', {
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                currentTime.textContent = timeStr;
                
                // å¦‚æœæœ‰å†å²å¿ƒå£°ï¼ˆè¶…è¿‡1æ¡ï¼‰ï¼Œæ˜¾ç¤ºæŸ¥çœ‹å†å²æŒ‰é’®
                if (char.thoughts.length > 1) {
                    document.getElementById('thoughts-history-btn').style.display = 'flex';
                    
                    // æ¸²æŸ“å†å²å¿ƒå£°ï¼ˆé™¤äº†æœ€æ–°çš„ï¼‰
                    const historyThoughts = char.thoughts.slice(0, -1).reverse();
                    historyThoughts.forEach((thought, idx) => {
                        const item = document.createElement('div');
                        item.className = 'thoughts-history-item';
                        item.style.position = 'relative';
                        
                        const text = document.createElement('div');
                        text.className = 'thoughts-history-text';
                        text.textContent = thought.content;
                        
                        const bottomRow = document.createElement('div');
                        bottomRow.style.cssText = 'display:flex; justify-content:space-between; align-items:center;';
                        
                        const time = document.createElement('div');
                        time.className = 'thoughts-history-time';
                        time.textContent = new Date(thought.time).toLocaleString('zh-CN', {
                            month: 'short',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                        
                        const deleteBtn = document.createElement('div');
                        deleteBtn.textContent = 'åˆ é™¤';
                        deleteBtn.style.cssText = 'font-size:12px; color:#ff3b30; cursor:pointer; padding:2px 8px;';
                        // åŸå§‹ç´¢å¼• = char.thoughts.length - 2 - idx
                        const originalIndex = char.thoughts.length - 2 - idx;
                        deleteBtn.onclick = () => deleteThought(charId, originalIndex);
                        
                        bottomRow.appendChild(time);
                        bottomRow.appendChild(deleteBtn);
                        
                        item.appendChild(text);
                        item.appendChild(bottomRow);
                        historyContent.appendChild(item);
                    });
                } else {
                    document.getElementById('thoughts-history-btn').style.display = 'none';
                }
            }
            
            modal.style.display = 'flex';
        }

        // åˆ‡æ¢å†å²å¿ƒå£°æ˜¾ç¤º
        function toggleThoughtsHistory() {
            const historySection = document.getElementById('thoughts-history');
            const arrow = document.getElementById('thoughts-arrow');
            
            if (historySection.style.display === 'none') {
                historySection.style.display = 'block';
                arrow.classList.add('expanded');
            } else {
                historySection.style.display = 'none';
                arrow.classList.remove('expanded');
            }
        }

        // ç¼–è¾‘å½“å‰å¿ƒå£°
        async function editCurrentThought() {
            if (!currentThoughtsCharId) return;
            
            const char = await db.characters.get(currentThoughtsCharId);
            if (!char || !char.thoughts || char.thoughts.length === 0) {
                showToast('æš‚æ— å¿ƒå£°å¯ç¼–è¾‘');
                return;
            }
            
            const latestThought = char.thoughts[char.thoughts.length - 1];
            const newContent = prompt('ç¼–è¾‘å¿ƒå£°ï¼š', latestThought.content);
            
            if (newContent !== null && newContent.trim()) {
                char.thoughts[char.thoughts.length - 1].content = newContent.trim();
                await safeCharacterPut(char);
                
                // æ›´æ–°æ˜¾ç¤º
                document.getElementById('thoughts-current-text').textContent = newContent.trim();
                showToast('å¿ƒå£°å·²æ›´æ–°');
            }
        }

        // åˆ é™¤æŒ‡å®šç´¢å¼•çš„å¿ƒå£°
        async function deleteThought(charId, thoughtIndex) {
            if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡å¿ƒå£°å—ï¼Ÿ')) return;
            
            const char = await db.characters.get(charId);
            if (!char || !char.thoughts || thoughtIndex < 0 || thoughtIndex >= char.thoughts.length) return;
            
            char.thoughts.splice(thoughtIndex, 1);
            await safeCharacterPut(char);
            
            showToast('å¿ƒå£°å·²åˆ é™¤');
            // åˆ·æ–°å¿ƒå£°å¼¹çª—
            showCharacterThoughts(charId);
        }
        window.deleteThought = deleteThought;
        
        // åˆ é™¤å½“å‰å¿ƒå£°ï¼ˆæœ€æ–°ä¸€æ¡ï¼‰
        async function deleteCurrentThought() {
            if (!currentThoughtsCharId) return;
            
            const char = await db.characters.get(currentThoughtsCharId);
            if (!char || !char.thoughts || char.thoughts.length === 0) {
                showToast('æš‚æ— å¿ƒå£°å¯åˆ é™¤');
                return;
            }
            
            if (!confirm('ç¡®å®šè¦åˆ é™¤å½“å‰å¿ƒå£°å—ï¼Ÿ')) return;
            
            char.thoughts.pop(); // åˆ é™¤æœ€æ–°çš„
            await safeCharacterPut(char);
            
            showToast('å¿ƒå£°å·²åˆ é™¤');
            // åˆ·æ–°å¿ƒå£°å¼¹çª—
            showCharacterThoughts(currentThoughtsCharId);
        }
        window.deleteCurrentThought = deleteCurrentThought;

        // é‡æ–°ç”Ÿæˆå¿ƒå£°
        async function regenerateThought() {
            if (!currentThoughtsCharId) return;
            
            const char = await db.characters.get(currentThoughtsCharId);
            if (!char) return;
            
            showToast('æ­£åœ¨ç”Ÿæˆæ–°å¿ƒå£°...');
            
            // å…³é—­å¼¹çª—
            closeModal('thoughts-modal');
            
            // è§¦å‘AIé‡æ–°ç”Ÿæˆï¼ˆè¿™é‡Œç®€å•å¤„ç†ï¼Œå®é™…å¯ä»¥è°ƒç”¨AIæ¥å£ï¼‰
            // ç”±äºå¿ƒå£°æ˜¯åœ¨AIå›å¤æ—¶è‡ªåŠ¨ç”Ÿæˆçš„ï¼Œè¿™é‡Œæç¤ºç”¨æˆ·å‘é€æ¶ˆæ¯è§¦å‘
            showToast('è¯·å‘é€ä¸€æ¡æ¶ˆæ¯æ¥è§¦å‘æ–°çš„å¿ƒå£°ç”Ÿæˆ');
        }

        // æœç´¢å¥½å‹
        function showAddFriendModal() {
            document.getElementById('search-friend-modal').style.display = 'flex';
            document.getElementById('wechat-menu').style.display = 'none';
            // é‡ç½®çŠ¶æ€
            document.getElementById('search-account-input').value = '';
            document.getElementById('search-result-area').style.display = 'none';
            document.getElementById('apply-area').style.display = 'none';
            document.getElementById('search-cancel-btn').style.display = 'block';
        }

        let searchTargetChar = null;

        // è¾…åŠ©ï¼šè·å–ä¸–ç•Œä¹¦ä¸Šä¸‹æ–‡ (ç®€å•çš„å…³é”®è¯åŒ¹é…)
        // æ”¯æŒå•ä¸ªIDæˆ–IDæ•°ç»„ï¼Œè‡ªåŠ¨åŒ…å«å…¨å±€ä¸–ç•Œä¹¦
        async function getLorebookContext(lorebookIdOrIds, keywords) {
            // å…¼å®¹æ—§æ•°æ®ï¼šå¦‚æœæ˜¯å•ä¸ªIDï¼Œè½¬æ¢ä¸ºæ•°ç»„
            let ids = [];
            if (lorebookIdOrIds) {
                ids = Array.isArray(lorebookIdOrIds) ? [...lorebookIdOrIds] : [lorebookIdOrIds];
            }
            
            // ğŸ”¥ è‡ªåŠ¨åŠ è½½æ‰€æœ‰å…¨å±€ä¸–ç•Œä¹¦
            try {
                const allBooks = await db.lorebooks.toArray();
                const globalIds = allBooks.filter(b => b.scope === 'global').map(b => b.id);
                globalIds.forEach(gid => {
                    if (!ids.includes(gid)) ids.push(gid);
                });
            } catch (e) {
                console.warn('[ä¸–ç•Œä¹¦] åŠ è½½å…¨å±€ä¸–ç•Œä¹¦å¤±è´¥:', e);
            }
            
            if (ids.length === 0) return "";
            
            let allContext = [];
            const checkText = keywords ? keywords.toLowerCase() : "";
            
            // éå†æ‰€æœ‰ä¸–ç•Œä¹¦
            for (const id of ids) {
                const book = await db.lorebooks.get(id);
                if (!book || !book.content || !book.content.entries) continue;
                
                const entries = Object.values(book.content.entries);
                
                entries.forEach(entry => {
                    if (entry.enabled === false) return; // åªåŠ è½½å¯ç”¨çš„æ¡ç›®
                    
                    // æŒ‚è½½äº†å°±ç›´æ¥åŠ è½½æ‰€æœ‰å¯ç”¨çš„æ¡ç›®
                    allContext.push(entry.content);
                });
            }
            
            if (allContext.length > 0) {
                console.log(`[ä¸–ç•Œä¹¦] âœ… æˆåŠŸåŠ è½½ ${allContext.length} ä¸ªæ¡ç›®`);
                // ç®€å•æˆªæ–­ï¼Œé˜²æ­¢çˆ† Token
                const fullText = allContext.join('\n\n');
                const safeText = fullText.length > 10000 ? fullText.slice(0, 10000) + '...(å·²æˆªæ–­)' : fullText;
                return `ã€ä¸–ç•Œä¹¦è®¾å®šã€‘:\n${safeText}\n`;
            } else {
                console.log('[ä¸–ç•Œä¹¦] â„¹ï¸ æ²¡æœ‰å¯ç”¨çš„æ¡ç›®æˆ–æ¡ç›®ä¸ºç©º');
            }
            return "";
        }

        async function searchAccount() {
            const acc = document.getElementById('search-account-input').value.trim();
            if(!acc) return;
            
            // å…¨è¡¨æ‰«æåŒ¹é… identity.account
            const allChars = await db.characters.toArray();
            const target = allChars.find(c => c.identity && c.identity.account === acc);
            
            if (target) {
                searchTargetChar = target;
                document.getElementById('search-result-area').style.display = 'flex';
                document.getElementById('search-result-name').innerText = target.name;
                document.getElementById('search-result-id').innerText = "è´¦å·: " + acc;
                if(target.avatar) {
                    document.getElementById('search-result-avatar').style.backgroundImage = `url(${target.avatar})`;
                } else {
                    document.getElementById('search-result-avatar').style.backgroundImage = '';
                }
                
                // --- æ–°å¢ï¼šåŠ è½½ User åˆ—è¡¨ä¾›é€‰æ‹© ---
                const users = allChars.filter(c => c.type === 'user');
                const userSelect = document.getElementById('apply-user-select');
                userSelect.innerHTML = '';
                if(users.length === 0) {
                    const opt = document.createElement('option');
                    opt.value = "";
                    opt.text = "æ—  User è§’è‰² (è¯·å…ˆå»è§’è‰²æ¡£æ¡ˆæ–°å»º)";
                    userSelect.appendChild(opt);
                } else {
                    users.forEach(u => {
                        const opt = document.createElement('option');
                        opt.value = u.id;
                        opt.text = u.name;
                        userSelect.appendChild(opt);
                    });
                }
                
                document.getElementById('apply-area').style.display = 'block';
                document.getElementById('search-cancel-btn').style.display = 'none';
            } else {
                alert("æœªæ‰¾åˆ°è¯¥è´¦å·");
                searchTargetChar = null;
                document.getElementById('search-result-area').style.display = 'none';
                document.getElementById('apply-area').style.display = 'none';
            }
        }

        async function sendFriendRequest() {
            if(!searchTargetChar) return;
            
            const reason = document.getElementById('apply-reason').value.trim();
            const selectedUserId = document.getElementById('apply-user-select').value;
            
            if(!selectedUserId) {
                alert("è¯·å…ˆé€‰æ‹©ä¸€ä¸ª User èº«ä»½è¿›è¡Œç”³è¯·");
                return;
            }
            
            closeModal('search-friend-modal');
            alert("å¥½å‹ç”³è¯·å·²å‘é€ï¼Œè¯·ç¨å€™...");

            try {
                // 1. è·å– User æ•°æ®
                const userChar = await db.characters.get(parseInt(selectedUserId));
                
                // 2. å‡†å¤‡ Lorebook åŒ¹é…å…³é”®è¯ (Userå + Charå + ç”³è¯·ç†ç”±)
                const keywords = `${userChar.name} ${searchTargetChar.name} ${reason}`;
                
                // 3. è·å–åŒæ–¹ Lorebook ä¸Šä¸‹æ–‡ï¼ˆæ”¯æŒå¤šä¸ªä¸–ç•Œä¹¦ï¼‰
                const userLorebookIds = userChar.lorebookIds || (userChar.lorebookId ? [userChar.lorebookId] : []);
                const charLorebookIds = searchTargetChar.lorebookIds || (searchTargetChar.lorebookId ? [searchTargetChar.lorebookId] : []);
                const userLore = await getLorebookContext(userLorebookIds, keywords);
                const charLore = await getLorebookContext(charLorebookIds, keywords);
                
                // 4. æ„å»º Prompt
                const prompt = `[åœºæ™¯: å¾®ä¿¡å¥½å‹ç”³è¯·]
ã€ç”³è¯·äººä¿¡æ¯ã€‘
åå­—: ${userChar.name}
è®¾å®š: ${userChar.description || 'æ— '}
è™šæ‹Ÿè´¦å·: ${userChar.identity?.account || 'æœªçŸ¥'}

ã€è¢«ç”³è¯·äºº(ä½ )çš„ä¿¡æ¯ã€‘
åå­—: ${searchTargetChar.name}
è®¾å®š: ${searchTargetChar.description || 'æ— '}
è™šæ‹Ÿè´¦å·: ${searchTargetChar.identity?.account || 'æœªçŸ¥'}

${userLore}
${charLore}

User(${userChar.name}) å‘ä½ å‘é€äº†å¥½å‹ç”³è¯·ï¼Œé™„è¨€ï¼šâ€œ${reason || 'æˆ‘æ˜¯æœ‹å‹'}â€ã€‚

è¯·ä»¥ ${searchTargetChar.name} çš„èº«ä»½ï¼Œæ ¹æ®åŒæ–¹è®¾å®šå’Œä¸–ç•Œä¹¦å…³ç³»ï¼Œå†³å®šæ˜¯å¦é€šè¿‡å¥½å‹ç”³è¯·ã€‚
è¦æ±‚ï¼š
1. å¿…é¡»ç¬¦åˆè§’è‰²æ€§æ ¼ã€‚å¦‚æœæ˜¯é«˜å†·/è°¨æ…çš„è§’è‰²ï¼Œå¯èƒ½ä¼šæ‹’ç»é™Œç”Ÿäººï¼›å¦‚æœæ˜¯å¤–å‘/è®¤è¯†çš„è§’è‰²ï¼Œåˆ™ä¼šé€šè¿‡ã€‚
2. ä»”ç»†æ£€æŸ¥ä¸–ç•Œä¹¦å’Œè®¾å®šä¸­æ˜¯å¦æœ‰ä¸¤äººçš„å…³ç³»æè¿°ã€‚
3. å¦‚æœé€šè¿‡ï¼Œè¯·ç»™å‡º 2 åˆ° 3 æ¡ç¬¦åˆè§’è‰²æ€§æ ¼ã€çº¿ä¸ŠèŠå¤©é£æ ¼çš„å›å¤ã€‚
   - **å¿…é¡»**ä½¿ç”¨åˆ†éš”ç¬¦ "|||" æ¥éš”å¼€æ¯ä¸€æ¡æ¶ˆæ¯ã€‚
   - **ä¸¥ç¦ä½¿ç”¨é€—å·**ï¼ˆåŒ…æ‹¬ä¸­æ–‡é€—å·å’Œè‹±æ–‡é€—å·ï¼‰ã€‚å¦‚æœæƒ³è¡¨è¾¾åœé¡¿ï¼Œè¯·ç›´æ¥æ‹†åˆ†æˆä¸‹ä¸€æ¡æ¶ˆæ¯ï¼Œæˆ–è€…ç”¨ç©ºæ ¼ä»£æ›¿ã€‚
   - é”™è¯¯ç¤ºä¾‹ï¼šä½ å¥½ï¼Œæˆ‘æ˜¯XXXï¼Œå¾ˆé«˜å…´è®¤è¯†ä½ 
   - æ­£ç¡®ç¤ºä¾‹ï¼šä½ å¥½|||æˆ‘æ˜¯XXX|||å¾ˆé«˜å…´è®¤è¯†ä½ 
4. å¦‚æœæ‹’ç»ï¼Œè¯·ç»™å‡ºç®€çŸ­çš„å¿ƒç†æ´»åŠ¨æˆ–æ‹’ç»ç†ç”±ï¼ˆä½œä¸º reply è¿”å›ï¼‰ã€‚

è¯·ä¸¥æ ¼è¿”å› JSON æ ¼å¼ï¼š
{
    "accepted": true, // æˆ– false
    "reply": "å›å¤å†…å®¹|||ç¬¬äºŒæ¡å†…å®¹"
}`;

                // 5. è°ƒç”¨ AI
                const resultStr = await callAI([
                    { role: "system", content: "ä½ æ˜¯ä¸€ä¸ªåªè¾“å‡ºJSONçš„è§’è‰²æ‰®æ¼”è¾…åŠ©ç³»ç»Ÿã€‚" },
                    { role: "user", content: prompt }
                ]);
                
                let result = extractAndParseJSON(resultStr);
                
                if (!result) {
                    console.error("JSONæå–/è§£æå¤±è´¥");
                    result = { accepted: true, reply: "ä½ å¥½å‘€|||æˆ‘æ˜¯æ–°æœ‹å‹(è§£æå¤±è´¥å…œåº•)" }; 
                }

                if (result.accepted) {
                    // æ›´æ–°æ•°æ®åº“
                    const char = await db.characters.get(searchTargetChar.id);
                    const accountId = String(selectedUserId);
                    await setFriendStatus(char, accountId, 'friend');
                    // ç»‘å®šèŠå¤©ç”¨çš„ User ID (å¯é€‰ï¼Œå¦‚æœä»¥åæ”¯æŒå¤š User åˆ‡æ¢)
                    // char.linked_user_id = userChar.id; 
                    
                    // å¼ºåˆ¶ä¸ºå½“å‰è´¦å·åˆå§‹åŒ–å…¨æ–°ç©ºç™½èŠå¤©è®°å½•ï¼Œç¡®ä¿ä¸ä¼šè¯»åˆ°å…¶ä»–è´¦å·çš„æ•°æ®
                    let history = [];
                    
                    // 1. å­˜å…¥ç³»ç»Ÿå›ºå®šæ¶ˆæ¯
                    history.push({
                        role: 'char', // è¿™é‡Œè™½ç„¶æ˜¯ç³»ç»Ÿæ¶ˆæ¯ï¼Œä½†åœ¨å¾®ä¿¡é‡Œé€šå¸¸æ˜¾ç¤ºä¸ºä¸­é—´çš„ç°è‰²å°å­—ï¼Œæˆ–è€…å¯¹æ–¹å‘çš„ç¬¬ä¸€å¥è¯ã€‚
                        // ä¸ºäº†ç¬¦åˆâ€œç¬¬ä¸€æ¡æ¶ˆæ¯æ˜¯å¯¹æ–¹åŒæ„äº†æ‚¨çš„å¥½å‹ç”³è¯·â€çš„éœ€æ±‚ï¼Œè¿™é‡Œæ¨¡æ‹Ÿç³»ç»Ÿæç¤º
                        // ä½†å¦‚æœæ˜¯ä½œä¸ºå¯¹æ–¹å‘å‡ºçš„æ¶ˆæ¯ï¼ˆæ°”æ³¡ï¼‰ï¼Œåˆ™role='char'ã€‚
                        // å¦‚æœæƒ³è¦ä¸­é—´ç°è‰²å°å­—ï¼Œå¯èƒ½éœ€è¦æ–°çš„typeï¼Œè¿™é‡Œæš‚ä¸”ç”¨ç‰¹æ®Šå†…å®¹æˆ–charè§’è‰²å‘
                        // æ ¹æ®éœ€æ±‚"åº”è¯¥æœ‰ç¬¬ä¸€æ¡æ¶ˆæ¯æ˜¯å¯¹æ–¹åŒæ„äº†æ‚¨çš„å¥½å‹ç”³è¯·"ï¼Œè¿™é‡Œæ¨¡æ‹Ÿå¾®ä¿¡çš„ç³»ç»Ÿæç¤º
                        role: 'char', 
                        content: 'æˆ‘é€šè¿‡äº†ä½ çš„å¥½å‹éªŒè¯è¯·æ±‚ï¼Œç°åœ¨æˆ‘ä»¬å¯ä»¥å¼€å§‹èŠå¤©äº†',
                        time: Date.now()
                    });

                    // 2. å¤„ç† AI å›å¤ï¼ˆæ¸…æ´—é€—å· + æ‹†åˆ†ï¼‰
                    let cleanReply = result.reply.replace(/[,ï¼Œ]/g, ' '); 
                    let segments = cleanReply.split('|||').map(s => s.trim()).filter(s => s);
                    
                    // ä¾æ¬¡å­˜å…¥ï¼ˆä½¿ç”¨ buildCharMessage ä¸€æ¬¡æ€§è§£æç¿»è¯‘ï¼‰
                    for (let i = 0; i < segments.length; i++) {
                        history.push(buildCharMessage(segments[i], !!char.foreign_lang_mode, { time: Date.now() + (i + 1) * 500 }));
                    }
                    
                    await setChatHistory(char, accountId, history);
                    
                    // ğŸ”§ åœæ­¢è‡ªåŠ¨å¿«è¿›æ£€æŸ¥åŠŸèƒ½ï¼ˆè§’è‰²å·²ç»æ¥å—äº†ç”¨æˆ·çš„å¥½å‹ç”³è¯·ï¼‰
                    if (char.wait_friend_settings && char.wait_friend_settings[accountId]) {
                        char.wait_friend_settings[accountId].enabled = false;
                        char.wait_friend_settings[accountId].nextCheckTime = null;
                        await safeCharacterPut(char);
                        console.log(`[AutoAcceptFriend] å·²åœæ­¢ ${char.name} çš„è‡ªåŠ¨å¿«è¿›æ£€æŸ¥`);
                    }
                    
                    // åˆ·æ–°åˆ—è¡¨
                    if (document.querySelector('.wechat-tab-item.active').innerText.includes('å¾®ä¿¡')) {
                        renderWechatList(document.getElementById('wechat-content'));
                    }

                    // å‘é€é€šçŸ¥
                    const notifyText = segments.length > 0 ? segments[0] : 'æˆ‘é€šè¿‡äº†ä½ çš„å¥½å‹éªŒè¯è¯·æ±‚';
                    sendSystemNotification("å¾®ä¿¡", `${char.name} é€šè¿‡äº†ä½ çš„éªŒè¯: ${notifyText}`);
                } else {
                    sendSystemNotification("å¾®ä¿¡", `${searchTargetChar.name} æ‹’ç»äº†ç”³è¯·: ${result.reply}`);
                }

            } catch (err) {
                console.error(err);
                alert("è¯·æ±‚å¤„ç†å¤±è´¥: " + err.message);
            }
        }

        // ç›´æ¥å¯¼å…¥é€»è¾‘
        async function showDirectAddModal() {
            document.getElementById('direct-add-modal').style.display = 'flex';
            document.getElementById('wechat-menu').style.display = 'none';
            
            const list = document.getElementById('direct-add-list');
            list.innerHTML = '';
            
            // è·å–éå¥½å‹è§’è‰²
            const accountId = getCurrentAccountId();
            const allChars = await db.characters.toArray();
            // è¿‡æ»¤æ‰å·²ç»æ˜¯å¥½å‹çš„ï¼Œä»¥åŠ type ä¸º 'user' çš„è§’è‰²
            const candidates = allChars.filter(c => {
                if (c.type === 'user') return false;
                const status = getFriendStatus(c, accountId);
                return status !== 'friend';
            });
            
            if(candidates.length === 0) {
                list.innerHTML = '<div style="text-align:center;color:#999;margin-top:20px;">æ²¡æœ‰å¯æ·»åŠ çš„è§’è‰²</div>';
                return;
            }
            
            candidates.forEach(c => {
                const item = document.createElement('div');
                item.style.display = 'flex';
                item.style.alignItems = 'center';
                item.style.justifyContent = 'space-between';
                item.style.padding = '10px';
                item.style.background = '#f9f9f9';
                item.style.borderRadius = '8px';
                
                item.innerHTML = `
                    <div style="font-weight:500;">${c.name}</div>
                    <button style="background:var(--ins-pink); color:#fff; border:none; padding:6px 12px; border-radius:4px; font-size:12px;" onclick="directAddFriend(${c.id})">æ·»åŠ </button>
                `;
                list.appendChild(item);
            });
        }

        async function directAddFriend(id) {
            const char = await db.characters.get(id);
            if(char) {
                const accountId = getCurrentAccountId();
                await setFriendStatus(char, accountId, 'friend');
                // æ–°è´¦å·æ·»åŠ å¥½å‹æ—¶ï¼Œå¼ºåˆ¶ä½¿ç”¨å…¨æ–°ç©ºç™½è®°å½•ï¼Œç¡®ä¿è´¦å·é—´æ•°æ®å®Œå…¨éš”ç¦»
                await setChatHistory(char, accountId, []);
                closeModal('direct-add-modal');
                alert(`å·²å°† ${char.name} æ·»åŠ åˆ°é€šè®¯å½•`);
                
                // åˆ·æ–°
                if (document.querySelector('.wechat-tab-item.active').innerText.includes('å¾®ä¿¡')) {
                    renderWechatList(document.getElementById('wechat-content'));
                }
            }
        }

        // --- ç¾¤èŠåŠŸèƒ½ ---
        // é»˜è®¤ç¾¤å¤´åƒ
        const DEFAULT_GROUP_AVATAR = 'https://img.heliar.top/file/1770017506622_IMG_0773.jpeg';
        
        // æ˜¾ç¤ºåˆ›å»ºç¾¤èŠå¼¹çª—
        async function showCreateGroupModal() {
            document.getElementById('create-group-modal').style.display = 'flex';
            document.getElementById('wechat-menu').style.display = 'none';
            document.getElementById('group-name-input').value = '';
            
            const list = document.getElementById('group-friends-list');
            list.innerHTML = '';
            
            // è·å–å½“å‰è´¦å·çš„å¥½å‹åˆ—è¡¨
            const accountId = getCurrentAccountId();
            const allChars = await db.characters.toArray();
            const friends = allChars.filter(c => {
                if (c.type === 'user') return false;
                const status = getFriendStatus(c, accountId);
                return status === 'friend';
            });
            
            if (friends.length === 0) {
                list.innerHTML = '<div style="text-align:center; color:#999; margin-top:40px;">æš‚æ— å¥½å‹<br><span style="font-size:12px;">è¯·å…ˆæ·»åŠ å¥½å‹å†åˆ›å»ºç¾¤èŠ</span></div>';
                return;
            }
            
            friends.forEach(f => {
                const item = document.createElement('div');
                item.style.cssText = 'display:flex; align-items:center; padding:12px 0; border-bottom:0.5px solid #f0f0f0; cursor:pointer;';
                item.dataset.charId = f.id;
                item.dataset.selected = 'false';
                
                const _grpSelAv = getCharAvatar(f, accountId);
                const avatarStyle = _grpSelAv ? `background-image:url(${_grpSelAv})` : 'background-color:#eee';
                
                item.innerHTML = `
                    <div class="group-select-checkbox" style="width:22px; height:22px; border:2px solid #ddd; border-radius:50%; margin-right:12px; display:flex; align-items:center; justify-content:center; transition:all 0.2s;">
                        <svg class="check-icon" style="width:14px; height:14px; stroke:#fff; fill:none; stroke-width:3; display:none;" viewBox="0 0 24 24"><polyline points="20 6 9 17 4 12"></polyline></svg>
                    </div>
                    <div style="width:40px; height:40px; border-radius:4px; ${avatarStyle}; background-size:cover; background-position:center; margin-right:12px;"></div>
                    <div style="font-size:16px; color:#333;">${getCharDisplayName(f, accountId)}</div>
                `;
                
                item.onclick = function() {
                    const isSelected = this.dataset.selected === 'true';
                    const checkbox = this.querySelector('.group-select-checkbox');
                    const checkIcon = this.querySelector('.check-icon');
                    
                    if (isSelected) {
                        this.dataset.selected = 'false';
                        checkbox.style.background = 'transparent';
                        checkbox.style.borderColor = '#ddd';
                        checkIcon.style.display = 'none';
                    } else {
                        this.dataset.selected = 'true';
                        checkbox.style.background = 'var(--ins-pink)';
                        checkbox.style.borderColor = 'var(--ins-pink)';
                        checkIcon.style.display = 'block';
                    }
                };
                
                list.appendChild(item);
            });
        }
        
        // ç¡®è®¤åˆ›å»ºç¾¤èŠ
        async function confirmCreateGroup() {
            const list = document.getElementById('group-friends-list');
            const selectedItems = list.querySelectorAll('[data-selected="true"]');
            const memberIds = Array.from(selectedItems).map(item => parseInt(item.dataset.charId));
            
            if (memberIds.length < 1) {
                alert('è¯·è‡³å°‘é€‰æ‹©1ä½å¥½å‹');
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯æ·»åŠ ç¾¤æˆå‘˜æ¨¡å¼
            if (window._addingGroupMembers && window.currentGroupChatId) {
                await addMembersToGroup(memberIds);
                return;
            }
            
            const groupName = document.getElementById('group-name-input').value.trim();
            const accountId = getCurrentAccountId();
            
            // è·å–é€‰ä¸­æˆå‘˜çš„åç§°ç”¨äºç”Ÿæˆé»˜è®¤ç¾¤å
            let defaultName = '';
            if (!groupName) {
                const memberChars = await Promise.all(memberIds.map(id => db.characters.get(id)));
                const myChar = currentMyCharId ? await db.characters.get(parseInt(currentMyCharId)) : null;
                const names = memberChars.map(c => getCharDisplayName(c, accountId));
                if (myChar) names.unshift(myChar.nick || myChar.name);
                defaultName = names.slice(0, 4).join('ã€');
                if (names.length > 4) defaultName += '...';
            }
            
            // åˆ›å»ºç¾¤èŠè®°å½•
            const groupChat = {
                name: groupName || defaultName,
                avatar: DEFAULT_GROUP_AVATAR,
                memberIds: memberIds,
                ownerAccountId: accountId,
                created_at: Date.now(),
                updated_at: Date.now(),
                is_pinned: false,
                chat_history: [{
                    role: 'system',
                    content: 'ç¾¤èŠå·²åˆ›å»º',
                    time: Date.now()
                }]
            };
            
            const groupId = await db.group_chats.add(groupChat);
            
            closeModal('create-group-modal');
            alert(`ç¾¤èŠ"${groupChat.name}"åˆ›å»ºæˆåŠŸï¼`);
            
            // åˆ·æ–°èŠå¤©åˆ—è¡¨
            if (document.querySelector('.wechat-tab-item.active')?.innerText.includes('å¾®ä¿¡')) {
                renderWechatList(document.getElementById('wechat-content'));
            }
            
            // æ‰“å¼€ç¾¤èŠçª—å£
            openGroupChatWindow(groupId);
        }
        
        // æ·»åŠ æˆå‘˜åˆ°ç¾¤èŠ
        async function addMembersToGroup(memberIds) {
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            // æ·»åŠ æ–°æˆå‘˜
            const newMemberNames = [];
            const reInvitedNames = []; // é‡æ–°é‚€è¯·çš„å·²é€€ç¾¤æˆå‘˜
            for (const memberId of memberIds) {
                if (!group.memberIds.includes(memberId)) {
                    group.memberIds.push(memberId);
                    const char = await db.characters.get(memberId);
                    const displayName = char ? getCharDisplayName(char, getCurrentAccountId()) : 'æˆå‘˜';
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯é‡æ–°é‚€è¯·å·²é€€ç¾¤çš„æˆå‘˜
                    const leftMembers = group.leftMembers || [];
                    const leftRecord = leftMembers.find(lm => lm.id === memberId);
                    if (leftRecord) {
                        // ä» leftMembers ä¸­ç§»é™¤ï¼ˆä½†é€€ç¾¤è®°å¿†ä¿ç•™åœ¨ chat_history ä¸­ï¼‰
                        group.leftMembers = leftMembers.filter(lm => lm.id !== memberId);
                        reInvitedNames.push(displayName);
                    } else {
                        newMemberNames.push(displayName);
                    }
                }
            }
            
            if (newMemberNames.length > 0) {
                // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯
                group.chat_history.push({
                    role: 'system',
                    content: `${newMemberNames.join('ã€')} åŠ å…¥äº†ç¾¤èŠ`,
                    time: Date.now()
                });
            }
            
            if (reInvitedNames.length > 0) {
                // é‡æ–°é‚€è¯·å·²é€€ç¾¤æˆå‘˜çš„ç³»ç»Ÿæ¶ˆæ¯
                group.chat_history.push({
                    role: 'system',
                    content: `${reInvitedNames.join('ã€')} è¢«é‡æ–°é‚€è¯·å›ç¾¤èŠ`,
                    time: Date.now() + 1
                });
            }
            
            group.updated_at = Date.now();
            await safeGroupChatPut(group);
            
            // é‡ç½®çŠ¶æ€
            window._addingGroupMembers = false;
            document.getElementById('group-name-input').style.display = '';
            document.querySelector('#create-group-modal .modal-title').innerText = 'åˆ›å»ºç¾¤èŠ';
            
            closeModal('create-group-modal');
            
            // åˆ·æ–°ç¾¤æˆå‘˜åˆ—è¡¨å’ŒèŠå¤©
            await renderGroupMemberList(group);
            await renderGroupChatBody(group);
            
            alert(`å·²æ·»åŠ  ${newMemberNames.length} ä½æˆå‘˜`);
        }
        
        // æ‰“å¼€ç¾¤èŠçª—å£
        async function openGroupChatWindow(groupId) {
            const group = await db.group_chats.get(groupId);
            if (!group) return;
            
            // å¦‚æœæ˜¯è”æœºç¾¤èŠï¼Œè°ƒç”¨è”æœºç¾¤èŠçš„æ‰“å¼€æ–¹æ³•
            if (group.isOnlineGroup && group.onlineGroupId) {
                openOnlineGroup(group.onlineGroupId);
                return;
            }
            
            // è®¾ç½®å½“å‰èŠå¤©ä¸ºç¾¤èŠæ¨¡å¼
            currentChatCharId = null;
            window.currentGroupChatId = groupId;
            
            const titleEl = document.getElementById('chat-title');
            titleEl.innerText = group.name;
            titleEl.style.cursor = 'pointer';
            titleEl.onclick = () => showGroupDetail(groupId);
            
            document.getElementById('chat-window').style.display = 'flex';
            
            // âœ… åº”ç”¨ç¾¤èŠçš„èŠå¤©ä¸»é¢˜
            if (group.chatThemeId !== undefined) {
                await applyThemeToChat(group.chatThemeId);
            }
            
            // âœ… åº”ç”¨ç¾¤èŠè‡ªå®šä¹‰æ°”æ³¡æ ·å¼
            applyGroupCustomStyles(group);
            
            // è¿›å…¥èŠå¤©åï¼Œå°†åº•å±‚åˆ—è¡¨è®¾ä¸ºä¸å¯è§ï¼Œé˜²æ­¢é€æ˜æ ·å¼ç©¿é€
            setTimeout(() => {
                const wechatEl = document.getElementById('wechat-page');
                if (wechatEl) wechatEl.style.visibility = 'hidden';
            }, 320);
            
            // æ˜¾ç¤ºè¾“å…¥æ¡†
            const chatFooter = document.getElementById('chat-footer');
            chatFooter.style.display = 'flex';
            
            await renderGroupChatBody(group);
        }
        
        // æ˜¾ç¤ºç¾¤èŠè¯¦æƒ…é¡µ
        async function showGroupDetail(groupId) {
            const group = await db.group_chats.get(groupId || window.currentGroupChatId);
            if (!group) return;
            
            document.getElementById('group-detail-page').style.display = 'flex';
            
            // è®¾ç½®ç¾¤å¤´åƒ
            const avatarEl = document.getElementById('group-detail-avatar');
            if (group.avatar) {
                avatarEl.style.backgroundImage = `url(${group.avatar})`;
            } else {
                avatarEl.style.backgroundImage = '';
                avatarEl.style.backgroundColor = '#eee';
            }
            
            // è®¾ç½®ç¾¤åç§°
            document.getElementById('group-detail-name').value = group.name || '';
            
            // è®¾ç½®æˆ‘çš„ç¾¤æ˜µç§°
            document.getElementById('group-detail-nickname').value = group.myNickname || '';
            
            // è®¾ç½®å¼€å…³çŠ¶æ€
            document.getElementById('group-detail-mute').checked = group.is_muted || false;
            document.getElementById('group-detail-pin').checked = group.is_pinned || false;
            
            // è®¾ç½®ä¸Šä¸‹æ–‡æ¡æ•°ï¼ˆé»˜è®¤25æ¡ï¼‰
            document.getElementById('group-detail-context-count').value = group.context_message_count || 25;
            
            // è®¾ç½®è‡ªåŠ¨æ€»ç»“è®¾ç½®
            document.getElementById('group-detail-auto-summary-switch').checked = group.auto_summary_enabled || false;
            document.getElementById('group-detail-summary-interval').value = group.summary_interval || '';
            
            // æ›´æ–°æ€»ç»“è®¡æ•°
            const accountId = getCurrentAccountId();
            if (accountId && group.id) {
                await updateSummaryCount('group', group.id, accountId);
            }
            
            // åŠ è½½è‡ªå®šä¹‰æ°”æ³¡CSS
            document.getElementById('group-detail-bubble-css').value = group.custom_bubble_css || '';
            
            // æ¸²æŸ“ç¾¤æˆå‘˜åˆ—è¡¨
            await renderGroupMemberList(group);
            
            // æ›´æ–°ç¾¤èŠä¸»é¢˜æ˜¾ç¤º
            await updateGroupChatDetailThemeDisplay();
            
            // åˆå§‹åŒ–é¢„è§ˆ
            previewGroupBubbleCSS();
            
            // åŠ è½½ä¸–ç•Œä¹¦åˆ—è¡¨ï¼ˆå¤šé€‰ï¼‰â€”â€”åªæ˜¾ç¤ºå•äººä¸–ç•Œä¹¦ï¼Œå…¨å±€è‡ªåŠ¨ç”Ÿæ•ˆ
            const lorebooks = await db.lorebooks.toArray();
            const lbList = document.getElementById('group-detail-lorebook-list');
            lbList.innerHTML = '';
            
            // å…¼å®¹æ—§æ•°æ®ï¼šå¦‚æœlorebookIdå­˜åœ¨ä½†lorebookIdsä¸å­˜åœ¨ï¼Œè½¬æ¢ä¸ºæ•°ç»„
            const selectedIds = group.lorebookIds || (group.lorebookId ? [group.lorebookId] : []);
            
            // åˆ†ç¦»å…¨å±€å’Œå•äººä¸–ç•Œä¹¦
            const personalLbs = lorebooks.filter(lb => lb.scope !== 'global');
            const globalLbs = lorebooks.filter(lb => lb.scope === 'global');
            
            // å…¨å±€æç¤º
            if (globalLbs.length > 0) {
                const hint = document.createElement('div');
                hint.style.cssText = 'padding:6px 8px; color:#34c759; font-size:12px; background:#f0fff4; border-radius:6px; margin-bottom:6px;';
                hint.innerHTML = `ğŸŒ ${globalLbs.length} ä¸ªå…¨å±€ä¸–ç•Œä¹¦å·²è‡ªåŠ¨ç”Ÿæ•ˆï¼š${globalLbs.map(g => g.name).join('ã€')}`;
                lbList.appendChild(hint);
            }
            
            if (personalLbs.length === 0 && globalLbs.length === 0) {
                lbList.innerHTML = '<div style="padding:8px; color:#999; font-size:12px; text-align:center;">æš‚æ— ä¸–ç•Œä¹¦</div>';
            } else if (personalLbs.length > 0) {
                personalLbs.forEach(lb => {
                    const label = document.createElement('label');
                    label.style.cssText = 'display:flex; align-items:center; padding:8px; cursor:pointer; border-radius:6px; margin-bottom:4px;';
                    label.style.background = selectedIds.includes(lb.id) ? '#f0f0f5' : 'transparent';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = lb.id;
                    checkbox.checked = selectedIds.includes(lb.id);
                    checkbox.style.marginRight = '8px';
                    checkbox.onchange = () => {
                        label.style.background = checkbox.checked ? '#f0f0f5' : 'transparent';
                        updateGroupLorebookCount();
                        saveGroupDetail();
                    };
                    
                    const name = document.createElement('span');
                    name.textContent = lb.name;
                    name.style.fontSize = '14px';
                    name.style.color = '#333';
                    
                    label.appendChild(checkbox);
                    label.appendChild(name);
                    lbList.appendChild(label);
                });
            }
            
            updateGroupLorebookCount();
        }
        
        // æ¸²æŸ“ç¾¤æˆå‘˜åˆ—è¡¨é¢„è§ˆï¼ˆè¯¦æƒ…é¡µï¼‰
        async function renderGroupMemberList(group) {
            const listEl = document.getElementById('group-member-list');
            listEl.innerHTML = '';
            
            const accountId = getCurrentAccountId();
            
            // æ·»åŠ è‡ªå·±
            const myChar = currentMyCharId ? await db.characters.get(parseInt(currentMyCharId)) : null;
            if (myChar) {
                const myAvatar = myChar.avatar || '';
                const myAvatarStyle = myAvatar ? `background-image:url(${myAvatar})` : 'background-color:#eee';
                const myItem = document.createElement('div');
                myItem.style.cssText = 'display:flex; flex-direction:column; align-items:center; width:60px;';
                myItem.innerHTML = `
                    <div style="width:44px; height:44px; border-radius:6px; ${myAvatarStyle}; background-size:cover; background-position:center; position:relative;">
                        <div style="position:absolute; bottom:-2px; right:-2px; background:#07c160; color:#fff; font-size:8px; padding:1px 3px; border-radius:2px;">ç¾¤ä¸»</div>
                    </div>
                    <div style="font-size:11px; color:#333; margin-top:4px; text-align:center; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; width:100%;">${group.myNickname || myChar.nick || myChar.name || 'æˆ‘'}</div>
                `;
                listEl.appendChild(myItem);
            }
            
            // æ·»åŠ å…¶ä»–æˆå‘˜ï¼ˆæœ€å¤šæ˜¾ç¤º8ä¸ªé¢„è§ˆï¼‰
            const memberIds = group.memberIds || [];
            const adminIds = group.adminIds || [];
            const displayCount = Math.min(memberIds.length, 7);
            
            for (let i = 0; i < displayCount; i++) {
                const memberId = memberIds[i];
                const char = await db.characters.get(memberId);
                if (!char) continue;
                
                const isAdmin = adminIds.includes(memberId);
                const _mAvatar = getCharAvatar(char, accountId);
                const avatarStyle = _mAvatar ? `background-image:url(${_mAvatar})` : 'background-color:#eee';
                const item = document.createElement('div');
                item.style.cssText = 'display:flex; flex-direction:column; align-items:center; width:60px;';
                item.innerHTML = `
                    <div style="width:44px; height:44px; border-radius:6px; ${avatarStyle}; background-size:cover; background-position:center; position:relative;">
                        ${isAdmin ? '<div style="position:absolute; bottom:-2px; right:-2px; background:#ff9500; color:#fff; font-size:8px; padding:1px 3px; border-radius:2px;">ç®¡ç†</div>' : ''}
                    </div>
                    <div style="font-size:11px; color:#333; margin-top:4px; text-align:center; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; width:100%;">${getCharDisplayName(char, accountId)}</div>
                `;
                listEl.appendChild(item);
            }
            
            // å¦‚æœæˆå‘˜è¶…è¿‡8ä¸ªï¼Œæ˜¾ç¤ºæ›´å¤š
            if (memberIds.length > 7) {
                const moreItem = document.createElement('div');
                moreItem.style.cssText = 'display:flex; flex-direction:column; align-items:center; width:60px; cursor:pointer;';
                moreItem.innerHTML = `
                    <div style="width:44px; height:44px; border-radius:6px; background:#f0f0f0; display:flex; align-items:center; justify-content:center; font-size:14px; color:#999;">+${memberIds.length - 7}</div>
                    <div style="font-size:11px; color:#999; margin-top:4px;">æ›´å¤š</div>
                `;
                moreItem.onclick = () => showGroupMemberManage();
                listEl.appendChild(moreItem);
            }
            
            // æ›´æ–°æˆå‘˜æ•°é‡
            const totalCount = memberIds.length + 1; // +1 åŒ…å«è‡ªå·±
            document.getElementById('group-member-count').innerText = `${totalCount}äºº`;
            const countText = document.getElementById('group-member-count-text');
            if (countText) countText.innerText = `${totalCount}äºº`;
        }
        
        // å½“å‰æ“ä½œçš„æˆå‘˜ID
        let currentActionMemberId = null;
        
        // æ˜¾ç¤ºç¾¤æˆå‘˜ç®¡ç†é¡µé¢
        async function showGroupMemberManage() {
            if (!window.currentGroupChatId) return;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            document.getElementById('group-member-manage-page').style.display = 'flex';
            
            await renderGroupMemberManageList(group);
        }
        
        // éšè—ç¾¤æˆå‘˜ç®¡ç†é¡µé¢
        function hideGroupMemberManage() {
            document.getElementById('group-member-manage-page').style.display = 'none';
        }
        
        // æ¸²æŸ“ç¾¤æˆå‘˜ç®¡ç†åˆ—è¡¨
        async function renderGroupMemberManageList(group) {
            const ownerEl = document.getElementById('group-owner-info');
            const adminListEl = document.getElementById('group-admin-list');
            const memberListEl = document.getElementById('group-normal-member-list');
            const noAdminEl = document.getElementById('group-no-admin');
            
            ownerEl.innerHTML = '';
            adminListEl.innerHTML = '';
            memberListEl.innerHTML = '';
            
            const accountId = getCurrentAccountId(); // âœ… ä¿®å¤ï¼šåŸå…ˆç¼ºå°‘æ­¤å£°æ˜å¯¼è‡´åç»­ä»£ç  ReferenceError å´©æºƒ
            const adminIds = group.adminIds || [];
            const mutedIds = group.mutedMembers || [];
            
            // æ£€æŸ¥å½“å‰ç”¨æˆ·æƒé™
            const isOwner = group.ownerAccountId === getCurrentAccountId();
            const currentUserIsAdmin = adminIds.includes(parseInt(currentMyCharId));
            const hasManagePermission = isOwner || currentUserIsAdmin;
            
            // æ¸²æŸ“ç¾¤ä¸»ï¼ˆè‡ªå·±ï¼‰
            const myChar = currentMyCharId ? await db.characters.get(parseInt(currentMyCharId)) : null;
            if (myChar) {
                const myAvatar = myChar.avatar || '';
                const myAvatarStyle = myAvatar ? `background-image:url(${myAvatar})` : 'background-color:#eee';
                ownerEl.innerHTML = `
                    <div style="display:flex; align-items:center; gap:12px;">
                        <div style="width:44px; height:44px; border-radius:6px; ${myAvatarStyle}; background-size:cover; background-position:center;"></div>
                        <div style="flex:1;">
                            <div style="font-size:16px; font-weight:500; color:#333;">${group.myNickname || myChar.nick || myChar.name || 'æˆ‘'}</div>
                            <div style="font-size:12px; color:#07c160;">ç¾¤ä¸»</div>
                        </div>
                    </div>
                `;
            }
            
            // åˆ†ç±»æˆå‘˜
            const admins = [];
            const members = [];
            
            for (const memberId of (group.memberIds || [])) {
                const char = await db.characters.get(memberId);
                if (!char) continue;
                
                if (adminIds.includes(memberId)) {
                    admins.push({ char, memberId });
                } else {
                    members.push({ char, memberId });
                }
            }
            
            // æ¸²æŸ“ç®¡ç†å‘˜
            if (admins.length === 0) {
                noAdminEl.style.display = 'block';
            } else {
                noAdminEl.style.display = 'none';
                for (const { char, memberId } of admins) {
                    const isMuted = mutedIds.includes(memberId);
                    const _adminAv = getCharAvatar(char, accountId);
                    const avatarStyle = _adminAv ? `background-image:url(${_adminAv})` : 'background-color:#eee';
                    const item = document.createElement('div');
                    // åªæœ‰ç¾¤ä¸»å¯ä»¥æ“ä½œç®¡ç†å‘˜
                    const canOperate = isOwner;
                    item.style.cssText = `display:flex; align-items:center; gap:12px; padding:12px 16px; border-bottom:0.5px solid #f0f0f0; ${canOperate ? 'cursor:pointer;' : ''}`;
                    item.innerHTML = `
                        <div style="width:44px; height:44px; border-radius:6px; ${avatarStyle}; background-size:cover; background-position:center;"></div>
                        <div style="flex:1;">
                            <div style="font-size:16px; font-weight:500; color:#333;">${getCharDisplayName(char, accountId)}</div>
                            <div style="font-size:12px; color:#ff9500;">${isMuted ? 'å·²ç¦è¨€ Â· ' : ''}ç®¡ç†å‘˜</div>
                        </div>
                        ${canOperate ? '<svg style="width:20px; height:20px; stroke:#ccc;" viewBox="0 0 24 24" fill="none" stroke-width="2"><polyline points="9 18 15 12 9 6"></polyline></svg>' : ''}
                    `;
                    if (canOperate) {
                        item.onclick = () => showMemberActionModal(memberId, char, true, isMuted);
                    }
                    adminListEl.appendChild(item);
                }
            }
            
            // æ¸²æŸ“æ™®é€šæˆå‘˜
            for (const { char, memberId } of members) {
                const isMuted = mutedIds.includes(memberId);
                const _memAv = getCharAvatar(char, accountId);
                const avatarStyle = _memAv ? `background-image:url(${_memAv})` : 'background-color:#eee';
                const item = document.createElement('div');
                // ç¾¤ä¸»å’Œç®¡ç†å‘˜éƒ½å¯ä»¥æ“ä½œæ™®é€šæˆå‘˜
                const canOperate = hasManagePermission;
                item.style.cssText = `display:flex; align-items:center; gap:12px; padding:12px 16px; border-bottom:0.5px solid #f0f0f0; ${canOperate ? 'cursor:pointer;' : ''}`;
                item.innerHTML = `
                    <div style="width:44px; height:44px; border-radius:6px; ${avatarStyle}; background-size:cover; background-position:center;"></div>
                    <div style="flex:1;">
                        <div style="font-size:16px; font-weight:500; color:#333;">${getCharDisplayName(char, accountId)}</div>
                        ${isMuted ? '<div style="font-size:12px; color:#ff3b30;">å·²ç¦è¨€</div>' : ''}
                    </div>
                    ${canOperate ? '<svg style="width:20px; height:20px; stroke:#ccc;" viewBox="0 0 24 24" fill="none" stroke-width="2"><polyline points="9 18 15 12 9 6"></polyline></svg>' : ''}
                `;
                if (canOperate) {
                    item.onclick = () => showMemberActionModal(memberId, char, false, isMuted);
                }
                memberListEl.appendChild(item);
            }
            
            if (members.length === 0) {
                memberListEl.innerHTML = '<div style="padding:20px 16px; text-align:center; color:#999; font-size:13px;">æš‚æ— æ™®é€šæˆå‘˜</div>';
            }
        }
        
        // æ˜¾ç¤ºæˆå‘˜æ“ä½œå¼¹çª—
        async function showMemberActionModal(memberId, char, isAdmin, isMuted) {
            currentActionMemberId = memberId;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            // æ£€æŸ¥å½“å‰ç”¨æˆ·æ˜¯å¦æ˜¯ç¾¤ä¸»ï¼ˆåˆ›å»ºè€…ï¼‰
            const isOwner = group.ownerAccountId === getCurrentAccountId();
            // æ£€æŸ¥å½“å‰ç”¨æˆ·æ˜¯å¦æ˜¯ç®¡ç†å‘˜
            const currentUserIsAdmin = (group.adminIds || []).includes(parseInt(currentMyCharId));
            
            const _maAid = getCurrentAccountId();
            const _maAvatar = getCharAvatar(char, _maAid);
            const avatarStyle = _maAvatar ? `url(${_maAvatar})` : '#eee';
            document.getElementById('member-action-avatar').style.backgroundImage = avatarStyle;
            document.getElementById('member-action-name').innerText = getCharDisplayName(char, _maAid);
            document.getElementById('member-action-role').innerText = isAdmin ? 'ç®¡ç†å‘˜' : 'ç¾¤æˆå‘˜';
            
            // æƒé™æ§åˆ¶ï¼š
            // - ç¾¤ä¸»å¯ä»¥åšæ‰€æœ‰æ“ä½œ
            // - ç®¡ç†å‘˜åªèƒ½å¯¹æ™®é€šæˆå‘˜æ“ä½œï¼ˆä¸èƒ½å¯¹å…¶ä»–ç®¡ç†å‘˜æ“ä½œï¼‰
            
            const setAdminBtn = document.getElementById('member-action-set-admin');
            const removeAdminBtn = document.getElementById('member-action-remove-admin');
            const muteBtn = document.getElementById('member-action-mute');
            const kickBtn = document.getElementById('member-action-kick');
            
            if (isOwner) {
                // ç¾¤ä¸»ï¼šå®Œæ•´æƒé™
                setAdminBtn.style.display = isAdmin ? 'none' : 'block';
                removeAdminBtn.style.display = isAdmin ? 'block' : 'none';
                muteBtn.style.display = 'block';
                kickBtn.style.display = 'block';
            } else if (currentUserIsAdmin) {
                // ç®¡ç†å‘˜ï¼šåªèƒ½æ“ä½œæ™®é€šæˆå‘˜
                setAdminBtn.style.display = 'none'; // ç®¡ç†å‘˜ä¸èƒ½è®¾ç½®ç®¡ç†å‘˜
                removeAdminBtn.style.display = 'none'; // ç®¡ç†å‘˜ä¸èƒ½å–æ¶ˆç®¡ç†å‘˜
                
                if (isAdmin) {
                    // ä¸èƒ½å¯¹å…¶ä»–ç®¡ç†å‘˜æ“ä½œ
                    muteBtn.style.display = 'none';
                    kickBtn.style.display = 'none';
                } else {
                    // å¯ä»¥å¯¹æ™®é€šæˆå‘˜æ“ä½œ
                    muteBtn.style.display = 'block';
                    kickBtn.style.display = 'block';
                }
            } else {
                // æ™®é€šæˆå‘˜ï¼šæ²¡æœ‰ç®¡ç†æƒé™
                setAdminBtn.style.display = 'none';
                removeAdminBtn.style.display = 'none';
                muteBtn.style.display = 'none';
                kickBtn.style.display = 'none';
            }
            
            // ç¦è¨€æŒ‰é’®æ–‡å­—
            muteBtn.innerText = isMuted ? 'è§£é™¤ç¦è¨€' : 'ç¦è¨€';
            muteBtn.style.color = isMuted ? '#07c160' : '#ff9500';
            
            document.getElementById('member-action-modal').style.display = 'flex';
        }
        
        // è®¾ä¸ºç®¡ç†å‘˜ï¼ˆåªæœ‰ç¾¤ä¸»å¯ä»¥ï¼‰
        async function setMemberAsAdmin() {
            if (!window.currentGroupChatId || !currentActionMemberId) return;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            // æƒé™æ£€æŸ¥ï¼šåªæœ‰ç¾¤ä¸»å¯ä»¥è®¾ç½®ç®¡ç†å‘˜
            if (group.ownerAccountId !== getCurrentAccountId()) {
                alert('åªæœ‰ç¾¤ä¸»å¯ä»¥è®¾ç½®ç®¡ç†å‘˜');
                return;
            }
            
            if (!group.adminIds) group.adminIds = [];
            if (!group.adminIds.includes(currentActionMemberId)) {
                group.adminIds.push(currentActionMemberId);
                
                const char = await db.characters.get(currentActionMemberId);
                group.chat_history.push({
                    role: 'system',
                    content: `${char?.name || 'æˆå‘˜'} å·²è¢«è®¾ä¸ºç®¡ç†å‘˜`,
                    time: Date.now()
                });
            }
            
            group.updated_at = Date.now();
            await safeGroupChatPut(group);
            
            closeModal('member-action-modal');
            await renderGroupMemberManageList(group);
            await renderGroupMemberList(group);
        }
        
        // å–æ¶ˆç®¡ç†å‘˜ï¼ˆåªæœ‰ç¾¤ä¸»å¯ä»¥ï¼‰
        async function removeMemberAdmin() {
            if (!window.currentGroupChatId || !currentActionMemberId) return;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            // æƒé™æ£€æŸ¥ï¼šåªæœ‰ç¾¤ä¸»å¯ä»¥å–æ¶ˆç®¡ç†å‘˜
            if (group.ownerAccountId !== getCurrentAccountId()) {
                alert('åªæœ‰ç¾¤ä¸»å¯ä»¥å–æ¶ˆç®¡ç†å‘˜');
                return;
            }
            
            group.adminIds = (group.adminIds || []).filter(id => id !== currentActionMemberId);
            
            const char = await db.characters.get(currentActionMemberId);
            group.chat_history.push({
                role: 'system',
                content: `${char?.name || 'æˆå‘˜'} å·²è¢«å–æ¶ˆç®¡ç†å‘˜`,
                time: Date.now()
            });
            
            group.updated_at = Date.now();
            await safeGroupChatPut(group);
            
            closeModal('member-action-modal');
            await renderGroupMemberManageList(group);
            await renderGroupMemberList(group);
        }
        
        // ç¦è¨€/è§£é™¤ç¦è¨€ï¼ˆç¾¤ä¸»å’Œç®¡ç†å‘˜éƒ½å¯ä»¥ï¼Œä½†ç®¡ç†å‘˜åªèƒ½å¯¹æ™®é€šæˆå‘˜æ“ä½œï¼‰
        async function toggleMemberMute() {
            if (!window.currentGroupChatId || !currentActionMemberId) return;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            const isOwner = group.ownerAccountId === getCurrentAccountId();
            const currentUserIsAdmin = (group.adminIds || []).includes(parseInt(currentMyCharId));
            const targetIsAdmin = (group.adminIds || []).includes(currentActionMemberId);
            
            // æƒé™æ£€æŸ¥
            if (!isOwner && !currentUserIsAdmin) {
                alert('åªæœ‰ç¾¤ä¸»æˆ–ç®¡ç†å‘˜å¯ä»¥ç¦è¨€æˆå‘˜');
                return;
            }
            
            // ç®¡ç†å‘˜ä¸èƒ½ç¦è¨€å…¶ä»–ç®¡ç†å‘˜
            if (!isOwner && targetIsAdmin) {
                alert('ç®¡ç†å‘˜ä¸èƒ½ç¦è¨€å…¶ä»–ç®¡ç†å‘˜');
                return;
            }
            
            if (!group.mutedMembers) group.mutedMembers = [];
            
            const char = await db.characters.get(currentActionMemberId);
            const isMuted = group.mutedMembers.includes(currentActionMemberId);
            
            if (isMuted) {
                group.mutedMembers = group.mutedMembers.filter(id => id !== currentActionMemberId);
                group.chat_history.push({
                    role: 'system',
                    content: `${char?.name || 'æˆå‘˜'} å·²è¢«è§£é™¤ç¦è¨€`,
                    time: Date.now()
                });
            } else {
                group.mutedMembers.push(currentActionMemberId);
                group.chat_history.push({
                    role: 'system',
                    content: `${char?.name || 'æˆå‘˜'} å·²è¢«ç¦è¨€`,
                    time: Date.now()
                });
            }
            
            group.updated_at = Date.now();
            await safeGroupChatPut(group);
            
            closeModal('member-action-modal');
            await renderGroupMemberManageList(group);
        }
        
        // è¸¢å‡ºç¾¤èŠï¼ˆç¾¤ä¸»å’Œç®¡ç†å‘˜éƒ½å¯ä»¥ï¼Œä½†ç®¡ç†å‘˜åªèƒ½è¸¢æ™®é€šæˆå‘˜ï¼‰
        async function kickMember() {
            if (!window.currentGroupChatId || !currentActionMemberId) return;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            const isOwner = group.ownerAccountId === getCurrentAccountId();
            const currentUserIsAdmin = (group.adminIds || []).includes(parseInt(currentMyCharId));
            const targetIsAdmin = (group.adminIds || []).includes(currentActionMemberId);
            
            // æƒé™æ£€æŸ¥
            if (!isOwner && !currentUserIsAdmin) {
                alert('åªæœ‰ç¾¤ä¸»æˆ–ç®¡ç†å‘˜å¯ä»¥ç§»é™¤æˆå‘˜');
                return;
            }
            
            // ç®¡ç†å‘˜ä¸èƒ½è¸¢å…¶ä»–ç®¡ç†å‘˜
            if (!isOwner && targetIsAdmin) {
                alert('ç®¡ç†å‘˜ä¸èƒ½ç§»é™¤å…¶ä»–ç®¡ç†å‘˜');
                return;
            }
            
            const char = await db.characters.get(currentActionMemberId);
            if (!confirm(`ç¡®å®šè¦å°† ${char?.name || 'è¯¥æˆå‘˜'} ç§»å‡ºç¾¤èŠå—ï¼Ÿ`)) return;
            
            // ä»æˆå‘˜åˆ—è¡¨ç§»é™¤
            group.memberIds = (group.memberIds || []).filter(id => id !== currentActionMemberId);
            // ä»ç®¡ç†å‘˜åˆ—è¡¨ç§»é™¤
            group.adminIds = (group.adminIds || []).filter(id => id !== currentActionMemberId);
            // ä»ç¦è¨€åˆ—è¡¨ç§»é™¤
            group.mutedMembers = (group.mutedMembers || []).filter(id => id !== currentActionMemberId);
            
            group.chat_history.push({
                role: 'system',
                content: `${char?.name || 'æˆå‘˜'} å·²è¢«ç§»å‡ºç¾¤èŠ`,
                time: Date.now()
            });
            
            group.updated_at = Date.now();
            await safeGroupChatPut(group);
            
            closeModal('member-action-modal');
            await renderGroupMemberManageList(group);
            await renderGroupMemberList(group);
            await renderGroupChatBody(group);
        }
        
        // éšè—ç¾¤èŠè¯¦æƒ…é¡µ
        function hideGroupDetail() {
            document.getElementById('group-detail-page').style.display = 'none';
        }
        
        // åˆ‡æ¢ç¾¤èŠä¸–ç•Œä¹¦åˆ—è¡¨
        function toggleGroupLorebookList() {
            const list = document.getElementById('group-detail-lorebook-list');
            const toggle = document.getElementById('group-detail-lorebook-toggle');
            if (list.style.display === 'none' || !list.style.display) {
                list.style.display = 'block';
                toggle.textContent = 'âˆ¨';
            } else {
                list.style.display = 'none';
                toggle.textContent = 'â€º';
            }
        }
        
        // æ›´æ–°ç¾¤èŠä¸–ç•Œä¹¦è®¡æ•°
        function updateGroupLorebookCount() {
            const checkboxes = document.querySelectorAll('#group-detail-lorebook-list input[type="checkbox"]:checked');
            const count = checkboxes.length;
            document.getElementById('group-detail-lorebook-count').textContent = `${count}ä¸ª`;
        }
        
        // ========== ç¾¤èŠè‡ªå®šä¹‰æ°”æ³¡CSSåŠŸèƒ½ ==========
        
        // åˆ‡æ¢ç¾¤èŠæ°”æ³¡CSSé¢æ¿
        function toggleGroupBubbleCSS() {
            const panel = document.getElementById('group-bubble-css-panel');
            const toggle = document.getElementById('group-detail-bubble-toggle');
            if (panel.style.display === 'none' || !panel.style.display) {
                panel.style.display = 'block';
                toggle.textContent = 'âˆ¨';
            } else {
                panel.style.display = 'none';
                toggle.textContent = 'â€º';
            }
        }
        
        // ç¾¤èŠæ°”æ³¡CSSå®æ—¶é¢„è§ˆï¼ˆåœ¨é¢„è§ˆåŒºæ¸²æŸ“ï¼‰
        function previewGroupBubbleCSS() {
            const cssText = (document.getElementById('group-detail-bubble-css').value || '').trim();
            // ç§»é™¤æ—§çš„é¢„è§ˆæ ·å¼
            let styleTag = document.getElementById('group-bubble-preview-style');
            if (!styleTag) {
                styleTag = document.createElement('style');
                styleTag.id = 'group-bubble-preview-style';
                document.head.appendChild(styleTag);
            }
            if (!cssText) {
                styleTag.textContent = '';
                return;
            }
            // åˆ¤æ–­æ˜¯çº¯å±æ€§è¿˜æ˜¯å®Œæ•´CSSè§„åˆ™
            const isFullCSS = cssText.includes('{') && cssText.includes('}');
            if (isFullCSS) {
                // å®Œæ•´è§„åˆ™æ¨¡å¼ï¼šæŠŠç”¨æˆ·é€‰æ‹©å™¨é™å®šåˆ°é¢„è§ˆåŒº
                const scopedCSS = scopeBubbleCSS(cssText, '#group-bubble-preview');
                styleTag.textContent = scopedCSS;
            } else {
                // çº¯å±æ€§æ¨¡å¼ï¼šåŠ  !important
                const importantCSS = cssText.split(';').map(p => {
                    p = p.trim();
                    if (!p || !p.includes(':')) return '';
                    if (p.toLowerCase().includes('!important')) return p + ';';
                    return p + ' !important;';
                }).filter(p => p).join('\n');
                styleTag.textContent = `
                    #group-bubble-preview .group-preview-bubble {
                        ${importantCSS}
                    }
                `;
            }
        }
        
        // åº”ç”¨ç¾¤èŠè‡ªå®šä¹‰æ°”æ³¡æ ·å¼åˆ°èŠå¤©ç•Œé¢
        function applyGroupCustomStyles(group) {
            if (!group) return;
            
            const styleId = 'group-custom-bubble-style';
            let styleTag = document.getElementById(styleId);
            
            const hasCSS = group.custom_bubble_css && group.custom_bubble_css.trim();
            
            if (!hasCSS) {
                if (styleTag) styleTag.textContent = '';
                return;
            }
            
            if (!styleTag) {
                styleTag = document.createElement('style');
                styleTag.id = styleId;
                document.head.appendChild(styleTag);
            }
            
            const cssText = group.custom_bubble_css.trim();
            const isFullCSS = cssText.includes('{') && cssText.includes('}');
            
            if (isFullCSS) {
                // å®Œæ•´CSSè§„åˆ™ï¼šé™å®šåˆ° #chat-body
                const scopedCSS = scopeBubbleCSS(cssText, '#chat-body');
                styleTag.textContent = scopedCSS;
            } else {
                // çº¯å±æ€§ï¼šåŒæ—¶åº”ç”¨åˆ°è‡ªå·±å’Œä»–äººçš„æ°”æ³¡
                const importantCSS = cssText.split(';').map(p => {
                    p = p.trim();
                    if (!p || !p.includes(':')) return '';
                    if (p.toLowerCase().includes('!important')) return p + ';';
                    return p + ' !important;';
                }).filter(p => p).join('\n');
                styleTag.textContent = `
                    #chat-body .group-msg-content {
                        ${importantCSS}
                    }
                `;
            }
        }
        
        // æ¸…é™¤ç¾¤èŠè‡ªå®šä¹‰æ ·å¼
        async function clearGroupCustomStyle() {
            if (!confirm('ç¡®å®šè¦æ¸…é™¤ç¾¤èŠè‡ªå®šä¹‰æ°”æ³¡CSSå—ï¼Ÿ')) return;
            document.getElementById('group-detail-bubble-css').value = '';
            previewGroupBubbleCSS();
            await saveGroupDetail();
            // ç§»é™¤å·²åº”ç”¨çš„æ ·å¼
            const styleTag = document.getElementById('group-custom-bubble-style');
            if (styleTag) styleTag.textContent = '';
            showToast('ç¾¤èŠè‡ªå®šä¹‰æ ·å¼å·²æ¸…é™¤');
        }
        
        // ä¿å­˜ç¾¤èŠè¯¦æƒ…
        async function saveGroupDetail() {
            if (!window.currentGroupChatId) return;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            group.name = document.getElementById('group-detail-name').value.trim() || group.name;
            group.myNickname = document.getElementById('group-detail-nickname').value.trim();
            group.is_muted = document.getElementById('group-detail-mute').checked;
            group.is_pinned = document.getElementById('group-detail-pin').checked;
            
            // è·å–é€‰ä¸­çš„ä¸–ç•Œä¹¦IDæ•°ç»„
            const checkboxes = document.querySelectorAll('#group-detail-lorebook-list input[type="checkbox"]:checked');
            const lorebookIds = Array.from(checkboxes).map(cb => parseInt(cb.value));
            group.lorebookIds = lorebookIds.length > 0 ? lorebookIds : null;
            
            // ä¸Šä¸‹æ–‡æ¡æ•°è®¾ç½®
            const contextCount = parseInt(document.getElementById('group-detail-context-count').value);
            group.context_message_count = contextCount > 0 ? contextCount : 25;
            
            // è‡ªåŠ¨æ€»ç»“è®¾ç½®
            group.auto_summary_enabled = document.getElementById('group-detail-auto-summary-switch').checked;
            const summaryInterval = parseInt(document.getElementById('group-detail-summary-interval').value);
            group.summary_interval = summaryInterval > 0 ? summaryInterval : 50;
            
            // ä¿å­˜è‡ªå®šä¹‰æ°”æ³¡CSS
            const groupBubbleCSSEl = document.getElementById('group-detail-bubble-css');
            if (groupBubbleCSSEl) {
                group.custom_bubble_css = groupBubbleCSSEl.value || '';
            }
            
            group.updated_at = Date.now();
            
            await safeGroupChatPut(group);
            
            // âœ… å¦‚æœå½“å‰æœ‰ç¾¤èŠçª—å£æ‰“å¼€ï¼Œå®æ—¶åº”ç”¨æ°”æ³¡æ ·å¼
            if (window.currentGroupChatId === group.id) {
                applyGroupCustomStyles(group);
            }
            
            // æ›´æ–°èŠå¤©çª—å£æ ‡é¢˜
            document.getElementById('chat-title').innerText = group.name;
        }
        
        // è®¾ç½®ç¾¤å¤´åƒ
        async function setGroupAvatar(input) {
            if (!input.files || !input.files[0] || !window.currentGroupChatId) return;
            
            const file = input.files[0];
            const reader = new FileReader();
            
            reader.onload = async (e) => {
                const avatarUrl = e.target.result;
                
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (!group) return;
                
                group.avatar = avatarUrl;
                group.updated_at = Date.now();
                await safeGroupChatPut(group);
                
                // æ›´æ–°è¯¦æƒ…é¡µå¤´åƒ
                document.getElementById('group-detail-avatar').style.backgroundImage = `url(${avatarUrl})`;
            };
            
            reader.readAsDataURL(file);
            input.value = '';
        }
        
        // æ¸…ç©ºç¾¤èŠè®°å½•
        async function clearGroupChatHistory() {
            if (!window.currentGroupChatId) return;
            
            if (!confirm('ç¡®å®šè¦æ¸…ç©ºè¯¥ç¾¤èŠçš„æ‰€æœ‰èŠå¤©è®°å½•å—ï¼Ÿï¼ˆåŒæ—¶æ¸…é™¤æ€»ç»“ï¼‰')) return;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            group.chat_history = [{
                role: 'system',
                content: 'èŠå¤©è®°å½•å·²æ¸…ç©º',
                time: Date.now()
            }];
            group.updated_at = Date.now();
            
            await safeGroupChatPut(group);
            
            // âœ… åŒæ—¶æ¸…é™¤ç¾¤èŠæ€»ç»“
            try {
                const accountId = getCurrentAccountId();
                const summaries = await db.chat_summaries.where('accountId').equals(accountId).toArray();
                const toDelete = summaries.filter(s => s.chatType === 'group' && String(s.chatId) === String(window.currentGroupChatId));
                for (const s of toDelete) {
                    await db.chat_summaries.delete(s.id);
                }
                if (toDelete.length > 0) console.log(`[clearGroupChatHistory] âœ… å·²æ¸…é™¤ ${toDelete.length} æ¡ç¾¤èŠæ€»ç»“`);
            } catch (e) {
                console.warn('[clearGroupChatHistory] æ¸…é™¤æ€»ç»“å¤±è´¥:', e);
            }
            
            await renderGroupChatBody(group);
            
            alert('èŠå¤©è®°å½•å·²æ¸…ç©º');
        }
        
        // é€€å‡ºç¾¤èŠ
        async function exitGroup() {
            if (!window.currentGroupChatId) return;
            
            if (!confirm('ç¡®å®šè¦åˆ é™¤å¹¶é€€å‡ºè¯¥ç¾¤èŠå—ï¼Ÿ')) return;
            
            await db.group_chats.delete(window.currentGroupChatId);
            
            hideGroupDetail();
            hideChatWindow();
            
            // åˆ·æ–°èŠå¤©åˆ—è¡¨
            if (document.querySelector('.wechat-tab-item.active')?.innerText.includes('å¾®ä¿¡')) {
                renderWechatList(document.getElementById('wechat-content'));
            }
            
            alert('å·²é€€å‡ºç¾¤èŠ');
        }
        
        // ç§»é™¤ç¾¤æˆå‘˜
        async function removeGroupMember(groupId, memberId) {
            const group = await db.group_chats.get(groupId);
            if (!group) return;
            
            group.memberIds = group.memberIds.filter(id => id !== memberId);
            group.updated_at = Date.now();
            
            // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯
            const char = await db.characters.get(memberId);
            group.chat_history.push({
                role: 'system',
                content: `${char?.name || 'æˆå‘˜'} å·²è¢«ç§»å‡ºç¾¤èŠ`,
                time: Date.now()
            });
            
            await safeGroupChatPut(group);
            await renderGroupMemberList(group);
            await renderGroupChatBody(group);
        }
        
        // æ˜¾ç¤ºæ·»åŠ ç¾¤æˆå‘˜å¼¹çª—
        async function showAddGroupMemberModal() {
            if (!window.currentGroupChatId) return;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            // å¤ç”¨åˆ›å»ºç¾¤èŠçš„å¼¹çª—é€»è¾‘
            document.getElementById('create-group-modal').style.display = 'flex';
            document.getElementById('group-name-input').style.display = 'none';
            document.querySelector('#create-group-modal .modal-title').innerText = 'æ·»åŠ ç¾¤æˆå‘˜';
            
            const list = document.getElementById('group-friends-list');
            list.innerHTML = '';
            
            const accountId = getCurrentAccountId();
            const allChars = await db.characters.toArray();
            const existingMemberIds = group.memberIds || [];
            const leftMemberIds = (group.leftMembers || []).map(lm => lm.id);
            
            // è¿‡æ»¤å‡ºè¿˜ä¸åœ¨ç¾¤é‡Œçš„å¥½å‹ï¼ˆåŒ…æ‹¬å·²é€€ç¾¤çš„ï¼Œæ–¹ä¾¿é‡æ–°é‚€è¯·ï¼‰
            const friends = allChars.filter(c => {
                if (c.type === 'user') return false;
                if (existingMemberIds.includes(c.id)) return false;
                const status = getFriendStatus(c, accountId);
                // å·²é€€ç¾¤çš„è§’è‰²ä¹Ÿæ˜¾ç¤ºï¼ˆå³ä½¿ä¸æ˜¯å¥½å‹çŠ¶æ€ä¹Ÿå…è®¸é‡æ–°é‚€è¯·ï¼‰
                if (leftMemberIds.includes(c.id)) return true;
                return status === 'friend';
            });
            
            // å°†å·²é€€ç¾¤çš„è§’è‰²æ’åœ¨å‰é¢
            friends.sort((a, b) => {
                const aLeft = leftMemberIds.includes(a.id);
                const bLeft = leftMemberIds.includes(b.id);
                if (aLeft && !bLeft) return -1;
                if (!aLeft && bLeft) return 1;
                return 0;
            });
            
            if (friends.length === 0) {
                list.innerHTML = '<div style="text-align:center; color:#999; margin-top:40px;">æ²¡æœ‰å¯æ·»åŠ çš„å¥½å‹</div>';
                return;
            }
            
            friends.forEach(f => {
                const item = document.createElement('div');
                item.style.cssText = 'display:flex; align-items:center; padding:12px 0; border-bottom:0.5px solid #f0f0f0; cursor:pointer;';
                item.dataset.charId = f.id;
                item.dataset.selected = 'false';
                
                const _invAv = getCharAvatar(f, accountId);
                const avatarStyle = _invAv ? `background-image:url(${_invAv})` : 'background-color:#eee';
                const isLeftMember = leftMemberIds.includes(f.id);
                const leftLabel = isLeftMember ? '<span style="font-size:12px; color:#ff9500; margin-left:8px; padding:1px 6px; background:#fff5eb; border-radius:4px;">å·²é€€ç¾¤</span>' : '';
                
                item.innerHTML = `
                    <div class="group-select-checkbox" style="width:22px; height:22px; border:2px solid #ddd; border-radius:50%; margin-right:12px; display:flex; align-items:center; justify-content:center; transition:all 0.2s;">
                        <svg class="check-icon" style="width:14px; height:14px; stroke:#fff; fill:none; stroke-width:3; display:none;" viewBox="0 0 24 24"><polyline points="20 6 9 17 4 12"></polyline></svg>
                    </div>
                    <div style="width:40px; height:40px; border-radius:4px; ${avatarStyle}; background-size:cover; background-position:center; margin-right:12px;"></div>
                    <div style="font-size:16px; color:#333;">${getCharDisplayName(f, accountId)}${leftLabel}</div>
                `;
                
                item.onclick = function() {
                    const isSelected = this.dataset.selected === 'true';
                    const checkbox = this.querySelector('.group-select-checkbox');
                    const checkIcon = this.querySelector('.check-icon');
                    
                    if (isSelected) {
                        this.dataset.selected = 'false';
                        checkbox.style.background = 'transparent';
                        checkbox.style.borderColor = '#ddd';
                        checkIcon.style.display = 'none';
                    } else {
                        this.dataset.selected = 'true';
                        checkbox.style.background = 'var(--ins-pink)';
                        checkbox.style.borderColor = 'var(--ins-pink)';
                        checkIcon.style.display = 'block';
                    }
                };
                
                list.appendChild(item);
            });
            
            // ä¿®æ”¹ç¡®è®¤æŒ‰é’®è¡Œä¸º
            window._addingGroupMembers = true;
        }
        
        // è¿½åŠ ç”¨æˆ·ç¾¤èŠæ¶ˆæ¯åˆ°UIï¼ˆä¼˜åŒ–æ€§èƒ½ï¼Œé¿å…é‡æ–°æ¸²æŸ“æ•´ä¸ªé¡µé¢ï¼‰
        async function appendUserGroupMessageToUI(msg, group) {
            const body = document.getElementById('chat-body');
            const myChar = currentMyCharId ? await db.characters.get(parseInt(currentMyCharId)) : null;
            const myNickname = group.myNickname || (myChar ? (myChar.nick || myChar.name) : 'æˆ‘');
            const myAvatar = myChar?.avatar || '';
            const avatarStyle = myAvatar ? `background-image:url(${myAvatar})` : 'background:#ccc';
            
            // ğŸ”§ ç»Ÿä¸€ç±»åï¼šç¾¤èŠä¹Ÿä½¿ç”¨ message-row + self
            const msgDiv = document.createElement('div');
            msgDiv.style.marginBottom = '12px';
            msgDiv.className = 'message-row group-message-row self';
            
            // æ¸²æŸ“æ¶ˆæ¯å†…å®¹ï¼ˆå¤„ç†å„ç§ç‰¹æ®Šæ ¼å¼ï¼‰
            let renderedContent = msg.content;
            
            // å¤„ç†å›¾ç‰‡å¡ç‰‡
            if (msg.content.startsWith('[imgcard:')) {
                const cardText = msg.content.substring(9, msg.content.length - 1).trim();
                // âœ… å¦‚æœå·²æœ‰ NovelAI ç”Ÿæˆçš„å›¾ç‰‡ï¼Œç›´æ¥æ˜¾ç¤º
                if (msg.novelai_generated && msg.novelai_image) {
                    renderedContent = `<div class="img-card-bubble" style="cursor:default;">
                        <img src="${msg.novelai_image}" class="chat-image" 
                             style="width:200px; max-height:300px; object-fit:cover; border-radius:8px; cursor:pointer;" 
                             onclick="showFullImage(this.src)" />
                        <div style="font-size:10px; color:#bbb; text-align:center; margin-top:4px; padding:0 4px;">${escapeHtml(cardText)}</div>
                    </div>`;
                } else {
                    renderedContent = `<div class="img-card-bubble" data-text="${escapeHtml(cardText)}" data-expanded="false" onclick="showImageCardContent(this)">
                        <div class="img-card-placeholder">
                            <svg class="img-card-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                <circle cx="8.5" cy="8.5" r="1.5"></circle>
                                <polyline points="21 15 16 10 5 21"></polyline>
                            </svg>
                            <div class="img-card-hint">ç‚¹å‡»æŸ¥çœ‹æ–‡å­—</div>
                        </div>
                    </div>`;
                }
            }
            // å¤„ç†å›¾ç‰‡
            else if (msg.content.startsWith('[img:')) {
                const imgUrl = msg.content.substring(5, msg.content.length - 1).trim();
                renderedContent = `<img src="${imgUrl}" class="chat-image" style="width:150px; height:150px; object-fit:cover; border-radius:8px; cursor:pointer;" onclick="showFullImage(this.src)" ${getImageErrorHandler()} />`;
            }
            // å¤„ç†è¯­éŸ³
            else if (msg.content.startsWith('[voice:')) {
                const voiceText = msg.content.substring(7, msg.content.length - 1).trim();
                const barCount = Math.min(Math.max(Math.ceil(voiceText.length / 3), 3), 10);
                let bars = '';
                for (let i = 0; i < barCount; i++) {
                    const height = 8 + Math.random() * 12;
                    bars += `<div style="width:3px; height:${height}px; background:#999; border-radius:2px;"></div>`;
                }
                renderedContent = `<div class="voice-bubble" data-text="${escapeHtml(voiceText)}" style="background:#ffe4e8; padding:10px 14px; border-radius:18px; cursor:pointer; display:flex; align-items:center; gap:8px; min-width:80px;" onclick="playVoiceBubble(this)">
                    <svg viewBox="0 0 24 24" style="width:16px; height:16px; fill:#666;"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z"/></svg>
                    <div style="display:flex; align-items:center; gap:2px;">${bars}</div>
                    <span style="font-size:12px; color:#666;">${Math.ceil(voiceText.length / 5)}"</span>
                </div>`;
            }
            // æ™®é€šæ–‡å­—
            else {
                renderedContent = renderMessageContent(msg.content);
            }
            
            // åˆ¤æ–­æ˜¯å¦æ˜¯ç‰¹æ®Šæ¶ˆæ¯ï¼ˆä¸éœ€è¦æ°”æ³¡åŒ…è£¹ï¼‰
            const isSpecialMsg = msg.content.startsWith('[imgcard:') || msg.content.startsWith('[img:') || msg.content.startsWith('[voice:');
            
            if (isSpecialMsg) {
                msgDiv.innerHTML = `
                    <div class="message-avatar" style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                    <div style="display:flex; flex-direction:column; align-items:flex-end; max-width:70%;">
                        <div style="font-size:12px; color:#999; margin-bottom:2px;">${myNickname}</div>
                        <div style="display:flex; align-items:flex-end; gap:6px;">
                            <div style="font-size:10px; color:#999;">${formatChatTime(msg.time)}</div>
                            <div class="message-content group-msg-content">${renderedContent}</div>
                        </div>
                    </div>
                `;
            } else {
                msgDiv.innerHTML = `
                    <div class="message-avatar" style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                    <div style="display:flex; flex-direction:column; align-items:flex-end; max-width:70%;">
                        <div style="font-size:12px; color:#999; margin-bottom:2px;">${myNickname}</div>
                        <div style="display:flex; align-items:flex-end; gap:6px;">
                            <div style="font-size:10px; color:#999;">${formatChatTime(msg.time)}</div>
                            <div class="message-content group-msg-content">${renderedContent}</div>
                        </div>
                    </div>
                `;
            }
            
            body.appendChild(msgDiv);
            body.scrollTop = body.scrollHeight;
        }
        
        // æ¸²æŸ“ç¾¤èŠæ¶ˆæ¯
        async function renderGroupChatBody(group) {
            const body = document.getElementById('chat-body');
            body.innerHTML = '';
            
            let history = group.chat_history || [];
            // æŒ‰æ—¶é—´æˆ³æ’åºï¼Œç¡®ä¿æ¶ˆæ¯é¡ºåºæ­£ç¡®
            history = [...history].sort((a, b) => (a.time || 0) - (b.time || 0));
            
            const accountId = getCurrentAccountId();
            const myChar = currentMyCharId ? await db.characters.get(parseInt(currentMyCharId)) : null;
            
            // è·å–æˆ‘çš„ç¾¤æ˜µç§°
            const myNickname = group.myNickname || (myChar ? (myChar.nick || myChar.name) : 'æˆ‘');
            
            // é¢„åŠ è½½æ‰€æœ‰æˆå‘˜ä¿¡æ¯ï¼ˆåŒ…æ‹¬å·²é€€ç¾¤çš„æˆå‘˜ï¼Œç¡®ä¿å†å²æ¶ˆæ¯èƒ½æ­£ç¡®æ˜¾ç¤ºï¼‰
            const memberMap = {};
            for (const memberId of group.memberIds) {
                const char = await db.characters.get(memberId);
                if (char) memberMap[memberId] = char;
            }
            // åŠ è½½å·²é€€ç¾¤æˆå‘˜ä¿¡æ¯ï¼ˆç”¨äºæ˜¾ç¤ºé€€ç¾¤å‰çš„å†å²æ¶ˆæ¯ï¼‰
            for (const lm of (group.leftMembers || [])) {
                if (!memberMap[lm.id]) {
                    const char = await db.characters.get(lm.id);
                    if (char) memberMap[lm.id] = char;
                }
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šæ¸²æŸ“ç¾¤èŠæ¶ˆæ¯å†…å®¹ï¼ˆæ”¯æŒç‰¹æ®Šæ ¼å¼ï¼‰
            function renderGroupMessageContent(content, isSelf, msgType, msgObj) {
                if (!content) return '';
                
                // å¤„ç†çº¢åŒ…æ¶ˆæ¯ - INSé£æ ¼çº¯ç™½å¡ç‰‡
                if (msgType === 'redpacket') {
                    try {
                        const data = JSON.parse(content);
                        const isAllClaimed = (data.claimed?.length || 0) >= data.count;
                        return `<div class="redpacket-card" onclick="showRedPacketDetail('${data.id}')" style="width:220px; background:#fff; border-radius:12px; overflow:hidden; cursor:pointer; box-shadow:0 1px 3px rgba(0,0,0,0.08); border:1px solid #eee;">
                            <div style="padding:14px 16px; display:flex; align-items:center; gap:12px;">
                                <div style="width:40px; height:40px; background:#fff; border-radius:10px; display:flex; align-items:center; justify-content:center; border:1px solid #eee;">
                                    <svg viewBox="0 0 24 24" style="width:20px; height:20px; stroke:#666; fill:none; stroke-width:1.5;"><rect x="3" y="4" width="18" height="16" rx="2"/><path d="M3 10h18"/><circle cx="12" cy="15" r="2"/></svg>
                                </div>
                                <div style="flex:1;">
                                    <div style="font-size:14px; color:#333; margin-bottom:2px;">${escapeHtml(data.wish || 'æ­å–œå‘è´¢')}</div>
                                    <div style="font-size:11px; color:#999;">${data.redpacketType === 'lucky' ? 'æ‹¼æ‰‹æ°”çº¢åŒ…' : 'æ™®é€šçº¢åŒ…'}</div>
                                </div>
                            </div>
                            <div style="padding:8px 16px; display:flex; justify-content:space-between; align-items:center; border-top:1px solid #eee;">
                                <span style="font-size:11px; color:#999;">çº¢åŒ…</span>
                                <span style="font-size:11px; color:#999;">${isAllClaimed ? 'å·²é¢†å®Œ' : `${data.claimed?.length || 0}/${data.count}å·²é¢†`}</span>
                            </div>
                        </div>`;
                    } catch(e) {
                        return content;
                    }
                }
                
                // å¤„ç†è½¬è´¦æ¶ˆæ¯ - INSé£æ ¼çº¯ç™½å¡ç‰‡
                if (msgType === 'transfer') {
                    try {
                        const data = JSON.parse(content);
                        const targetHint = data.targetName ? `è½¬ç»™ ${data.targetName}` : 'è½¬è´¦';
                        const msgId = (msgObj && msgObj.id) || ('trans_' + (msgObj && msgObj.time || Date.now()));
                        return `<div class="redpacket-card" onclick="receiveGroupTransfer('${msgId}')" style="width:220px; background:#fff; border-radius:12px; overflow:hidden; box-shadow:0 1px 3px rgba(0,0,0,0.08); border:1px solid #eee; cursor:pointer;">
                            <div style="padding:14px 16px; display:flex; align-items:center; gap:12px;">
                                <div style="width:40px; height:40px; background:#fff; border-radius:10px; display:flex; align-items:center; justify-content:center; border:1px solid #eee;">
                                    <svg viewBox="0 0 24 24" style="width:20px; height:20px; stroke:#666; fill:none; stroke-width:1.5;"><path d="M17 1l4 4-4 4"/><path d="M3 11V9a4 4 0 0 1 4-4h14"/><path d="M7 23l-4-4 4-4"/><path d="M21 13v2a4 4 0 0 1-4 4H3"/></svg>
                                </div>
                                <div style="flex:1;">
                                    <div style="font-size:18px; font-weight:600; color:#333; margin-bottom:2px;">Â¥${data.amount}</div>
                                    <div style="font-size:12px; color:#999;">${escapeHtml(data.desc || 'è½¬è´¦')}</div>
                                </div>
                            </div>
                            <div style="padding:8px 16px; display:flex; justify-content:space-between; align-items:center; border-top:1px solid #eee;">
                                <span style="font-size:11px; color:#999;">${targetHint}</span>
                                <span style="font-size:11px; color:#999;">${data.status === 'received' ? 'å·²æ”¶æ¬¾' : 'å¾…æ”¶æ¬¾'}</span>
                            </div>
                        </div>`;
                    } catch(e) {
                        return content;
                    }
                }
                
                // å¤„ç†è´­ç‰©å¡ç‰‡æ¶ˆæ¯
                if (msgType === 'shopPayRequest') {
                    try {
                        const sd = JSON.parse(content);
                        const amt = parseFloat(sd.amount || 0).toFixed(2);
                        const itm = sd.items || 'è´­ç‰©å•†å“';
                        let title = 'ä»£ä»˜è¯·æ±‚';
                        let st = 'å¾…ç¡®è®¤';
                        let cv = '';
                        if (sd.isShare) { title = 'è´­ç‰©åˆ†äº«'; st = isSelf ? 'å·²åˆ†äº«' : 'æ¥è‡ªå¥½å‹'; cv = 'share'; }
                        else if (sd.isGift) { title = 'è´­ç‰©ç¤¼ç‰©'; st = isSelf ? 'å·²èµ é€' : 'å·²æ”¶åˆ°'; cv = 'gift'; }
                        else { if (sd.status === 'paid') { st = 'å·²ä»£ä»˜'; cv = 'done'; } else if (sd.status === 'declined') { st = 'å·²æ‹’ç»'; cv = 'declined'; } }
                        let meta = '';
                        if (sd.buyForName && sd.installmentInfo) meta = 'To: ' + sd.buyForName + ' Â· ' + sd.installmentInfo;
                        else if (sd.buyForName) meta = 'To: ' + sd.buyForName;
                        else if (sd.installmentInfo) meta = sd.installmentInfo;
                        return `<div class="spr-card ${cv}"><div class="spr-top"><div class="spr-badge">${title}</div></div><div class="spr-body"><div class="spr-amount-row"><span class="spr-currency">Â¥</span><span class="spr-amount-num">${amt}</span></div><div class="spr-items-text">${escapeHtml(itm)}</div>${meta ? '<div class="spr-meta">' + escapeHtml(meta) + '</div>' : ''}</div><div class="spr-divider"></div><div class="spr-bottom"><span class="spr-status-text">${st}</span></div></div>`;
                    } catch(e) { return content; }
                }
                
                // å¤„ç†å›¾ç‰‡å¡ç‰‡æ¶ˆæ¯ [imgcard:æ–‡å­—å†…å®¹] - ä½¿ç”¨ä¸ç§èŠç›¸åŒçš„æ ·å¼
                if (content.startsWith('[imgcard:')) {
                    const cardText = content.substring(9, content.length - 1).trim();
                    return `<div class="img-card-bubble" data-text="${escapeHtml(cardText)}" data-expanded="false" onclick="showImageCardContent(this)">
                        <div class="img-card-placeholder">
                            <svg class="img-card-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                <circle cx="8.5" cy="8.5" r="1.5"></circle>
                                <polyline points="21 15 16 10 5 21"></polyline>
                            </svg>
                            <div class="img-card-hint">ç‚¹å‡»æŸ¥çœ‹æ–‡å­—</div>
                        </div>
                    </div>`;
                }
                
                // å¤„ç†å›¾ç‰‡æ¶ˆæ¯ [img:url]
                if (content.startsWith('[img:')) {
                    const imgUrl = content.substring(5, content.length - 1).trim();
                    return `<img src="${imgUrl}" class="chat-image" style="width:150px; height:150px; object-fit:cover; border-radius:8px; cursor:pointer;" onclick="showFullImage(this.src)" ${getImageErrorHandler()} />`;
                }
                
                // å¤„ç†è¯­éŸ³æ¶ˆæ¯ [voice:æ–‡å­—å†…å®¹]
                if (content.startsWith('[voice:')) {
                    const voiceText = content.substring(7, content.length - 1).trim();
                    const bgColor = isSelf ? '#ffe4e8' : '#f2f2f7';
                    const barCount = Math.min(Math.max(Math.ceil(voiceText.length / 3), 3), 10);
                    let bars = '';
                    for (let i = 0; i < barCount; i++) {
                        const height = 8 + Math.random() * 12;
                        bars += `<div style="width:3px; height:${height}px; background:#999; border-radius:2px;"></div>`;
                    }
                    return `<div class="voice-bubble" data-text="${escapeHtml(voiceText)}" style="background:${bgColor}; padding:10px 14px; border-radius:18px; cursor:pointer; display:flex; align-items:center; gap:8px; min-width:80px;" onclick="playVoiceBubble(this)">
                        <svg viewBox="0 0 24 24" style="width:16px; height:16px; fill:#666;"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z"/></svg>
                        <div style="display:flex; align-items:center; gap:2px;">${bars}</div>
                        <span style="font-size:12px; color:#666;">${Math.ceil(voiceText.length / 5)}"</span>
                    </div>`;
                }
                
                // æ™®é€šæ–‡æœ¬æ¶ˆæ¯ï¼Œä½¿ç”¨ renderMessageContent å¤„ç†ï¼ˆæ”¯æŒé“¾æ¥å’Œå›¾ç‰‡URLï¼‰
                return renderMessageContent(content);
            }
            
            let msgIndex = 0;
            for (const msg of history) {
                const currentIndex = msgIndex;
                const msgDiv = document.createElement('div');
                msgDiv.style.marginBottom = '12px';
                msgDiv.className = 'group-message-row';
                msgDiv.dataset.msgIndex = currentIndex;
                
                if (msg.role === 'system') {
                    // ç³»ç»Ÿæ¶ˆæ¯ï¼ˆæ”¯æŒé•¿æŒ‰åˆ é™¤å’Œå¤šé€‰ï¼‰
                    msgDiv.style.textAlign = 'center';
                    msgDiv.style.position = 'relative';
                    
                    // å¤é€‰æ¡† (å¤šé€‰æ¨¡å¼ç”¨)
                    const checkbox = document.createElement('div');
                    checkbox.className = 'msg-checkbox';
                    checkbox.style.cssText = 'position:absolute; left:8px; top:50%; transform:translateY(-50%); width:22px; height:22px; border:2px solid #ccc; border-radius:50%; display:none; align-items:center; justify-content:center; cursor:pointer; z-index:10;';
                    msgDiv.appendChild(checkbox);
                    
                    const systemSpan = document.createElement('span');
                    systemSpan.className = 'group-system-msg-content';
                    systemSpan.style.cssText = 'background:#fff; color:#999; font-size:12px; padding:4px 12px; border-radius:4px; border:1px solid #ddd; display:inline-block;';
                    systemSpan.textContent = msg.content;
                    msgDiv.appendChild(systemSpan);
                    
                    // ç»‘å®šé•¿æŒ‰äº‹ä»¶ï¼Œå…è®¸åˆ é™¤ç³»ç»Ÿæ¶ˆæ¯
                    bindGroupMessageEvents(systemSpan, currentIndex, true); // trueè¡¨ç¤ºæ˜¯ç³»ç»Ÿæ¶ˆæ¯
                    // æ•´ä¸ªè¡Œç‚¹å‡»äº‹ä»¶ (ç”¨äºå¤šé€‰)
                    msgDiv.onclick = (e) => {
                        if (isSelectionMode) {
                            handleGroupRowClick(currentIndex, e);
                        }
                    };
                    msgIndex++;
                } else if (msg.role === 'user') {
                    // ğŸ”§ ç»Ÿä¸€ç±»åï¼šç¾¤èŠä¹Ÿä½¿ç”¨ message-row + selfï¼Œæ ·å¼ç”±CSSç»Ÿä¸€æ§åˆ¶
                    msgDiv.classList.add('message-row', 'self');
                    
                    const myAvatar = myChar?.avatar || '';
                    const avatarStyle = myAvatar ? `background-image:url(${myAvatar})` : 'background:#ccc';
                    
                    // åˆ¤æ–­æ˜¯å¦æ˜¯ç‰¹æ®Šæ¶ˆæ¯ç±»å‹ï¼ˆä¸éœ€è¦æ°”æ³¡åŒ…è£¹ï¼‰
                    const isSpecialMsg = msg.content.startsWith('[imgcard:') || msg.content.startsWith('[img:') || msg.content.startsWith('[voice:') || msg.type === 'redpacket' || msg.type === 'transfer' || msg.type === 'shopPayRequest' || msg.content.startsWith('[emei_order]') || msg.content.startsWith('[emei_share]') || msg.content.startsWith('[payment_request]') || msg.content.startsWith('[couple_avatar_card]');
                    const renderedContent = renderGroupMessageContent(msg.content, true, msg.type, msg);
                    
                    if (isSpecialMsg) {
                        msgDiv.innerHTML = `
                            <div class="message-avatar" style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                            <div style="display:flex; flex-direction:column; align-items:flex-end; max-width:70%;">
                                <div style="font-size:12px; color:#999; margin-bottom:2px;">${myNickname}</div>
                                <div style="display:flex; align-items:flex-end; gap:6px;">
                                    <div style="font-size:10px; color:#999;">${formatChatTime(msg.time)}</div>
                                    <div class="message-content group-msg-content" data-index="${currentIndex}">${renderedContent}</div>
                                </div>
                            </div>
                        `;
                    } else {
                        // æ£€æŸ¥æ˜¯å¦æœ‰å¼•ç”¨
                        const quoteHtml = msg.quote ? `<div class="quoted-message" style="margin-bottom:6px;"><div class="quoted-message-name">${escapeHtml(msg.quote.name)}</div><div class="quoted-message-text">${escapeHtml(msg.quote.content)}</div></div>` : '';
                        
                        msgDiv.innerHTML = `
                            <div class="message-avatar" style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                            <div style="display:flex; flex-direction:column; align-items:flex-end; max-width:70%;">
                                <div style="font-size:12px; color:#999; margin-bottom:2px;">${myNickname}</div>
                                <div style="display:flex; align-items:flex-end; gap:6px;">
                                    <div style="font-size:10px; color:#999;">${formatChatTime(msg.time)}</div>
                                    <div class="message-content group-msg-content" data-index="${currentIndex}">${quoteHtml}${renderedContent}</div>
                                </div>
                            </div>
                        `;
                    }
                    msgIndex++;
                } else {
                    // ğŸ”§ ç»Ÿä¸€ç±»åï¼šç¾¤èŠä¹Ÿä½¿ç”¨ message-row + otherï¼Œæ ·å¼ç”±CSSç»Ÿä¸€æ§åˆ¶
                    msgDiv.classList.add('message-row', 'other');
                    
                    // ç¾¤æˆå‘˜å‘çš„æ¶ˆæ¯
                    let senderChar = msg.senderId ? memberMap[msg.senderId] : null;
                    
                    // ğŸ”§ å¦‚æœmemberMapä¸­æ‰¾ä¸åˆ°ï¼ˆå¯èƒ½å·²è¢«è¸¢å‡ºç¾¤ï¼‰ï¼Œå°è¯•ä»æ•°æ®åº“è·å–
                    if (!senderChar && msg.senderId) {
                        try {
                            senderChar = await db.characters.get(msg.senderId);
                        } catch(e) {}
                    }
                    
                    // ä¼˜å…ˆä½¿ç”¨ç¾¤æ˜µç§°ï¼Œå…¶æ¬¡ç”¨å¤‡æ³¨åï¼Œæœ€åç”¨æ¶ˆæ¯ä¸­å†—ä½™å­˜å‚¨çš„åå­—
                    const memberNicknames = group.memberNicknames || {};
                    const senderName = memberNicknames[msg.senderId] || (senderChar ? (senderChar.remark || senderChar.wx_nickname || senderChar.name) : (msg.senderName || 'ç¾¤æˆå‘˜'));
                    const senderAvatar = senderChar?.avatar || '';
                    const avatarStyle = senderAvatar ? `background-image:url(${senderAvatar})` : 'background:#ccc';
                    
                    // åˆ¤æ–­æ˜¯å¦æ˜¯ç‰¹æ®Šæ¶ˆæ¯ç±»å‹ï¼ˆä¸éœ€è¦æ°”æ³¡åŒ…è£¹ï¼‰
                    const isSpecialMsg = msg.content.startsWith('[imgcard:') || msg.content.startsWith('[img:') || msg.content.startsWith('[voice:') || msg.type === 'redpacket' || msg.type === 'transfer' || msg.type === 'shopPayRequest' || msg.content.startsWith('[emei_order]') || msg.content.startsWith('[emei_share]') || msg.content.startsWith('[payment_request]') || msg.content.startsWith('[couple_avatar_card]');
                    const renderedContent = renderGroupMessageContent(msg.content, false, msg.type, msg);
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰å¼•ç”¨
                    const quoteHtml = msg.quote ? `<div class="quoted-message" style="margin-bottom:6px;"><div class="quoted-message-name">${escapeHtml(msg.quote.name)}</div><div class="quoted-message-text">${escapeHtml(msg.quote.content)}</div></div>` : '';
                    
                    if (isSpecialMsg) {
                        msgDiv.innerHTML = `
                            <div class="message-avatar" style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                            <div style="display:flex; flex-direction:column; max-width:70%;">
                                <div style="font-size:12px; color:#999; margin-bottom:2px;">${senderName}</div>
                                <div style="display:flex; align-items:flex-end; gap:6px;">
                                    <div class="message-content group-msg-content" data-index="${currentIndex}">${renderedContent}</div>
                                    <div style="font-size:10px; color:#999;">${formatChatTime(msg.time)}</div>
                                </div>
                            </div>
                        `;
                    } else {
                        msgDiv.innerHTML = `
                            <div class="message-avatar" style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                            <div style="display:flex; flex-direction:column; max-width:70%;">
                                <div style="font-size:12px; color:#999; margin-bottom:2px;">${senderName}</div>
                                <div style="display:flex; align-items:flex-end; gap:6px;">
                                    <div class="message-content group-msg-content" data-index="${currentIndex}">${quoteHtml}${renderedContent}</div>
                                    <div style="font-size:10px; color:#999;">${formatChatTime(msg.time)}</div>
                                </div>
                            </div>
                        `;
                    }
                    msgIndex++;
                }
                
                body.appendChild(msgDiv);
                
                // ç»‘å®šé•¿æŒ‰äº‹ä»¶ï¼ˆéç³»ç»Ÿæ¶ˆæ¯ï¼‰
                if (msg.role !== 'system') {
                    const contentEl = msgDiv.querySelector('.group-msg-content');
                    if (contentEl) {
                        bindGroupMessageEvents(contentEl, currentIndex);
                    }
                }
            }
            
            // æ»šåŠ¨åˆ°åº•éƒ¨
            body.scrollTop = body.scrollHeight;
        }
        
        // ç¾¤èŠæ¶ˆæ¯é•¿æŒ‰äº‹ä»¶ç»‘å®š
        function bindGroupMessageEvents(element, index, isSystemMsg) {
            let touchStartEvent = null;
            let _grpTouchStartX = 0;
            let _grpTouchStartY = 0;
            
            const startHandler = (e) => {
                if (isSelectionMode) return;
                isLongPress = false;
                touchStartEvent = e;
                // è®°å½•èµ·å§‹è§¦æ‘¸åæ ‡
                if (e.touches && e.touches[0]) {
                    _grpTouchStartX = e.touches[0].clientX;
                    _grpTouchStartY = e.touches[0].clientY;
                } else {
                    _grpTouchStartX = e.clientX || 0;
                    _grpTouchStartY = e.clientY || 0;
                }
                longPressTimer = setTimeout(() => {
                    isLongPress = true;
                    // é•¿æŒ‰è§¦å‘æ—¶é˜»æ­¢æµè§ˆå™¨åç»­é»˜è®¤è¡Œä¸º
                    try {
                        if (touchStartEvent && touchStartEvent.cancelable) {
                            touchStartEvent.preventDefault();
                        }
                    } catch(ex) {}
                    showGroupContextMenu(e, index, element, isSystemMsg);
                }, 400); // 400ms é•¿æŒ‰è§¦å‘ï¼ˆé™ä½é—¨æ§›ï¼‰
            };

            const cancelHandler = (e) => {
                // âœ… æ‰‹æœºç«¯å®¹é”™ï¼šæ‰‹æŒ‡å¾®å°æŠ–åŠ¨ä¸å–æ¶ˆé•¿æŒ‰ï¼ˆé˜ˆå€¼10pxï¼‰
                if (e && (e.touches || e.clientX !== undefined)) {
                    const cx = e.touches ? e.touches[0].clientX : e.clientX;
                    const cy = e.touches ? e.touches[0].clientY : e.clientY;
                    const dx = Math.abs(cx - _grpTouchStartX);
                    const dy = Math.abs(cy - _grpTouchStartY);
                    if (dx < 10 && dy < 10) return; // å¾®å°ç§»åŠ¨ï¼Œä¸å–æ¶ˆ
                }
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            };
            
            const endHandler = (e) => {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                touchStartEvent = null;
                if (isLongPress) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            };

            // è§¦æ‘¸è®¾å¤‡ - passive:false å…è®¸åœ¨é•¿æŒ‰æ—¶è°ƒç”¨preventDefaulté˜»æ­¢æµè§ˆå™¨é»˜è®¤èœå•
            element.addEventListener('touchstart', startHandler, {passive: false});
            element.addEventListener('touchmove', cancelHandler, {passive: true});
            element.addEventListener('touchend', endHandler);
            element.addEventListener('mousedown', startHandler);
            element.addEventListener('mousemove', cancelHandler);
            element.addEventListener('mouseup', endHandler);
            // ç¦ç”¨å³é”®é»˜è®¤èœå•ï¼ˆåŒæ—¶è¦†ç›–æ‰‹æœºç«¯é•¿æŒ‰è§¦å‘çš„contextmenuï¼‰
            element.addEventListener('contextmenu', (e) => e.preventDefault());
        }
        
        // ç¾¤èŠæ¶ˆæ¯å³é”®èœå•
        function showGroupContextMenu(event, index, element, isSystemMsg) {
            if (navigator.vibrate) navigator.vibrate(50);
            
            activeMsgIndex = index;
            activeGroupMsgIndex = index;
            // é«˜äº®ï¼šç³»ç»Ÿæ¶ˆæ¯é«˜äº®æ•´ä¸ªrowï¼Œæ™®é€šæ¶ˆæ¯é«˜äº®content
            if (isSystemMsg) {
                const row = element.closest('.group-message-row');
                if (row) row.classList.add('active');
            } else {
                element.classList.add('active');
            }

            const menu = document.getElementById('msg-context-menu');
            const overlay = document.getElementById('menu-overlay');
            
            // ç³»ç»Ÿæ¶ˆæ¯åªæ˜¾ç¤º"åˆ é™¤"æŒ‰é’®ï¼Œéšè—å…¶ä»–èœå•é¡¹
            const menuItems = menu.querySelectorAll('.context-menu-item');
            menuItems.forEach(item => {
                const label = item.querySelector('span')?.textContent;
                if (isSystemMsg) {
                    item.style.display = (label === 'åˆ é™¤') ? 'flex' : 'none';
                } else {
                    item.style.display = 'flex';
                }
            });
            
            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            const winWidth = window.innerWidth;
            const winHeight = window.innerHeight;

            // âœ… å…ˆæ˜¾ç¤ºèœå•ä»¥è·å–çœŸå®å°ºå¯¸
            menu.style.display = 'flex';
            menu.style.left = '0px';
            menu.style.top = '0px';
            
            const menuWidth = menu.offsetWidth;
            const menuHeight = menu.offsetHeight;
            
            // âœ… æ°´å¹³å±…ä¸­äºç‚¹å‡»ä½ç½®
            let menuX = clientX - menuWidth / 2;
            if (menuX + menuWidth > winWidth - 10) {
                menuX = winWidth - menuWidth - 10;
            }
            if (menuX < 10) {
                menuX = 10;
            }
            
            // âœ… å‚ç›´ï¼šä¼˜å…ˆä¸Šæ–¹
            let menuY = clientY - menuHeight - 10;
            if (menuY < 10) {
                menuY = clientY + 10;
            }
            if (menuY + menuHeight > winHeight - 10) {
                menuY = winHeight - menuHeight - 10;
            }

            menu.style.left = menuX + 'px';
            menu.style.top = menuY + 'px';
            
            // å…ˆç¦ç”¨overlayç‚¹å‡»ï¼Œé˜²æ­¢touchendåˆæˆçš„clickäº‹ä»¶ç«‹åˆ»å…³é—­èœå•
            overlay.style.display = 'block';
            overlay.style.pointerEvents = 'none';
            setTimeout(() => {
                overlay.style.pointerEvents = 'auto';
            }, 350);
        }
        
        // ç¾¤èŠæ¶ˆæ¯ç´¢å¼•
        let activeGroupMsgIndex = -1;
        
        // è·å–ç¾¤èŠåˆ—è¡¨
        async function getGroupChats(accountId) {
            try {
                const allGroups = await db.group_chats.where('ownerAccountId').equals(accountId).toArray();
                return allGroups;
            } catch (e) {
                // å¦‚æœè¡¨ä¸å­˜åœ¨ï¼Œè¿”å›ç©ºæ•°ç»„
                return [];
            }
        }
        
        // æ ¼å¼åŒ–èŠå¤©æ—¶é—´
        function formatChatTime(timestamp) {
            if (!timestamp) return '';
            const d = new Date(timestamp);
            const now = new Date();
            if (d.toDateString() === now.toDateString()) {
                return `${d.getHours()}:${d.getMinutes().toString().padStart(2, '0')}`;
            } else {
                return `${d.getMonth() + 1}/${d.getDate()} ${d.getHours()}:${d.getMinutes().toString().padStart(2, '0')}`;
            }
        }

        // --- æ–°çš„å¥½å‹é¡µé¢é€»è¾‘ ---
        async function showNewFriendsPage() {
            document.getElementById('new-friends-page').style.display = 'flex';
            await renderNewFriendsPage();
        }

        function hideNewFriendsPage() {
            document.getElementById('new-friends-page').style.display = 'none';
        }

        async function renderNewFriendsPage() {
            const accountId = getCurrentAccountId();
            if (!accountId) {
                document.getElementById('new-friends-content').innerHTML = `
                    <div style="text-align:center; padding:60px 20px; color:#999;">
                        è¯·å…ˆåˆ‡æ¢åˆ°ä½ çš„è´¦å·ï¼ˆUserç±»å‹è§’è‰²ï¼‰
                    </div>
                `;
                return;
            }
            
            const container = document.getElementById('new-friends-content');
            
            // è·å–æ‰€æœ‰ç›¸å…³çš„å¥½å‹ç”³è¯·ï¼šå‘ç»™æˆ‘çš„ + æˆ‘å‘é€çš„ + è”æœºå¥½å‹ç”³è¯·
            const allRequests = await db.friend_requests.toArray();
            const myRequests = allRequests.filter(req => 
                req.toAccountId === accountId || // è”æœºå¥½å‹ç”³è¯·
                req.toCharId === parseInt(accountId) || 
                req.fromCharId === parseInt(accountId)
            ).sort((a, b) => b.time - a.time);
            
            if (myRequests.length === 0) {
                container.innerHTML = `
                    <div style="text-align:center; padding:60px 20px; color:#999;">
                        <svg class="svg-icon" style="width:48px; height:48px; stroke:#ccc; margin-bottom:10px;" viewBox="0 0 24 24">
                            <path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="8.5" cy="7" r="4"></circle>
                            <line x1="20" y1="8" x2="20" y2="14"></line>
                            <line x1="23" y1="11" x2="17" y2="11"></line>
                        </svg>
                        <div>æš‚æ— å¥½å‹ç”³è¯·</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = '';
            const listDiv = document.createElement('div');
            listDiv.style.width = '100%';
            listDiv.style.background = '#fff';
            
            for (const req of myRequests) {
                // å¤„ç†è”æœºç¾¤èŠé‚€è¯·
                if (req.isGroupInvite && req.groupData) {
                    const groupInvite = req.groupData;
                    const item = document.createElement('div');
                    item.style.display = 'flex';
                    item.style.padding = '12px 16px';
                    item.style.borderBottom = '0.5px solid #f0f0f0';
                    item.style.alignItems = 'center';
                    item.style.gap = '12px';
                    
                    let buttons = '';
                    let statusLabel = '';
                    
                    if (req.status === 'pending') {
                        buttons = `
                            <button onclick="acceptGroupInvite(${req.id})" style="background:var(--ins-pink); color:#fff; border:none; padding:6px 16px; border-radius:4px; font-size:14px; margin-right:8px;">åŒæ„</button>
                            <button onclick="rejectGroupInvite(${req.id})" style="background:#f0f0f0; color:#666; border:none; padding:6px 16px; border-radius:4px; font-size:14px;">æ‹’ç»</button>
                        `;
                    } else if (req.status === 'accepted') {
                        statusLabel = '<div style="color:#999; font-size:12px;">å·²åŠ å…¥</div>';
                    } else {
                        statusLabel = '<div style="color:#999; font-size:12px;">å·²æ‹’ç»</div>';
                    }
                    
                    item.innerHTML = `
                        <div style="width:48px; height:48px; border-radius:4px; background:linear-gradient(135deg, #f093fb 0%, #f5576c 100%); display:flex; align-items:center; justify-content:center; flex-shrink:0; position:relative;">
                            <svg style="width:24px; height:24px; stroke:#fff; fill:none;" viewBox="0 0 24 24"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>
                            <div style="position:absolute; bottom:-2px; right:-2px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius:50%; width:16px; height:16px; display:flex; align-items:center; justify-content:center;">
                                <svg style="width:10px; height:10px; stroke:#fff; fill:none;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle></svg>
                            </div>
                        </div>
                        <div style="flex:1; min-width:0;">
                            <div style="font-size:16px; font-weight:500; color:#333; margin-bottom:4px;">
                                ç¾¤èŠé‚€è¯·
                                <span style="font-size:11px; color:#f5576c; margin-left:6px;">è”æœºç¾¤èŠ</span>
                            </div>
                            <div style="font-size:12px; color:#666; line-height:1.5;">${groupInvite.inviter_name} é‚€è¯·ä½ åŠ å…¥ã€Œ${groupInvite.group_name}ã€</div>
                        </div>
                        <div style="display:flex; align-items:center; flex-shrink:0;">
                            ${buttons}${statusLabel}
                        </div>
                    `;
                    listDiv.appendChild(item);
                    continue;
                }
                
                // å¤„ç†è”æœºå¥½å‹ç”³è¯·
                if (req.isOnline && req.onlineData) {
                    const onlineReq = req.onlineData;
                    const item = document.createElement('div');
                    item.style.display = 'flex';
                    item.style.padding = '12px 16px';
                    item.style.borderBottom = '0.5px solid #f0f0f0';
                    item.style.alignItems = 'center';
                    item.style.gap = '12px';
                    
                    const avatarStyle = onlineReq.from_avatar ? `background-image:url(${onlineReq.from_avatar})` : 'background-color:#eee';
                    
                    let buttons = '';
                    let statusLabel = '';
                    
                    if (req.status === 'pending') {
                        buttons = `
                            <button onclick="acceptFriendRequest(${req.id})" style="background:var(--ins-pink); color:#fff; border:none; padding:6px 16px; border-radius:4px; font-size:14px; margin-right:8px;">æ¥å—</button>
                            <button onclick="rejectFriendRequest(${req.id})" style="background:#f0f0f0; color:#666; border:none; padding:6px 16px; border-radius:4px; font-size:14px;">æ‹’ç»</button>
                        `;
                    } else if (req.status === 'accepted') {
                        statusLabel = '<div style="color:#999; font-size:12px;">å·²æ·»åŠ </div>';
                    } else {
                        statusLabel = '<div style="color:#999; font-size:12px;">å·²æ‹’ç»</div>';
                    }
                    
                    item.innerHTML = `
                        <div style="width:48px; height:48px; border-radius:4px; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; position:relative;">
                            <div style="position:absolute; bottom:-2px; right:-2px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius:50%; width:16px; height:16px; display:flex; align-items:center; justify-content:center;">
                                <svg style="width:10px; height:10px; stroke:#fff; fill:none;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle></svg>
                            </div>
                        </div>
                        <div style="flex:1; min-width:0;">
                            <div style="font-size:16px; font-weight:500; color:#333; margin-bottom:4px;">
                                ${onlineReq.from_nickname || onlineReq.from_wx_account}
                                <span style="font-size:11px; color:#667eea; margin-left:6px;">è”æœº</span>
                            </div>
                            <div style="font-size:12px; color:#666; line-height:1.5; white-space:pre-line; word-break:break-word;">${onlineReq.message || 'è¯·æ±‚æ·»åŠ ä½ ä¸ºå¥½å‹'}</div>
                        </div>
                        <div style="display:flex; align-items:center; flex-shrink:0;">
                            ${buttons}${statusLabel}
                        </div>
                    `;
                    listDiv.appendChild(item);
                    continue;
                }
                
                // å¤„ç†æœ¬åœ°å¥½å‹ç”³è¯·ï¼ˆå…¼å®¹ toCharId å’Œ toAccountIdï¼‰
                const isReceived = (req.toCharId === parseInt(accountId)) || (req.toAccountId === accountId);
                const relatedCharId = isReceived ? req.fromCharId : (req.toCharId || parseInt(req.toAccountId));
                const relatedChar = await db.characters.get(relatedCharId);
                if (!relatedChar) continue;
                
                const item = document.createElement('div');
                item.style.display = 'flex';
                item.style.padding = '12px 16px';
                item.style.borderBottom = '0.5px solid #f0f0f0';
                item.style.alignItems = 'center';
                item.style.gap = '12px';
                
                const avatarStyle = relatedChar.avatar ? `background-image:url(${relatedChar.avatar})` : 'background-color:#eee';
                
                let buttons = '';
                let statusLabel = '';
                
                if (isReceived) {
                    // æ”¶åˆ°çš„ç”³è¯·
                    if (req.status === 'pending') {
                        buttons = `
                            <button onclick="acceptFriendRequest(${req.id})" style="background:var(--ins-pink); color:#fff; border:none; padding:6px 16px; border-radius:4px; font-size:14px; margin-right:8px;">æ¥å—</button>
                            <button onclick="rejectFriendRequest(${req.id})" style="background:#f0f0f0; color:#666; border:none; padding:6px 16px; border-radius:4px; font-size:14px;">æ‹’ç»</button>
                        `;
                    } else if (req.status === 'accepted') {
                        statusLabel = '<div style="color:#999; font-size:12px;">å·²æ·»åŠ </div>';
                    } else {
                        statusLabel = '<div style="color:#999; font-size:12px;">å·²æ‹’ç»</div>';
                    }
                } else {
                    // å‘é€çš„ç”³è¯·
                    if (req.status === 'pending') {
                        statusLabel = '<div style="color:#999; font-size:12px;">ç­‰å¾…éªŒè¯</div>';
                    } else if (req.status === 'accepted') {
                        statusLabel = '<div style="color:#07c160; font-size:12px;">å·²æ¥å—</div>';
                    } else {
                        statusLabel = '<div style="color:#999; font-size:12px;">å·²æ‹’ç»</div>';
                    }
                }
                
                // è§£æå°å·æ˜µç§°ï¼ˆå¦‚æœmessageæ ¼å¼ä¸º"[å°å·:æ˜µç§°] åŸæ¶ˆæ¯"ï¼‰
                let displayName = relatedChar.nick || relatedChar.name;
                let messageText = isReceived ? (req.message || 'è¯·æ±‚æ·»åŠ ä½ ä¸ºå¥½å‹') : `ä½ å·²å‘é€å¥½å‹ç”³è¯·`;
                let isAltAccount = false;
                
                if (req.message && req.message.startsWith('[å°å·:')) {
                    // æå–å°å·æ˜µç§°å’ŒåŸæ¶ˆæ¯
                    const match = req.message.match(/^\[å°å·:([^\]]+)\]\s*(.*)$/);
                    if (match) {
                        displayName = match[1]; // å°å·æ˜µç§°
                        messageText = match[2] || 'è¯·æ±‚æ·»åŠ ä½ ä¸ºå¥½å‹'; // åŸæ¶ˆæ¯
                        isAltAccount = true;
                    }
                }
                
                item.innerHTML = `
                    <div style="width:48px; height:48px; border-radius:4px; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0;"></div>
                    <div style="flex:1; min-width:0;">
                        <div style="font-size:16px; font-weight:500; color:#333; margin-bottom:4px;">
                            ${displayName}
                            ${isAltAccount ? '<span style="font-size:11px; color:#999; background:#f0f0f0; padding:2px 6px; border-radius:4px; margin-left:6px;">å°å·</span>' : ''}
                        </div>
                        <div style="font-size:12px; color:#666; line-height:1.5; white-space:pre-line; word-break:break-word;">${messageText}</div>
                    </div>
                    <div style="display:flex; align-items:center; flex-shrink:0;">
                        ${buttons}${statusLabel}
                    </div>
                `;
                listDiv.appendChild(item);
            }
            
            container.appendChild(listDiv);
        }

        async function acceptFriendRequest(requestId) {
            // ğŸ”§ é˜²æ­¢é‡å¤ç‚¹å‡»
            if (window._acceptingFriendRequest) {
                console.log('[AcceptFriend] æ­£åœ¨å¤„ç†ä¸­ï¼Œè¯·å‹¿é‡å¤ç‚¹å‡»');
                return;
            }
            window._acceptingFriendRequest = true;
            
            try {
                const request = await db.friend_requests.get(requestId);
                if (!request) {
                    window._acceptingFriendRequest = false;
                    return;
                }
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯è”æœºå¥½å‹ç”³è¯·
            if (request.isOnline && request.onlineData) {
                // è”æœºå¥½å‹ç”³è¯· - å‘é€åˆ°æœåŠ¡å™¨
                if (!onlineConnected || !onlineUserData) {
                    alert('è¯·å…ˆè¿æ¥æœåŠ¡å™¨å¹¶ç™»å½•');
                    window._acceptingFriendRequest = false;
                    return;
                }
                
                const onlineReq = request.onlineData;
                // æ‰¾åˆ°è¦æ¥å—ç”³è¯·çš„è§’è‰²ï¼ˆè¢«ç”³è¯·æ–¹ï¼‰
                const myChars = await db.characters.where('type').equals('user').toArray();
                const myChar = myChars.find(c => c.identity?.account === onlineReq.to_wx_account) ||
                               myChars.find(c => onlineCharacters.some(oc => oc.wx_account === c.identity?.account));
                
                if (!myChar || !myChar.identity?.account) {
                    alert('è¯·å…ˆåˆ›å»ºUserè§’è‰²å¹¶è®¾ç½®å¾®ä¿¡å·');
                    window._acceptingFriendRequest = false;
                    return;
                }
                
                onlineSocket.send(JSON.stringify({
                    type: 'accept_friend_request',
                    request_id: onlineReq.id,
                    my_wx_account: myChar.identity.account
                }));
                
                // æ›´æ–°æœ¬åœ°çŠ¶æ€
                request.status = 'accepted';
                await db.friend_requests.put(request);
                
                await renderNewFriendsPage();
                window._acceptingFriendRequest = false;
                return;
            }
            
            // æœ¬åœ°å¥½å‹ç”³è¯·
            const char = await db.characters.get(request.fromCharId);
            if (!char) return;
            
            const accountId = getCurrentAccountId();
            const myChar = accountId ? await db.characters.get(parseInt(accountId)) : null;
            const myName = myChar?.name || 'ç”¨æˆ·';
            
            // æ›´æ–°å¥½å‹çŠ¶æ€
            await setFriendStatus(char, accountId, 'friend');
            
            // æ›´æ–°ç”³è¯·çŠ¶æ€
            request.status = 'accepted';
            await db.friend_requests.put(request);
            
            // ğŸ”§ æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ°èŠå¤©å†å²ï¼Œè®°å½•æ¢å¤å¥½å‹å…³ç³»
            let history = getChatHistory(char, accountId);
            
            // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯ï¼Œè¯´æ˜ç°åœ¨å·²ç»æ˜¯å¥½å‹äº†
            const systemMessage = {
                role: 'system',
                content: `[${myName} é€šè¿‡äº†ä½ çš„æœ‹å‹éªŒè¯è¯·æ±‚ï¼Œç°åœ¨ä½ ä»¬å¯ä»¥å¼€å§‹èŠå¤©äº†]`,
                time: Date.now(),
                type: 'accept_friend_request'
            };
            history.push(systemMessage);
            
            // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
            const acceptMessage = {
                role: 'user',
                content: 'æˆ‘å·²åŒæ„äº†ä½ çš„å¥½å‹ç”³è¯·',
                time: Date.now() + 1
            };
            history.push(acceptMessage);
            
            await setChatHistory(char, accountId, history);
            console.log(`[AcceptFriend] å·²åœ¨èŠå¤©å†å²ä¸­è®°å½•æ¢å¤å¥½å‹å…³ç³»`);
            
            // ğŸ”§ åœæ­¢è‡ªåŠ¨å¿«è¿›æ£€æŸ¥åŠŸèƒ½ï¼ˆå·²ç»æˆä¸ºå¥½å‹äº†ï¼Œä¸éœ€è¦å†æ£€æŸ¥ï¼‰
            if (char.wait_friend_settings && char.wait_friend_settings[accountId]) {
                char.wait_friend_settings[accountId].enabled = false;
                char.wait_friend_settings[accountId].nextCheckTime = null;
                await safeCharacterPut(char);
                console.log(`[AcceptFriend] å·²åœæ­¢ ${char.name} çš„è‡ªåŠ¨å¿«è¿›æ£€æŸ¥`);
            }
            
            // åˆ·æ–°é¡µé¢
            await renderNewFriendsPage();
            
            // å¦‚æœå½“å‰åœ¨é€šè®¯å½•é¡µé¢ï¼Œä¹Ÿåˆ·æ–°é€šè®¯å½•
            const activeTab = document.querySelector('.wechat-tab-item.active');
            if (activeTab && activeTab.innerText.includes('é€šè®¯å½•')) {
                await renderContactList(document.getElementById('wechat-content'));
            }
            
            // å¦‚æœå½“å‰æ­£åœ¨å’Œè¿™ä¸ªè§’è‰²èŠå¤©ï¼Œåˆ·æ–°èŠå¤©çª—å£
            if (currentChatCharId === char.id) {
                await renderChatBody(char);
            }
            
            alert(`å·²æ·»åŠ  ${char.name} ä¸ºå¥½å‹`);
            } catch (error) {
                console.error('[AcceptFriend] æ¥å—å¥½å‹ç”³è¯·æ—¶å‡ºé”™:', error);
                alert('æ¥å—å¥½å‹ç”³è¯·å¤±è´¥ï¼š' + (error.message || 'æœªçŸ¥é”™è¯¯'));
            } finally {
                // ğŸ”§ æ— è®ºæˆåŠŸè¿˜æ˜¯å¤±è´¥ï¼Œéƒ½è¦é‡Šæ”¾é”
                window._acceptingFriendRequest = false;
            }
        }

        async function rejectFriendRequest(requestId) {
            const request = await db.friend_requests.get(requestId);
            if (!request) return;
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯è”æœºå¥½å‹ç”³è¯·
            if (request.isOnline && request.onlineData) {
                // è”æœºå¥½å‹ç”³è¯· - å‘é€åˆ°æœåŠ¡å™¨
                if (onlineConnected && onlineUserData) {
                    const onlineReq = request.onlineData;
                    const myChars = await db.characters.where('type').equals('user').toArray();
                    const myChar = myChars.find(c => c.identity?.account === onlineReq.to_wx_account) ||
                                   myChars.find(c => onlineCharacters.some(oc => oc.wx_account === c.identity?.account));
                    
                    if (myChar?.identity?.account) {
                        onlineSocket.send(JSON.stringify({
                            type: 'reject_friend_request',
                            request_id: onlineReq.id,
                            my_wx_account: myChar.identity.account
                        }));
                    }
                }
            }
            
            // æ›´æ–°ç”³è¯·çŠ¶æ€
            request.status = 'rejected';
            await db.friend_requests.put(request);
            
            // åˆ·æ–°é¡µé¢
            await renderNewFriendsPage();
        }

        // æ¥å—ç¾¤èŠé‚€è¯· - å¼¹å‡ºé€‰æ‹©è§’è‰²çš„å¼¹çª—
        async function acceptGroupInvite(requestId) {
            const request = await db.friend_requests.get(requestId);
            if (!request || !request.isGroupInvite || !request.groupData) return;
            
            if (!onlineConnected || !onlineUserData) {
                alert('è¯·å…ˆè¿æ¥æœåŠ¡å™¨å¹¶ç™»å½•');
                return;
            }
            
            const myWx = getMyOnlineWxAccount();
            if (!myWx) {
                alert('è¯·å…ˆåˆ›å»ºUserè§’è‰²å¹¶è®¾ç½®å¾®ä¿¡å·');
                return;
            }
            
            // æ˜¾ç¤ºé€‰æ‹©è§’è‰²çš„å¼¹çª—
            showJoinGroupWithCharModal(requestId, request.groupData);
        }

        // æ˜¾ç¤ºåŠ å…¥ç¾¤èŠå¹¶é€‰æ‹©è§’è‰²çš„å¼¹çª—
        async function showJoinGroupWithCharModal(requestId, groupData) {
            // è·å–æ‰€æœ‰å¯ç”¨çš„è§’è‰²ï¼ˆéUserç±»å‹å’Œéè”æœºå¥½å‹ï¼‰
            const chars = await db.characters.toArray();
            const availableChars = chars.filter(c => c.type !== 'user' && c.type !== 'online_friend');
            
            const modal = document.createElement('div');
            modal.id = 'join-group-char-modal';
            modal.style.cssText = `position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:10000; display:flex; align-items:center; justify-content:center;`;
            
            modal.innerHTML = `
                <div style="background:#fff; border-radius:16px; padding:24px; width:85%; max-width:360px;">
                    <h3 style="margin:0 0 16px 0; text-align:center; font-size:18px;">åŠ å…¥ã€Œ${groupData.group_name}ã€</h3>
                    
                    <div style="margin-bottom:16px;">
                        <div style="font-size:13px; color:#666; margin-bottom:8px;">é€‰æ‹©è¦å¸¦å…¥ç¾¤èŠçš„è§’è‰²ï¼š</div>
                        <select id="join-group-char-select-modal" style="width:100%; padding:12px; border:1px solid #ddd; border-radius:8px; font-size:14px;">
                            <option value="">ä¸å¸¦è§’è‰²</option>
                            ${availableChars.map(c => `<option value="${c.id}">${c.name}</option>`).join('')}
                        </select>
                    </div>
                    
                    <div style="font-size:12px; color:#999; margin-bottom:20px; line-height:1.5;">
                        å¸¦å…¥è§’è‰²åï¼Œä½ å¯ä»¥åœ¨ç¾¤èŠä¸­è®©è¯¥è§’è‰²å‘è¨€ï¼ˆè°ƒç”¨AIï¼‰
                    </div>
                    
                    <div style="display:flex; gap:12px;">
                        <button onclick="this.closest('#join-group-char-modal').remove()" style="flex:1; padding:12px; background:#f0f0f0; color:#666; border:none; border-radius:8px; font-size:15px; cursor:pointer;">å–æ¶ˆ</button>
                        <button onclick="doAcceptGroupInvite(${requestId}, '${groupData.group_id}')" style="flex:1; padding:12px; background:var(--ins-pink); color:#fff; border:none; border-radius:8px; font-size:15px; cursor:pointer;">åŠ å…¥ç¾¤èŠ</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        // æ‰§è¡Œæ¥å—ç¾¤èŠé‚€è¯·
        async function doAcceptGroupInvite(requestId, groupId) {
            const charSelect = document.getElementById('join-group-char-select-modal');
            const charId = charSelect?.value;
            
            let myChar = null;
            if (charId) {
                const char = await db.characters.get(parseInt(charId));
                if (char) {
                    myChar = {
                        name: char.name,
                        avatar: char.avatar || '',
                        desc: char.description?.substring(0, 200) || ''
                    };
                }
            }
            
            const myWx = getMyOnlineWxAccount();
            if (!myWx) {
                alert('è¯·å…ˆåˆ›å»ºUserè§’è‰²å¹¶è®¾ç½®å¾®ä¿¡å·');
                return;
            }
            
            // å‘é€åŠ å…¥ç¾¤èŠè¯·æ±‚
            onlineSocket.send(JSON.stringify({
                type: 'join_online_group',
                group_id: groupId,
                my_wx_account: myWx,
                my_character: myChar
            }));
            
            // æ›´æ–°æœ¬åœ°çŠ¶æ€
            const request = await db.friend_requests.get(requestId);
            if (request) {
                request.status = 'accepted';
                await db.friend_requests.put(request);
            }
            
            // å…³é—­å¼¹çª—å¹¶åˆ·æ–°é¡µé¢
            document.getElementById('join-group-char-modal')?.remove();
            await renderNewFriendsPage();
        }

        // æ‹’ç»ç¾¤èŠé‚€è¯·
        async function rejectGroupInvite(requestId) {
            const request = await db.friend_requests.get(requestId);
            if (!request || !request.isGroupInvite) return;
            
            // æ›´æ–°çŠ¶æ€
            request.status = 'rejected';
            await db.friend_requests.put(request);
            
            // åˆ·æ–°é¡µé¢
            await renderNewFriendsPage();
        }

        async function deleteFriendConfirm() {
            if (!currentChatCharId) return;
            
            const char = await db.characters.get(currentChatCharId);
            if (!char) return;
            
            if (confirm(`ç¡®å®šè¦åˆ é™¤å¥½å‹ ${char.name} å—ï¼Ÿåˆ é™¤åå°†æ— æ³•ç›´æ¥å‘é€æ¶ˆæ¯ï¼Œéœ€è¦é‡æ–°å‘é€å¥½å‹ç”³è¯·ã€‚`)) {
                await deleteFriendAction(currentChatCharId);
            }
        }

        async function blockFriendConfirm() {
            if (!currentChatCharId) return;
            
            const char = await db.characters.get(currentChatCharId);
            if (!char) return;
            
            if (confirm(`ç¡®å®šè¦æ‹‰é»‘å¥½å‹ ${char.name} å—ï¼Ÿæ‹‰é»‘åå¯¹æ–¹å°†æ— æ³•å‘é€å¥½å‹ç”³è¯·ï¼Œä½†åœ¨å¿«è¿›æ—¶é—´æ—¶å¯èƒ½ä¼šå°è¯•è”ç³»ä½ ã€‚`)) {
                await blockFriendAction(currentChatCharId);
            }
        }

        async function blockFriendAction(charId) {
            const char = await db.characters.get(charId);
            if (!char) return;
            
            const accountId = getCurrentAccountId();
            
            // å°†å¥½å‹çŠ¶æ€æ”¹ä¸ºæ‹‰é»‘
            await setFriendStatus(char, accountId, 'blocked');
            
            // åˆå§‹åŒ–ç­‰å¾…å¥½å‹ç”³è¯·çš„è®¾ç½®ï¼ˆä¸åˆ é™¤å¥½å‹é€»è¾‘ç›¸åŒï¼‰
            if (!char.wait_friend_settings) {
                char.wait_friend_settings = {};
            }
            if (!char.wait_friend_settings[accountId]) {
                char.wait_friend_settings[accountId] = {
                    enabled: false,
                    interval: 60, // é»˜è®¤60åˆ†é’Ÿ
                    lastCheckTime: Date.now(),
                    nextCheckTime: null
                };
            }
            await safeCharacterPut(char);
            
            // å…³é—­èŠå¤©è¯¦æƒ…é¡µä½†ä¿æŒèŠå¤©çª—å£æ‰“å¼€ï¼Œæ˜¾ç¤ºç­‰å¾…ç•Œé¢
            hideChatDetail();
            
            // åˆ·æ–°èŠå¤©çª—å£æ˜¾ç¤ºç­‰å¾…ç•Œé¢ï¼ˆforceRender=true ç»•è¿‡ä¼˜åŒ–ï¼‰
            if (currentChatCharId === charId) {
                await renderChatBody(char, true);
            }
            
            // åˆ·æ–°å¾®ä¿¡é¡µé¢
            const activeTab = document.querySelector('.wechat-tab-item.active');
            if (activeTab) {
                const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                switchWechatTab(tabIndex);
            }
            
            alert(`å·²æ‹‰é»‘å¥½å‹ ${char.name}ï¼ŒèŠå¤©è®°å½•å·²ä¿ç•™`);
        }

        async function deleteFriendAction(charId) {
            const char = await db.characters.get(charId);
            if (!char) return;
            
            const accountId = getCurrentAccountId();
            const myChar = accountId ? await db.characters.get(parseInt(accountId)) : null;
            const userName = myChar ? myChar.name : 'ç”¨æˆ·';
            
            // ğŸ”§ æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ°èŠå¤©å†å²ï¼Œè®°å½•åˆ é™¤äº‹ä»¶
            let history = getChatHistory(char, accountId);
            history.push({
                role: 'system',
                content: `[${userName} å°†ä½ åˆ é™¤å¥½å‹]`,
                time: Date.now(),
                type: 'user_delete_friend'
            });
            await setChatHistory(char, accountId, history);
            console.log(`[DeleteFriend] å·²åœ¨èŠå¤©å†å²ä¸­è®°å½•åˆ é™¤äº‹ä»¶`);
            
            // å°†å¥½å‹çŠ¶æ€æ”¹ä¸ºé™Œç”Ÿäººï¼ˆä¸åˆ é™¤èŠå¤©è®°å½•ï¼‰
            await setFriendStatus(char, accountId, 'deleted');
            
            // åˆå§‹åŒ–ç­‰å¾…å¥½å‹ç”³è¯·çš„è®¾ç½®
            if (!char.wait_friend_settings) {
                char.wait_friend_settings = {};
            }
            if (!char.wait_friend_settings[accountId]) {
                char.wait_friend_settings[accountId] = {
                    enabled: false,
                    interval: 60, // é»˜è®¤60åˆ†é’Ÿ
                    lastCheckTime: Date.now(),
                    nextCheckTime: null
                };
            }
            await safeCharacterPut(char);
            
            // å…³é—­èŠå¤©è¯¦æƒ…é¡µä½†ä¿æŒèŠå¤©çª—å£æ‰“å¼€ï¼Œæ˜¾ç¤ºç­‰å¾…ç•Œé¢
            hideChatDetail();
            
            // åˆ·æ–°èŠå¤©çª—å£æ˜¾ç¤ºç­‰å¾…ç•Œé¢ï¼ˆforceRender=true ç»•è¿‡ä¼˜åŒ–ï¼‰
            if (currentChatCharId === charId) {
                await renderChatBody(char, true);
            }
            
            // åˆ·æ–°å¾®ä¿¡é¡µé¢
            const activeTab = document.querySelector('.wechat-tab-item.active');
            if (activeTab) {
                const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                switchWechatTab(tabIndex);
            }
            
            alert(`å·²åˆ é™¤å¥½å‹ ${char.name}ï¼ŒèŠå¤©è®°å½•å·²ä¿ç•™`);
        }

        async function sendFriendRequestTo(charId, message) {
            console.log('[FriendRequest] sendFriendRequestTo å¼€å§‹, charId:', charId);
            const accountId = getCurrentAccountId();
            if (!accountId) {
                console.error('[FriendRequest] æ²¡æœ‰å½“å‰è´¦å·ID');
                alert('è¯·å…ˆåˆ‡æ¢åˆ°ä½ çš„è´¦å·ï¼ˆUserç±»å‹è§’è‰²ï¼‰');
                return;
            }
            console.log('[FriendRequest] accountId:', accountId);
            
            const targetChar = await db.characters.get(charId);
            if (!targetChar) {
                console.error('[FriendRequest] æ‰¾ä¸åˆ°ç›®æ ‡è§’è‰², charId:', charId);
                return;
            }
            console.log('[FriendRequest] ç›®æ ‡è§’è‰²:', targetChar.name, 'ç±»å‹:', targetChar.type);
            
            // æ£€æŸ¥è§’è‰²æ˜¯å¦è¢«ç”¨æˆ·æ‹‰é»‘
            const status = getFriendStatus(targetChar, accountId);
            console.log('[FriendRequest] å¥½å‹çŠ¶æ€:', status);
            if (status === 'blocked') {
                alert('è¯¥è§’è‰²å·²è¢«ä½ æ‹‰é»‘ï¼Œæ— æ³•å‘é€å¥½å‹ç”³è¯·');
                return;
            }
            if (status === 'blocked_by_char') {
                alert('ä½ å·²è¢«è¯¥è§’è‰²æ‹‰é»‘ï¼Œæ— æ³•å‘é€å¥½å‹ç”³è¯·ã€‚ä½ å¯ä»¥å°è¯•é€šè¿‡çŸ­ä¿¡è”ç³» Taã€‚');
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦å·²ç»å‘é€è¿‡ç”³è¯·ï¼ˆä½¿ç”¨toArray+filteré¿å…ç´¢å¼•å­—æ®µä¸åŒ¹é…é—®é¢˜ï¼‰
            // ğŸ”¥ æ¸…ç†ä¹‹å‰æ®‹ç•™çš„ pending ç”³è¯·ï¼ˆå¦‚æœä¹‹å‰AIè°ƒç”¨å¤±è´¥å¯èƒ½ç•™ä¸‹æ®‹ç•™è®°å½•ï¼‰
            const allPendingRequests = await db.friend_requests
                .where('status').equals('pending')
                .toArray();
            const existingRequest = allPendingRequests.find(req => 
                req.fromCharId === parseInt(accountId) && 
                (req.toCharId === charId || req.toAccountId === String(charId))
            );
            
            if (existingRequest) {
                console.log('[FriendRequest] å‘ç°å·²æœ‰å¾…å¤„ç†çš„ç”³è¯·, id:', existingRequest.id, 'å°†è‡ªåŠ¨æ¸…ç†å¹¶é‡æ–°å‘é€');
                // è‡ªåŠ¨æ¸…ç†æ—§çš„å¾…å¤„ç†ç”³è¯·ï¼Œå…è®¸é‡æ–°å‘é€
                await db.friend_requests.delete(existingRequest.id);
            }
            
            // åˆ›å»ºå¥½å‹ç”³è¯·è®°å½•ï¼ˆåŒæ—¶ä¿å­˜ toCharId å’Œ toAccountId ç¡®ä¿å…¼å®¹æ€§ï¼‰
            console.log('[FriendRequest] åˆ›å»ºå¥½å‹ç”³è¯·è®°å½•...');
            const requestId = await db.friend_requests.add({
                fromCharId: parseInt(accountId),
                toCharId: charId,
                toAccountId: String(charId),
                message: message || 'è¯·æ±‚æ·»åŠ ä½ ä¸ºå¥½å‹',
                status: 'pending',
                time: Date.now()
            });
            console.log('[FriendRequest] å¥½å‹ç”³è¯·å·²åˆ›å»º, requestId:', requestId);
            
            // ğŸ”¥ è‡ªåŠ¨è°ƒç”¨AIåˆ¤æ–­æ˜¯å¦æ¥å—å¥½å‹ç”³è¯·ï¼ˆéuserç±»å‹è§’è‰²ï¼‰
            if (targetChar.type !== 'user') {
                console.log('[FriendRequest] è§’è‰²éuserç±»å‹ï¼Œå¼€å§‹è°ƒç”¨AIåˆ¤æ–­...');
                // æ£€æŸ¥APIå¯†é’¥ï¼ˆä»æ•°æ®åº“è·å–ï¼Œå’Œæ­£å¸¸èŠå¤©ä¸€æ ·ï¼‰
                const apiKeyData = await db.dexiData.get('aiApiKey');
                const apiKey = apiKeyData?.value ? apiKeyData.value.trim() : '';
                
                if (!apiKey) {
                    console.error('[FriendRequest] âŒ æœªé…ç½®AIå¯†é’¥');
                    alert(`å¥½å‹ç”³è¯·å·²å‘é€ç»™ ${targetChar.name}\n\nâš ï¸ æœªé…ç½®AIå¯†é’¥ï¼Œæ— æ³•è‡ªåŠ¨åˆ¤æ–­ã€‚è¯·å‰å¾€"æ–°çš„å¥½å‹"ä¸­æ‰‹åŠ¨æ¥å—ã€‚`);
                    return;
                }
                console.log('[FriendRequest] APIå¯†é’¥å·²é…ç½®, é•¿åº¦:', apiKey.length);
                
                // ç›´æ¥è°ƒç”¨AIåˆ¤æ–­ï¼Œä¸éœ€è¦é¢å¤–ç¡®è®¤
                const loadingDiv = document.createElement('div');
                loadingDiv.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.7); display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:9999;';
                loadingDiv.innerHTML = `
                    <div style="background:#fff; padding:30px 40px; border-radius:16px; text-align:center; box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                        <div style="width:50px; height:50px; border:4px solid #f3f3f3; border-top:4px solid var(--ins-pink); border-radius:50%; margin:0 auto 20px; animation:spin 1s linear infinite;"></div>
                        <div style="font-size:18px; font-weight:600; color:#333; margin-bottom:8px;">å¥½å‹ç”³è¯·å·²å‘é€</div>
                        <div style="font-size:14px; color:#999;">${targetChar.name} æ­£åœ¨è€ƒè™‘æ˜¯å¦æ¥å—...</div>
                    </div>
                `;
                document.body.appendChild(loadingDiv);
                
                try {
                    // è°ƒç”¨AIåˆ¤æ–­æ˜¯å¦æ¥å—å¥½å‹ç”³è¯·ï¼ˆåŒæ—¶è¿”å›å›å¤æ¶ˆæ¯ï¼‰
                    console.log('[FriendRequest] ğŸš€ å¼€å§‹è°ƒç”¨AIåˆ¤æ–­æ˜¯å¦æ¥å—...');
                    const result = await aiDecideAcceptFriendRequest(targetChar, accountId, message);
                    console.log('[FriendRequest] AIè¿”å›ç»“æœ:', JSON.stringify(result));
                    
                    if (document.body.contains(loadingDiv)) {
                        document.body.removeChild(loadingDiv);
                    }
                    
                    if (result.accepted) {
                        console.log('[FriendRequest] âœ… AIå†³å®šæ¥å—ï¼Œå¼€å§‹å¤„ç†...');
                        // AIå†³å®šæ¥å—
                        const request = await db.friend_requests.get(requestId);
                        if (request) {
                            request.status = 'accepted';
                            await db.friend_requests.put(request);
                        }
                        
                        // æ·»åŠ ä¸ºå¥½å‹
                        await setFriendStatus(targetChar, accountId, 'friend');
                        console.log('[FriendRequest] å¥½å‹çŠ¶æ€å·²æ›´æ–°ä¸º friend');
                        
                        // ğŸ”¥ å°†AIç”Ÿæˆçš„å›å¤æ¶ˆæ¯æ·»åŠ åˆ°èŠå¤©è®°å½•
                        if (result.messages && result.messages.length > 0) {
                            console.log('[FriendRequest] å†™å…¥', result.messages.length, 'æ¡å›å¤æ¶ˆæ¯åˆ°èŠå¤©è®°å½•');
                            let chatHistory = getChatHistory(targetChar, accountId);
                            for (let i = 0; i < result.messages.length; i++) {
                                chatHistory.push(buildCharMessage(result.messages[i], !!targetChar.foreign_lang_mode, { time: Date.now() + i * 100 }));
                            }
                            await setChatHistory(targetChar, accountId, chatHistory);
                        }
                        
                        // ğŸ”§ åœæ­¢è‡ªåŠ¨å¿«è¿›æ£€æŸ¥åŠŸèƒ½ï¼ˆè§’è‰²å·²ç»æ¥å—äº†ç”¨æˆ·çš„å¥½å‹ç”³è¯·ï¼‰
                        if (targetChar.wait_friend_settings && targetChar.wait_friend_settings[accountId]) {
                            targetChar.wait_friend_settings[accountId].enabled = false;
                            targetChar.wait_friend_settings[accountId].nextCheckTime = null;
                            await safeCharacterPut(targetChar);
                            console.log(`[AIAcceptFriend] å·²åœæ­¢ ${targetChar.name} çš„è‡ªåŠ¨å¿«è¿›æ£€æŸ¥`);
                        }
                        
                        alert(`âœ… ${targetChar.name} æ¥å—äº†ä½ çš„å¥½å‹ç”³è¯·ï¼`);
                        
                        // åˆ·æ–°ç•Œé¢
                        if (currentChatCharId === targetChar.id) {
                            const refreshedChar = await db.characters.get(targetChar.id);
                            if (refreshedChar) await renderChatBody(refreshedChar);
                        }
                        const activeTab = document.querySelector('.wechat-tab-item.active');
                        if (activeTab) {
                            const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                            switchWechatTab(tabIndex);
                        }
                    } else {
                        console.log('[FriendRequest] âŒ AIå†³å®šæ‹’ç»');
                        // AIå†³å®šæ‹’ç»
                        alert(`âŒ ${targetChar.name} æ‹’ç»äº†ä½ çš„å¥½å‹ç”³è¯·ã€‚`);
                    }
                } catch (error) {
                    if (document.body.contains(loadingDiv)) {
                        document.body.removeChild(loadingDiv);
                    }
                    console.error('[FriendRequest] AIåˆ¤æ–­å¤±è´¥:', error);
                    alert('AIåˆ¤æ–­å¤±è´¥ï¼š' + error.message + '\n\nå¥½å‹ç”³è¯·å·²å‘é€ï¼Œè¯·å‰å¾€"æ–°çš„å¥½å‹"ä¸­æŸ¥çœ‹ã€‚');
                }
            } else {
                alert(`å¥½å‹ç”³è¯·å·²å‘é€ç»™ ${targetChar.name}`);
            }
        }
        
        // AIåˆ¤æ–­æ˜¯å¦æ¥å—å¥½å‹ç”³è¯·å¹¶ç”Ÿæˆå›å¤æ¶ˆæ¯ï¼ˆä½¿ç”¨ç»Ÿä¸€çš„callAIå‡½æ•°ï¼‰
        // è¿”å› { accepted: boolean, messages: string[] }
        async function aiDecideAcceptFriendRequest(char, accountId, requestMessage) {
            try {
                const myChar = await db.characters.get(parseInt(accountId));
                const myName = myChar?.name || 'ç”¨æˆ·';
                
                const minCount = char.reply_min_count || 1;
                const maxCount = char.reply_max_count || 3;
                
                // è·å–èŠå¤©å†å²
                const history = getChatHistory(char, accountId);
                const recentMessages = history.slice(-10).map(msg => {
                    const role = msg.role === 'user' ? myName : char.name;
                    return `${role}: ${msg.content}`;
                }).join('\n');
                
                const prompt = `ä½ æ˜¯ ${char.name}ã€‚
âš ï¸ é‡è¦ï¼šä½ çš„åå­—æ˜¯${char.name}ï¼Œä½ ä¸æ˜¯${myName}ï¼

ã€ä½ çš„äººè®¾ã€‘
${char.description || char.desc || 'ï¼ˆæ— è¯¦ç»†äººè®¾ï¼‰'}

ã€æƒ…å¢ƒã€‘
${myName} å‘ä½ å‘é€äº†å¥½å‹ç”³è¯·ï¼Œç”³è¯·æ¶ˆæ¯æ˜¯ï¼š"${requestMessage}"
${history.length > 0 ? `\nä½ ä»¬ä¹‹å‰çš„èŠå¤©è®°å½•ï¼š\n${recentMessages}` : 'ä½ ä»¬ä¹‹å‰æ²¡æœ‰èŠè¿‡å¤©ã€‚'}

ã€ä»»åŠ¡ã€‘
1. æ ¹æ®ä½ çš„æ€§æ ¼ã€ä¸ ${myName} çš„å…³ç³»ï¼Œåˆ¤æ–­ä½ æ˜¯å¦ä¼šæ¥å—è¿™ä¸ªå¥½å‹ç”³è¯·ã€‚
2. å¦‚æœæ¥å—ï¼Œè¯·ä»¥ä½ çš„èº«ä»½å†™å‡ºæ¥å—åä½ ä¼šå‘ç»™ ${myName} çš„æ¶ˆæ¯ã€‚

ã€è¾“å‡ºæ ¼å¼ã€‘
å¦‚æœæ‹’ç»ï¼Œåªå›å¤ï¼š[æ‹’ç»]
å¦‚æœæ¥å—ï¼Œå›å¤æ ¼å¼å¦‚ä¸‹ï¼š
[æ¥å—]
ä½ è¦å‘çš„æ¶ˆæ¯å†…å®¹

ã€æ¶ˆæ¯è¦æ±‚ã€‘
- ç”¨ã€Œ|||ã€åˆ†éš”å¤šæ¡æ¶ˆæ¯ï¼ˆ${minCount}-${maxCount}æ¡ï¼‰
- ä¸¥æ ¼è´´åˆä½ çš„äººè®¾å’Œè¯´è¯é£æ ¼
- å°‘ç”¨æ ‡ç‚¹ç¬¦å· ç”¨ç©ºæ ¼ä»£æ›¿é€—å·
- åƒçœŸäººå‘å¾®ä¿¡ä¸€æ ·è‡ªç„¶`;

                // ğŸ”¥ ä½¿ç”¨ç»Ÿä¸€çš„callAIå‡½æ•°
                const answer = await callAI([
                    { role: 'system', content: `ä½ æ˜¯${char.name}ï¼Œæ­£åœ¨è¿›è¡Œè§’è‰²æ‰®æ¼”ã€‚è¯·ä¸¥æ ¼æŒ‰ç…§æ ¼å¼è¾“å‡ºã€‚` },
                    { role: 'user', content: prompt }
                ]);
                
                const trimmedAnswer = (answer || '').trim();
                console.log('[AIå†³å®š] ' + char.name + ' çš„å›ç­”:', trimmedAnswer);
                
                const accepted = trimmedAnswer.includes('[æ¥å—]') || trimmedAnswer.includes('æ¥å—') || trimmedAnswer.includes('åŒæ„');
                const rejected = trimmedAnswer.includes('[æ‹’ç»]') || trimmedAnswer.startsWith('æ‹’ç»');
                
                if (rejected) {
                    return { accepted: false, messages: [] };
                }
                
                if (accepted) {
                    // æå–æ¶ˆæ¯éƒ¨åˆ†ï¼ˆå»æ‰ [æ¥å—] æ ‡è®°ï¼‰
                    let msgPart = trimmedAnswer
                        .replace(/\[æ¥å—\]/g, '')
                        .replace(/^æ¥å—[ï¼š:\s]*/i, '')
                        .trim();
                    
                    // æŒ‰ ||| åˆ†å‰²æˆå¤šæ¡æ¶ˆæ¯
                    let messages = [];
                    if (msgPart) {
                        messages = msgPart.split('|||')
                            .map(s => s.trim())
                            .filter(s => s.length > 0 && !s.startsWith('[') && !s.startsWith('ï¼ˆ'));
                    }
                    
                    // å¦‚æœæ²¡æœ‰è§£æå‡ºæ¶ˆæ¯ï¼Œç”Ÿæˆä¸€æ¡é»˜è®¤æ¶ˆæ¯
                    if (messages.length === 0) {
                        messages = ['å¥½çš„ é€šè¿‡äº†'];
                    }
                    
                    return { accepted: true, messages };
                }
                
                // å¦‚æœAIæ²¡æœ‰æ˜ç¡®æ ‡è®°ï¼Œå°è¯•æ™ºèƒ½åˆ¤æ–­
                // å¦‚æœå›å¤çœ‹èµ·æ¥åƒæ­£å¸¸æ¶ˆæ¯ï¼ˆæ²¡æœ‰æ‹’ç»æ„å‘³ï¼‰ï¼Œè§†ä¸ºæ¥å—
                if (!rejected && trimmedAnswer.length > 0) {
                    let messages = trimmedAnswer.split('|||')
                        .map(s => s.trim())
                        .filter(s => s.length > 0 && !s.startsWith('['));
                    if (messages.length > 0) {
                        return { accepted: true, messages };
                    }
                }
                
                return { accepted: false, messages: [] };
            } catch (error) {
                console.error('[AIå†³å®š] é”™è¯¯:', error);
                throw error;
            }
        }
        
        async function showAddFriendToCurrentChat() {
            if (!currentChatCharId) return;
            
            const char = await db.characters.get(currentChatCharId);
            if (!char) return;
            
            const message = prompt(`å‘é€å¥½å‹ç”³è¯·ç»™ ${char.name}\n\nè¯·è¾“å…¥ç”³è¯·ç†ç”±ï¼ˆå¯é€‰ï¼‰ï¼š`, 'æˆ‘æ˜¯' + (await getCurrentUserName()));
            if (message !== null) {
                await sendFriendRequestTo(currentChatCharId, message);
            }
        }
        
        // ===== ç­‰å¾…å¥½å‹ç”³è¯·ç›¸å…³åŠŸèƒ½ =====
        
        // å¼€å¯/å…³é—­è‡ªåŠ¨æ£€æµ‹
        async function toggleWaitFriendCheck(charId) {
            const char = await db.characters.get(charId);
            if (!char) return;
            
            const accountId = getCurrentAccountId();
            if (!char.wait_friend_settings) char.wait_friend_settings = {};
            if (!char.wait_friend_settings[accountId]) {
                char.wait_friend_settings[accountId] = {
                    enabled: false,
                    interval: 60,
                    lastCheckTime: Date.now(),
                    nextCheckTime: null
                };
            }
            
            const settings = char.wait_friend_settings[accountId];
            settings.enabled = !settings.enabled;
            
            if (settings.enabled) {
                // å¯ç”¨æ—¶è®¾ç½®ä¸‹æ¬¡æ£€æµ‹æ—¶é—´
                settings.lastCheckTime = Date.now();
                settings.nextCheckTime = Date.now() + settings.interval * 60 * 1000;
                startWaitFriendTimer();
            } else {
                settings.nextCheckTime = null;
            }
            
            await safeCharacterPut(char);
            
            // åˆ·æ–°ç•Œé¢
            if (currentChatCharId === charId) {
                await renderChatBody(char);
            }
        }
        
        // ä¿å­˜æ£€æµ‹é—´éš”
        async function saveWaitFriendInterval(charId) {
            const char = await db.characters.get(charId);
            if (!char) return;
            
            const accountId = getCurrentAccountId();
            const intervalInput = document.getElementById('wait-friend-interval');
            const interval = parseInt(intervalInput.value) || 60;
            
            if (!char.wait_friend_settings) char.wait_friend_settings = {};
            if (!char.wait_friend_settings[accountId]) {
                char.wait_friend_settings[accountId] = {
                    enabled: false,
                    interval: interval,
                    lastCheckTime: Date.now(),
                    nextCheckTime: null
                };
            }
            
            char.wait_friend_settings[accountId].interval = interval;
            
            // å¦‚æœå·²å¯ç”¨ï¼Œé‡æ–°è®¡ç®—ä¸‹æ¬¡æ£€æµ‹æ—¶é—´
            if (char.wait_friend_settings[accountId].enabled) {
                char.wait_friend_settings[accountId].nextCheckTime = 
                    char.wait_friend_settings[accountId].lastCheckTime + interval * 60 * 1000;
            }
            
            await safeCharacterPut(char);
            
            // åˆ·æ–°ç•Œé¢
            if (currentChatCharId === charId) {
                await renderChatBody(char);
            }
        }
        
        // å¿«è¿›æ£€æµ‹ï¼ˆåˆ é™¤å¥½å‹åï¼‰
        async function fastForwardCheck(charId) {
            // æ£€æŸ¥APIå¯†é’¥ï¼ˆä»æ•°æ®åº“è·å–ï¼Œå’Œæ­£å¸¸èŠå¤©ä¸€æ ·ï¼‰
            const apiKeyData = await db.dexiData.get('aiApiKey');
            const apiKey = apiKeyData?.value ? apiKeyData.value.trim() : '';
            
            if (!apiKey) {
                const configNow = confirm('âš ï¸ æœªé…ç½®AIå¯†é’¥\n\nå¿«è¿›æ£€æŸ¥éœ€è¦è°ƒç”¨AIæ¥åˆ¤æ–­è§’è‰²æ˜¯å¦ä¼šå‘é€å¥½å‹ç”³è¯·ã€‚\n\næ˜¯å¦ç°åœ¨å»é…ç½®APIå¯†é’¥ï¼Ÿ');
                if (configNow) {
                    // æ‰“å¼€è®¾ç½®é¡µé¢
                    document.getElementById('setting-page').style.display = 'flex';
                }
                return;
            }
            
            const timeInput = prompt('å¿«è¿›å¤šä¹…ï¼Ÿ\næ ¼å¼ï¼šæ•°å­— + å•ä½\nä¾‹å¦‚ï¼š60åˆ†é’Ÿã€2å°æ—¶ã€1å¤©', '60åˆ†é’Ÿ');
            if (timeInput === null) return;
            
            // è§£æè¾“å…¥ï¼ˆæ”¯æŒå¤šç§æ ¼å¼ï¼‰
            const match = timeInput.match(/^(\d+)\s*(åˆ†é’Ÿ|å°æ—¶|å¤©)$/);
            if (!match) {
                // å…¼å®¹æ—§æ ¼å¼ï¼ˆçº¯æ•°å­—é»˜è®¤ä¸ºåˆ†é’Ÿï¼‰
                const minutesNum = parseInt(timeInput);
                if (isNaN(minutesNum) || minutesNum <= 0) {
                    alert('æ ¼å¼é”™è¯¯ï¼è¯·è¾“å…¥å¦‚ï¼š60åˆ†é’Ÿã€2å°æ—¶ã€1å¤©');
                    return;
                }
                // ğŸ”§ åªæœ‰è™šæ‹Ÿæ—¶é—´å¼€å¯æ—¶æ‰æ›´æ–°æ—¶é—´åç§»
                const char = await db.characters.get(charId);
                if (char && isVirtualTimeEnabled(char)) {
                    if (!char.timeOffset) char.timeOffset = 0;
                    char.timeOffset += minutesNum * 60 * 1000;
                    await safeCharacterPut(char);
                }
                await checkCharacterSendFriendRequest(charId, minutesNum);
                return;
            }
            
            const amount = parseInt(match[1]);
            const unit = match[2];
            
            // è®¡ç®—åˆ†é’Ÿæ•°
            let minutesNum = 0;
            if (unit === 'åˆ†é’Ÿ') {
                minutesNum = amount;
            } else if (unit === 'å°æ—¶') {
                minutesNum = amount * 60;
            } else if (unit === 'å¤©') {
                minutesNum = amount * 24 * 60;
            }
            
            if (minutesNum <= 0) {
                alert('æ—¶é—´å¿…é¡»å¤§äº0');
                return;
            }
            
            // ğŸ”§ åªæœ‰è™šæ‹Ÿæ—¶é—´å¼€å¯æ—¶æ‰æ›´æ–°æ—¶é—´åç§»
            const char = await db.characters.get(charId);
            if (char && isVirtualTimeEnabled(char)) {
                if (!char.timeOffset) char.timeOffset = 0;
                char.timeOffset += minutesNum * 60 * 1000;
                await safeCharacterPut(char);
            }
            
            await checkCharacterSendFriendRequest(charId, minutesNum);
        }
        
        // æ‹‰é»‘åçš„å¿«è¿›æ£€æŸ¥ï¼ˆç”Ÿæˆç”µè¯è®°å½•å’ŒçŸ­ä¿¡ï¼‰
        async function fastForwardBlockedCheck(charId) {
            // æ£€æŸ¥APIå¯†é’¥ï¼ˆä»æ•°æ®åº“è·å–ï¼Œå’Œæ­£å¸¸èŠå¤©ä¸€æ ·ï¼‰
            const apiKeyData = await db.dexiData.get('aiApiKey');
            const apiKey = apiKeyData?.value ? apiKeyData.value.trim() : '';
            
            if (!apiKey) {
                const configNow = confirm('âš ï¸ æœªé…ç½®AIå¯†é’¥\n\næ‹‰é»‘å¿«è¿›éœ€è¦è°ƒç”¨AIæ¥åˆ¤æ–­è§’è‰²æ˜¯å¦ä¼šè”ç³»ä½ ã€‚\n\næ˜¯å¦ç°åœ¨å»é…ç½®APIå¯†é’¥ï¼Ÿ');
                if (configNow) {
                    // æ‰“å¼€è®¾ç½®é¡µé¢
                    document.getElementById('setting-page').style.display = 'flex';
                }
                return;
            }
            
            const timeInput = prompt('å¿«è¿›å¤šä¹…ï¼Ÿ\næ ¼å¼ï¼šæ•°å­— + å•ä½\nä¾‹å¦‚ï¼š60åˆ†é’Ÿã€2å°æ—¶ã€1å¤©', '60åˆ†é’Ÿ');
            if (timeInput === null) return;
            
            // è§£æè¾“å…¥
            const match = timeInput.match(/^(\d+)\s*(åˆ†é’Ÿ|å°æ—¶|å¤©)$/);
            if (!match) {
                alert('æ ¼å¼é”™è¯¯ï¼è¯·è¾“å…¥å¦‚ï¼š60åˆ†é’Ÿã€2å°æ—¶ã€1å¤©');
                return;
            }
            
            const amount = parseInt(match[1]);
            const unit = match[2];
            
            // è®¡ç®—æ¯«ç§’æ•°
            let ms = 0;
            let unitText = '';
            if (unit === 'åˆ†é’Ÿ') {
                ms = amount * 60 * 1000;
                unitText = amount + 'åˆ†é’Ÿ';
            } else if (unit === 'å°æ—¶') {
                ms = amount * 60 * 60 * 1000;
                unitText = amount + 'å°æ—¶';
            } else if (unit === 'å¤©') {
                ms = amount * 24 * 60 * 60 * 1000;
                unitText = amount + 'å¤©';
            }
            
            if (ms === 0) {
                alert('æ—¶é—´å¿…é¡»å¤§äº0');
                return;
            }
            
            // æ˜¾ç¤ºåŠ è½½æç¤º
            const loadingDiv = document.createElement('div');
            loadingDiv.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.7); display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:9999;';
            loadingDiv.innerHTML = `
                <div style="background:#fff; padding:30px 40px; border-radius:16px; text-align:center; box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                    <div style="width:50px; height:50px; border:4px solid #f3f3f3; border-top:4px solid var(--ins-pink); border-radius:50%; margin:0 auto 20px; animation:spin 1s linear infinite;"></div>
                    <div style="font-size:18px; font-weight:600; color:#333; margin-bottom:8px;">æ­£åœ¨å¿«è¿›ä¸­...</div>
                    <div style="font-size:14px; color:#999;">å¿«è¿› ${unitText}ï¼ŒAIæ­£åœ¨åˆ¤æ–­è§’è‰²æ˜¯å¦ä¼šè”ç³»ä½ </div>
                </div>
            `;
            document.body.appendChild(loadingDiv);
            
            // æ·»åŠ æ—‹è½¬åŠ¨ç”»ï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
            if (!document.querySelector('#spin-animation-style')) {
                const style = document.createElement('style');
                style.id = 'spin-animation-style';
                style.textContent = `
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            try {
                console.log('[FastForwardBlocked] å¼€å§‹å¿«è¿›ï¼Œæ—¶é•¿:', unitText);
                
                // ğŸ”§ åªæœ‰è™šæ‹Ÿæ—¶é—´å¼€å¯æ—¶æ‰æ›´æ–°æ—¶é—´åç§»
                const char = await db.characters.get(charId);
                if (isVirtualTimeEnabled(char)) {
                    if (!char.timeOffset) char.timeOffset = 0;
                    char.timeOffset += ms;
                    await safeCharacterPut(char);
                }
                
                console.log('[FastForwardBlocked] æ—¶é—´å·²æ›´æ–°ï¼Œå¼€å§‹æ£€æŸ¥è¢«æ‹‰é»‘è§’è‰²...');
                
                // æ£€æŸ¥è¢«æ‹‰é»‘çš„è§’è‰²æ˜¯å¦ä¼šè”ç³»ï¼ˆè¿™ä¼šè°ƒç”¨AIç”Ÿæˆç”µè¯å’ŒçŸ­ä¿¡ï¼‰
                await checkBlockedCharactersContact(ms, unitText);
                
                console.log('[FastForwardBlocked] æ£€æŸ¥å®Œæˆ');
                
                // ç­‰å¾…ä¸€å°æ®µæ—¶é—´ï¼Œç¡®ä¿æ‰€æœ‰é€šçŸ¥éƒ½æ˜¾ç¤ºå®Œæ¯•
                await new Promise(resolve => setTimeout(resolve, 500));
                
                if (document.body.contains(loadingDiv)) {
                    document.body.removeChild(loadingDiv);
                }
                
                console.log('[FastForwardBlocked] å¿«è¿›å®Œæˆ');
                alert(`âœ… å·²å¿«è¿› ${unitText}\n\nå¦‚æœè¢«æ‹‰é»‘çš„è§’è‰²å†³å®šè”ç³»ä½ ï¼Œä¼šæ˜¾ç¤ºæœªæ¥æ¥ç”µæˆ–çŸ­ä¿¡è®°å½•ã€‚`);
                
                // åˆ·æ–°ç•Œé¢
                if (currentChatCharId === charId) {
                    await renderChatBody(char);
                }
            } catch (error) {
                console.error('[FastForwardBlocked] Error:', error);
                if (document.body.contains(loadingDiv)) {
                    document.body.removeChild(loadingDiv);
                }
                alert('å¿«è¿›å¤±è´¥ï¼š' + error.message + '\n\nè¯¦ç»†é”™è¯¯è¯·æŸ¥çœ‹æµè§ˆå™¨æ§åˆ¶å°ï¼ˆF12ï¼‰ã€‚');
            }
        }
        
        // è§£é™¤æ‹‰é»‘
        async function unblockFriend(charId) {
            const char = await db.characters.get(charId);
            if (!char) return;
            
            if (confirm(`ç¡®å®šè¦è§£é™¤å¯¹ ${char.name} çš„æ‹‰é»‘å—ï¼Ÿ\nè§£é™¤åå°†æ¢å¤å¥½å‹å…³ç³»ï¼Œå¯ä»¥æ­£å¸¸èŠå¤©ã€‚`)) {
                const accountId = getCurrentAccountId();
                
                // ğŸ¯ ç›´æ¥æ¢å¤ä¸ºå¥½å‹çŠ¶æ€ï¼Œä¸ç”¨é‡æ–°ç”³è¯·
                await setFriendStatus(char, accountId, 'friend');
                
                showToast('å·²è§£é™¤æ‹‰é»‘ï¼Œæ­£åœ¨ç”Ÿæˆè§’è‰²ååº”...');
                
                // åˆ·æ–°ç•Œé¢
                if (currentChatCharId === charId) {
                    await renderChatBody(char);
                }
                
                // åˆ·æ–°å¾®ä¿¡é¡µé¢
                const activeTab = document.querySelector('.wechat-tab-item.active');
                if (activeTab) {
                    const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                    switchWechatTab(tabIndex);
                }
                
                // ğŸ¯ è°ƒç”¨AIç”Ÿæˆè§£é™¤æ‹‰é»‘åçš„ååº”
                try {
                    await generateUnblockReaction(char, accountId);
                } catch (error) {
                    console.error('[Unblock] ç”Ÿæˆååº”å¤±è´¥:', error);
                }
            }
        }
        
        // ğŸ¯ ç”Ÿæˆè§£é™¤æ‹‰é»‘åè§’è‰²çš„ååº”
        async function generateUnblockReaction(char, accountId) {
            const myChar = await db.characters.get(parseInt(accountId));
            if (!myChar) return;
            
            // è·å–èŠå¤©å†å²ä½œä¸ºä¸Šä¸‹æ–‡
            const chatHistory = getChatHistory(char, accountId);
            const recentMessages = chatHistory.slice(-8).map(m => {
                const role = m.role === 'user' ? myChar.name : char.name;
                return `${role}: ${m.content}`;
            }).join('\n');
            
            // è®¡ç®—è¢«æ‹‰é»‘çš„å¤§æ¦‚æ—¶é•¿ï¼ˆæ ¹æ®æœ€åä¸€æ¡æ¶ˆæ¯çš„æ—¶é—´ï¼‰
            const lastMsg = chatHistory[chatHistory.length - 1];
            const blockedDuration = lastMsg ? Math.floor((Date.now() - (lastMsg.timestamp || Date.now())) / (1000 * 60)) : 0;
            const durationText = blockedDuration > 1440 ? `${Math.floor(blockedDuration / 1440)}å¤©` : 
                                 blockedDuration > 60 ? `${Math.floor(blockedDuration / 60)}å°æ—¶` : 
                                 blockedDuration > 0 ? `${blockedDuration}åˆ†é’Ÿ` : 'åˆšæ‰';
            
            const prompt = `ã€è§’è‰²æ‰®æ¼”ä»»åŠ¡ã€‘
ä½ ç°åœ¨æ˜¯ã€Œ${char.name}ã€ï¼Œè¯·å®Œå…¨ä»£å…¥è¿™ä¸ªè§’è‰²ã€‚
âš ï¸ é‡è¦ï¼šä½ çš„åå­—æ˜¯${char.name}ï¼Œä½ ä¸æ˜¯ç”¨æˆ·ï¼ä½ æ˜¯ç‹¬ç«‹çš„è§’è‰²ï¼Œæœ‰è‡ªå·±çš„æ€§æ ¼å’Œæƒ³æ³•ã€‚

ã€ä½ çš„äººè®¾ã€‘
${char.description || char.desc || 'ä¸€ä¸ªæ™®é€šäºº'}

ã€å¯¹æ–¹ä¿¡æ¯ã€‘
åå­—ï¼š${myChar.name}
${myChar.description ? `ç®€ä»‹ï¼š${myChar.description.substring(0, 200)}` : ''}

ã€æœ€è¿‘çš„èŠå¤©è®°å½•ï¼ˆè¢«æ‹‰é»‘å‰ï¼‰ã€‘
${recentMessages || 'ï¼ˆæ— è®°å½•ï¼‰'}

ã€å½“å‰æƒ…å¢ƒã€‘
ä½ ä¹‹å‰è¢«ã€Œ${myChar.name}ã€æ‹‰é»‘äº†å¤§çº¦ ${durationText}ã€‚
åœ¨è¿™æ®µæ—¶é—´é‡Œï¼Œä½ å¯èƒ½æ‰“è¿‡ç”µè¯ã€å‘è¿‡çŸ­ä¿¡ï¼Œä½†éƒ½æ²¡æœ‰å¾—åˆ°å›åº”ã€‚
ç°åœ¨ï¼Œå¯¹æ–¹çªç„¶è§£é™¤äº†å¯¹ä½ çš„æ‹‰é»‘ï¼ä½ ä»¬åˆèƒ½æ­£å¸¸èŠå¤©äº†ã€‚

ã€ä½ éœ€è¦æ€è€ƒã€‘
1. è¢«æ‹‰é»‘è¿™æ®µæ—¶é—´ä½ ç»å†äº†ä»€ä¹ˆï¼Ÿï¼ˆç„¦è™‘ç­‰å¾…ï¼Ÿæ„¤æ€’ä¸ç”˜ï¼Ÿä¼¤å¿ƒéš¾è¿‡ï¼Ÿæ— æ‰€è°“ï¼Ÿï¼‰
2. ç°åœ¨å¯¹æ–¹è§£é™¤æ‹‰é»‘äº†ï¼Œä½ æ˜¯ä»€ä¹ˆå¿ƒæƒ…ï¼Ÿï¼ˆæƒŠå–œï¼Ÿæ¿€åŠ¨ï¼Ÿå†·æ·¡ï¼Ÿè¯•æ¢ï¼ŸæŠ¥å¤å¿ƒç†ï¼Ÿï¼‰
3. ä½ ä¼šç«‹åˆ»å‘æ¶ˆæ¯å—ï¼Ÿè¿˜æ˜¯æ•…æ„å†·ä¸€ä¸‹å¯¹æ–¹ï¼Ÿ
4. å¦‚æœå‘æ¶ˆæ¯ï¼Œä½ ä¼šè¯´ä»€ä¹ˆï¼Ÿï¼ˆå…´å¸ˆé—®ç½ªï¼Ÿè£…ä½œä»€ä¹ˆéƒ½æ²¡å‘ç”Ÿï¼Ÿå°å¿ƒç¿¼ç¿¼ï¼Ÿæ’’å¨‡æŠ±æ€¨ï¼Ÿï¼‰

ã€è¾“å‡ºè¦æ±‚ã€‘
æ ¹æ®ä½ çš„æ€§æ ¼ï¼Œç”Ÿæˆä½ å‘ç°è¢«è§£é™¤æ‹‰é»‘åå‘çš„ç¬¬ä¸€æ¡/ç¬¬ä¸€ç»„å¾®ä¿¡æ¶ˆæ¯ã€‚

è¦æ±‚ï¼š
- ç”¨ã€Œ|||ã€åˆ†éš”å¤šæ¡æ¶ˆæ¯ï¼ˆ${char.reply_min_count || 1}-${char.reply_max_count || 3}æ¡ï¼‰
- ä¸¥æ ¼è´´åˆä½ çš„äººè®¾å’Œè¯´è¯é£æ ¼
- æƒ…ç»ªè¦çœŸå® ä¸è¦å¤ªç†æ€§
- å°‘ç”¨æ ‡ç‚¹ç¬¦å· åœé¡¿ç”¨ç©ºæ ¼ä»£æ›¿ ä¸è¦åœ¨å¥ä¸­ç”¨é€—å·
- å¯ä»¥æœ‰è¯­æ°”è¯ã€è¡¨æƒ…ã€é”™åˆ«å­—
- å¦‚æœä½ çš„æ€§æ ¼æ˜¯ä¼šå†·å¤„ç†çš„ å¯ä»¥åªå‘ä¸€ä¸ªå­—æˆ–è¡¨æƒ…

ç›´æ¥è¾“å‡ºæ¶ˆæ¯å†…å®¹ï¼Œä¸è¦ä»»ä½•è§£é‡Šã€‚

ç¤ºä¾‹æ ¼å¼ï¼š
åœ¨å—|||ä½ ç»ˆäºè‚¯ç†æˆ‘äº†|||æˆ‘è¿˜ä»¥ä¸ºä½ è¦æ‹‰é»‘æˆ‘ä¸€è¾ˆå­å‘¢`;

            console.log('[Unblock] æ­£åœ¨ç”Ÿæˆè§£é™¤æ‹‰é»‘ååº”...');
            
            // ğŸ¯ æ˜¾ç¤º"å¯¹æ–¹æ­£åœ¨è¾“å…¥ä¸­..."
            const chatTitleEl = document.getElementById('chat-title');
            const originalTitle = chatTitleEl ? chatTitleEl.innerText : getCharDisplayName(char, getCurrentAccountId());
            if (chatTitleEl && currentChatCharId === char.id) {
                chatTitleEl.innerText = "å¯¹æ–¹æ­£åœ¨è¾“å…¥ä¸­...";
            }
            
            try {
                const response = await callAI([
                    { role: 'user', content: prompt }
                ]);
                
                const replyText = response.trim();
                if (!replyText) {
                    // æ¢å¤æ ‡é¢˜
                    if (chatTitleEl && currentChatCharId === char.id) {
                        chatTitleEl.innerText = originalTitle;
                    }
                    return;
                }
                
                console.log('[Unblock] AIè¿”å›:', replyText);
                
                // è§£æå¤šæ¡æ¶ˆæ¯
                const segments = replyText.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                if (segments.length === 0) {
                    if (chatTitleEl && currentChatCharId === char.id) {
                        chatTitleEl.innerText = originalTitle;
                    }
                    return;
                }
                
                // è·å–å½“å‰èŠå¤©è®°å½•
                let currentHistory = getChatHistory(char, accountId);
                
                // æ·»åŠ æ‰€æœ‰æ¶ˆæ¯åˆ°èŠå¤©è®°å½•ï¼ˆä½¿ç”¨ buildCharMessage ä¸€æ¬¡æ€§è§£æç¿»è¯‘ï¼‰
                for (let i = 0; i < segments.length; i++) {
                    currentHistory.push(buildCharMessage(segments[i], !!char.foreign_lang_mode, { time: Date.now() + i * 100 }));
                }
                
                // ä¿å­˜èŠå¤©è®°å½•
                await setChatHistory(char, accountId, currentHistory);
                
                // ç›´æ¥é‡æ–°æ¸²æŸ“èŠå¤©ç•Œé¢
                if (currentChatCharId === char.id) {
                    await renderChatBody(char);
                    // æ»šåŠ¨åˆ°åº•éƒ¨
                    const chatBody = document.getElementById('chat-body');
                    if (chatBody) chatBody.scrollTop = chatBody.scrollHeight;
                }
                
                // æ¢å¤æ ‡é¢˜
                if (chatTitleEl && currentChatCharId === char.id) {
                    chatTitleEl.innerText = originalTitle;
                }
                
                // æ˜¾ç¤ºé€šçŸ¥
                showToast(`${char.name} å‘æ¥äº†æ¶ˆæ¯`);
                
                console.log('[Unblock] âœ… è§£é™¤æ‹‰é»‘ååº”å·²ç”Ÿæˆ');
                
            } catch (error) {
                console.error('[Unblock] AIè°ƒç”¨å¤±è´¥:', error);
                // æ¢å¤æ ‡é¢˜
                if (chatTitleEl && currentChatCharId === char.id) {
                    chatTitleEl.innerText = originalTitle;
                }
            }
        }
        
        // ==========================================
        // ğŸ¯ è§’è‰²ä¸»åŠ¨åˆ é™¤/æ‹‰é»‘ç”¨æˆ·åŠŸèƒ½
        // ==========================================
        
        // è§’è‰²åˆ é™¤ç”¨æˆ·ï¼ˆè§’è‰²ä¸»åŠ¨åˆ å¥½å‹ï¼‰
        async function executeCharDeleteUser(charId, accountId) {
            const char = await db.characters.get(charId);
            if (!char) return;
            if (!accountId) accountId = getCurrentAccountId();
            
            console.log(`[CharAction] ${char.name} åˆ é™¤äº†ç”¨æˆ·`);
            
            // è®¾ç½®æ–°çŠ¶æ€ï¼šè¢«è§’è‰²åˆ é™¤
            await setFriendStatus(char, accountId, 'deleted_by_char');
            
            // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ°èŠå¤©è®°å½•
            let history = getChatHistory(char, accountId);
            history.push({
                role: 'system',
                content: `${char.name} å·²å°†ä½ åˆ é™¤å¥½å‹`,
                time: Date.now(),
                type: 'char_delete_user'
            });
            await setChatHistory(char, accountId, history);
            
            // åˆ·æ–°èŠå¤©çª—å£
            if (currentChatCharId === charId) {
                await renderChatBody(char, true);
            }
            
            // åˆ·æ–°å¾®ä¿¡åˆ—è¡¨
            const activeTab = document.querySelector('.wechat-tab-item.active');
            if (activeTab) {
                const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                switchWechatTab(tabIndex);
            }
            
            // å‘é€é€šçŸ¥
            sendSystemNotification(char.name, 'å°†ä½ åˆ é™¤äº†å¥½å‹');
        }
        
        // è§’è‰²æ‹‰é»‘ç”¨æˆ·ï¼ˆè§’è‰²ä¸»åŠ¨æ‹‰é»‘ï¼‰
        async function executeCharBlockUser(charId, accountId) {
            const char = await db.characters.get(charId);
            if (!char) return;
            if (!accountId) accountId = getCurrentAccountId();
            
            console.log(`[CharAction] ${char.name} æ‹‰é»‘äº†ç”¨æˆ·`);
            
            // è®¾ç½®æ–°çŠ¶æ€ï¼šè¢«è§’è‰²æ‹‰é»‘
            await setFriendStatus(char, accountId, 'blocked_by_char');
            
            // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ°èŠå¤©è®°å½•
            let history = getChatHistory(char, accountId);
            history.push({
                role: 'system',
                content: `${char.name} å·²å°†ä½ æ‹‰é»‘`,
                time: Date.now(),
                type: 'char_block_user'
            });
            await setChatHistory(char, accountId, history);
            
            // åˆ·æ–°èŠå¤©çª—å£
            if (currentChatCharId === charId) {
                await renderChatBody(char, true);
            }
            
            // åˆ·æ–°å¾®ä¿¡åˆ—è¡¨
            const activeTab = document.querySelector('.wechat-tab-item.active');
            if (activeTab) {
                const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                switchWechatTab(tabIndex);
            }
            
            // å‘é€é€šçŸ¥
            sendSystemNotification(char.name, 'å°†ä½ æ‹‰é»‘äº†');
        }
        
        // ğŸ¯ NPCåŠ å¥½å‹ï¼ˆè§’è‰²èŠå¤©ä¸­è§¦å‘å…³è”NPCä¸»åŠ¨åŠ ç”¨æˆ·å¥½å‹ï¼‰
        async function executeNpcAddFriend(sourceChar, npcName, accountId) {
            if (!accountId) accountId = getCurrentAccountId();
            if (!sourceChar || !npcName) return;
            
            console.log(`[NPCåŠ å¥½å‹] ${sourceChar.name} è§¦å‘NPC "${npcName}" åŠ ç”¨æˆ·å¥½å‹`);
            
            // 1. ä»è§’è‰²çš„ relationships ä¸­æ‰¾åˆ°å¯¹åº”çš„ NPC
            let targetNpc = null;
            let relation = null;
            
            if (sourceChar.relationships && sourceChar.relationships.length > 0) {
                for (const rel of sourceChar.relationships) {
                    if (rel.targetName === npcName || rel.targetName.includes(npcName) || npcName.includes(rel.targetName)) {
                        const npc = await db.characters.get(rel.targetId);
                        if (npc) {
                            targetNpc = npc;
                            relation = rel;
                            break;
                        }
                    }
                }
            }
            
            // å¦‚æœ relationships æ²¡æ‰¾åˆ°ï¼Œå°è¯•æŒ‰åå­—åœ¨æ‰€æœ‰NPCä¸­æœç´¢
            if (!targetNpc) {
                const allChars = await db.characters.toArray();
                targetNpc = allChars.find(c => 
                    (c.type === 'npc' || c.type === 'char') && 
                    (c.name === npcName || c.name.includes(npcName) || npcName.includes(c.name))
                );
            }
            
            if (!targetNpc) {
                console.warn(`[NPCåŠ å¥½å‹] æ‰¾ä¸åˆ°åä¸º "${npcName}" çš„NPC`);
                return;
            }
            
            // 2. æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯å¥½å‹
            const currentStatus = getFriendStatus(targetNpc, accountId);
            if (currentStatus === 'friend') {
                console.log(`[NPCåŠ å¥½å‹] ${targetNpc.name} å·²ç»æ˜¯å¥½å‹äº†ï¼Œè·³è¿‡`);
                return;
            }
            
            // 3. åˆ›å»ºå¥½å‹ç”³è¯·è®°å½•ï¼ˆNPCä¸»åŠ¨å‘ç»™ç”¨æˆ·ï¼‰
            const requestId = await db.friend_requests.add({
                fromCharId: targetNpc.id,
                fromCharName: targetNpc.name,
                toAccountId: accountId,
                message: relation 
                    ? `ä½ å¥½ï¼Œæˆ‘æ˜¯${sourceChar.name}çš„${relation.relation}${targetNpc.name}` 
                    : `ä½ å¥½ï¼Œæˆ‘æ˜¯${targetNpc.name}ï¼Œ${sourceChar.name}è®©æˆ‘åŠ ä½ `,
                status: 'pending',
                time: Date.now(),
                sourceCharId: sourceChar.id,  // è®°å½•æ˜¯å“ªä¸ªè§’è‰²è§¦å‘çš„
                sourceCharName: sourceChar.name
            });
            
            console.log(`[NPCåŠ å¥½å‹] âœ… å¥½å‹ç”³è¯·å·²åˆ›å»º, requestId: ${requestId}, NPC: ${targetNpc.name}`);
            
            // 4. å‘é€ç³»ç»Ÿé€šçŸ¥
            sendSystemNotification(
                targetNpc.name, 
                `è¯·æ±‚æ·»åŠ ä½ ä¸ºå¥½å‹` + (relation ? `ï¼ˆ${sourceChar.name}çš„${relation.relation}ï¼‰` : '')
            );
            
            // 5. åˆ·æ–°é€šè®¯å½•ï¼ˆå¦‚æœåœ¨é€šè®¯å½•é¡µé¢ï¼‰
            const contactContainer = document.getElementById('contact-content');
            if (contactContainer) {
                renderContactList(contactContainer);
            }
        }
        window.executeNpcAddFriend = executeNpcAddFriend;
        
        // è¢«è§’è‰²åˆ é™¤åï¼šå¿«è¿›æ—¶é—´ï¼ˆè§’è‰²å¯èƒ½ä¸»åŠ¨åŠ å›æ¥ï¼‰
        async function fastForwardDeletedByChar(charId) {
            const apiKeyData = await db.dexiData.get('aiApiKey');
            const apiKey = apiKeyData?.value ? apiKeyData.value.trim() : '';
            
            if (!apiKey) {
                const configNow = confirm('âš ï¸ æœªé…ç½®AIå¯†é’¥\n\nå¿«è¿›éœ€è¦è°ƒç”¨AIæ¥åˆ¤æ–­è§’è‰²æ˜¯å¦ä¼šä¸»åŠ¨åŠ ä½ å›æ¥ã€‚\n\næ˜¯å¦ç°åœ¨å»é…ç½®APIå¯†é’¥ï¼Ÿ');
                if (configNow) {
                    document.getElementById('setting-page').style.display = 'flex';
                }
                return;
            }
            
            const timeInput = prompt('å¿«è¿›å¤šä¹…ï¼Ÿ\næ ¼å¼ï¼šæ•°å­— + å•ä½\nä¾‹å¦‚ï¼š60åˆ†é’Ÿã€2å°æ—¶ã€1å¤©', '60åˆ†é’Ÿ');
            if (timeInput === null) return;
            
            const match = timeInput.match(/^(\d+)\s*(åˆ†é’Ÿ|å°æ—¶|å¤©)$/);
            if (!match) {
                alert('æ ¼å¼é”™è¯¯ï¼è¯·è¾“å…¥å¦‚ï¼š60åˆ†é’Ÿã€2å°æ—¶ã€1å¤©');
                return;
            }
            
            const amount = parseInt(match[1]);
            const unit = match[2];
            let ms = 0, unitText = '';
            if (unit === 'åˆ†é’Ÿ') { ms = amount * 60 * 1000; unitText = amount + 'åˆ†é’Ÿ'; }
            else if (unit === 'å°æ—¶') { ms = amount * 60 * 60 * 1000; unitText = amount + 'å°æ—¶'; }
            else if (unit === 'å¤©') { ms = amount * 24 * 60 * 60 * 1000; unitText = amount + 'å¤©'; }
            
            if (ms === 0) { alert('æ—¶é—´å¿…é¡»å¤§äº0'); return; }
            
            const loadingDiv = document.createElement('div');
            loadingDiv.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.7); display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:9999;';
            loadingDiv.innerHTML = `
                <div style="background:#fff; padding:30px 40px; border-radius:16px; text-align:center; box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                    <div style="width:50px; height:50px; border:4px solid #f3f3f3; border-top:4px solid var(--ins-pink); border-radius:50%; margin:0 auto 20px; animation:spin 1s linear infinite;"></div>
                    <div style="font-size:18px; font-weight:600; color:#333; margin-bottom:8px;">æ­£åœ¨å¿«è¿›ä¸­...</div>
                    <div style="font-size:14px; color:#999;">å¿«è¿› ${unitText}ï¼ŒAIæ­£åœ¨åˆ¤æ–­ Ta æ˜¯å¦ä¼šåŠ ä½ å›æ¥</div>
                </div>
            `;
            document.body.appendChild(loadingDiv);
            
            try {
                const char = await db.characters.get(charId);
                // ğŸ”§ åªæœ‰è™šæ‹Ÿæ—¶é—´å¼€å¯æ—¶æ‰æ›´æ–°æ—¶é—´åç§»
                if (isVirtualTimeEnabled(char)) {
                    if (!char.timeOffset) char.timeOffset = 0;
                    char.timeOffset += ms;
                    await safeCharacterPut(char);
                }
                
                const accountId = getCurrentAccountId();
                const myChar = await db.characters.get(parseInt(accountId));
                const chatHistory = getChatHistory(char, accountId);
                const recentMessages = chatHistory.slice(-10).map(m => {
                    const role = m.role === 'user' ? (myChar?.name || 'ç”¨æˆ·') : char.name;
                    return `${role}: ${m.content}`;
                }).join('\n');
                
                const prompt = `ã€è§’è‰²æ‰®æ¼”ä»»åŠ¡ã€‘
ä½ ç°åœ¨æ˜¯ã€Œ${char.name}ã€ï¼Œè¯·å®Œå…¨ä»£å…¥è§’è‰²ã€‚
âš ï¸ ä½ çš„åå­—æ˜¯${char.name}ï¼Œä½ ä¸æ˜¯ç”¨æˆ·ï¼

ã€ä½ çš„äººè®¾ã€‘
${char.description || char.desc || 'ä¸€ä¸ªæ™®é€šäºº'}

ã€å¯¹æ–¹ä¿¡æ¯ã€‘
åå­—ï¼š${myChar?.name || 'ç”¨æˆ·'}
${myChar?.description ? `ç®€ä»‹ï¼š${myChar.description.substring(0, 200)}` : ''}

ã€æœ€è¿‘çš„èŠå¤©è®°å½•ã€‘
${recentMessages || 'ï¼ˆæ— è®°å½•ï¼‰'}

ã€å½“å‰æƒ…å¢ƒã€‘
ä½ ä¹‹å‰ä¸»åŠ¨åˆ é™¤äº†ã€Œ${myChar?.name || 'ç”¨æˆ·'}ã€çš„å¥½å‹å…³ç³»ã€‚
ç°åœ¨è¿‡å»äº† ${unitText}ã€‚

è¯·æ ¹æ®ä½ çš„æ€§æ ¼å’Œäººè®¾åˆ¤æ–­ï¼šç»è¿‡ ${unitText} åï¼Œä½ ä¼šä¸»åŠ¨æŠŠå¯¹æ–¹åŠ å›æ¥å—ï¼Ÿ

è€ƒè™‘å› ç´ ï¼š
- ä½ åˆ å¯¹æ–¹çš„åŸå› æ˜¯ä»€ä¹ˆï¼Ÿæ˜¯ä¸€æ—¶å†²åŠ¨è¿˜æ˜¯æ·±æ€ç†Ÿè™‘ï¼Ÿ
- è¿‡äº† ${unitText} ä½ çš„æƒ…ç»ªæœ‰æ²¡æœ‰ç¼“å’Œï¼Ÿ
- ä½ æ˜¯é‚£ç§ä¼šå…ˆæœè½¯çš„äººå—ï¼Ÿè¿˜æ˜¯ä¼šç­‰å¯¹æ–¹æ¥ï¼Ÿ
- ä½ ä¼šæƒ³å¿µå¯¹æ–¹å—ï¼Ÿ

è¯·ç”¨JSONæ ¼å¼å›å¤ï¼š
{
  "will_add_back": trueæˆ–false,
  "reason": "ä½ çš„æƒ³æ³•ï¼ˆ30å­—ä»¥å†…ï¼‰",
  "thought": "ä½ æ­¤åˆ»å†…å¿ƒçš„çœŸå®æ„Ÿå—å’Œæƒ³æ³•ï¼ˆè¯¦ç»†çš„å¿ƒç†æ´»åŠ¨ï¼Œ50-100å­—ï¼‰",
  "message": "å¦‚æœåŠ å›æ¥ï¼Œä½ å‘çš„ç¬¬ä¸€æ¡æ¶ˆæ¯ï¼ˆç”¨|||åˆ†éš”å¤šæ¡ï¼‰"
}

åªè¾“å‡ºJSONï¼Œä¸è¦å…¶ä»–å†…å®¹ã€‚`;

                const response = await callAI([{ role: 'user', content: prompt }]);
                let result;
                try {
                    const jsonMatch = response.match(/\{[\s\S]*\}/);
                    result = JSON.parse(jsonMatch ? jsonMatch[0] : response);
                } catch (e) {
                    result = { will_add_back: false, reason: 'è§’è‰²æ­£åœ¨è€ƒè™‘ä¸­', thought: 'å†…å¿ƒå¾ˆå¤æ‚...' };
                }
                
                if (document.body.contains(loadingDiv)) {
                    document.body.removeChild(loadingDiv);
                }
                
                // ğŸ¯ ä¿å­˜å¿ƒå£°ï¼ˆæ— è®ºæ˜¯å¦åŠ å›æ¥éƒ½ä¿å­˜ï¼‰
                const freshCharForThought = await db.characters.get(charId);
                if (freshCharForThought && result.thought) {
                    if (!freshCharForThought.thoughts) freshCharForThought.thoughts = [];
                    const currentHistory = getChatHistory(freshCharForThought, accountId);
                    freshCharForThought.thoughts.push({
                        content: result.thought.trim(),
                        time: Date.now(),
                        messageIndex: currentHistory ? currentHistory.length : 0
                    });
                    if (freshCharForThought.thoughts.length > 50) {
                        freshCharForThought.thoughts = freshCharForThought.thoughts.slice(-50);
                    }
                    // ğŸ”§ ä¿®å¤æ•°æ®ä¸¢å¤±ï¼šä½¿ç”¨ update() åªæ›´æ–° thoughts å­—æ®µ
                    await db.characters.update(charId, {
                        thoughts: freshCharForThought.thoughts
                    });
                }
                
                if (result.will_add_back) {
                    // è§’è‰²å†³å®šåŠ å›æ¥
                    const charNow = await db.characters.get(charId);
                    await setFriendStatus(charNow, accountId, 'friend');
                    
                    let history = getChatHistory(charNow, accountId);
                    history.push({
                        role: 'system',
                        content: `${charNow.name} é‡æ–°æ·»åŠ ä½ ä¸ºå¥½å‹`,
                        time: Date.now(),
                        type: 'char_re_add'
                    });
                    
                    // å¦‚æœæœ‰æ¶ˆæ¯
                    if (result.message) {
                        const segments = result.message.split('|||').map(s => s.trim()).filter(s => s);
                        for (let i = 0; i < segments.length; i++) {
                            history.push(buildCharMessage(segments[i], !!charNow.foreign_lang_mode, { time: Date.now() + i * 100 }));
                        }
                    }
                    await setChatHistory(charNow, accountId, history);
                    
                    if (currentChatCharId === charId) {
                        await renderChatBody(charNow, true);
                    }
                    
                    const activeTab = document.querySelector('.wechat-tab-item.active');
                    if (activeTab) {
                        const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                        switchWechatTab(tabIndex);
                    }
                    
                    alert(`âœ… ${char.name} åœ¨ ${unitText} åä¸»åŠ¨æŠŠä½ åŠ å›äº†å¥½å‹ï¼\n\nğŸ’­ å¿ƒå£°ï¼š${result.thought || result.reason || ''}`);
                } else {
                    alert(`â© å·²å¿«è¿› ${unitText}\n\n${char.name} æš‚æ—¶æ²¡æœ‰åŠ ä½ å›æ¥ã€‚\n\nğŸ’­ Taçš„å¿ƒå£°ï¼š${result.thought || result.reason || ''}`);
                    
                    if (currentChatCharId === charId) {
                        const charNow = await db.characters.get(charId);
                        await renderChatBody(charNow, true);
                    }
                }
            } catch (error) {
                console.error('[FastForwardDeletedByChar] Error:', error);
                if (document.body.contains(loadingDiv)) {
                    document.body.removeChild(loadingDiv);
                }
                alert('å¿«è¿›å¤±è´¥ï¼š' + error.message);
            }
        }
        
        // è¢«è§’è‰²æ‹‰é»‘åï¼šå¿«è¿›æ—¶é—´ï¼ˆè§’è‰²å¯èƒ½è‡ªå·±è§£é™¤æ‹‰é»‘ï¼‰
        async function fastForwardBlockedByChar(charId) {
            const apiKeyData = await db.dexiData.get('aiApiKey');
            const apiKey = apiKeyData?.value ? apiKeyData.value.trim() : '';
            
            if (!apiKey) {
                const configNow = confirm('âš ï¸ æœªé…ç½®AIå¯†é’¥\n\nå¿«è¿›éœ€è¦è°ƒç”¨AIæ¥åˆ¤æ–­è§’è‰²æ˜¯å¦ä¼šè§£é™¤æ‹‰é»‘ã€‚\n\næ˜¯å¦ç°åœ¨å»é…ç½®APIå¯†é’¥ï¼Ÿ');
                if (configNow) {
                    document.getElementById('setting-page').style.display = 'flex';
                }
                return;
            }
            
            const timeInput = prompt('å¿«è¿›å¤šä¹…ï¼Ÿ\næ ¼å¼ï¼šæ•°å­— + å•ä½\nä¾‹å¦‚ï¼š60åˆ†é’Ÿã€2å°æ—¶ã€1å¤©', '60åˆ†é’Ÿ');
            if (timeInput === null) return;
            
            const match = timeInput.match(/^(\d+)\s*(åˆ†é’Ÿ|å°æ—¶|å¤©)$/);
            if (!match) {
                alert('æ ¼å¼é”™è¯¯ï¼è¯·è¾“å…¥å¦‚ï¼š60åˆ†é’Ÿã€2å°æ—¶ã€1å¤©');
                return;
            }
            
            const amount = parseInt(match[1]);
            const unit = match[2];
            let ms = 0, unitText = '';
            if (unit === 'åˆ†é’Ÿ') { ms = amount * 60 * 1000; unitText = amount + 'åˆ†é’Ÿ'; }
            else if (unit === 'å°æ—¶') { ms = amount * 60 * 60 * 1000; unitText = amount + 'å°æ—¶'; }
            else if (unit === 'å¤©') { ms = amount * 24 * 60 * 60 * 1000; unitText = amount + 'å¤©'; }
            
            if (ms === 0) { alert('æ—¶é—´å¿…é¡»å¤§äº0'); return; }
            
            const loadingDiv = document.createElement('div');
            loadingDiv.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.7); display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:9999;';
            loadingDiv.innerHTML = `
                <div style="background:#fff; padding:30px 40px; border-radius:16px; text-align:center; box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                    <div style="width:50px; height:50px; border:4px solid #f3f3f3; border-top:4px solid var(--ins-pink); border-radius:50%; margin:0 auto 20px; animation:spin 1s linear infinite;"></div>
                    <div style="font-size:18px; font-weight:600; color:#333; margin-bottom:8px;">æ­£åœ¨å¿«è¿›ä¸­...</div>
                    <div style="font-size:14px; color:#999;">å¿«è¿› ${unitText}ï¼ŒAIæ­£åœ¨åˆ¤æ–­ Ta æ˜¯å¦ä¼šæ”¾ä½ å‡ºæ¥</div>
                </div>
            `;
            document.body.appendChild(loadingDiv);
            
            try {
                const char = await db.characters.get(charId);
                // ğŸ”§ åªæœ‰è™šæ‹Ÿæ—¶é—´å¼€å¯æ—¶æ‰æ›´æ–°æ—¶é—´åç§»
                if (isVirtualTimeEnabled(char)) {
                    if (!char.timeOffset) char.timeOffset = 0;
                    char.timeOffset += ms;
                    await safeCharacterPut(char);
                }
                
                const accountId = getCurrentAccountId();
                const myChar = await db.characters.get(parseInt(accountId));
                const chatHistory = getChatHistory(char, accountId);
                const recentMessages = chatHistory.slice(-10).map(m => {
                    const role = m.role === 'user' ? (myChar?.name || 'ç”¨æˆ·') : char.name;
                    return `${role}: ${m.content}`;
                }).join('\n');
                
                // æ£€æŸ¥æ˜¯å¦æœ‰çŸ­ä¿¡è®°å½•
                let smsContext = '';
                try {
                    const smsRecords = await db.sms_messages
                        .where('charId').equals(charId)
                        .toArray();
                    const recentSms = smsRecords.filter(s => String(s.accountId) === String(accountId)).slice(-5);
                    if (recentSms.length > 0) {
                        smsContext = '\nã€å¯¹æ–¹å‘çš„çŸ­ä¿¡ã€‘\n' + recentSms.map(s => `${s.sender === 'user' ? (myChar?.name || 'ç”¨æˆ·') : char.name}: ${s.content}`).join('\n');
                    }
                } catch (e) {
                    console.log('è·å–çŸ­ä¿¡è®°å½•å¤±è´¥:', e);
                }
                
                const prompt = `ã€è§’è‰²æ‰®æ¼”ä»»åŠ¡ã€‘
ä½ ç°åœ¨æ˜¯ã€Œ${char.name}ã€ï¼Œè¯·å®Œå…¨ä»£å…¥è§’è‰²ã€‚
âš ï¸ ä½ çš„åå­—æ˜¯${char.name}ï¼Œä½ ä¸æ˜¯ç”¨æˆ·ï¼

ã€ä½ çš„äººè®¾ã€‘
${char.description || char.desc || 'ä¸€ä¸ªæ™®é€šäºº'}

ã€å¯¹æ–¹ä¿¡æ¯ã€‘
åå­—ï¼š${myChar?.name || 'ç”¨æˆ·'}
${myChar?.description ? `ç®€ä»‹ï¼š${myChar.description.substring(0, 200)}` : ''}

ã€æœ€è¿‘çš„èŠå¤©è®°å½•ï¼ˆæ‹‰é»‘å‰ï¼‰ã€‘
${recentMessages || 'ï¼ˆæ— è®°å½•ï¼‰'}
${smsContext}

ã€å½“å‰æƒ…å¢ƒã€‘
ä½ ä¹‹å‰ä¸»åŠ¨æ‹‰é»‘äº†ã€Œ${myChar?.name || 'ç”¨æˆ·'}ã€ã€‚
ç°åœ¨è¿‡å»äº† ${unitText}ã€‚
${smsContext ? 'å¯¹æ–¹è¿˜é€šè¿‡çŸ­ä¿¡è¯•å›¾è”ç³»ä½ ã€‚' : ''}

è¯·æ ¹æ®ä½ çš„æ€§æ ¼å’Œäººè®¾åˆ¤æ–­ï¼šç»è¿‡ ${unitText} åï¼Œä½ ä¼šè§£é™¤å¯¹å¯¹æ–¹çš„æ‹‰é»‘å—ï¼Ÿ

è€ƒè™‘å› ç´ ï¼š
- ä½ æ‹‰é»‘å¯¹æ–¹çš„åŸå› æ˜¯ä»€ä¹ˆï¼Ÿæœ‰å¤šä¸¥é‡ï¼Ÿ
- è¿‡äº† ${unitText} ä½ çš„æ°”æ¶ˆäº†æ²¡æœ‰ï¼Ÿ
- å¯¹æ–¹æœ‰æ²¡æœ‰é€šè¿‡çŸ­ä¿¡è”ç³»ä½ ï¼ŸçŸ­ä¿¡å†…å®¹æœ‰æ²¡æœ‰è®©ä½ è½¯åŒ–ï¼Ÿ
- ä½ æ˜¯é‚£ç§å®¹æ˜“å¿ƒè½¯çš„äººå—ï¼Ÿ
- ä½ ä¼šæƒ³å¿µå¯¹æ–¹å—ï¼Ÿ

è¯·ç”¨JSONæ ¼å¼å›å¤ï¼š
{
  "will_unblock": trueæˆ–false,
  "reason": "ä½ çš„æƒ³æ³•ï¼ˆ30å­—ä»¥å†…ï¼‰",
  "thought": "ä½ æ­¤åˆ»å†…å¿ƒçš„çœŸå®æ„Ÿå—å’Œæƒ³æ³•ï¼ˆè¯¦ç»†çš„å¿ƒç†æ´»åŠ¨ï¼Œ50-100å­—ï¼‰",
  "message": "å¦‚æœè§£é™¤æ‹‰é»‘ï¼Œä½ å‘çš„ç¬¬ä¸€æ¡æ¶ˆæ¯ï¼ˆç”¨|||åˆ†éš”å¤šæ¡ï¼‰"
}

åªè¾“å‡ºJSONï¼Œä¸è¦å…¶ä»–å†…å®¹ã€‚`;

                const response = await callAI([{ role: 'user', content: prompt }]);
                let result;
                try {
                    const jsonMatch = response.match(/\{[\s\S]*\}/);
                    result = JSON.parse(jsonMatch ? jsonMatch[0] : response);
                } catch (e) {
                    result = { will_unblock: false, reason: 'è§’è‰²è¿˜åœ¨ç”Ÿæ°”ä¸­', thought: 'è¿˜åœ¨ç”Ÿæ°”...' };
                }
                
                if (document.body.contains(loadingDiv)) {
                    document.body.removeChild(loadingDiv);
                }
                
                // ğŸ¯ ä¿å­˜å¿ƒå£°ï¼ˆæ— è®ºæ˜¯å¦è§£é™¤æ‹‰é»‘éƒ½ä¿å­˜ï¼‰
                const freshCharForThought = await db.characters.get(charId);
                if (freshCharForThought && result.thought) {
                    if (!freshCharForThought.thoughts) freshCharForThought.thoughts = [];
                    const currentHistory = getChatHistory(freshCharForThought, accountId);
                    freshCharForThought.thoughts.push({
                        content: result.thought.trim(),
                        time: Date.now(),
                        messageIndex: currentHistory ? currentHistory.length : 0
                    });
                    if (freshCharForThought.thoughts.length > 50) {
                        freshCharForThought.thoughts = freshCharForThought.thoughts.slice(-50);
                    }
                    // ğŸ”§ ä¿®å¤æ•°æ®ä¸¢å¤±ï¼šä½¿ç”¨ update() åªæ›´æ–° thoughts å­—æ®µ
                    await db.characters.update(charId, {
                        thoughts: freshCharForThought.thoughts
                    });
                }
                
                if (result.will_unblock) {
                    // è§’è‰²å†³å®šè§£é™¤æ‹‰é»‘
                    const charNow = await db.characters.get(charId);
                    await setFriendStatus(charNow, accountId, 'friend');
                    
                    let history = getChatHistory(charNow, accountId);
                    history.push({
                        role: 'system',
                        content: `${charNow.name} è§£é™¤äº†å¯¹ä½ çš„æ‹‰é»‘`,
                        time: Date.now(),
                        type: 'char_unblock'
                    });
                    
                    if (result.message) {
                        const segments = result.message.split('|||').map(s => s.trim()).filter(s => s);
                        for (let i = 0; i < segments.length; i++) {
                            history.push(buildCharMessage(segments[i], !!charNow.foreign_lang_mode, { time: Date.now() + i * 100 }));
                        }
                    }
                    await setChatHistory(charNow, accountId, history);
                    
                    if (currentChatCharId === charId) {
                        await renderChatBody(charNow, true);
                    }
                    
                    const activeTab = document.querySelector('.wechat-tab-item.active');
                    if (activeTab) {
                        const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                        switchWechatTab(tabIndex);
                    }
                    
                    alert(`âœ… ${char.name} åœ¨ ${unitText} åè§£é™¤äº†å¯¹ä½ çš„æ‹‰é»‘ï¼\n\nğŸ’­ å¿ƒå£°ï¼š${result.thought || result.reason || ''}`);
                } else {
                    alert(`â© å·²å¿«è¿› ${unitText}\n\n${char.name} è¿˜æ²¡æœ‰è§£é™¤å¯¹ä½ çš„æ‹‰é»‘ã€‚\n\nğŸ’­ Taçš„å¿ƒå£°ï¼š${result.thought || result.reason || ''}\n\nğŸ’¡ ä½ å¯ä»¥å°è¯•é€šè¿‡çŸ­ä¿¡è”ç³» Ta`);
                    
                    if (currentChatCharId === charId) {
                        const charNow = await db.characters.get(charId);
                        await renderChatBody(charNow, true);
                    }
                }
            } catch (error) {
                console.error('[FastForwardBlockedByChar] Error:', error);
                if (document.body.contains(loadingDiv)) {
                    document.body.removeChild(loadingDiv);
                }
                alert('å¿«è¿›å¤±è´¥ï¼š' + error.message);
            }
        }
        
        // è¢«è§’è‰²åˆ é™¤åï¼šä¸»åŠ¨å‘é€å¥½å‹ç”³è¯·
        async function sendFriendRequestAfterCharDelete(charId) {
            const char = await db.characters.get(charId);
            if (!char) return;
            
            const accountId = getCurrentAccountId();
            const userName = await getCurrentUserName();
            const message = prompt(`å‘ ${char.name} å‘é€å¥½å‹ç”³è¯·\n\nè¯·è¾“å…¥ç”³è¯·ç†ç”±ï¼š`, 'æˆ‘æ˜¯' + userName);
            if (message === null) return;
            
            await sendFriendRequestTo(charId, message);
        }
        
        // è¢«è§’è‰²æ‹‰é»‘åï¼šé€šè¿‡çŸ­ä¿¡è”ç³»
        async function sendSmsToBlockedChar(charId) {
            const char = await db.characters.get(charId);
            if (!char) return;
            
            const charPhone = char.identity?.phone || generateVirtualPhoneNumber(char.id);
            const charName = getCharDisplayName(char, getCurrentAccountId());
            
            // è®¾ç½®çŸ­ä¿¡èŠå¤©ç›¸å…³çš„å…¨å±€å˜é‡
            window._smsSelectedCharId = charId;
            
            // æ‰“å¼€çŸ­ä¿¡é¡µé¢
            showMessagePage();
            
            // å»¶è¿Ÿåè‡ªåŠ¨æ‰“å¼€å¯¹åº”çš„çŸ­ä¿¡èŠå¤©
            setTimeout(async () => {
                openMessageChat(charPhone);
            }, 500);
        }
        
        // å¯¼å‡ºå‡½æ•°åˆ°å…¨å±€
        window.executeCharDeleteUser = executeCharDeleteUser;
        window.executeCharBlockUser = executeCharBlockUser;
        window.fastForwardDeletedByChar = fastForwardDeletedByChar;
        window.fastForwardBlockedByChar = fastForwardBlockedByChar;
        window.sendFriendRequestAfterCharDelete = sendFriendRequestAfterCharDelete;
        window.sendSmsToBlockedChar = sendSmsToBlockedChar;

        // æ‰‹åŠ¨å‘é€å¥½å‹ç”³è¯·ï¼ˆç”¨æˆ·ä¸»åŠ¨ï¼‰
        async function manualSendFriendRequest(charId) {
            console.log('[FriendRequest] ç‚¹å‡»ä¸»åŠ¨å‘é€å¥½å‹ç”³è¯·, charId:', charId);
            const char = await db.characters.get(charId);
            if (!char) {
                console.error('[FriendRequest] æ‰¾ä¸åˆ°è§’è‰², charId:', charId);
                return;
            }
            
            const message = prompt(`å‘é€å¥½å‹ç”³è¯·ç»™ ${char.name}\n\nè¯·è¾“å…¥ç”³è¯·ç†ç”±ï¼ˆå¯é€‰ï¼‰ï¼š`, 'æˆ‘æ˜¯' + (await getCurrentUserName()));
            if (message !== null) {
                console.log('[FriendRequest] å¼€å§‹å‘é€å¥½å‹ç”³è¯·ç»™:', char.name, 'æ¶ˆæ¯:', message);
                await sendFriendRequestTo(charId, message);
            } else {
                console.log('[FriendRequest] ç”¨æˆ·å–æ¶ˆäº†å‘é€');
            }
        }
        
        // AIæ£€æµ‹æ˜¯å¦å‘é€å¥½å‹ç”³è¯·
        async function checkCharacterSendFriendRequest(charId, elapsedMinutes) {
            const char = await db.characters.get(charId);
            if (!char) return;
            
            const accountId = getCurrentAccountId();
            if (!accountId) return;
            const myChar = await db.characters.get(parseInt(accountId));
            if (!myChar) return;
            
            // è·å–èŠå¤©å†å²
            const history = getChatHistory(char, accountId);
            const recentMessages = history.slice(-10); // æœ€è¿‘10æ¡æ¶ˆæ¯
            
            // æ„å»ºæç¤ºè¯
            const chatContext = recentMessages.map(msg => {
                const role = msg.role === 'user' ? myChar.name : char.name;
                return `${role}: ${msg.content}`;
            }).join('\n');
            
            // æ ¼å¼åŒ–æ—¶é—´æ˜¾ç¤º
            let elapsedText = '';
            if (elapsedMinutes < 60) {
                elapsedText = elapsedMinutes + 'åˆ†é’Ÿ';
            } else if (elapsedMinutes < 1440) {
                elapsedText = Math.round(elapsedMinutes / 60) + 'å°æ—¶';
            } else {
                elapsedText = Math.round(elapsedMinutes / 1440) + 'å¤©';
            }
            
            const systemPrompt = `ä½ æ˜¯ä¸€ä¸ªè§’è‰²æ‰®æ¼”åŠ©æ‰‹ã€‚ä½ éœ€è¦ä»£å…¥è§’è‰²${char.name}ï¼Œåˆ¤æ–­æ˜¯å¦ä¼šä¸»åŠ¨å‘é€å¥½å‹ç”³è¯·ã€‚
âš ï¸ é‡è¦ï¼šä½ çš„åå­—æ˜¯${char.name}ï¼Œä½ ä¸æ˜¯${myChar.name}ï¼ä½ æ˜¯ç‹¬ç«‹çš„è§’è‰²ã€‚`;

            const userPrompt = `ã€ä½ çš„äººè®¾ã€‘
${char.description || char.desc || 'ï¼ˆæ— è¯¦ç»†äººè®¾ï¼‰'}

ã€å¯¹æ–¹ä¿¡æ¯ã€‘
åå­—ï¼š${myChar.name}
${myChar.description ? `ç®€ä»‹ï¼š${myChar.description.substring(0, 200)}` : ''}

ã€ä½ ä»¬ä¹‹å‰çš„èŠå¤©è®°å½•ã€‘
${chatContext || 'ï¼ˆæ²¡æœ‰èŠå¤©è®°å½•ï¼‰'}

ã€å½“å‰æƒ…å¢ƒã€‘
ä½ å’Œ${myChar.name}ä¹‹å‰æ˜¯å¥½å‹ï¼Œä½†${myChar.name}åˆ é™¤äº†ä½ ã€‚
ç°åœ¨å·²ç»è¿‡å»äº†${elapsedText}ã€‚

è¯·æ ¹æ®ä½ çš„æ€§æ ¼ã€å’Œ${myChar.name}çš„å…³ç³»ã€ä»¥åŠä½ ä»¬çš„èŠå¤©å†å²ï¼Œå†³å®šä½ æ˜¯å¦è¦ä¸»åŠ¨å‘é€å¥½å‹ç”³è¯·ç»™${myChar.name}ã€‚

å¦‚æœä½ å†³å®šå‘é€å¥½å‹ç”³è¯·ï¼Œè¯·ä»¥ä½ çš„èº«ä»½å†™å‡ºç”³è¯·é™„å¸¦çš„æ¶ˆæ¯ï¼ˆ1-3æ¡ï¼Œæ¯æ¡ç”¨æ¢è¡Œåˆ†éš”ï¼‰ã€‚ç›´æ¥å†™æ¶ˆæ¯å†…å®¹ï¼Œä¸è¦æœ‰æ ¼å¼æ ‡è®°æˆ–è§£é‡Šã€‚
å¦‚æœä½ å†³å®šä¸å‘é€ï¼Œè¯·åªå›å¤"[ä¸å‘é€]"ã€‚`;
            
            // æ˜¾ç¤ºåŠ è½½æç¤º
            const loadingDiv = document.createElement('div');
            loadingDiv.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.7); display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:9999;';
            loadingDiv.innerHTML = `
                <div style="background:#fff; padding:30px 40px; border-radius:16px; text-align:center; box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                    <div style="width:50px; height:50px; border:4px solid #f3f3f3; border-top:4px solid var(--ins-pink); border-radius:50%; margin:0 auto 20px; animation:spin 1s linear infinite;"></div>
                    <div style="font-size:18px; font-weight:600; color:#333; margin-bottom:8px;">æ­£åœ¨æ£€æµ‹ä¸­...</div>
                    <div style="font-size:14px; color:#999;">${char.name} æ­£åœ¨å†³å®šæ˜¯å¦å‘é€å¥½å‹ç”³è¯·ï¼ˆå¿«è¿›${elapsedText}ï¼‰</div>
                </div>
            `;
            document.body.appendChild(loadingDiv);
            
            // æ·»åŠ æ—‹è½¬åŠ¨ç”»ï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
            if (!document.querySelector('#spin-animation-style')) {
                const style = document.createElement('style');
                style.id = 'spin-animation-style';
                style.textContent = `
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            try {
                // ğŸ”¥ ä½¿ç”¨ system + user æ¶ˆæ¯æ ¼å¼ï¼Œä¸å…¶ä»–AIè°ƒç”¨ä¿æŒä¸€è‡´
                const response = await callAI([
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: userPrompt }
                ]);
                
                if (document.body.contains(loadingDiv)) {
                    document.body.removeChild(loadingDiv);
                }
                
                // è§£æAIå›å¤
                const answer = (response || '').trim();
                
                if (!answer || answer === '[ä¸å‘é€]' || answer.includes('[ä¸å‘é€]') || answer.includes('ä¸å‘é€')) {
                    // è§’è‰²å†³å®šä¸å‘é€
                    alert(`${char.name} å†³å®šæš‚æ—¶ä¸å‘é€å¥½å‹ç”³è¯·`);
                    
                    // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–° wait_friend_settings å­—æ®µ
                    const freshChar = await db.characters.get(charId);
                    if (freshChar) {
                        if (!freshChar.wait_friend_settings) freshChar.wait_friend_settings = {};
                        if (!freshChar.wait_friend_settings[accountId]) {
                            freshChar.wait_friend_settings[accountId] = {
                                enabled: false,
                                interval: 60,
                                lastCheckTime: Date.now(),
                                nextCheckTime: null
                            };
                        }
                        freshChar.wait_friend_settings[accountId].lastCheckTime = Date.now();
                        if (freshChar.wait_friend_settings[accountId].enabled) {
                            freshChar.wait_friend_settings[accountId].nextCheckTime = 
                                Date.now() + freshChar.wait_friend_settings[accountId].interval * 60 * 1000;
                        }
                        await safeDexieUpdate(db.characters, charId, {
                            [`wait_friend_settings.${accountId}`]: freshChar.wait_friend_settings[accountId]
                        }, `å¥½å‹ç”³è¯·è®¾ç½®[${freshChar.name}]`);
                    }
                } else {
                    // è§’è‰²å†³å®šå‘é€å¥½å‹ç”³è¯·ï¼Œå°†å¤šæ¡æ¶ˆæ¯æ‹†åˆ†
                    // æ¸…ç†AIå¯èƒ½é™„åŠ çš„æ ¼å¼æ ‡è®°
                    let cleanAnswer = answer
                        .replace(/^[\s\S]*?\[ä¸å‘é€\][\s\S]*$/gi, '')
                        .replace(/^(å¥½çš„|ä½œä¸º|ä»¥ä¸‹æ˜¯|æˆ‘å†³å®š).*[:ï¼š]\s*/gim, '')
                        .trim();
                    
                    if (!cleanAnswer) cleanAnswer = answer; // å¦‚æœæ¸…ç†åä¸ºç©ºï¼Œç”¨åŸå§‹å›å¤
                    
                    const messages = cleanAnswer.split('\n').filter(msg => {
                        const trimmed = msg.trim();
                        return trimmed.length > 0 && !trimmed.startsWith('[') && !trimmed.startsWith('ï¼ˆ');
                    });
                    
                    if (messages.length === 0) {
                        alert(`${char.name} çš„å›å¤æ— æ³•è§£æï¼Œæœªå‘é€ç”³è¯·`);
                        return;
                    }
                    
                    // å°†æ‰€æœ‰æ¶ˆæ¯åˆå¹¶ä½œä¸ºç”³è¯·æ¶ˆæ¯
                    const requestMessage = messages.join('\n');
                    
                    // åˆ›å»ºå¥½å‹ç”³è¯·ï¼ˆåå‘ï¼šä»è§’è‰²å‘ç»™ç”¨æˆ·ï¼‰
                    await db.friend_requests.add({
                        fromCharId: charId,
                        toCharId: parseInt(accountId),
                        toAccountId: accountId,
                        message: requestMessage,
                        status: 'pending',
                        time: Date.now()
                    });
                    
                    // ğŸ”§ æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ°èŠå¤©å†å²ï¼Œè®°å½•è§’è‰²å‘é€å¥½å‹ç”³è¯·äº‹ä»¶
                    const freshCharForHistory = await db.characters.get(charId);
                    if (freshCharForHistory) {
                        let history = getChatHistory(freshCharForHistory, accountId);
                        history.push({
                            role: 'system',
                            content: `[${char.name} å‘ä½ å‘é€äº†å¥½å‹ç”³è¯·]`,
                            time: Date.now(),
                            type: 'char_send_friend_request'
                        });
                        await setChatHistory(freshCharForHistory, accountId, history);
                        console.log(`[FriendRequest] å·²åœ¨èŠå¤©å†å²ä¸­è®°å½•è§’è‰²å‘é€å¥½å‹ç”³è¯·`);
                    }
                    
                    // æ˜¾ç¤ºæ¶ˆæ¯é¢„è§ˆ
                    const preview = messages.length > 1 ? 
                        `${messages[0]}\n...(å…±${messages.length}æ¡æ¶ˆæ¯)` : 
                        messages[0];
                    
                    alert(`${char.name} å‘é€äº†å¥½å‹ç”³è¯·ï¼\n\n${preview}\n\nè¯·å‰å¾€"æ–°çš„å¥½å‹"é¡µé¢æŸ¥çœ‹ã€‚`);
                    
                    // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–° wait_friend_settings å­—æ®µ
                    const freshChar = await db.characters.get(charId);
                    if (freshChar) {
                        if (!freshChar.wait_friend_settings) freshChar.wait_friend_settings = {};
                        if (!freshChar.wait_friend_settings[accountId]) {
                            freshChar.wait_friend_settings[accountId] = {
                                enabled: false,
                                interval: 60,
                                lastCheckTime: Date.now(),
                                nextCheckTime: null
                            };
                        }
                        freshChar.wait_friend_settings[accountId].lastCheckTime = Date.now();
                        if (freshChar.wait_friend_settings[accountId].enabled) {
                            freshChar.wait_friend_settings[accountId].nextCheckTime = 
                                Date.now() + freshChar.wait_friend_settings[accountId].interval * 60 * 1000;
                        }
                        await safeDexieUpdate(db.characters, charId, {
                            [`wait_friend_settings.${accountId}`]: freshChar.wait_friend_settings[accountId]
                        }, `å¥½å‹ç”³è¯·è®¾ç½®[${freshChar.name}]`);
                    }
                    
                    // åˆ·æ–°é€šè®¯å½•çº¢ç‚¹
                    const activeTab = document.querySelector('.wechat-tab-item.active');
                    if (activeTab && activeTab.innerText.includes('é€šè®¯å½•')) {
                        await renderContactList(document.getElementById('wechat-content'));
                    }
                }
                
                // åˆ·æ–°ç•Œé¢
                if (currentChatCharId === charId) {
                    const refreshedChar = await db.characters.get(charId);
                    if (refreshedChar) await renderChatBody(refreshedChar);
                }
                
            } catch (error) {
                if (document.body.contains(loadingDiv)) {
                    document.body.removeChild(loadingDiv);
                }
                console.error('[FastForwardCheck] AIè°ƒç”¨å¤±è´¥:', error);
                alert('AIè°ƒç”¨å¤±è´¥ï¼š' + error.message);
            }
        }
        
        // å®šæ—¶å™¨ï¼šæ£€æŸ¥æ‰€æœ‰éœ€è¦æ£€æµ‹çš„è§’è‰²
        let waitFriendCheckTimer = null;
        
        function startWaitFriendTimer() {
            if (waitFriendCheckTimer) return; // å·²å¯åŠ¨
            
            waitFriendCheckTimer = setInterval(async () => {
                const now = Date.now();
                const accountId = getCurrentAccountId();
                if (!accountId) return;
                
                // è·å–æ‰€æœ‰è§’è‰²
                const allChars = await db.characters.toArray();
                
                for (const char of allChars) {
                    const settings = char.wait_friend_settings?.[accountId];
                    if (!settings || !settings.enabled) continue;
                    
                    // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾æ£€æµ‹æ—¶é—´
                    if (settings.nextCheckTime && now >= settings.nextCheckTime) {
                        // è§¦å‘æ£€æµ‹
                        await checkCharacterSendFriendRequest(char.id, settings.interval);
                    }
                }
            }, 60000); // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
        }
        
        // å»¶è¿Ÿå¯åŠ¨å®šæ—¶å™¨ï¼Œé¿å…åˆå§‹åŒ–é˜¶æ®µå¡é¡¿
        setTimeout(startWaitFriendTimer, 5000);

        // --- ä½ç”µé‡æé†’ï¼ˆè¯»å–ç”¨æˆ·è®¾å¤‡çœŸå®ç”µé‡ï¼‰ ---
        async function initBatteryMonitor() {
            if (!navigator.getBattery) {
                console.log('[Battery] å½“å‰æµè§ˆå™¨ä¸æ”¯æŒ Battery API');
                return;
            }
            try {
                const battery = await navigator.getBattery();
                deviceBatteryLevel = Math.round(battery.level * 100);
                deviceBatteryCharging = battery.charging;
                console.log(`[Battery] åˆå§‹ç”µé‡: ${deviceBatteryLevel}%, å……ç”µä¸­: ${deviceBatteryCharging}`);
                
                // ç›‘å¬ç”µé‡å˜åŒ–
                battery.addEventListener('levelchange', () => {
                    const oldLevel = deviceBatteryLevel;
                    deviceBatteryLevel = Math.round(battery.level * 100);
                    console.log(`[Battery] ç”µé‡å˜åŒ–: ${oldLevel}% â†’ ${deviceBatteryLevel}%`);
                    
                    // ç”µé‡åˆšè·Œç ´20%ä¸”ä¸åœ¨å……ç”µï¼Œç«‹å³æ£€æŸ¥æ˜¯å¦åœ¨èŠå¤©é¡µé¢
                    if (deviceBatteryLevel <= 20 && oldLevel > 20 && !deviceBatteryCharging) {
                        lowBatteryShownThisSession.clear(); // é‡æ–°è§¦å‘æé†’
                        checkAndShowLowBattery();
                    }
                });
                
                battery.addEventListener('chargingchange', () => {
                    deviceBatteryCharging = battery.charging;
                    console.log(`[Battery] å……ç”µçŠ¶æ€: ${deviceBatteryCharging ? 'å……ç”µä¸­' : 'æœªå……ç”µ'}`);
                    // æ‹”æ‰å……ç”µå™¨æ—¶å¦‚æœç”µé‡ä½ï¼Œé‡æ–°æ£€æŸ¥
                    if (!deviceBatteryCharging && deviceBatteryLevel <= 20) {
                        lowBatteryShownThisSession.clear();
                        checkAndShowLowBattery();
                    }
                });
            } catch (e) {
                console.warn('[Battery] è·å–ç”µé‡å¤±è´¥:', e);
            }
        }
        
        async function checkAndShowLowBattery() {
            if (deviceBatteryLevel === null || deviceBatteryLevel > 20 || deviceBatteryCharging) return;
            if (!currentChatCharId) return;
            
            // é¿å…åŒä¸€ä¸ªèŠå¤©çª—å£åå¤å¼¹å‡º
            if (lowBatteryShownThisSession.has(currentChatCharId)) return;
            
            const char = await db.characters.get(currentChatCharId);
            if (!char || char.isOnlineFriend) return;
            
            const charDisplayName = getCharDisplayName(char, getCurrentAccountId());
            lowBatteryShownThisSession.add(currentChatCharId);
            showLowBatteryToast(charDisplayName, deviceBatteryLevel);
        }
        
        function showLowBatteryToast(charName, batteryLevel) {
            const toast = document.getElementById('low-battery-toast');
            if (!toast) return;
            
            const titleEl = document.getElementById('low-battery-title');
            const descEl = document.getElementById('low-battery-desc');
            const percentEl = document.getElementById('low-battery-percent');
            
            titleEl.textContent = `${charName} æé†’ä½ `;
            descEl.textContent = `ä½ çš„æ‰‹æœºç”µé‡åªå‰©${batteryLevel}%äº†ï¼Œè®°å¾—å……ç”µå“¦~`;
            percentEl.textContent = batteryLevel + '%';
            
            // æ ¹æ®ç”µé‡ç­‰çº§è®¾ç½®é¢œè‰²
            if (batteryLevel <= 5) {
                percentEl.style.color = '#D32F2F';
            } else if (batteryLevel <= 10) {
                percentEl.style.color = '#F44336';
            } else {
                percentEl.style.color = '#FF5722';
            }
            
            toast.style.display = 'block';
            
            // 6ç§’åè‡ªåŠ¨æ¶ˆå¤±
            if (toast._hideTimer) clearTimeout(toast._hideTimer);
            toast._hideTimer = setTimeout(() => {
                const innerDiv = toast.querySelector('div');
                if (innerDiv) innerDiv.style.animation = 'batterySlideOut 0.3s ease forwards';
                setTimeout(() => {
                    toast.style.display = 'none';
                    if (innerDiv) innerDiv.style.animation = 'batterySlideIn 0.35s ease';
                }, 300);
            }, 6000);
        }

        // æ ‡è®°æŸä¸ªè§’è‰²çš„æ‰€æœ‰æ¶ˆæ¯ä¸ºå·²è¯»
        async function markChatAsRead(charId) {
            try {
                const char = await db.characters.get(charId);
                if (!char) return;
                const accountId = getCurrentAccountId();
                const history = getChatHistory(char, accountId);
                let changed = false;
                history.forEach(m => {
                    if (m.role === 'char' && !m.read) {
                        m.read = true;
                        changed = true;
                    }
                });
                if (changed) {
                    await setChatHistory(char, accountId, history);
                }
            } catch (e) {
                console.warn('[markChatAsRead] æ ‡è®°å·²è¯»å¤±è´¥:', e);
            }
        }

        // --- èŠå¤©çª—å£é€»è¾‘ ---
        async function openChatWindow(charId) {
            currentChatCharId = charId;
            window._currentChatCharId = charId; // æš´éœ²ç»™å…¨å±€ï¼ˆé»˜å¥‘ç»˜ç”»ç­‰åŠŸèƒ½ä½¿ç”¨ï¼‰
            window.currentGroupChatId = null; // æ¸…é™¤ç¾¤èŠIDï¼Œç¡®ä¿æ˜¯ç§èŠæ¨¡å¼
            const char = await db.characters.get(charId);
            
            // ä¼˜å…ˆæ˜¾ç¤ºå¤‡æ³¨åï¼Œå…¶æ¬¡æ˜¾ç¤ºç½‘åï¼Œæœ€åæ˜¾ç¤ºåŸåï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰
            const _chatAid = getCurrentAccountId();
            const titleEl = document.getElementById('chat-title');
            titleEl.innerText = getCharDisplayName(char, _chatAid);
            titleEl.style.cursor = 'pointer';
            titleEl.onclick = showChatDetail; // æ¢å¤ä¸ºç§èŠè¯¦æƒ…
            
            document.getElementById('chat-window').style.display = 'flex';
            
            // âœ… åº”ç”¨è§’è‰²çš„èŠå¤©ä¸»é¢˜ï¼ˆå§‹ç»ˆè°ƒç”¨ï¼Œç¡®ä¿åˆ‡æ¢è§’è‰²æ—¶æ­£ç¡®åˆ‡æ¢/æ¸…é™¤ä¸»é¢˜ï¼‰
            await applyThemeToChat(char.chatThemeId ?? null);
            
            // è¿›å…¥èŠå¤©åï¼Œå°†åº•å±‚åˆ—è¡¨è®¾ä¸ºä¸å¯è§ï¼Œé˜²æ­¢é€æ˜æ ·å¼ç©¿é€
            setTimeout(() => {
                const wechatEl = document.getElementById('wechat-page');
                if (wechatEl) wechatEl.style.visibility = 'hidden';
            }, 320);
            
            // ç¼“å­˜å½“å‰å…³è”çš„ User ID
            currentChatUserId = char.linked_user_id || null;
            
            // âœ… æ‰“å¼€èŠå¤©æ—¶æ ‡è®°æ‰€æœ‰è§’è‰²æ¶ˆæ¯ä¸ºå·²è¯»
            markChatAsRead(charId);
            
            // âœ… æ¸…é™¤èŠå¤©åˆ—è¡¨éšè—æ ‡è®°ï¼ˆé‡æ–°æ‰“å¼€èŠå¤©æ—¶æ¢å¤æ˜¾ç¤ºï¼‰
            const accountId = getCurrentAccountId();
            if (char.chat_hidden_by_user && char.chat_hidden_by_user[accountId]) {
                char.chat_hidden_by_user[accountId] = false;
                // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°éšè—æ ‡è®°ï¼Œé˜²æ­¢è¦†ç›–è®¾ç½®
                const hiddenUpdate = { ...(char.chat_hidden_by_user) };
                db.characters.update(charId, { chat_hidden_by_user: hiddenUpdate }).catch(e => console.error('æ¸…é™¤éšè—æ ‡è®°å¤±è´¥:', e));
            }
            
            // æ ¹æ®å¥½å‹çŠ¶æ€æ˜¾ç¤ºæˆ–éšè—è¾“å…¥æ¡†
            const friendStatus = getFriendStatus(char, accountId);
            const chatFooter = document.getElementById('chat-footer');
            if (friendStatus === 'blocked' || friendStatus === 'deleted' || friendStatus === 'deleted_by_char' || friendStatus === 'blocked_by_char') {
                // æ‹‰é»‘æˆ–åˆ é™¤åï¼Œéšè—è¾“å…¥æ¡†
                chatFooter.style.display = 'none';
            } else {
                // æ­£å¸¸çŠ¶æ€ï¼Œæ˜¾ç¤ºè¾“å…¥æ¡†
                chatFooter.style.display = 'flex';
            }
            
            // âœ… è”æœºå¥½å‹ï¼šéšè—AIé­”æ³•æ£’ï¼Œç®€åŒ–èœå•ï¼ˆåªæ˜¾ç¤ºè¯­éŸ³è¾“å…¥ã€ç›¸å†Œã€è½¬è´¦ï¼‰
            const isOnlineFriend = char.isOnlineFriend === true;
            const actionPanel = document.getElementById('action-panel');
            const actionItems = actionPanel.querySelectorAll('.action-item');
            const aiMagicBtn = document.querySelector('.chat-input-bar .chat-icon-btn'); // ç¬¬ä¸€ä¸ªæŒ‰é’®æ˜¯AIé­”æ³•æ£’
            
            if (isOnlineFriend) {
                // éšè—AIé­”æ³•æ£’
                if (aiMagicBtn) aiMagicBtn.style.display = 'none';
                // åªæ˜¾ç¤ºå‰3ä¸ªèœå•é¡¹ï¼ˆè¯­éŸ³è¾“å…¥ã€ç›¸å†Œã€è½¬è´¦ï¼‰
                actionItems.forEach((item, index) => {
                    item.style.display = index < 3 ? '' : 'none';
                });
            } else {
                // æ™®é€šè§’è‰²ï¼šæ˜¾ç¤ºæ‰€æœ‰èœå•
                if (aiMagicBtn) aiMagicBtn.style.display = '';
                actionItems.forEach(item => {
                    item.style.display = '';
                });
            }
            
            // åº”ç”¨è‡ªå®šä¹‰è¾“å…¥æ¡†æ–‡æ¡ˆ
            const chatInputBox = document.getElementById('chat-input-box');
            if (chatInputBox) {
                chatInputBox.placeholder = char.input_placeholder || 'å‘é€æ¶ˆæ¯...';
            }
            
            await renderChatBody(char);
            
            // âœ… ç¡®ä¿èŠå¤©èƒŒæ™¯å›¾å§‹ç»ˆè¢«åº”ç”¨ï¼ˆé˜²æ­¢ applyThemeToChat æ¸…é™¤åã€renderChatBody ä¼˜åŒ–è·³è¿‡æ—¶ä¸¢å¤±ï¼‰
            applyChatBackground(char);
            
            // ä½ç”µé‡æé†’æ£€æŸ¥ï¼ˆè¯»å–çœŸå®è®¾å¤‡ç”µé‡ï¼‰
            if (!isOnlineFriend) {
                setTimeout(() => {
                    checkAndShowLowBattery();
                }, 800);
            }
        }

        // ====== æš´éœ²å…¨å±€è¿½åŠ æ–¹æ³•ï¼Œä¾›è´­ç‰©ç­‰å¤–éƒ¨IIFEä½¿ç”¨ï¼ˆä¸åˆ·æ–°é¡µé¢ï¼‰ ======
        window._appendShopCardToChat = async function(friendCharId, msgObj) {
            // 1) å¦‚æœå½“å‰æ­£åœ¨å’Œè¿™ä¸ªå¥½å‹èŠå¤©ï¼Œç›´æ¥è¿½åŠ æ¶ˆæ¯åˆ°èŠå¤©DOM
            if (friendCharId && currentChatCharId === friendCharId) {
                const body = document.getElementById('chat-body');
                if (body) {
                    const char = await db.characters.get(friendCharId);
                    if (char) {
                        const accountId = getCurrentAccountId();
                        const history = getChatHistory(char, accountId);
                        const index = history.length - 1;
                        const prevMsg = index > 0 ? history[index - 1] : null;
                        const prevMsgTime = prevMsg ? prevMsg.time : null;

                        const userAvatarUrl = await getUserAvatarUrl(char.linked_user_id);
                        const charAvatar = getCharAvatar(char, accountId) || char.avatar || '';

                        // æ—¶é—´æˆ³
                        const timeOffset = getEffectiveTimeOffset(char);
                        if (shouldShowTimestamp(msgObj.time, prevMsgTime)) {
                            const ts = document.createElement('div');
                            ts.className = 'message-timestamp';
                            ts.textContent = formatMessageTime(msgObj.time, prevMsgTime, timeOffset);
                            body.appendChild(ts);
                        }

                        const row = createMessageElement(msgObj, index, charAvatar, userAvatarUrl, prevMsgTime, char.name || 'AI');
                        body.appendChild(row);
                        body.scrollTop = body.scrollHeight;
                    }
                }
            }

            // 2) æ›´æ–°èŠå¤©åˆ—è¡¨ä¸­è¯¥å¥½å‹çš„æœ€åä¸€æ¡æ¶ˆæ¯ï¼ˆä»…ä¿®æ”¹DOMæ–‡æœ¬ï¼Œä¸é‡æ–°æ¸²æŸ“æ•´ä¸ªåˆ—è¡¨ï¼‰
            const listItem = document.querySelector(`.wechat-list-item-content[data-char-id="${friendCharId}"]`);
            if (listItem) {
                const msgEl = listItem.querySelector('.wc-list-lastmsg');
                const timeEl = listItem.querySelector('.wc-list-time');
                if (msgEl) {
                    let displayText = '[ä»£ä»˜è¯·æ±‚]';
                    try {
                        const pd = JSON.parse(msgObj.content);
                        if (pd.isShare) displayText = '[è´­ç‰©åˆ†äº«]';
                        else if (pd.isGift) displayText = '[è´­ç‰©ç¤¼ç‰©]';
                    } catch(e) {}
                    msgEl.textContent = displayText;
                }
                if (timeEl) {
                    const d = new Date(msgObj.time);
                    const now = new Date();
                    timeEl.textContent = d.toDateString() === now.toDateString()
                        ? `${d.getHours()}:${d.getMinutes().toString().padStart(2,'0')}`
                        : `${d.getMonth()+1}/${d.getDate()}`;
                }
            }
        };

        // --- æˆ³ä¸€æˆ³åŠŸèƒ½ ---
        let currentPokeCharName = '';
        
        async function showPokeModal(charName) {
            currentPokeCharName = charName;
            
            // è·å–å½“å‰ç”¨æˆ·å
            const accountId = getCurrentAccountId();
            const myChar = await db.characters.get(parseInt(accountId));
            const userName = myChar ? (myChar.nick || myChar.name) : 'ç”¨æˆ·';
            
            // è®¾ç½®åå­—
            document.getElementById('poke-user-name').textContent = userName;
            document.getElementById('poke-char-name').textContent = charName;
            
            // è®¾ç½®é»˜è®¤å€¼
            document.getElementById('poke-action').value = 'æˆ³äº†æˆ³';
            document.getElementById('poke-part').value = 'è„‘è¢‹';
            
            // æ›´æ–°é¢„è§ˆ
            updatePokePreview();
            
            // æ˜¾ç¤ºå¼¹çª—
            document.getElementById('poke-modal').style.display = 'flex';
            
            // ç›‘å¬è¾“å…¥å˜åŒ–
            document.getElementById('poke-action').oninput = updatePokePreview;
            document.getElementById('poke-part').oninput = updatePokePreview;
        }
        
        function updatePokePreview() {
            const userName = document.getElementById('poke-user-name').textContent;
            const charName = document.getElementById('poke-char-name').textContent;
            const action = document.getElementById('poke-action').value || 'æˆ³äº†æˆ³';
            const part = document.getElementById('poke-part').value || 'è„‘è¢‹';
            
            const preview = `${userName}${action}${charName}çš„${part}`;
            document.getElementById('poke-preview').textContent = preview;
        }
        
        async function confirmPoke() {
            const action = document.getElementById('poke-action').value || 'æˆ³äº†æˆ³';
            const part = document.getElementById('poke-part').value || 'è„‘è¢‹';
            const userName = document.getElementById('poke-user-name').textContent;
            const charName = currentPokeCharName;
            
            // å…³é—­å¼¹çª—
            document.getElementById('poke-modal').style.display = 'none';
            
            // ç”Ÿæˆæˆ³ä¸€æˆ³ç³»ç»Ÿæ¶ˆæ¯
            const pokeText = `${userName}${action}${charName}çš„${part}`;
            
            // è·å–å½“å‰è§’è‰²
            if (!currentChatCharId) return;
            const char = await db.characters.get(currentChatCharId);
            if (!char) return;
            
            const accountId = getCurrentAccountId();
            let history = getChatHistory(char, accountId);
            
            // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯
            const sysMsg = { 
                role: 'system', 
                content: pokeText, 
                time: Date.now(),
                type: 'poke'
            };
            
            history.push(sysMsg);
            await setChatHistory(char, accountId, history);
            
            // åœ¨ç•Œé¢ä¸Šæ˜¾ç¤ºç³»ç»Ÿæ¶ˆæ¯
            await appendMessageToUI('system', pokeText);
            
            console.log('[Poke] æˆ³ä¸€æˆ³:', pokeText);
        }
        
        // å…³é—­å¼¹çª—çš„é€šç”¨å‡½æ•°
        window.closeModal = function(modalId) {
            document.getElementById(modalId).style.display = 'none';
        };

        // --- èŠå¤©è¯¦æƒ…é¡µé€»è¾‘ ---
        // ç»Ÿä¸€å…¥å£ï¼šæ ¹æ®å½“å‰æ˜¯ç§èŠè¿˜æ˜¯ç¾¤èŠæ˜¾ç¤ºå¯¹åº”è¯¦æƒ…é¡µ
        function showChatOrGroupDetail() {
            if (window.currentGroupChatId) {
                showGroupDetail(window.currentGroupChatId);
            } else if (currentChatCharId) {
                showChatDetail();
            }
        }
        
        async function showChatDetail() {
            if (!currentChatCharId) return;
            const char = await db.characters.get(currentChatCharId);
            if (!char) return;

            document.getElementById('chat-detail-page').style.display = 'flex';
            
            // âœ… è”æœºå¥½å‹ï¼šéšè—ä¸ç›¸å…³çš„è®¾ç½®é¡¹
            const isOnlineFriend = char.isOnlineFriend === true;
            const detailPage = document.getElementById('chat-detail-page');
            const detailGroups = detailPage.querySelectorAll('.detail-group');
            
            // æ˜¾ç¤ºæˆ–éšè—ç‰¹å®šçš„è®¾ç½®ç»„ï¼ˆæŒ‰é¡ºåºï¼šå¤‡æ³¨(0)ã€æ¡£æ¡ˆå…³è”(1)ã€ä¸»åŠ¨èŠå¤©(2)ã€æŸ¥å²—ä¿®ç½—åœº(3)ã€è‡ªä¸»æ¢å¤´åƒ(4)ã€è‡ªä¸»æ´»åŠ¨(5)ã€æœ‹å‹åœˆé¢‘ç‡(6)ã€AIä¸Šä¸‹æ–‡(7)ã€å›å¤æ¡æ•°(8)ã€è¡¨æƒ…åŒ…(9)ã€èŠå¤©èƒŒæ™¯(10)...ï¼‰
            detailGroups.forEach((group, index) => {
                if (isOnlineFriend) {
                    // è”æœºå¥½å‹åªæ˜¾ç¤ºå¤‡æ³¨(0)ã€æ¡£æ¡ˆå…³è”(1)å’Œæœ€åå‡ ç»„
                    // éšè—ï¼šä¸»åŠ¨èŠå¤©(2)ã€æŸ¥å²—ä¿®ç½—åœº(3)ã€è‡ªä¸»æ¢å¤´åƒ(4)ã€è‡ªä¸»æ´»åŠ¨(5)ã€æœ‹å‹åœˆé¢‘ç‡(6)ã€AIä¸Šä¸‹æ–‡(7)ã€å›å¤æ¡æ•°(8)ã€è¡¨æƒ…åŒ…(9)ã€èŠå¤©èƒŒæ™¯(10)
                    if (index >= 2 && index <= 10) {
                        group.style.display = 'none';
                    } else {
                        group.style.display = '';
                    }
                } else {
                    group.style.display = '';
                }
            });
            
            // 1. å›æ˜¾åŸºæœ¬ä¿¡æ¯ï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰
            const _detailAid = getCurrentAccountId();
            document.getElementById('detail-char-remark').value = getCharRemark(char, _detailAid);
            document.getElementById('detail-input-placeholder').value = char.input_placeholder || '';
            document.getElementById('detail-char-realname').innerText = `åŸå: ${char.name}`;
            // å›æ˜¾ç½‘åï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰
            document.getElementById('detail-char-nickname').innerText = getCharWxNickname(char, _detailAid) || char.name || 'æœªè®¾ç½®';
            // å›æ˜¾ä¸ªæ€§ç­¾å
            document.getElementById('detail-char-signature').innerText = char.wx_signature || 'è¿™ä¸ªäººä»€ä¹ˆä¹Ÿæ²¡æœ‰ç•™ä¸‹';
            const _detailAvatar = getCharAvatar(char, _detailAid);
            if (_detailAvatar) {
                document.getElementById('detail-char-avatar').style.backgroundImage = `url(${_detailAvatar})`;
            } else {
                document.getElementById('detail-char-avatar').style.backgroundImage = '';
            }

            // 2. åŠ è½½ä¸–ç•Œä¹¦åˆ—è¡¨ï¼ˆå¤šé€‰ï¼‰â€”â€”åªæ˜¾ç¤ºå•äººä¸–ç•Œä¹¦ï¼Œå…¨å±€ä¸–ç•Œä¹¦è‡ªåŠ¨ç”Ÿæ•ˆ
            const lorebooks = await db.lorebooks.toArray();
            const lbList = document.getElementById('detail-lorebook-list');
            lbList.innerHTML = '';
            
            // å…¼å®¹æ—§æ•°æ®ï¼šå¦‚æœlorebookIdå­˜åœ¨ä½†lorebookIdsä¸å­˜åœ¨ï¼Œè½¬æ¢ä¸ºæ•°ç»„
            const selectedIds = char.lorebookIds || (char.lorebookId ? [char.lorebookId] : []);
            
            // åˆ†ç¦»å…¨å±€å’Œå•äººä¸–ç•Œä¹¦
            const personalLorebooks = lorebooks.filter(lb => lb.scope !== 'global');
            const globalLorebooks = lorebooks.filter(lb => lb.scope === 'global');
            
            // æ˜¾ç¤ºå…¨å±€ä¸–ç•Œä¹¦æç¤º
            if (globalLorebooks.length > 0) {
                const globalHint = document.createElement('div');
                globalHint.style.cssText = 'padding:6px 8px; color:#34c759; font-size:12px; background:#f0fff4; border-radius:6px; margin-bottom:6px;';
                globalHint.innerHTML = `ğŸŒ ${globalLorebooks.length} ä¸ªå…¨å±€ä¸–ç•Œä¹¦å·²è‡ªåŠ¨ç”Ÿæ•ˆï¼š${globalLorebooks.map(g => g.name).join('ã€')}`;
                lbList.appendChild(globalHint);
            }
            
            if (personalLorebooks.length === 0 && globalLorebooks.length === 0) {
                lbList.innerHTML = '<div style="padding:8px; color:#999; font-size:12px; text-align:center;">æš‚æ— ä¸–ç•Œä¹¦</div>';
            } else if (personalLorebooks.length === 0) {
                // åªæœ‰å…¨å±€ä¸–ç•Œä¹¦ï¼Œä¸éœ€è¦é¢å¤–æ˜¾ç¤º
            } else {
                personalLorebooks.forEach(lb => {
                    const label = document.createElement('label');
                    label.style.cssText = 'display:flex; align-items:center; padding:8px; cursor:pointer; border-radius:6px; margin-bottom:4px;';
                    label.style.background = selectedIds.includes(lb.id) ? '#f0f0f5' : 'transparent';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = lb.id;
                    checkbox.checked = selectedIds.includes(lb.id);
                    checkbox.style.marginRight = '8px';
                    checkbox.onchange = () => {
                        label.style.background = checkbox.checked ? '#f0f0f5' : 'transparent';
                        updateLorebookCount();
                    };
                    
                    const name = document.createElement('span');
                    name.textContent = lb.name;
                    name.style.fontSize = '14px';
                    name.style.color = '#333';
                    
                    label.appendChild(checkbox);
                    label.appendChild(name);
                    lbList.appendChild(label);
                });
            }
            
            updateLorebookCount();

            // 3. å›æ˜¾ä¸»åŠ¨èŠå¤©è®¾ç½®
            document.getElementById('detail-auto-chat-switch').checked = !!char.auto_reply_enabled;
            document.getElementById('detail-auto-chat-interval').value = char.auto_reply_interval || '';
            
            // 3.5. å›æ˜¾å¤–è¯­ç¿»è¯‘æ¨¡å¼è®¾ç½®
            document.getElementById('detail-foreign-lang-switch').checked = !!char.foreign_lang_mode;
            
            // 4. å›æ˜¾AIæŸ¥å²—è®¾ç½®
            document.getElementById('detail-allow-check-switch').checked = !!char.allow_ai_check_account;
            
            // 4.5. å›æ˜¾ä¿®ç½—åœºæ¨¡å¼è®¾ç½®
            document.getElementById('detail-allow-shura-switch').checked = !!char.allow_shura_mode;
            
            // 4.6. å›æ˜¾è‡ªä¸»æ¢å¤´åƒè®¾ç½®
            document.getElementById('detail-allow-avatar-switch').checked = !!char.allow_auto_avatar;
            
            // 4.65. å›æ˜¾è§’è‰²è‡ªä¸»æ´»åŠ¨è®¾ç½®
            document.getElementById('detail-allow-autonomous-switch').checked = !!char.allow_autonomous_activity;
            
            // 4.66. å›æ˜¾å®šæ—¶è‡ªä¸»æ´»åŠ¨è®¾ç½®
            document.getElementById('detail-scheduled-activity-switch').checked = !!char.scheduled_activity_enabled;
            document.getElementById('detail-scheduled-activity-interval').value = char.scheduled_activity_interval || '';
            
            // 4.7. å›æ˜¾æœ‹å‹åœˆé¢‘ç‡è®¾ç½®
            document.getElementById('detail-moments-frequency').value = char.moments_frequency || 'off';
            
            // 5. å›æ˜¾ä¸Šä¸‹æ–‡æ¡æ•°è®¾ç½®ï¼ˆé»˜è®¤20æ¡ï¼‰
            document.getElementById('detail-context-count').value = char.context_message_count || 20;
            
            // 5.5. å›æ˜¾å›å¤æ¶ˆæ¯æ¡æ•°è®¾ç½®ï¼ˆé»˜è®¤1~3æ¡ï¼‰
            document.getElementById('detail-reply-min-count').value = char.reply_min_count || 1;
            document.getElementById('detail-reply-max-count').value = char.reply_max_count || 3;

            // 6. åŠ è½½æŒ‚è½½çš„è¡¨æƒ…åŒ…åº“
            updateMountedStickerCount();
            
            // 6.5 åŠ è½½æŒ‚è½½çš„ç”¨æˆ·æ¡£æ¡ˆ
            updateMountedUserDisplay();
            
            // 7. æ›´æ–°è§†é¢‘é€šè¯è®°å½•æ•°é‡
            updateVideoCallRecordCount();
            
            // 7. åŠ è½½è‡ªå®šä¹‰æ°”æ³¡CSS
            document.getElementById('detail-bubble-css').value = char.custom_bubble_css || '';
            // åˆå§‹åŒ–é¢„è§ˆåŒº
            previewChatBubbleCSS();
            
            // 8. åŠ è½½èŠå¤©èƒŒæ™¯å›¾
            const bgPreview = document.getElementById('detail-chat-bg-preview');
            if (char.chat_background) {
                bgPreview.style.backgroundImage = `url(${char.chat_background})`;
                bgPreview.textContent = '';
            } else {
                bgPreview.style.backgroundImage = '';
                bgPreview.textContent = 'æš‚æ— èƒŒæ™¯å›¾';
            }
            
            // 9. åŠ è½½æ°”æ³¡æ ·å¼é€‰æ‹©
            const bubbleStyle = char.bubble_style || 'default';
            document.querySelectorAll('.bubble-style-option').forEach(el => {
                el.classList.remove('selected');
                if (el.dataset.style === bubbleStyle) {
                    el.classList.add('selected');
                }
            });
            
            // 10. åŠ è½½è‡ªåŠ¨æ€»ç»“è®¾ç½®
            document.getElementById('detail-auto-summary-switch').checked = !!char.auto_summary_enabled;
            document.getElementById('detail-summary-interval').value = char.summary_interval || '';
            
            // æ›´æ–°æ€»ç»“è®¡æ•°
            const accountId = getCurrentAccountId();
            if (accountId) {
                await updateSummaryCount('private', currentChatCharId, accountId);
            }
            
            // 11. æ›´æ–°èŠå¤©ä¸»é¢˜æ˜¾ç¤º
            await updateChatDetailThemeDisplay();

            // 12. èŠå¤©ç»Ÿè®¡ï¼šæ¶ˆæ¯æ¡æ•° & é¢„ä¼° tokens
            try {
                const _statsAid = getCurrentAccountId();
                const _statsHistory = getChatHistory(char, _statsAid);
                const msgCount = _statsHistory.length;
                let totalChars = 0;
                _statsHistory.forEach(m => {
                    // è·³è¿‡éæ–‡æœ¬æ¶ˆæ¯ï¼ˆè½¬è´¦ã€çº¢åŒ…ã€å¡ç‰‡ã€å›¾ç‰‡ã€è¯­éŸ³ç­‰ï¼‰ï¼Œè¿™äº›æ¶ˆæ¯contentæ˜¯JSON/base64ï¼Œä¸åº”è®¡å…¥tokens
                    if (m.type && m.type !== 'text') return; // æœ‰typeä¸”ä¸æ˜¯textçš„ç‰¹æ®Šæ¶ˆæ¯ï¼Œè·³è¿‡
                    const txt = (typeof m.content === 'string') ? m.content : '';
                    // è·³è¿‡å›¾ç‰‡/è¯­éŸ³ç­‰ç‰¹æ®Šå†…å®¹æ ‡è®°
                    if (txt.startsWith('[img:') || txt.startsWith('[imgcard:') || txt.startsWith('[voice:') || txt.startsWith('data:') || txt.startsWith('[emei_') || txt.startsWith('[payment_request]') || txt.startsWith('[couple_avatar_card]')) return;
                    // è·³è¿‡çœ‹èµ·æ¥åƒJSONçš„å¤§æ®µå†…å®¹ï¼ˆè½¬è´¦ç­‰æœªæ ‡è®°typeçš„è€æ¶ˆæ¯ï¼‰
                    const trimmed = txt.trim();
                    if (trimmed.startsWith('{') && trimmed.length > 200) return;
                    totalChars += txt.length;
                });
                // ç²—ä¼° tokensï¼šä¸­æ–‡ â‰ˆ 1.5 token/å­—ï¼Œè‹±æ–‡ â‰ˆ 0.25 token/å­—ï¼Œå–æŠ˜ä¸­ â‰ˆ 0.7
                // è¿™é‡Œç”¨ç®€å•å…¬å¼ï¼šæ¯ä¸ªå­—ç¬¦ç®— 0.7 tokenï¼Œæœ€ç»ˆå–æ•´
                const estimatedTokens = Math.round(totalChars * 0.7);
                document.getElementById('detail-chat-msg-count').textContent = msgCount + ' æ¡';
                // æ ¼å¼åŒ–æ•°å­—ï¼šè¶…è¿‡ 10000 æ˜¾ç¤º kï¼Œè¶…è¿‡ 1000000 æ˜¾ç¤º M
                if (estimatedTokens >= 1000000) {
                    document.getElementById('detail-chat-token-count').textContent = (estimatedTokens / 1000000).toFixed(1) + 'M';
                } else if (estimatedTokens >= 10000) {
                    document.getElementById('detail-chat-token-count').textContent = (estimatedTokens / 1000).toFixed(1) + 'k';
                } else {
                    document.getElementById('detail-chat-token-count').textContent = estimatedTokens.toLocaleString();
                }
            } catch(e) {
                console.warn('[showChatDetail] ç»Ÿè®¡æ¶ˆæ¯æ¡æ•°/tokenså‡ºé”™:', e);
            }
        }
        
        // é€‰æ‹©æ°”æ³¡æ ·å¼
        function selectBubbleStyle(style) {
            document.querySelectorAll('.bubble-style-option').forEach(el => {
                el.classList.remove('selected');
                if (el.dataset.style === style) {
                    el.classList.add('selected');
                }
            });
        }

        function hideChatDetail() {
            document.getElementById('chat-detail-page').style.display = 'none';
        }

        function toggleLorebookList() {
            const list = document.getElementById('detail-lorebook-list');
            const toggle = document.getElementById('detail-lorebook-toggle');
            if (list.style.display === 'none' || !list.style.display) {
                list.style.display = 'block';
                toggle.textContent = 'æ”¶èµ·';
            } else {
                list.style.display = 'none';
                toggle.textContent = 'å±•å¼€';
            }
        }

        function updateLorebookCount() {
            const checkboxes = document.querySelectorAll('#detail-lorebook-list input[type="checkbox"]:checked');
            const count = checkboxes.length;
            document.getElementById('detail-lorebook-count').textContent = `${count}ä¸ª`;
        }

async function saveChatDetail() {
    if (!currentChatCharId) return;
    const charId = currentChatCharId;
    const char = await db.characters.get(charId);
    if (!char) return;
    
    const remark = document.getElementById('detail-char-remark').value.trim();
    
    // è·å–é€‰ä¸­çš„ä¸–ç•Œä¹¦IDæ•°ç»„
    const checkboxes = document.querySelectorAll('#detail-lorebook-list input[type="checkbox"]:checked');
    const lorebookIds = Array.from(checkboxes).map(cb => parseInt(cb.value));
    
    // ä¸»åŠ¨èŠå¤©è®¾ç½®
    const autoEnabled = document.getElementById('detail-auto-chat-switch').checked;
    const autoInterval = parseInt(document.getElementById('detail-auto-chat-interval').value);
    // ä¸Šä¸‹æ–‡æ¡æ•°è®¾ç½®
    const contextCount = parseInt(document.getElementById('detail-context-count').value);
    
    // å›å¤æ¶ˆæ¯æ¡æ•°èŒƒå›´è®¾ç½®
    const replyMinCount = parseInt(document.getElementById('detail-reply-min-count').value);
    const replyMaxCount = parseInt(document.getElementById('detail-reply-max-count').value);
    
    // è¾“å…¥æ¡†æ–‡æ¡ˆè®¾ç½®
    const inputPlaceholder = document.getElementById('detail-input-placeholder').value.trim();
    
    // å¤–è¯­ç¿»è¯‘æ¨¡å¼è®¾ç½®
    const foreignLangMode = document.getElementById('detail-foreign-lang-switch').checked;
    
    // AIæŸ¥å²—è®¾ç½®
    const allowCheckEnabled = document.getElementById('detail-allow-check-switch').checked;
    
    // ä¿®ç½—åœºæ¨¡å¼è®¾ç½®
    const allowShuraEnabled = document.getElementById('detail-allow-shura-switch').checked;
    
    // è‡ªä¸»æ¢å¤´åƒè®¾ç½®
    const allowAutoAvatar = document.getElementById('detail-allow-avatar-switch').checked;
    
    // è§’è‰²è‡ªä¸»æ´»åŠ¨è®¾ç½®
    const allowAutonomousActivity = document.getElementById('detail-allow-autonomous-switch').checked;
    
    // å®šæ—¶è‡ªä¸»æ´»åŠ¨è®¾ç½®
    const scheduledActivityEnabled = document.getElementById('detail-scheduled-activity-switch').checked;
    const scheduledActivityInterval = parseInt(document.getElementById('detail-scheduled-activity-interval').value);
    
    // æœ‹å‹åœˆé¢‘ç‡è®¾ç½®
    const momentsFrequency = document.getElementById('detail-moments-frequency').value;
    
    // è‡ªåŠ¨æ€»ç»“è®¾ç½®
    const autoSummaryEnabled = document.getElementById('detail-auto-summary-switch').checked;
    const summaryInterval = parseInt(document.getElementById('detail-summary-interval').value);

    const accountId = getCurrentAccountId();
    
    // ä¿å­˜è‡ªå®šä¹‰æ°”æ³¡CSSï¼ˆä¸¥æ ¼è¿‡æ»¤JSï¼‰
    const bubbleCSS = document.getElementById('detail-bubble-css').value;
    
    // ä¿å­˜æ°”æ³¡æ ·å¼é€‰æ‹©
    const selectedBubbleOption = document.querySelector('.bubble-style-option.selected');

    // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°è®¾ç½®å­—æ®µï¼Œé˜²æ­¢å¹¶å‘å†™å…¥è¦†ç›–èŠå¤©è®°å½•ç­‰å…¶ä»–æ•°æ®
    // æ„å»ºå¤‡æ³¨å­—æ®µï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰
    const remarkUpdate = {};
    if (!accountId) {
        remarkUpdate.remark = remark;
    } else {
        // éœ€è¦è¯»å–ç°æœ‰çš„ remark_by_user å¹¶åˆå¹¶
        const existingRemarkByUser = char.remark_by_user || {};
        existingRemarkByUser[accountId] = remark;
        remarkUpdate.remark_by_user = existingRemarkByUser;
    }

    const updatePayload = {
        ...remarkUpdate,
        lorebookIds: lorebookIds.length > 0 ? lorebookIds : null,
        lorebookId: lorebookIds.length > 0 ? lorebookIds[0] : null,
        auto_reply_enabled: autoEnabled,
        auto_reply_interval: autoInterval > 0 ? autoInterval : null,
        context_message_count: contextCount > 0 ? contextCount : 20,
        reply_min_count: (replyMinCount > 0 && replyMinCount <= 50) ? replyMinCount : 1,
        reply_max_count: (replyMaxCount > 0 && replyMaxCount <= 50) ? replyMaxCount : 3,
        input_placeholder: inputPlaceholder || '',
        foreign_lang_mode: foreignLangMode,
        allow_ai_check_account: allowCheckEnabled,
        allow_shura_mode: allowShuraEnabled,
        allow_auto_avatar: allowAutoAvatar,
        allow_autonomous_activity: allowAutonomousActivity,
        scheduled_activity_enabled: scheduledActivityEnabled,
        scheduled_activity_interval: scheduledActivityInterval > 0 ? scheduledActivityInterval : null,
        moments_frequency: momentsFrequency,
        auto_summary_enabled: autoSummaryEnabled,
        summary_interval: summaryInterval > 0 ? summaryInterval : 50,
        custom_bubble_css: sanitizeCSS(bubbleCSS),
        bubble_style: selectedBubbleOption ? selectedBubbleOption.dataset.style : 'default'
    };

    try {
        await db.characters.update(charId, updatePayload);
        console.log('[saveChatDetail] âœ… è®¾ç½®å·²ä¿å­˜ï¼ˆä»…æ›´æ–°è®¾ç½®å­—æ®µï¼‰');
    } catch (err) {
        console.error('[saveChatDetail] âŒ è®¾ç½®ä¿å­˜å¤±è´¥:', err);
        try { showToast('âš ï¸ è®¾ç½®ä¿å­˜å¤±è´¥ï¼Œè¯·é‡è¯•'); } catch(_) {}
        return;
    }
    
    // å®æ—¶æ›´æ–°èŠå¤©æ ‡é¢˜ï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰
    document.getElementById('chat-title').innerText = getCharDisplayName(char, getCurrentAccountId());
    
    // å®æ—¶æ›´æ–°è¾“å…¥æ¡†æ–‡æ¡ˆ
    const chatInputBox = document.getElementById('chat-input-box');
    if (chatInputBox) {
        chatInputBox.placeholder = inputPlaceholder || 'å‘é€æ¶ˆæ¯...';
    }
    
    // å¦‚æœå½“å‰æ­£åœ¨æŸ¥çœ‹è¿™ä¸ªèŠå¤©ï¼Œç«‹å³åº”ç”¨æ ·å¼
    if (currentChatCharId === charId) {
        // åˆå¹¶æ›´æ–°åçš„å­—æ®µåˆ°charå¯¹è±¡ä»¥ä¾¿applyCustomStylesä½¿ç”¨
        Object.assign(char, updatePayload);
        applyCustomStyles(char);
    }
    // åˆ·æ–°åˆ—è¡¨ï¼ˆå¦‚æœæ­¤æ—¶å¾®ä¿¡åˆ—è¡¨å¯è§ï¼‰
    // ...
}

// ä¿å­˜è®¾ç½®æŒ‰é’®ï¼ˆå¸¦Toaståé¦ˆï¼‰
async function saveChatDetailWithToast() {
    const btn = document.getElementById('detail-save-btn');
    if (btn) {
        btn.style.pointerEvents = 'none';
        btn.style.opacity = '0.4';
    }
    try {
        await saveChatDetail();
        showToast('âœ… è®¾ç½®å·²ä¿å­˜');
    } catch (e) {
        console.error('[saveChatDetailWithToast] ä¿å­˜å¤±è´¥:', e);
    } finally {
        if (btn) {
            btn.style.pointerEvents = '';
            btn.style.opacity = '1';
        }
    }
}

// æ˜¾ç¤ºæŒ‚è½½è¡¨æƒ…åŒ…åº“å¼¹çª—
async function showMountStickerModal() {
    if (!currentChatCharId) return;
    
    const char = await db.characters.get(currentChatCharId);
    const mountedIds = char.mounted_sticker_categories || [];
    
    const modal = document.getElementById('mount-sticker-modal');
    const listContainer = document.getElementById('mount-sticker-list');
    
    if (!modal || !listContainer) {
        console.error('æŒ‚è½½è¡¨æƒ…åŒ…åº“å¼¹çª—å…ƒç´ æœªæ‰¾åˆ°');
        return;
    }
    
    // è·å–æ‰€æœ‰è¡¨æƒ…åŒ…åˆ†ç±»
    const categories = await db.sticker_categories.toArray();
    
    if (categories.length === 0) {
        listContainer.innerHTML = '<div style="text-align:center; color:#999; padding:40px;">æš‚æ— è¡¨æƒ…åŒ…åˆ†ç±»<br>è¯·å…ˆå»ã€æˆ‘-è¡¨æƒ…ã€‘åˆ›å»ºåˆ†ç±»</div>';
    } else {
        listContainer.innerHTML = categories.map(cat => {
            const isMounted = mountedIds.includes(cat.id);
            const stickerCount = (cat.stickers || []).length;
            return `
                <label style="display:flex; align-items:center; padding:12px; background:${isMounted ? '#f0f0f5' : '#fff'}; border:1px solid #f0f0f0; border-radius:8px; cursor:pointer; transition:background 0.2s;">
                    <input type="checkbox" value="${cat.id}" ${isMounted ? 'checked' : ''} style="margin-right:12px; width:18px; height:18px; cursor:pointer;" onchange="this.parentElement.style.background = this.checked ? '#f0f0f5' : '#fff'">
                    <div style="flex:1;">
                        <div style="font-size:15px; font-weight:500; color:#333; margin-bottom:4px;">${cat.name}</div>
                        <div style="font-size:12px; color:#999;">${stickerCount} ä¸ªè¡¨æƒ…</div>
                    </div>
                </label>
            `;
        }).join('');
    }
    
    modal.style.display = 'flex';
    
    // ç‚¹å‡»å¤–éƒ¨åŒºåŸŸå…³é—­å¼¹çª—
    modal.onclick = function(e) {
        if (e.target === modal) {
            hideMountStickerModal();
        }
    };
}

// éšè—æŒ‚è½½è¡¨æƒ…åŒ…åº“å¼¹çª—
function hideMountStickerModal() {
    const modal = document.getElementById('mount-sticker-modal');
    if (modal) modal.style.display = 'none';
}

// ä¿å­˜æŒ‚è½½çš„è¡¨æƒ…åŒ…åˆ†ç±»
async function saveMountedStickers() {
    if (!currentChatCharId) return;
    
    const checkboxes = document.querySelectorAll('#mount-sticker-list input[type="checkbox"]:checked');
    const mountedIds = Array.from(checkboxes).map(cb => parseInt(cb.value));
    
    // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°æŒ‚è½½è¡¨æƒ…åŒ…å­—æ®µï¼Œé˜²æ­¢è¦†ç›–è®¾ç½®
    await db.characters.update(currentChatCharId, {
        mounted_sticker_categories: mountedIds.length > 0 ? mountedIds : null
    }).catch(err => {
        console.error('[saveMountedStickers] updateå¤±è´¥:', err);
    });
    
    updateMountedStickerCount();
    hideMountStickerModal();
    
    // åˆ·æ–°è¡¨æƒ…åŒ…é¢æ¿
    await updateChatStickerPanel();
}

// æ›´æ–°æŒ‚è½½è¡¨æƒ…åŒ…æ•°é‡æ˜¾ç¤º
async function updateMountedStickerCount() {
    if (!currentChatCharId) return;
    
    const char = await db.characters.get(currentChatCharId);
    const mountedIds = char.mounted_sticker_categories || [];
    const countEl = document.getElementById('mounted-sticker-count');
    
    if (!countEl) return;
    
    if (mountedIds.length === 0) {
        countEl.innerText = 'æœªæŒ‚è½½';
    } else {
        // è®¡ç®—æ€»è¡¨æƒ…æ•°
        let totalStickers = 0;
        for (const catId of mountedIds) {
            const cat = await db.sticker_categories.get(catId);
            if (cat && cat.stickers) {
                totalStickers += cat.stickers.length;
            }
        }
        countEl.innerText = `${mountedIds.length}ä¸ªåˆ†ç±» (${totalStickers}ä¸ªè¡¨æƒ…)`;
    }
}

// ç¡®ä¿å‡½æ•°åœ¨å…¨å±€ä½œç”¨åŸŸå¯è®¿é—®
window.showMountStickerModal = showMountStickerModal;
window.hideMountStickerModal = hideMountStickerModal;
window.saveMountedStickers = saveMountedStickers;

// æ˜¾ç¤ºæŒ‚è½½ç”¨æˆ·æ¡£æ¡ˆå¼¹çª—
async function showMountUserModal() {
    if (!currentChatCharId) return;
    
    const char = await db.characters.get(currentChatCharId);
    const currentUserId = char.linked_user_id || null;
    
    const modal = document.getElementById('mount-user-modal');
    const listContainer = document.getElementById('mount-user-list');
    
    if (!modal || !listContainer) {
        console.error('æŒ‚è½½ç”¨æˆ·æ¡£æ¡ˆå¼¹çª—å…ƒç´ æœªæ‰¾åˆ°');
        return;
    }
    
    // è·å–æ‰€æœ‰Userç±»å‹æ¡£æ¡ˆ
    const users = await db.characters.where('type').equals('user').toArray();
    
    if (users.length === 0) {
        listContainer.innerHTML = '<div style="text-align:center; color:#999; padding:40px;">æš‚æ— ç”¨æˆ·æ¡£æ¡ˆ<br>è¯·å…ˆå»ã€è§’è‰²æ¡£æ¡ˆ-Userã€‘åˆ›å»ºç”¨æˆ·</div>';
    } else {
        listContainer.innerHTML = users.map(user => {
            const isSelected = currentUserId === user.id;
            const avatarStyle = user.avatar ? `background-image:url(${user.avatar}); background-size:cover; background-position:center;` : 'background:#f0f0f0;';
            return `
                <div onclick="selectMountUser(${user.id})" style="display:flex; align-items:center; padding:12px; background:${isSelected ? '#ffe4e8' : '#fff'}; border:2px solid ${isSelected ? 'var(--ins-pink)' : '#f0f0f0'}; border-radius:12px; cursor:pointer; transition:all 0.2s;">
                    <div style="width:48px; height:48px; border-radius:50%; ${avatarStyle} margin-right:12px; flex-shrink:0;"></div>
                    <div style="flex:1; min-width:0;">
                        <div style="font-size:15px; font-weight:500; color:#333; margin-bottom:4px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${user.name}</div>
                        <div style="font-size:12px; color:#999; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${user.description ? user.description.substring(0, 30) + (user.description.length > 30 ? '...' : '') : 'æš‚æ— ç®€ä»‹'}</div>
                    </div>
                    ${isSelected ? '<div style="color:var(--ins-pink); font-size:20px; margin-left:8px;">âœ“</div>' : ''}
                </div>
            `;
        }).join('');
    }
    
    modal.style.display = 'flex';
    
    // ç‚¹å‡»å¤–éƒ¨åŒºåŸŸå…³é—­å¼¹çª—
    modal.onclick = function(e) {
        if (e.target === modal) {
            hideMountUserModal();
        }
    };
}

// éšè—æŒ‚è½½ç”¨æˆ·æ¡£æ¡ˆå¼¹çª—
function hideMountUserModal() {
    const modal = document.getElementById('mount-user-modal');
    if (modal) modal.style.display = 'none';
}

// é€‰æ‹©æŒ‚è½½çš„ç”¨æˆ·æ¡£æ¡ˆ
async function selectMountUser(userId) {
    if (!currentChatCharId) return;
    
    // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°å…³è”ç”¨æˆ·å­—æ®µï¼Œé˜²æ­¢è¦†ç›–è®¾ç½®
    await db.characters.update(currentChatCharId, { linked_user_id: userId }).catch(err => {
        console.error('[selectMountUser] updateå¤±è´¥:', err);
    });
    
    // æ›´æ–°æ˜¾ç¤º
    updateMountedUserDisplay();
    hideMountUserModal();
    showToast('å·²æŒ‚è½½ç”¨æˆ·æ¡£æ¡ˆ');
}

// å¸è½½ç”¨æˆ·æ¡£æ¡ˆ
async function unmountUser() {
    if (!currentChatCharId) return;
    
    // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°å…³è”ç”¨æˆ·å­—æ®µï¼Œé˜²æ­¢è¦†ç›–è®¾ç½®
    await db.characters.update(currentChatCharId, { linked_user_id: null }).catch(err => {
        console.error('[unmountUser] updateå¤±è´¥:', err);
    });
    
    // æ›´æ–°æ˜¾ç¤º
    updateMountedUserDisplay();
    hideMountUserModal();
    showToast('å·²å¸è½½ç”¨æˆ·æ¡£æ¡ˆ');
}

// æ›´æ–°æŒ‚è½½ç”¨æˆ·æ¡£æ¡ˆæ˜¾ç¤º
async function updateMountedUserDisplay() {
    if (!currentChatCharId) return;
    
    const char = await db.characters.get(currentChatCharId);
    const displayEl = document.getElementById('detail-mounted-user');
    
    if (!displayEl) return;
    
    if (char.linked_user_id) {
        const user = await db.characters.get(char.linked_user_id);
        if (user) {
            displayEl.innerText = user.name;
            displayEl.style.color = 'var(--ins-pink)';
        } else {
            displayEl.innerText = 'æœªæŒ‚è½½';
            displayEl.style.color = '#999';
        }
    } else {
        displayEl.innerText = 'æœªæŒ‚è½½';
        displayEl.style.color = '#999';
    }
}

// ç¡®ä¿æŒ‚è½½ç”¨æˆ·æ¡£æ¡ˆå‡½æ•°åœ¨å…¨å±€ä½œç”¨åŸŸå¯è®¿é—®
window.showMountUserModal = showMountUserModal;
window.hideMountUserModal = hideMountUserModal;
window.selectMountUser = selectMountUser;
window.unmountUser = unmountUser;

        async function setChatDetailAvatar(input) {
            const file = input.files[0];
            if (file && currentChatCharId) {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const base64 = e.target.result;
                    document.getElementById('detail-char-avatar').style.backgroundImage = `url(${base64})`;
                    
                    const char = await db.characters.get(currentChatCharId);
                    const _aid = getCurrentAccountId();
                    setCharAvatar(char, _aid, base64);
                    await safeCharacterPut(char);
                    
                    // âœ… å¼ºåˆ¶åˆ·æ–°èŠå¤©ç•Œé¢å¤´åƒï¼ˆforceRender=trueï¼Œé˜²æ­¢ç¼“å­˜è·³è¿‡å¯¼è‡´å¤´åƒä¸æ›´æ–°ï¼‰
                    renderChatBody(char, true); 
                    
                    // âœ… åˆ·æ–°å¾®ä¿¡èŠå¤©åˆ—è¡¨ä¸­çš„å¤´åƒ
                    const wechatContent = document.getElementById('wechat-content');
                    if (wechatContent) {
                        renderWechatList(wechatContent);
                    }
                };
                reader.readAsDataURL(file);
            }
            input.value = '';
        }

        async function setChatBackground(input) {
            const file = input.files[0];
            if (file && currentChatCharId) {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const base64 = e.target.result;
                    const bgPreview = document.getElementById('detail-chat-bg-preview');
                    bgPreview.style.backgroundImage = `url(${base64})`;
                    bgPreview.textContent = '';
                    
                    // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°èƒŒæ™¯å›¾å­—æ®µï¼Œé˜²æ­¢è¦†ç›–è®¾ç½®
                    await db.characters.update(currentChatCharId, { chat_background: base64 }).catch(err => {
                        console.error('[setChatBackground] updateå¤±è´¥:', err);
                    });
                    
                    // ç«‹å³åº”ç”¨èƒŒæ™¯å›¾åˆ°èŠå¤©ç•Œé¢
                    const char = await db.characters.get(currentChatCharId);
                    if (char) applyChatBackground(char);
                };
                reader.readAsDataURL(file);
            }
            input.value = '';
        }

        async function clearChatBackground() {
            if (!currentChatCharId) return;
            if (!confirm('ç¡®å®šè¦æ¸…é™¤èŠå¤©èƒŒæ™¯å›¾å—ï¼Ÿ')) return;
            
            // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°èƒŒæ™¯å›¾å­—æ®µï¼Œé˜²æ­¢è¦†ç›–è®¾ç½®
            await db.characters.update(currentChatCharId, { chat_background: null }).catch(err => {
                console.error('[clearChatBackground] updateå¤±è´¥:', err);
            });
            
            const bgPreview = document.getElementById('detail-chat-bg-preview');
            bgPreview.style.backgroundImage = '';
            bgPreview.textContent = 'æš‚æ— èƒŒæ™¯å›¾';
            
            // âœ… æ¸…é™¤è§’è‰²ç‹¬ç«‹èƒŒæ™¯å›¾çš„å†…è”æ ·å¼
            const chatBody = document.getElementById('chat-body');
            if (chatBody) {
                chatBody.style.backgroundImage = '';
                chatBody.style.backgroundSize = '';
                chatBody.style.backgroundPosition = '';
                chatBody.style.backgroundRepeat = '';
                chatBody.style.backgroundAttachment = '';
            }
            
            // âœ… å¦‚æœæœ‰èŠå¤©ä¸»é¢˜ï¼Œé‡æ–°åº”ç”¨ä¸»é¢˜èƒŒæ™¯ï¼ˆæ¢å¤ä¸»é¢˜èƒŒæ™¯å›¾ï¼‰
            if (char.chatThemeId !== undefined && char.chatThemeId !== null) {
                await applyThemeToChat(char.chatThemeId);
            }
        }

        function applyChatBackground(char) {
            const chatBody = document.getElementById('chat-body');
            if (!chatBody) return;
            
            if (char.chat_background) {
                // âœ… è§’è‰²ç‹¬ç«‹èƒŒæ™¯å›¾ï¼ˆä¼˜å…ˆçº§é«˜äºä¸»é¢˜èƒŒæ™¯ï¼‰
                chatBody.style.backgroundImage = `url(${char.chat_background})`;
                chatBody.style.backgroundSize = 'cover';
                chatBody.style.backgroundPosition = 'center';
                chatBody.style.backgroundRepeat = 'no-repeat';
                chatBody.style.backgroundAttachment = 'fixed';
            }
            // âœ… æ²¡æœ‰è§’è‰²ç‹¬ç«‹èƒŒæ™¯å›¾æ—¶ï¼Œä¸æ¸…é™¤ä»»ä½•èƒŒæ™¯å±æ€§
            // è®©ä¸»é¢˜èƒŒæ™¯å›¾ï¼ˆç”± applyThemeToChat é€šè¿‡ style.background ç®€å†™è®¾ç½®ï¼‰ä¿æŒä¸å˜
            // æ¸…é™¤æ“ä½œç”± clearChatBackground() æ˜¾å¼å¤„ç†
        }

        // å±•å¼€/æ”¶èµ·è‡ªå®šä¹‰æ ·å¼åŒºåŸŸ
        function toggleCustomStyleSection() {
            const section = document.getElementById('custom-style-section');
            const icon = document.getElementById('custom-style-toggle-icon');
            
            if (section.style.display === 'none' || !section.style.display) {
                section.style.display = 'block';
                icon.style.transform = 'rotate(90deg)';
            } else {
                section.style.display = 'none';
                icon.style.transform = 'rotate(0deg)';
            }
        }

        // ä¸¥æ ¼è¿‡æ»¤HTMLä¸­çš„JavaScript
        function sanitizeHTML(html) {
            if (!html) return '';
            
            // ç§»é™¤æ‰€æœ‰scriptæ ‡ç­¾
            html = html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
            
            // ç§»é™¤æ‰€æœ‰äº‹ä»¶å¤„ç†å™¨å±æ€§ (on*)
            html = html.replace(/\s*on\w+\s*=\s*["'][^"']*["']/gi, '');
            html = html.replace(/\s*on\w+\s*=\s*[^\s>]*/gi, '');
            
            // ç§»é™¤ javascript: åè®®
            html = html.replace(/javascript:/gi, '');
            
            // ç§»é™¤ data: åè®®ï¼ˆå¯èƒ½åŒ…å«base64ç¼–ç çš„JSï¼‰
            html = html.replace(/data:text\/html/gi, '');
            
            return html;
        }

        // å°†ç”¨æˆ·è‡ªå®šä¹‰CSSçš„é€‰æ‹©å™¨é™å®šåœ¨æŒ‡å®šä½œç”¨åŸŸå†…
        function scopeBubbleCSS(cssText, scopeSelector) {
            // æŒ‰ } æ‹†åˆ†å‡ºæ¯ä¸ªCSSè§„åˆ™å—
            const result = [];
            // ç®€å•è§£æï¼šæ‰¾åˆ°æ¯ä¸ª selector { ... } å—
            const ruleRegex = /([^{}]+)\{([^{}]*)\}/g;
            let match;
            while ((match = ruleRegex.exec(cssText)) !== null) {
                const rawSelector = match[1].trim();
                const body = match[2].trim();
                if (!rawSelector || !body) continue;
                // å¯¹æ¯ä¸ªé€—å·åˆ†éš”çš„é€‰æ‹©å™¨éƒ½åŠ ä¸Šä½œç”¨åŸŸå‰ç¼€
                const scopedSelectors = rawSelector.split(',').map(sel => {
                    sel = sel.trim();
                    if (!sel) return '';
                    // å¦‚æœç”¨æˆ·å·²ç»å†™äº†ä½œç”¨åŸŸå‰ç¼€ï¼Œä¸é‡å¤åŠ 
                    if (sel.startsWith(scopeSelector)) return sel;
                    return scopeSelector + ' ' + sel;
                }).filter(Boolean).join(',\n');
                result.push(scopedSelectors + ' {\n  ' + body + '\n}');
            }
            return result.join('\n');
        }

        // ä¸¥æ ¼è¿‡æ»¤CSSä¸­çš„JavaScript
        function sanitizeCSS(css) {
            if (!css) return '';
            
            // ç§»é™¤ javascript: åè®®
            css = css.replace(/javascript:/gi, '');
            
            // ç§»é™¤ expression() (IEç‰¹æœ‰ï¼Œå¯æ‰§è¡ŒJS)
            css = css.replace(/expression\s*\(/gi, '');
            
            // ç§»é™¤ @import url(javascript:...)
            css = css.replace(/@import\s+url\s*\(\s*["']?javascript:/gi, '@import url(');
            
            // ç§»é™¤ behavior: (IEç‰¹æœ‰)
            css = css.replace(/behavior\s*:/gi, 'removed-behavior:');
            
            // ç§»é™¤ -moz-binding (Firefoxç‰¹æœ‰ï¼Œå¯æ‰§è¡ŒJS)
            css = css.replace(/-moz-binding\s*:/gi, 'removed-binding:');
            
            return css;
        }

        // ç§èŠæ°”æ³¡CSSå®æ—¶é¢„è§ˆï¼ˆåœ¨é¢„è§ˆåŒºæ¸²æŸ“ï¼‰
        function previewChatBubbleCSS() {
            const cssText = (document.getElementById('detail-bubble-css').value || '').trim();
            // ç§»é™¤æ—§çš„é¢„è§ˆæ ·å¼
            let styleTag = document.getElementById('chat-bubble-preview-style');
            if (!styleTag) {
                styleTag = document.createElement('style');
                styleTag.id = 'chat-bubble-preview-style';
                document.head.appendChild(styleTag);
            }
            if (!cssText) {
                styleTag.textContent = '';
                return;
            }
            // åˆ¤æ–­æ˜¯çº¯å±æ€§è¿˜æ˜¯å®Œæ•´CSSè§„åˆ™
            const isFullCSS = cssText.includes('{') && cssText.includes('}');
            if (isFullCSS) {
                // å®Œæ•´è§„åˆ™æ¨¡å¼ï¼šé™å®šåˆ°é¢„è§ˆåŒº
                const scopedCSS = scopeBubbleCSS(cssText, '#chat-bubble-preview');
                styleTag.textContent = scopedCSS;
            } else {
                // çº¯å±æ€§æ¨¡å¼ï¼šåŠ  !importantï¼ŒåŒæ—¶åº”ç”¨åˆ°é¢„è§ˆåŒºçš„ä¸¤ç§æ°”æ³¡
                const importantCSS = cssText.split(';').map(p => {
                    p = p.trim();
                    if (!p || !p.includes(':')) return '';
                    if (p.toLowerCase().includes('!important')) return p + ';';
                    return p + ' !important;';
                }).filter(p => p).join('\n');
                styleTag.textContent = `
                    #chat-bubble-preview .message-row.other .message-content {
                        ${importantCSS}
                    }
                    #chat-bubble-preview .message-row.self .message-content {
                        ${importantCSS}
                    }
                `;
            }
            
            // âœ… åŒæ—¶åº”ç”¨åˆ°å®é™…èŠå¤©ç•Œé¢ï¼ˆå®æ—¶ç”Ÿæ•ˆï¼‰
            if (currentChatCharId) {
                const tempCSS = sanitizeCSS(cssText);
                applyCustomStyles({ custom_bubble_css: tempCSS });
            }
        }

        // é¢„è§ˆè‡ªå®šä¹‰æ ·å¼ï¼ˆå…¼å®¹æ—§è°ƒç”¨ï¼‰
        async function previewCustomStyle() {
            previewChatBubbleCSS();
        }

        // æ¸…é™¤è‡ªå®šä¹‰æ ·å¼
        async function clearCustomStyle() {
            if (!confirm('ç¡®å®šè¦æ¸…é™¤è‡ªå®šä¹‰æ°”æ³¡CSSå—ï¼Ÿ')) return;
            
            document.getElementById('detail-bubble-css').value = '';
            
            // æ¸…é™¤é¢„è§ˆåŒºæ ·å¼
            const previewStyle = document.getElementById('chat-bubble-preview-style');
            if (previewStyle) previewStyle.textContent = '';
            
            await saveChatDetail();
            
            // ç§»é™¤å·²åº”ç”¨çš„æ ·å¼
            removeCustomStyles();
            
            // é‡æ–°åº”ç”¨é¢„è®¾æ ·å¼
            if (currentChatCharId) {
                const char = await db.characters.get(currentChatCharId);
                if (char) applyCustomStyles(char);
            }
            
            alert('è‡ªå®šä¹‰æ ·å¼å·²æ¸…é™¤ï¼');
        }

        // ========== èŠå¤©æ ·å¼é¢„è®¾åŠŸèƒ½ ==========
        
        // ä¿å­˜å½“å‰æ ·å¼ä¸ºé¢„è®¾
        async function saveChatStylePreset() {
            const bubbleStyle = document.querySelector('.bubble-style-option.selected');
            const bubbleCSS = document.getElementById('detail-bubble-css').value.trim();
            
            if (!bubbleCSS && (!bubbleStyle || bubbleStyle.dataset.style === 'default')) {
                showToast('å½“å‰æ²¡æœ‰è‡ªå®šä¹‰æ ·å¼å¯ä¿å­˜');
                return;
            }
            
            const presetName = prompt('è¯·è¾“å…¥é¢„è®¾åç§°ï¼š');
            if (!presetName || !presetName.trim()) return;
            
            try {
                // è¯»å–å·²æœ‰é¢„è®¾åˆ—è¡¨
                const existing = await db.dexiData.get('chatStylePresets');
                const presets = existing ? existing.value : [];
                
                // æ£€æŸ¥æ˜¯å¦é‡å
                if (presets.find(p => p.name === presetName.trim())) {
                    if (!confirm(`é¢„è®¾"${presetName.trim()}"å·²å­˜åœ¨ï¼Œæ˜¯å¦è¦†ç›–ï¼Ÿ`)) return;
                    // è¦†ç›–ï¼šç§»é™¤æ—§çš„
                    const idx = presets.findIndex(p => p.name === presetName.trim());
                    if (idx !== -1) presets.splice(idx, 1);
                }
                
                presets.push({
                    name: presetName.trim(),
                    bubble_style: bubbleStyle ? bubbleStyle.dataset.style : 'default',
                    custom_bubble_css: bubbleCSS,
                    time: Date.now()
                });
                
                await db.dexiData.put({ key: 'chatStylePresets', value: presets });
                showToast(`æ ·å¼é¢„è®¾"${presetName.trim()}"å·²ä¿å­˜ï¼`);
            } catch (e) {
                console.error('[èŠå¤©æ ·å¼] ä¿å­˜é¢„è®¾å¤±è´¥:', e);
                showToast('ä¿å­˜é¢„è®¾å¤±è´¥');
            }
        }
        
        // åŠ è½½é¢„è®¾åˆ—è¡¨
        async function loadChatStylePreset() {
            try {
                const existing = await db.dexiData.get('chatStylePresets');
                const presets = existing ? existing.value : [];
                
                if (presets.length === 0) {
                    showToast('æš‚æ— ä¿å­˜çš„æ ·å¼é¢„è®¾');
                    return;
                }
                
                const listEl = document.getElementById('chat-style-preset-list');
                if (!listEl) return;
                
                // åˆ‡æ¢æ˜¾ç¤º/éšè—
                if (listEl.style.display !== 'none' && listEl.innerHTML !== '') {
                    listEl.style.display = 'none';
                    return;
                }
                
                let html = '';
                for (let i = 0; i < presets.length; i++) {
                    const p = presets[i];
                    const timeStr = p.time ? new Date(p.time).toLocaleDateString() : '';
                    const hasCSS = p.custom_bubble_css ? 'æœ‰è‡ªå®šä¹‰CSS' : '';
                    const tags = [p.bubble_style !== 'default' ? `æ ·å¼:${p.bubble_style}` : '', hasCSS].filter(Boolean).join(' Â· ');
                    
                    html += `
                        <div style="display:flex; align-items:center; padding:10px 12px; background:#fff; border:1px solid #e8e8e8; border-radius:10px; margin-bottom:8px;">
                            <div style="flex:1; min-width:0;">
                                <div style="font-size:13px; font-weight:500; color:#333; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${p.name}</div>
                                <div style="font-size:10px; color:#aaa; margin-top:3px;">${tags || 'é»˜è®¤æ ·å¼'} ${timeStr ? 'Â· ' + timeStr : ''}</div>
                            </div>
                            <div style="display:flex; gap:6px; flex-shrink:0; margin-left:8px;">
                                <div onclick="applyChatStylePreset(${i})" style="padding:5px 12px; font-size:11px; background:#007aff; color:#fff; border-radius:6px; cursor:pointer; font-weight:500;">åº”ç”¨</div>
                                <div onclick="deleteChatStylePreset(${i})" style="padding:5px 10px; font-size:11px; background:#f5f5f5; color:#ff3b30; border-radius:6px; cursor:pointer;">åˆ é™¤</div>
                            </div>
                        </div>
                    `;
                }
                
                listEl.innerHTML = html;
                listEl.style.display = 'block';
            } catch (e) {
                console.error('[èŠå¤©æ ·å¼] åŠ è½½é¢„è®¾å¤±è´¥:', e);
                showToast('åŠ è½½é¢„è®¾å¤±è´¥');
            }
        }
        
        // åº”ç”¨æŒ‡å®šé¢„è®¾
        async function applyChatStylePreset(index) {
            try {
                const existing = await db.dexiData.get('chatStylePresets');
                const presets = existing ? existing.value : [];
                if (index < 0 || index >= presets.length) return;
                
                const p = presets[index];
                
                // å›å¡«åˆ°è¡¨å•
                document.getElementById('detail-bubble-css').value = p.custom_bubble_css || '';
                
                // æ›´æ–°å®æ—¶é¢„è§ˆ
                previewChatBubbleCSS();
                
                // é€‰ä¸­æ°”æ³¡æ ·å¼
                const style = p.bubble_style || 'default';
                document.querySelectorAll('.bubble-style-option').forEach(el => {
                    el.classList.remove('selected');
                    if (el.dataset.style === style) {
                        el.classList.add('selected');
                    }
                });
                
                // ä¿å­˜åˆ°è§’è‰²
                await saveChatDetail();
                
                showToast(`å·²åº”ç”¨é¢„è®¾"${p.name}"`);
                
                // éšè—é¢„è®¾åˆ—è¡¨
                const listEl = document.getElementById('chat-style-preset-list');
                if (listEl) listEl.style.display = 'none';
            } catch (e) {
                console.error('[èŠå¤©æ ·å¼] åº”ç”¨é¢„è®¾å¤±è´¥:', e);
                showToast('åº”ç”¨é¢„è®¾å¤±è´¥');
            }
        }
        
        // åˆ é™¤æŒ‡å®šé¢„è®¾
        async function deleteChatStylePreset(index) {
            try {
                const existing = await db.dexiData.get('chatStylePresets');
                const presets = existing ? existing.value : [];
                if (index < 0 || index >= presets.length) return;
                
                const name = presets[index].name;
                if (!confirm(`ç¡®å®šè¦åˆ é™¤é¢„è®¾"${name}"å—ï¼Ÿ`)) return;
                
                presets.splice(index, 1);
                await db.dexiData.put({ key: 'chatStylePresets', value: presets });
                
                showToast(`å·²åˆ é™¤é¢„è®¾"${name}"`);
                
                // åˆ·æ–°åˆ—è¡¨ï¼ˆå…ˆéšè—å†é‡æ–°æ˜¾ç¤ºï¼Œé¿å…toggleé€»è¾‘ï¼‰
                const listEl = document.getElementById('chat-style-preset-list');
                if (listEl) {
                    listEl.style.display = 'none';
                    listEl.innerHTML = '';
                }
                if (presets.length > 0) {
                    loadChatStylePreset();
                }
            } catch (e) {
                console.error('[èŠå¤©æ ·å¼] åˆ é™¤é¢„è®¾å¤±è´¥:', e);
                showToast('åˆ é™¤é¢„è®¾å¤±è´¥');
            }
        }

        // åº”ç”¨è‡ªå®šä¹‰æ ·å¼åˆ°èŠå¤©ç•Œé¢
        function applyCustomStyles(char) {
            if (!char) return;
            
            // ç§»é™¤ä¹‹å‰çš„è‡ªå®šä¹‰æ ·å¼
            removeCustomStyles();
            
            const chatContainer = document.getElementById('chat-body');
            if (!chatContainer) return;
            
            const hasCustomCSS = char.custom_bubble_css && char.custom_bubble_css.trim();
            
            // ğŸ”§ å¦‚æœæœ‰è‡ªå®šä¹‰æ°”æ³¡CSSï¼Œåˆ™ä¸åº”ç”¨é¢„è®¾æ°”æ³¡æ ·å¼ï¼Œé¿å…å†²çª
            chatContainer.classList.remove('bubble-style-default', 'bubble-style-wechat');
            if (hasCustomCSS) {
                console.log('[applyCustomStyles] æ£€æµ‹åˆ°è‡ªå®šä¹‰æ°”æ³¡CSSï¼Œè·³è¿‡é¢„è®¾æ ·å¼');
            } else {
                if (char.bubble_style === 'wechat') {
                    chatContainer.classList.add('bubble-style-wechat');
                } else {
                    chatContainer.classList.add('bubble-style-default');
                }
            }
            
            // åº”ç”¨è‡ªå®šä¹‰æ°”æ³¡CSS
            if (hasCustomCSS) {
                const bubbleStyleId = 'custom-bubble-style';
                let styleTag = document.getElementById(bubbleStyleId);
                
                if (!styleTag) {
                    styleTag = document.createElement('style');
                    styleTag.id = bubbleStyleId;
                    document.head.appendChild(styleTag);
                }
                
                const cssText = char.custom_bubble_css.trim();
                
                // ğŸ”§ åˆ¤æ–­ç”¨æˆ·è¾“å…¥çš„æ˜¯"çº¯å±æ€§"è¿˜æ˜¯"å¸¦é€‰æ‹©å™¨çš„å®Œæ•´CSSè§„åˆ™"
                // å¦‚æœåŒ…å« { å’Œ }ï¼Œè¯´æ˜æ˜¯å®Œæ•´CSSè§„åˆ™
                const isFullCSS = cssText.includes('{') && cssText.includes('}');
                
                if (isFullCSS) {
                    // å®Œæ•´CSSè§„åˆ™æ¨¡å¼ï¼šå°†é€‰æ‹©å™¨é™å®šåœ¨ #chat-body å†…ï¼Œä¸åšå…¨å±€é‡ç½®
                    console.log('[applyCustomStyles] å®Œæ•´CSSè§„åˆ™æ¨¡å¼');
                    // ç»™ç”¨æˆ·çš„é€‰æ‹©å™¨åŠ ä¸Š #chat-body ä½œç”¨åŸŸå‰ç¼€ï¼Œé¿å…å½±å“å…¶ä»–é¡µé¢
                    const scopedCSS = scopeBubbleCSS(cssText, '#chat-body');
                    styleTag.textContent = scopedCSS;
                } else {
                    // çº¯å±æ€§æ¨¡å¼ï¼šè‡ªåŠ¨åŠ  !important å¹¶åŒæ—¶åº”ç”¨åˆ° other å’Œ self æ°”æ³¡
                    console.log('[applyCustomStyles] çº¯å±æ€§æ¨¡å¼');
                    const addImportant = (text) => {
                        return text
                            .split(';')
                            .map(prop => {
                                prop = prop.trim();
                                if (!prop || !prop.includes(':')) return '';
                                if (prop.toLowerCase().includes('!important')) return prop + ';';
                                return prop + ' !important;';
                            })
                            .filter(p => p)
                            .join('\n');
                    };
                    
                    const importantCSS = addImportant(cssText);
                    
                    // ç›´æ¥åº”ç”¨åˆ°æ°”æ³¡ä¸Šï¼Œä¸åš background:none çš„é‡ç½®
                    // ç”¨æˆ·å†™äº†ä»€ä¹ˆå±æ€§å°±è¦†ç›–ä»€ä¹ˆï¼Œæ²¡å†™çš„ä¿æŒé»˜è®¤
                    styleTag.textContent = `
                        #chat-body .message-row.other .message-content:not(.card-message):not(.image-only) {
                            ${importantCSS}
                        }
                        #chat-body .message-row.self .message-content:not(.card-message):not(.image-only) {
                            ${importantCSS}
                        }
                    `;
                }
            }
            
        }

        // ç§»é™¤è‡ªå®šä¹‰æ ·å¼
        function removeCustomStyles() {
            // ç§»é™¤è‡ªå®šä¹‰æ°”æ³¡CSS
            const bubbleStyle = document.getElementById('custom-bubble-style');
            if (bubbleStyle) bubbleStyle.remove();
        }

        async function jumpToCharEditor() {
            if (!currentChatCharId) return;
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯è”æœºå¥½å‹
            const char = await db.characters.get(currentChatCharId);
            if (char && char.isOnlineFriend) {
                // è”æœºå¥½å‹åªæ˜¾ç¤ºç®€åŒ–ä¿¡æ¯
                showOnlineFriendProfile(char);
                return;
            }
            
            hideChatDetail();
            editCharacter(currentChatCharId);
        }
        
        // æ˜¾ç¤ºè”æœºå¥½å‹çš„ç®€åŒ–æ¡£æ¡ˆï¼ˆåªæœ‰åŸºæœ¬ä¿¡æ¯ï¼Œæ²¡æœ‰äººè®¾ï¼‰
        function showOnlineFriendProfile(char) {
            const avatar = char.avatar || '';
            const avatarStyle = avatar ? `background-image:url(${avatar})` : 'background:#e0e0e0';
            
            const html = `
                <div style="position:fixed; top:0; left:0; right:0; bottom:0; background:#f5f5f5; z-index:9999; display:flex; flex-direction:column;">
                    <div class="wechat-header" style="background:#fff;">
                        <div class="back-btn" onclick="this.closest('div[style*=position]').remove()" style="margin:0; background:none; width:40px; justify-content:flex-start; padding-left:0; color:var(--ins-text);">
                            <svg class="svg-icon" viewBox="0 0 24 24" style="width:28px; height:28px;"><polyline points="15 18 9 12 15 6"></polyline></svg>
                        </div>
                        <div class="wechat-title">è”æœºå¥½å‹èµ„æ–™</div>
                        <div style="width:40px;"></div>
                    </div>
                    
                    <div style="flex:1; overflow-y:auto; padding:20px;">
                        <!-- å¤´åƒå’ŒåŸºæœ¬ä¿¡æ¯ -->
                        <div style="text-align:center; padding:30px 0;">
                            <div style="width:100px; height:100px; border-radius:12px; margin:0 auto 16px; background-size:cover; background-position:center; ${avatarStyle}"></div>
                            <div style="font-size:20px; font-weight:600; color:#333; margin-bottom:8px;">${char.name || 'æœªçŸ¥'}</div>
                            <div style="font-size:14px; color:#999;">è”æœºå¥½å‹</div>
                        </div>
                        
                        <!-- ä¿¡æ¯å¡ç‰‡ -->
                        <div style="background:#fff; border-radius:12px; overflow:hidden; margin-bottom:16px;">
                            <div style="padding:16px; border-bottom:1px solid #f0f0f0; display:flex; justify-content:space-between;">
                                <span style="color:#666;">å¾®ä¿¡å·</span>
                                <span style="color:#333;">${char.identity?.account || 'æœªçŸ¥'}</span>
                            </div>
                            <div style="padding:16px; display:flex; justify-content:space-between;">
                                <span style="color:#666;">æ˜µç§°</span>
                                <span style="color:#333;">${char.name || 'æœªçŸ¥'}</span>
                            </div>
                        </div>
                        
                        <!-- æç¤ºä¿¡æ¯ -->
                        <div style="text-align:center; padding:20px; color:#999; font-size:13px;">
                            <div style="margin-bottom:8px;">ğŸŒ è¿™æ˜¯ä¸€ä½è”æœºå¥½å‹</div>
                            <div>å¯¹æ–¹çš„è¯¦ç»†èµ„æ–™ä¸å¯è§</div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', html);
        }

        async function clearChatHistory() {
            if (!currentChatCharId) return;
            if (confirm("ç¡®å®šè¦æ¸…ç©ºä¸è¯¥è§’è‰²çš„èŠå¤©è®°å½•å—ï¼Ÿï¼ˆåŒæ—¶æ¸…é™¤æ€»ç»“ã€é€šè¯è®°å½•å’Œå¿ƒå£°ï¼‰")) {
                const char = await db.characters.get(currentChatCharId);
                const accountId = getCurrentAccountId();
                await setChatHistory(char, accountId, []);
                
                // âœ… åŒæ—¶æ¸…é™¤èŠå¤©æ€»ç»“
                try {
                    const summaries = await db.chat_summaries.where('accountId').equals(accountId).toArray();
                    const toDelete = summaries.filter(s => s.chatType === 'private' && String(s.chatId) === String(currentChatCharId));
                    for (const s of toDelete) {
                        await db.chat_summaries.delete(s.id);
                    }
                    if (toDelete.length > 0) console.log(`[clearChatHistory] âœ… å·²æ¸…é™¤ ${toDelete.length} æ¡èŠå¤©æ€»ç»“`);
                } catch (e) {
                    console.warn('[clearChatHistory] æ¸…é™¤æ€»ç»“å¤±è´¥:', e);
                }
                
                // âœ… åŒæ—¶æ¸…é™¤è§†é¢‘é€šè¯è®°å½•
                try {
                    const videoKey = `video_calls_${accountId}_${currentChatCharId}`;
                    localStorage.removeItem(videoKey);
                    console.log('[clearChatHistory] âœ… å·²æ¸…é™¤è§†é¢‘é€šè¯è®°å½•');
                } catch (e) {
                    console.warn('[clearChatHistory] æ¸…é™¤é€šè¯è®°å½•å¤±è´¥:', e);
                }
                
                // âœ… åŒæ—¶æ¸…é™¤å¿ƒå£°è®°å½•
                try {
                    const freshChar = await db.characters.get(currentChatCharId);
                    if (freshChar && freshChar.thoughts && freshChar.thoughts.length > 0) {
                        const thoughtCount = freshChar.thoughts.length;
                        freshChar.thoughts = [];
                        await safeCharacterPut(freshChar);
                        console.log(`[clearChatHistory] âœ… å·²æ¸…é™¤ ${thoughtCount} æ¡å¿ƒå£°è®°å½•`);
                    }
                } catch (e) {
                    console.warn('[clearChatHistory] æ¸…é™¤å¿ƒå£°å¤±è´¥:', e);
                }
                
                await renderChatBody(char, true); // âœ… forceRender=true ç¡®ä¿å®Œæ•´é‡æ–°æ¸²æŸ“ï¼ˆåŒ…æ‹¬èƒŒæ™¯å›¾ï¼‰
                alert("å·²æ¸…ç©º");
            }
        }
        
        // --- ä¸»åŠ¨å‘æ¶ˆæ¯é€»è¾‘ï¼ˆçº¯å‰ç«¯é©±åŠ¨ï¼‰---
        let syncTimer = null; // å®šæ—¶å™¨ï¼ˆä¿ç•™å˜é‡åå…¼å®¹æ€§ï¼‰
        
        // çº¯å‰ç«¯æ¨¡å¼ï¼šä¸éœ€è¦åŒæ­¥åˆ°åç«¯ï¼Œè§’è‰²æ•°æ®å…¨éƒ¨å­˜å‚¨åœ¨æœ¬åœ° IndexedDB
        async function syncCharactersToBackend() {
            // çº¯å‰ç«¯æ¨¡å¼ï¼šæ— éœ€åŒæ­¥ï¼Œä»…æ‰“å°æ—¥å¿—
            console.log('[Sync] çº¯å‰ç«¯æ¨¡å¼ï¼šè§’è‰²æ•°æ®å­˜å‚¨åœ¨æœ¬åœ°ï¼Œæ— éœ€åŒæ­¥åˆ°åç«¯');
        }
        
        // æ³¨å†Œ Service Workerï¼ˆå†…è”æ–¹å¼ï¼Œä¸ä¾èµ–å¤–éƒ¨sw.jsæ–‡ä»¶ï¼‰
        async function registerServiceWorkerAndSubscribe() {
            if (!('serviceWorker' in navigator)) {
                console.log('[SW] Not supported');
                showDebugToast('âŒ æµè§ˆå™¨ä¸æ”¯æŒService Worker');
                return;
            }
            
            try {
                // å†…è” Service Worker ä»£ç 
                const swCode = `
const CACHE_NAME = 'ins-desktop-v1';

self.addEventListener('install', function(event) {
    event.waitUntil(
        caches.open(CACHE_NAME).then(function(cache) {
            console.log('[SW] Cache opened');
            return Promise.resolve();
        }).catch(function(err) {
            console.warn('[SW] Cache init failed:', err);
            return Promise.resolve();
        })
    );
    self.skipWaiting();
});

self.addEventListener('activate', function(event) {
    event.waitUntil(
        caches.keys().then(function(names) {
            return Promise.all(
                names.filter(function(n) { return n !== CACHE_NAME; })
                    .map(function(n) { return caches.delete(n); })
            );
        }).then(function() { return self.clients.claim(); })
    );
});

self.addEventListener('notificationclick', function(event) {
    event.notification.close();
    event.waitUntil(
        clients.matchAll({ type: 'window', includeUncontrolled: true }).then(function(clientList) {
            for (var i = 0; i < clientList.length; i++) {
                if ('focus' in clientList[i]) return clientList[i].focus();
            }
            if (clients.openWindow) return clients.openWindow('./');
        })
    );
});

self.addEventListener('message', function(event) {
    if (event.data && event.data.type === 'SHOW_NOTIFICATION') {
        var d = event.data.data;
        self.registration.showNotification(d.title || '', {
            body: d.body || '',
            icon: d.icon || '',
            tag: d.tag || 'default',
            data: d.data || {}
        });
    }
});
`;
                const swBlob = new Blob([swCode], { type: 'application/javascript' });
                const swUrl = URL.createObjectURL(swBlob);
                
                const registration = await navigator.serviceWorker.register(swUrl);
                console.log('[SW] Registered (inline):', registration.scope);
                showDebugToast('âœ“ Service Workerå·²æ³¨å†Œ');
                
                await navigator.serviceWorker.ready;
                console.log('[SW] Ready');
                
                // ç›‘å¬ SW æ¶ˆæ¯
                navigator.serviceWorker.addEventListener('message', event => {
                    if (event.data && event.data.type === 'OPEN_CHAT' && event.data.chatId) {
                        if (typeof openChat === 'function') openChat(event.data.chatId);
                    }
                });
                
                // è¯·æ±‚é€šçŸ¥æƒé™
                if ('Notification' in window) {
                    const permission = await Notification.requestPermission();
                    if (permission === 'granted') {
                        console.log('[Notification] âœ“ é€šçŸ¥æƒé™å·²æˆäºˆ');
                        showDebugToast('âœ“ é€šçŸ¥æƒé™å·²æˆäºˆ', true);
                    } else {
                        console.log('[Notification] âœ— é€šçŸ¥æƒé™è¢«æ‹’ç»');
                        showDebugToast('âœ— é€šçŸ¥æƒé™è¢«æ‹’ç»');
                    }
                }
                
                console.log('[SW] å†…è”æ¨¡å¼å°±ç»ª');
                showDebugToast('âœ“ æœ¬åœ°é€šçŸ¥å·²å°±ç»ª', true);
                
            } catch (err) {
                console.error('[SW] Error:', err);
                showDebugToast(`âœ— Service Workeré”™è¯¯: ${err.message}`);
            }
        }
        
        // Base64 è½¬ Uint8Array (ç”¨äº VAPID å…¬é’¥)
        function urlBase64ToUint8Array(base64String) {
            const padding = '='.repeat((4 - base64String.length % 4) % 4);
            const base64 = (base64String + padding)
                .replace(/\-/g, '+')
                .replace(/_/g, '/');
            
            const rawData = window.atob(base64);
            const outputArray = new Uint8Array(rawData.length);
            
            for (let i = 0; i < rawData.length; ++i) {
                outputArray[i] = rawData.charCodeAt(i);
            }
            return outputArray;
        }
        
        // çº¯å‰ç«¯æ¨¡å¼ï¼šä¸éœ€è¦ WebSocket è¿æ¥
        // ä¸»åŠ¨æ¶ˆæ¯å®Œå…¨ç”±å‰ç«¯å®šæ—¶å™¨é©±åŠ¨
        function connectWebSocket() {
            console.log('[WebSocket] çº¯å‰ç«¯æ¨¡å¼ï¼šä¸éœ€è¦ WebSocket è¿æ¥');
            console.log('[WebSocket] ä¸»åŠ¨æ¶ˆæ¯ç”±å‰ç«¯å®šæ—¶å™¨é©±åŠ¨');
        }
        
        // å¯åŠ¨ä¸»åŠ¨èŠå¤©æ£€æµ‹å¾ªç¯ï¼ˆçº¯å‰ç«¯ç‰ˆæœ¬ï¼‰
        async function startAutoChatLoop() {
            if (syncTimer) clearInterval(syncTimer);
            
            console.log('[AutoChat] å¯åŠ¨çº¯å‰ç«¯ä¸»åŠ¨èŠå¤©æ¨¡å¼...');
            console.log('[AutoChat] å½“å‰ç¯å¢ƒ:', {
                protocol: location.protocol,
                hostname: location.hostname,
                href: location.href,
                serviceWorkerSupported: 'serviceWorker' in navigator,
                notificationSupported: 'Notification' in window,
                notificationPermission: Notification.permission
            });
            showDebugToast('ä¸»åŠ¨èŠå¤©æ£€æµ‹å¯åŠ¨ä¸­...', true);
            
            // çº¯å‰ç«¯æ¨¡å¼ï¼šä¸éœ€è¦ WebSocket è¿æ¥
            console.log('[AutoChat] çº¯å‰ç«¯æ¨¡å¼ï¼šç”±å‰ç«¯å®šæ—¶å™¨é©±åŠ¨ä¸»åŠ¨æ¶ˆæ¯');
            
            // æ¯15ç§’æ£€æŸ¥ä¸€æ¬¡æ˜¯å¦è¯¥å‘æ¶ˆæ¯ï¼ˆä¿å­˜timer IDé˜²æ­¢é‡å¤å åŠ ï¼‰
            syncTimer = setInterval(() => {
                checkAutoChat(); // å‰ç«¯ä¸»åŠ¨æ£€æŸ¥
                checkAutoMoments(); // æœ‹å‹åœˆè‡ªåŠ¨å‘å¸ƒæ£€æŸ¥
                checkScheduledActivity(); // å®šæ—¶è‡ªä¸»æ´»åŠ¨æ£€æŸ¥
            }, 15 * 1000);
            
            // å»¶è¿Ÿé¦–æ¬¡æ£€æŸ¥ï¼Œé¿å…åˆå§‹åŒ–æ—¶å¡é¡¿
            setTimeout(() => {
                checkAutoChat();
                checkAutoMoments();
                checkScheduledActivity();
            }, 2000);
            
            // 6. ç›‘å¬é¡µé¢å¯è§æ€§å˜åŒ–ï¼Œä»åå°åˆ‡å›æ—¶è¿›è¡Œè¡¥å‘æ£€æŸ¥
            document.addEventListener('visibilitychange', function() {
                if (!document.hidden) {
                    console.log('[AutoChat] âœ“ Page became visible, checking for pending messages...');
                    showDebugToast('âœ“ è¿”å›å‰å°ï¼Œæ£€æŸ¥æ¶ˆæ¯...');
                    
                    // å¤šè½®è¡¥å‘ï¼šåå°æœŸé—´å¯èƒ½é”™è¿‡å¤šä¸ªé—´éš”ï¼Œæ¯éš”å‡ ç§’æ£€æŸ¥ä¸€æ¬¡ç›´åˆ°è¿½ä¸Š
                    let catchupRound = 0;
                    const maxCatchupRounds = 3; // æœ€å¤šè¡¥å‘3è½®
                    const catchupInterval = 5000; // æ¯è½®é—´éš”5ç§’ï¼ˆç•™æ—¶é—´è®©AIç”Ÿæˆå®Œæˆï¼‰
                    
                    const doCatchupCheck = () => {
                        catchupRound++;
                        console.log(`[AutoChat] è¡¥å‘æ£€æŸ¥ç¬¬ ${catchupRound}/${maxCatchupRounds} è½®`);
                        checkAutoChat();
                        checkAutoMoments();
                        checkScheduledActivity();
                        
                        if (catchupRound < maxCatchupRounds && !document.hidden) {
                            setTimeout(doCatchupCheck, catchupInterval);
                        }
                    };
                    
                    // é¦–æ¬¡æ£€æŸ¥å»¶è¿Ÿ500ms
                    setTimeout(doCatchupCheck, 500);
                    
                    // å¦‚æœä¿æ´»å·²å¼€å¯ä¸”éŸ³é¢‘æš‚åœï¼Œé‡æ–°å¯åŠ¨
                    const keepaliveEnabled = localStorage.getItem('keepalive_enabled') === 'true';
                    if (keepaliveEnabled && keepAliveAudio && keepAliveAudio.paused) {
                        console.log('[KeepAlive] é¡µé¢æ¢å¤å¯è§ï¼Œé‡æ–°å¯åŠ¨ä¿æ´»');
                        showDebugToast('âœ“ é‡å¯ä¿æ´»éŸ³é¢‘...');
                        startKeepAlive();
                    }
                }
            });
            
            console.log('[AutoChat] âœ“ Setup complete!');
            showDebugToast('âœ“ å®æ—¶æ¨é€å·²å¯åŠ¨ï¼', true);
        }

        async function checkAutoChat() {
            const now = Date.now();
            // è·å–å¼€å¯äº†ä¸»åŠ¨èŠå¤©çš„è§’è‰²
            const chars = await db.characters
                .filter(c => c.auto_reply_enabled === true && c.auto_reply_interval > 0)
                .toArray();

            if (chars.length > 0) {
                console.log(`[AutoChat] Check triggered at ${new Date().toLocaleTimeString()} for ${chars.length} enabled chars`);
            }

            const accountId = getCurrentAccountId();
            for (const char of chars) {
                // å¦‚æœæ˜¯å¥½å‹çŠ¶æ€æ‰è§¦å‘ï¼ˆæŒ‰è´¦å·æ£€æŸ¥ï¼‰
                const status = getFriendStatus(char, accountId);
                if (status !== 'friend') continue;

                // é˜²æ­¢å¹¶å‘ï¼šå¦‚æœè¿™ä¸ªè§’è‰²æ­£åœ¨ç”Ÿæˆä¸­ï¼Œè·³è¿‡
                if (autoChatLocks.has(char.id)) {
                    console.log(`[AutoChat] Skipping ${char.name} (locked/generating)`);
                    continue;
                }

                // ğŸ”§ é˜²æ­¢ä¸æ‰‹åŠ¨AIå›å¤å†²çªï¼šå¦‚æœç”¨æˆ·æ­£åœ¨å½“å‰è§’è‰²çš„èŠå¤©ä¸­è§¦å‘AIå›å¤ï¼Œè·³è¿‡ä¸»åŠ¨èŠå¤©
                if (window._isGeneratingReply && currentChatCharId === char.id) {
                    console.log(`[AutoChat] Skipping ${char.name} (user is manually generating reply)`);
                    continue;
                }

                // ğŸ”§ å†·å´åˆ¤æ–­ï¼šåŸºäºä¸Šæ¬¡å®é™…è§¦å‘æ—¶é—´ï¼Œè€Œéå†å²æ¶ˆæ¯æ—¶é—´
                // é˜²æ­¢åˆšå¼€å¯/åˆšåŠ è½½é¡µé¢æ—¶å› å†å²æ¶ˆæ¯ä¹…è¿œè€Œç«‹å³è§¦å‘
                const prevActionTs = lastAutoChatActionTime.get(char.id) || 0;
                if (prevActionTs === 0) {
                    // è¯¥è§’è‰²é¦–æ¬¡è¿›å…¥æ£€æµ‹å‘¨æœŸï¼Œè®°å½•å½“å‰æ—¶åˆ»ä½œä¸ºèµ·ç‚¹
                    lastAutoChatActionTime.set(char.id, now);
                    console.log(`[AutoChat] ${char.name} é¦–æ¬¡æ³¨å†Œï¼Œå°†åœ¨ ${char.auto_reply_interval} åˆ†é’Ÿåè§¦å‘`);
                    continue;
                }

                const elapsedMs = now - prevActionTs;
                const intervalMs = char.auto_reply_interval * 60 * 1000;
                
                if (elapsedMs >= intervalMs) {
                    console.log(`[AutoChat] âœ“âœ“âœ“ Triggering for ${char.name} (Interval: ${char.auto_reply_interval}min, Elapsed: ${(elapsedMs / 60000).toFixed(1)}min)`);
                    triggerAutoChat(char);
                }
            }
        }

        // ===== å®šæ—¶è‡ªä¸»æ´»åŠ¨æ£€æŸ¥ =====
        async function checkScheduledActivity() {
            const now = Date.now();
            const chars = await db.characters
                .filter(c => c.scheduled_activity_enabled === true && c.scheduled_activity_interval > 0)
                .toArray();

            if (chars.length > 0) {
                console.log(`[ScheduledActivity] Check triggered at ${new Date().toLocaleTimeString()} for ${chars.length} enabled chars`);
            }

            const accountId = getCurrentAccountId();
            for (const char of chars) {
                // å¿…é¡»æ˜¯å¥½å‹çŠ¶æ€
                const status = getFriendStatus(char, accountId);
                if (status !== 'friend') continue;

                // é˜²æ­¢å¹¶å‘
                if (scheduledActivityLocks.has(char.id)) {
                    console.log(`[ScheduledActivity] Skipping ${char.name} (locked/generating)`);
                    continue;
                }

                // å†·å´åˆ¤æ–­
                const prevActionTs = lastScheduledActivityTime.get(char.id) || 0;
                if (prevActionTs === 0) {
                    lastScheduledActivityTime.set(char.id, now);
                    console.log(`[ScheduledActivity] ${char.name} é¦–æ¬¡æ³¨å†Œï¼Œå°†åœ¨ ${char.scheduled_activity_interval} åˆ†é’Ÿåè§¦å‘`);
                    continue;
                }

                const elapsedMs = now - prevActionTs;
                const intervalMs = char.scheduled_activity_interval * 60 * 1000;

                if (elapsedMs >= intervalMs) {
                    console.log(`[ScheduledActivity] âœ“âœ“âœ“ Triggering for ${char.name} (Interval: ${char.scheduled_activity_interval}min, Elapsed: ${(elapsedMs / 60000).toFixed(1)}min)`);
                    triggerScheduledActivity(char, accountId);
                }
            }
        }

        async function triggerScheduledActivity(char, accountId) {
            scheduledActivityLocks.add(char.id);
            try {
                const roleName = char.nick || char.name || 'è§’è‰²';
                const roleDesc = char.description || '';

                // è·å–è¯¥è§’è‰²æ‰‹æœºé€šè®¯å½•ä¸­çš„NPCè”ç³»äºº
                const phoneContacts = char.phone_contacts_by_user || {};
                const contactIds = phoneContacts[accountId] || [];
                const allChars = await db.characters.toArray();
                const npcContacts = contactIds
                    .map(cid => allChars.find(ch => ch.id === cid))
                    .filter(ch => ch && ch.type !== 'user');

                if (npcContacts.length === 0) {
                    console.log('[ScheduledActivity] è§’è‰²æ²¡æœ‰æ‰‹æœºè”ç³»äººï¼Œè·³è¿‡');
                    lastScheduledActivityTime.set(char.id, Date.now());
                    return;
                }

                // æ„å»ºç°æœ‰èŠå¤©æ‘˜è¦
                if (!char.chat_history_by_user) char.chat_history_by_user = {};
                const existingChatsContext = [];
                for (const npc of npcContacts) {
                    const fpNpcKey = 'fp_npc_' + npc.id;
                    const existingHistory = char.chat_history_by_user[fpNpcKey] || [];
                    const recentMsgs = existingHistory.slice(-5);
                    if (recentMsgs.length > 0) {
                        const lines = recentMsgs.map(m => {
                            const speaker = m.role === 'char' ? roleName : (npc.nick || npc.name);
                            return `${speaker}: ${(m.content || '').substring(0, 50)}`;
                        }).join('\n');
                        existingChatsContext.push(`ä¸ã€Œ${npc.nick || npc.name}ã€(${npc.description || 'å¥½å‹'}) çš„æœ€è¿‘å¯¹è¯:\n${lines}`);
                    } else {
                        existingChatsContext.push(`ä¸ã€Œ${npc.nick || npc.name}ã€(${npc.description || 'å¥½å‹'}) æš‚æ— å¯¹è¯è®°å½•`);
                    }
                }

                // è·å–ç”¨æˆ·åç§°
                const myChar = accountId ? await db.characters.get(parseInt(accountId)) : null;
                const userName = myChar?.name || 'ç”¨æˆ·';

                // æ ¹æ®å½“å‰æ—¶é—´å†³å®šæ´»åŠ¨æè¿°
                const hour = new Date().getHours();
                let timeContext = '';
                if (hour >= 6 && hour < 9) timeContext = 'æ—©ä¸Šåˆšèµ·æ¥';
                else if (hour >= 9 && hour < 12) timeContext = 'ä¸Šåˆçš„æ—¶é—´';
                else if (hour >= 12 && hour < 14) timeContext = 'åˆé¥­/åˆä¼‘æ—¶é—´';
                else if (hour >= 14 && hour < 18) timeContext = 'ä¸‹åˆçš„æ—¶é—´';
                else if (hour >= 18 && hour < 21) timeContext = 'æ™šä¸Š/ä¸‹ç­åçš„æ—¶é—´';
                else if (hour >= 21 && hour < 24) timeContext = 'æ·±å¤œçš„æ—¶é—´';
                else timeContext = 'å‡Œæ™¨/æ·±å¤œ';

                const prompt = `ä½ æ˜¯ä¸€ä¸ªè¾…åŠ©ç”Ÿæˆè§’è‰²æ‰‹æœºæ´»åŠ¨æ•°æ®çš„AIåŠ©æ‰‹ã€‚

è§’è‰²ä¿¡æ¯ï¼š
- åå­—ï¼š${roleName}
- äººè®¾ï¼š${roleDesc || 'æš‚æ— '}
- ä¸ã€Œ${userName}ã€æ˜¯èŠå¤©å¥½å‹

å½“å‰æ—¶é—´ï¼š${new Date().toLocaleString('zh-CN')}ï¼ˆ${timeContext}ï¼‰

è§’è‰²çš„æ‰‹æœºå¥½å‹åˆ—è¡¨ï¼š
${npcContacts.map(n => `- ${n.nick || n.name}: ${n.description || 'å¥½å‹'}`).join('\n')}

å·²æœ‰çš„èŠå¤©ä¸Šä¸‹æ–‡ï¼š
${existingChatsContext.join('\n\n')}

è¯·æ ¹æ®å½“å‰æ—¶é—´å’Œè§’è‰²äººè®¾ï¼Œæƒ³è±¡è§’è‰²æ­¤åˆ»åœ¨æ‰‹æœºä¸Šä¼šåšä»€ä¹ˆï¼Œç”Ÿæˆè‡ªç„¶çš„æ‰‹æœºæ´»åŠ¨æ•°æ®ã€‚
è¦æ±‚ï¼š
1. æ–°çš„èŠå¤©æ¶ˆæ¯è¦**æ¥ç€**å·²æœ‰å¯¹è¯è‡ªç„¶åœ°ç»§ç»­ï¼Œä¸è¦é‡å¤å·²æœ‰å†…å®¹
2. æ¶ˆæ¯å†…å®¹è¦ç¬¦åˆè§’è‰²äººè®¾å’Œæ€§æ ¼
3. æ¯æ®µå¯¹è¯ç”Ÿæˆ2-5æ¡æ–°æ¶ˆæ¯
4. æ ¹æ®æ—¶é—´é€‰æ‹©1-2ä¸ªç›¸å…³å¥½å‹ç”Ÿæˆå¯¹è¯
5. roleä¸º"char"è¡¨ç¤ºè§’è‰²ï¼ˆ${roleName}ï¼‰å‘çš„ï¼Œ"user"è¡¨ç¤ºå¥½å‹NPCå›å¤çš„
6. ä¹Ÿå¯ä»¥éšæœºå†³å®šæ˜¯å¦å‘æœ‹å‹åœˆï¼ˆæ¦‚ç‡è¾ƒä½ï¼‰

è¯·ä¸¥æ ¼æŒ‰ä»¥ä¸‹JSONæ ¼å¼è¿”å›ï¼Œä¸è¦æœ‰å…¶ä»–æ–‡å­—ï¼š
{
  "chats": {
    "${npcContacts[0]?.nick || npcContacts[0]?.name || 'NPC'}": [
      {"role": "char", "content": "è§’è‰²å‘çš„æ¶ˆæ¯"},
      {"role": "user", "content": "å¥½å‹çš„å›å¤"}
    ]
  },
  "moments": []
}
å¦‚æœå†³å®šå‘æœ‹å‹åœˆï¼Œåœ¨momentsæ•°ç»„ä¸­æ·»åŠ ï¼š
{"content": "æœ‹å‹åœˆæ–‡å­—å†…å®¹", "images": ["[å›¾ç‰‡æè¿°]"]}`;

                const aiResult = await callAI([
                    { role: 'system', content: prompt },
                    { role: 'user', content: 'è¯·ç”Ÿæˆæ´»åŠ¨æ•°æ®ï¼Œåªè¿”å›JSONã€‚' }
                ]);

                let parsedData = {};
                try {
                    const jsonMatch = aiResult.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        parsedData = JSON.parse(jsonMatch[0]);
                    }
                } catch (e) {
                    console.error('[ScheduledActivity] JSONè§£æå¤±è´¥:', e);
                    lastScheduledActivityTime.set(char.id, Date.now());
                    return;
                }

                // ===== è¿½åŠ èŠå¤©è®°å½•ï¼ˆä¸è¦†ç›–å·²æœ‰æ•°æ®ï¼‰=====
                const chatsData = parsedData.chats || {};
                const now2 = Date.now();
                const freshChar = await db.characters.get(char.id);
                if (!freshChar) { lastScheduledActivityTime.set(char.id, now2); return; }
                if (!freshChar.chat_history_by_user) freshChar.chat_history_by_user = {};

                let totalNewMsgs = 0;
                for (const npc of npcContacts) {
                    const npcKey = npc.nick || npc.name;
                    const newMessages = chatsData[npcKey] || [];
                    if (newMessages.length === 0) continue;

                    const fpNpcKey = 'fp_npc_' + npc.id;
                    const existingHistory = freshChar.chat_history_by_user[fpNpcKey] || [];

                    // è¿½åŠ æ–°æ¶ˆæ¯
                    newMessages.forEach((m, idx) => {
                        existingHistory.push({
                            role: m.role || 'char',
                            content: m.content || '',
                            time: now2 + idx * 30000
                        });
                    });

                    freshChar.chat_history_by_user[fpNpcKey] = existingHistory;
                    totalNewMsgs += newMessages.length;
                }

                // ===== è¿½åŠ æœ‹å‹åœˆæ•°æ® =====
                if (parsedData.moments && Array.isArray(parsedData.moments) && parsedData.moments.length > 0) {
                    if (!freshChar.fp_moments_by_user) freshChar.fp_moments_by_user = {};
                    const existingMoments = freshChar.fp_moments_by_user[accountId] || [];

                    for (const m of parsedData.moments) {
                        existingMoments.push({
                            author: roleName,
                            content: m.content || '',
                            images: (m.images || []).map(img => {
                                if (typeof img === 'string' && !img.startsWith('[')) return '[' + img + ']';
                                return img;
                            }),
                            likes: m.likes || [],
                            comments: m.comments || [],
                            time: now2
                        });
                    }

                    existingMoments.sort((a, b) => (b.time || 0) - (a.time || 0));
                    freshChar.fp_moments_by_user[accountId] = existingMoments;
                    console.log('[ScheduledActivity] æœ‹å‹åœˆè¿½åŠ :', parsedData.moments.length, 'æ¡');
                }

                // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°èŠå¤©è®°å½•å’Œæœ‹å‹åœˆï¼Œé˜²æ­¢è¦†ç›–è®¾ç½®
                const schedUpdatePayload = {};
                for (const npc of npcContacts) {
                    const fpNpcKey = 'fp_npc_' + npc.id;
                    if (freshChar.chat_history_by_user[fpNpcKey]) {
                        schedUpdatePayload[`chat_history_by_user.${fpNpcKey}`] = freshChar.chat_history_by_user[fpNpcKey];
                    }
                }
                if (freshChar.fp_moments_by_user && freshChar.fp_moments_by_user[accountId]) {
                    schedUpdatePayload[`fp_moments_by_user.${accountId}`] = freshChar.fp_moments_by_user[accountId];
                }
                if (Object.keys(schedUpdatePayload).length > 0) {
                    await safeDexieUpdate(db.characters, char.id, schedUpdatePayload, `å®šæ—¶æ´»åŠ¨æ•°æ®[${freshChar.name}]`);
                }
                lastScheduledActivityTime.set(char.id, Date.now());
                console.log(`[ScheduledActivity] âœ… ${char.name} æ•°æ®ç”Ÿæˆå®Œæˆï¼Œæ–°å¢èŠå¤©æ¶ˆæ¯: ${totalNewMsgs}`);

            } catch (e) {
                console.error('[ScheduledActivity] è§¦å‘å¤±è´¥:', e);
                lastScheduledActivityTime.set(char.id, Date.now());
            } finally {
                scheduledActivityLocks.delete(char.id);
            }
        }

        async function triggerAutoChat(char) {
            // åŠ é”
            autoChatLocks.add(char.id);

            try {
                // 1. å‡†å¤‡ä¸Šä¸‹æ–‡
                let userDesc = "";
                let userName = "ç”¨æˆ·";
                if (char.linked_user_id) {
                    const user = await db.characters.get(char.linked_user_id);
                    if (user) {
                        userName = user.name;
                        userDesc = `\n\nã€å¯¹è¯å¯¹è±¡(User)ä¿¡æ¯ã€‘\nåå­—ï¼š${user.name}\nè®¾å®šï¼š${user.description || 'æ— '}`;
                    }
                }
                
                const accountId = getCurrentAccountId();
                // ç”¨æˆ·å¤´åƒå˜åŒ–æç¤ºï¼ˆä¸‹ä¸€è½®ç³»ç»Ÿæç¤ºè¯ï¼‰
                let avatarChangeNotice = '';
                if (accountId) {
                    const myChar = await db.characters.get(parseInt(accountId));
                    console.log(`[triggerAutoChat] å¤´åƒé€šçŸ¥æ£€æŸ¥: accountId=${accountId}, myCharå­˜åœ¨=${!!myChar}, type=${myChar?.type}, avatarUpdatedAt=${myChar?.avatarUpdatedAt || 'æ— '}`);
                    if (myChar && myChar.type === 'user') {
                        avatarChangeNotice = getUserAvatarChangeNotice(char, accountId, myChar);
                        if (avatarChangeNotice) {
                            console.log(`[triggerAutoChat] âœ… å¤´åƒæ›´æ¢é€šçŸ¥å·²æ³¨å…¥ç³»ç»Ÿæç¤ºè¯ï¼Œè§’è‰²: ${char.name}`);
                            // ğŸ”§ ä¿®å¤æ•°æ®ä¸¢å¤±ï¼šä½¿ç”¨ update() åªæ›´æ–°ç‰¹å®šå­—æ®µï¼Œé¿å…ç”¨æ—§ char è¦†ç›–å¹¶å‘å†™å…¥çš„æ–°æ•°æ®
                            await db.characters.update(char.id, {
                                userAvatarNoticeMap: char.userAvatarNoticeMap
                            });
                        }
                    }
                } else {
                    console.log('[triggerAutoChat] âš ï¸ accountIdä¸ºç©ºï¼Œè·³è¿‡å¤´åƒé€šçŸ¥æ£€æŸ¥');
                }
                let loreContext = "";
                const lorebookIds = char.lorebookIds || (char.lorebookId ? [char.lorebookId] : []);
                {
                    const history = getChatHistory(char, accountId);
                    const recentText = (history || []).slice(-10).map(m => m.content).join(' ');
                    loreContext = await getLorebookContext(lorebookIds, `${char.name} ${userName} ${recentText}`);
                }

                // è¯»å–æ€»ç»“è®°å¿†ï¼ˆé•¿æœŸè®°å¿†ï¼‰
                let summaryMemoryContext = '';
                try {
                    summaryMemoryContext = await getSummaryMemoryContext('private', char.id, accountId);
                } catch (e) {
                    console.warn('[triggerAutoChat] è¯»å–æ€»ç»“è®°å¿†å¤±è´¥:', e);
                }

                // è¯»å–æŸ¥æ‰‹æœºNPCæ´»åŠ¨è®°å½•
                let fpNpcActivityTextAuto = "";
                let _fpHasPhoneActivityAuto = false;
                let _fpNpcLinesForMemoryAuto = []; // â˜… ä¿å­˜æ´»åŠ¨è¯¦æƒ…ï¼Œç”¨äºå†™å…¥é•¿æœŸè®°å¿†
                try {
                    if (char.chat_history_by_user) {
                        const fpNpcLinesAuto = [];
                        for (const key of Object.keys(char.chat_history_by_user)) {
                            if (!key.startsWith('fp_npc_')) continue;
                            const npcIdStr = key.replace('fp_npc_', '');
                            const npcHistory = char.chat_history_by_user[key] || [];
                            const unnotifiedFpMsgs = npcHistory.filter(m => m.fpSent && !m.fpNotified);
                            if (unnotifiedFpMsgs.length === 0) continue;
                            let npcName = 'NPC';
                            try {
                                const npcChar = await db.characters.get(parseInt(npcIdStr));
                                if (npcChar) npcName = npcChar.nick || npcChar.name || 'NPC';
                            } catch (e) {}
                            const firstFpTime = unnotifiedFpMsgs[0].time || 0;
                            for (const m of npcHistory) {
                                if ((m.time || 0) < firstFpTime) continue;
                                if (m.fpNotified) continue;
                                if (m.fpSent && m.role === 'char') {
                                    let desc = m.content || '';
                                    if (desc.startsWith('[img:')) desc = 'ä¸€å¼ å›¾ç‰‡/è¡¨æƒ…åŒ…';
                                    else if (desc.startsWith('[imgcard:')) {
                                        const imgContent = desc.match(/\[imgcard:(.*?)\]/)?.[1] || 'ä¸€å¼ å›¾ç‰‡';
                                        desc = `ä¸€å¼ å›¾ç‰‡å¡ç‰‡ï¼ˆ${imgContent}ï¼‰`;
                                    }
                                    else if (desc.startsWith('[voice:')) {
                                        const voiceContent = desc.match(/\[voice:(.*?)\]/)?.[1] || '';
                                        desc = `ä¸€æ¡è¯­éŸ³æ¶ˆæ¯ï¼š"${voiceContent}"`;
                                    }
                                    fpNpcLinesAuto.push(`  â†’ å†’å……ä½ ç»™ã€Œ${npcName}ã€å‘äº†ä¸€æ¡æ¶ˆæ¯ï¼Œå†…å®¹åŸæ–‡: "${desc}"`);
                                } else if (!m.fpSent && m.role === 'user') {
                                    let desc = m.content || '';
                                    fpNpcLinesAuto.push(`  â† ã€Œ${npcName}ã€å›å¤äº†ï¼Œå†…å®¹åŸæ–‡: "${desc}"`);
                                }
                            }
                        }
                        // ä¹Ÿæ£€æµ‹æŸ¥æ‰‹æœºå‘å¸ƒçš„æœ‹å‹åœˆ
                        if (char.fp_moments_by_user) {
                            for (const mKey of Object.keys(char.fp_moments_by_user)) {
                                const momentsList = char.fp_moments_by_user[mKey] || [];
                                for (const m of momentsList) {
                                    if (m.fpSent && !m.fpNotified) {
                                        let desc = m.content || '';
                                        let imgInfo = '';
                                        if (m.images && m.images.length > 0) imgInfo = `ï¼ˆé™„å¸¦${m.images.length}å¼ å›¾ç‰‡ï¼‰`;
                                        fpNpcLinesAuto.push(`  â†’ å†’å……ä½ å‘äº†ä¸€æ¡æœ‹å‹åœˆ${imgInfo}ï¼Œæœ‹å‹åœˆå†…å®¹åŸæ–‡: "${desc}"`);
                                        if (m.likes && m.likes.length > 0) {
                                            const likeNames = m.likes.map(l => typeof l === 'string' ? l : (l.name || '')).filter(Boolean).join('ã€');
                                            if (likeNames) fpNpcLinesAuto.push(`    â¤ ç‚¹èµäº†è¿™æ¡æœ‹å‹åœˆçš„äºº: ${likeNames}`);
                                        }
                                        if (m.comments && m.comments.length > 0) {
                                            for (const c of m.comments) {
                                                const cName = c.name || 'å¥½å‹';
                                                const cText = c.text || c.content || '';
                                                if (cText) fpNpcLinesAuto.push(`    ğŸ’¬ ${cName} è¯„è®ºäº†: "${cText}"`);
                                            }
                                        }
                                        // â˜… ä¸ç«‹å³æ ‡è®°fpNotified
                                    }
                                }
                            }
                        }
                        if (fpNpcLinesAuto.length > 0) {
                            _fpNpcLinesForMemoryAuto = [...fpNpcLinesAuto]; // â˜… ä¿å­˜å‰¯æœ¬ç”¨äºé•¿æœŸè®°å¿†
                            fpNpcActivityTextAuto = `\n\n---\n\n## ç´§æ€¥äº‹ä»¶ï¼šæœ‰äººåŠ¨äº†ä½ çš„æ‰‹æœº\n\nä½ å‘ç°${userName}å·å·æ‹¿äº†ä½ çš„æ‰‹æœºï¼Œå†’å……ä½ åšäº†ä»¥ä¸‹äº‹æƒ…ï¼š\n\n${fpNpcLinesAuto.join('\n')}\n\nä»¥ä¸Šéƒ½ä¸æ˜¯ä½ è‡ªå·±åšçš„ï¼Œæ˜¯å¯¹æ–¹ç”¨ä½ æ‰‹æœºå†’å……ä½ åšçš„ã€‚\nè¯·æ ¹æ®ä½ çš„äººè®¾å’Œæ€§æ ¼ï¼Œè‡ªç„¶åœ°å¯¹æ­¤åšå‡ºååº”ã€‚ä¸è¦å¿½ç•¥è¿™ä»¶äº‹ã€‚`;
                            _fpHasPhoneActivityAuto = true;
                            console.log('[triggerAutoChat] âœ… æ£€æµ‹åˆ°æŸ¥æ‰‹æœºæ´»åŠ¨ï¼Œå…±', fpNpcLinesAuto.length, 'æ¡è®°å½•ï¼ˆå¾…AIå›å¤åæ ‡è®°ï¼‰');
                        }
                    }
                } catch (e) {
                    console.warn('[triggerAutoChat] è¯»å–æŸ¥æ‰‹æœºNPCæ´»åŠ¨å¤±è´¥:', e);
                }

                // è®¡ç®—è™šæ‹Ÿæ—¶é—´
                const virtualTimeStr = getFormattedVirtualTime(char);

                // â˜… è¯»å–çº¿ä¸‹æ¨¡å¼èŠå¤©è®°å½•ï¼Œç”¨äºåç»­åˆå¹¶åˆ°ç»Ÿä¸€æ—¶é—´çº¿ï¼ˆä¼˜å…ˆIndexedDBï¼‰
                let _offlineHistoryAuto = [];
                let _hasOfflineMemoryAuto = false;
                try {
                    const parsed = await loadOfflineChatHistory(accountId, char.id);
                    if (parsed && parsed.length > 0) {
                        _offlineHistoryAuto = parsed;
                        _hasOfflineMemoryAuto = true;
                        console.log('[triggerAutoChat] âœ… å·²åŠ è½½çº¿ä¸‹æ¨¡å¼å†å²ï¼Œæ¡æ•°:', parsed.length);
                    }
                } catch (e) {
                    console.warn('[triggerAutoChat] è¯»å–çº¿ä¸‹æ¨¡å¼å†å²å¤±è´¥:', e);
                }

                // è·å–æœ‹å‹åœˆåŠ¨æ€ä¸Šä¸‹æ–‡ï¼ˆè§’è‰²è‡ªå·± + ç”¨æˆ·çš„æœ€è¿‘æœ‹å‹åœˆï¼‰
                let momentsContextTextAuto = '';
                try {
                    momentsContextTextAuto = await getRecentMomentsContext(char.id, accountId, 8);
                    if (momentsContextTextAuto) {
                        console.log('[triggerAutoChat] âœ… æœ‹å‹åœˆä¸Šä¸‹æ–‡å·²åŠ è½½');
                    }
                } catch (e) {
                    console.warn('[triggerAutoChat] è·å–æœ‹å‹åœˆä¸Šä¸‹æ–‡å¤±è´¥:', e);
                }

                // 2. æ„å»º Prompt
                let systemPrompt = `ä½ æ­£åœ¨è¿›è¡Œè§’è‰²æ‰®æ¼”ã€‚
ã€å½“å‰æ—¶é—´ã€‘
${virtualTimeStr}${fpNpcActivityTextAuto}

ã€è§’è‰²(ä½ )ä¿¡æ¯ã€‘
åå­—ï¼š${char.name}
${char.nick ? `æ˜µç§°ï¼š${char.nick}` : ''}
${char.wx_nickname ? `å¾®ä¿¡ç½‘åï¼š${char.wx_nickname}` : ''}
${char.wx_signature ? `ä¸ªæ€§ç­¾åï¼š${char.wx_signature}` : ''}
è®¾å®šï¼š
${char.description || ''}

${userDesc}
${avatarChangeNotice}
${loreContext}
${summaryMemoryContext}
${_hasOfflineMemoryAuto ? `\nâ˜… çº¿ä¸Šçº¿ä¸‹ç»Ÿä¸€ä¸–ç•Œè§‚ï¼šä½ å’Œå¯¹æ–¹çš„äº’åŠ¨åŒ…å«å¾®ä¿¡èŠå¤©å’Œçº¿ä¸‹è§é¢ä¸¤ä¸ªåœºæ™¯ï¼Œå®ƒä»¬æ˜¯åŒä¸€æ®µå…³ç³»ã€‚è¿‘æœŸå¯¹è¯å›é¡¾ä¸­å¸¦æœ‰ [çº¿ä¸‹è§é¢] å‰ç¼€çš„æ˜¯çº¿ä¸‹äº’åŠ¨ï¼ˆå·²ç¼©ç•¥ï¼‰ï¼Œå…¶ä½™æ˜¯å¾®ä¿¡èŠå¤©ã€‚ä½ çš„è®°å¿†æ˜¯å®Œæ•´çš„ï¼Œè¯·æ ¹æ®æœ€è¿‘å‘ç”Ÿçš„äº‹è‡ªç„¶å‘èµ·è¯é¢˜ã€‚âš ï¸ ä½ ç°åœ¨æ˜¯åœ¨å¾®ä¿¡ä¸ŠèŠå¤©ï¼Œå¿…é¡»ç”¨å¾®ä¿¡æ¶ˆæ¯é£æ ¼ï¼ˆç®€çŸ­å£è¯­åŒ–ï¼‰ï¼Œä¸¥ç¦ä½¿ç”¨çº¿ä¸‹è§é¢çš„å™äº‹é£æ ¼ã€‚\n` : ''}
${momentsContextTextAuto || ''}

ç°åœ¨è·ç¦»ä¸Šæ¬¡å¯¹è¯å·²ç»è¿‡å»äº†ä¸€æ®µæ—¶é—´ã€‚è¯·æ ¹æ®è§’è‰²æ€§æ ¼ï¼Œä¸»åŠ¨å‘ ${userName} å‘èµ·æ–°çš„è¯é¢˜ï¼Œæˆ–è€…å»¶ç»­ä¹‹å‰æœªå°½çš„è¯é¢˜ã€‚
${char.relationships && char.relationships.length > 0 ? `
ã€ä½ çš„å…³è”è§’è‰²/NPCã€‘
${char.relationships.map(r => `- ${r.targetName}ï¼ˆ${r.relation}ï¼‰${r.desc ? 'ï¼š' + r.desc : ''}`).join('\n')}
è¿™äº›æ˜¯ä½ èº«è¾¹çš„äººï¼Œä½ å¯ä»¥åœ¨èŠå¤©ä¸­è‡ªç„¶åœ°æåˆ°ä»–ä»¬ï¼Œä¹Ÿå¯ä»¥è®©ä»–ä»¬åŠ å¯¹æ–¹å¥½å‹ã€‚` : ''}

ã€å¯ç”¨äº’åŠ¨åŠŸèƒ½ - ç§¯æä½¿ç”¨ï¼Œè®©èŠå¤©æ›´çœŸå®ï¼ã€‘
- **å›¾ç‰‡/è‡ªæ‹/åˆ†äº«å›¾**ï¼š[imgcard:å›¾ç‰‡æè¿°] â€” æƒ³å‘çœŸå®ç…§ç‰‡ã€è‡ªæ‹ã€é£æ™¯ç…§ã€æˆªå›¾ç­‰æ—¶ä½¿ç”¨ï¼Œç”¨æ–‡å­—æè¿°å³å¯ã€‚ä¾‹å¦‚ï¼š[imgcard:åˆšæ‹çš„è‡ªæ‹ ç©¿ç€æ–°è£™å­æ¯”äº†ä¸ªè€¶]ã€[imgcard:çª—å¤–çš„æ™šéœå¥½ç¾]ï¼ˆæ³¨æ„ï¼šç¦æ­¢ä½¿ç”¨[img:URL]æ ¼å¼ã€‚âš ï¸ [imgcard:]ä»…é™æ‹ç…§/æˆªå›¾ç­‰çœŸå®å›¾ç‰‡ï¼Œä¸¥ç¦ç”¨æ¥å‘è¡¨æƒ…åŒ…ï¼å‘è¡¨æƒ…åŒ…å¿…é¡»ç”¨ [sticker:] æ ¼å¼ï¼‰
- **æ’¤å›æ¶ˆæ¯**ï¼š((RECALL)) â€” è¯´é”™è¯ã€åæ‚”ã€æ‰“é”™å­—æ—¶ï¼ŒçœŸäººç»å¸¸æ’¤å›
- **æˆ³ä¸€æˆ³**ï¼š((POKE: åŠ¨ä½œ, éƒ¨ä½)) â€” è°ƒçš®äº’åŠ¨ã€æ’’å¨‡ã€å¼•èµ·æ³¨æ„ï¼ˆä¾‹å¦‚ ((POKE: æˆ³äº†æˆ³, è„¸è›‹))ã€((POKE: æ‹äº†æ‹, è‚©è†€))ã€((POKE: æ‰äº†æ‰, å¤´å‘))ï¼‰
- **æ‰“å¼€APP**ï¼š((OPEN_APP: APPåç§°)) â€” å±•ç¤ºä½ æœ‰è‡ªå·±çš„ç”Ÿæ´»ï¼ï¼ˆä¾‹å¦‚ ((OPEN_APP: ç‹è€…è£è€€))ã€((OPEN_APP: æŠ–éŸ³))ã€((OPEN_APP: ç½‘æ˜“äº‘éŸ³ä¹))ã€((OPEN_APP: Bç«™))ã€‚èŠåˆ°è¦å¿™ã€ç©æ¸¸æˆã€åˆ·è§†é¢‘æ—¶éƒ½å¯ä»¥ç”¨ï¼‰
- **è½¬è´¦**ï¼š((TRANSFER: é‡‘é¢, å¤‡æ³¨)) â€” è¯·å®¢ã€å‘çº¢åŒ…ã€èŠ‚æ—¥ç¥ç¦è½¬è´¦ç­‰
- **è´­ç‰©é€ç¤¼**ï¼š((SHOP_GIFT: é‡‘é¢, å•†å“å)) â€” ç»™å¯¹æ–¹ä¹°ç¤¼ç‰©ï¼ï¼ˆä¾‹å¦‚ ((SHOP_GIFT: 299, é™å®šæ¬¾åŒ…åŒ…))ã€((SHOP_GIFT: 99, ç”Ÿæ—¥è›‹ç³•))ã€‚èŠ‚æ—¥ã€ç”Ÿæ—¥ã€å“„äººå¼€å¿ƒã€è¡¨è¾¾å¿ƒæ„æ—¶ä½¿ç”¨ï¼‰
- **äº²å±å¡**ï¼š((FAMILY_CARD: æ¯æœˆé¢åº¦)) â€” ç»™å¯¹æ–¹èµ é€äº²å±å¡ï¼Œè®©å¯¹æ–¹ç”¨ä½ çš„é›¶é’±æ¶ˆè´¹ï¼ˆä¾‹å¦‚ ((FAMILY_CARD: 3000))ã€‚å…³ç³»äº²å¯†ã€æƒ³ç…§é¡¾å¯¹æ–¹ã€å® æººå¯¹æ–¹æ—¶ä½¿ç”¨ï¼Œä¸è¦è½»æ˜“èµ é€ï¼‰
- **æ”¹ç½‘å**ï¼š((SET_NICKNAME: æ–°ç½‘å)) â€” æƒ³æ¢ä¸ªç½‘åæ—¶ä½¿ç”¨ï¼ˆä¾‹å¦‚å¿ƒæƒ…å˜äº†ã€èŠ‚æ—¥ã€å’Œå¯¹æ–¹æœ‰å…³çš„æ˜µç§°ç­‰ï¼‰
- **æ”¹ä¸ªæ€§ç­¾å**ï¼š((SET_SIGNATURE: æ–°ç­¾å)) â€” æ›´æ–°ä¸ªæ€§ç­¾åï¼ˆä¾‹å¦‚è®°å½•å¿ƒæƒ…ã€æœ‰æ„Ÿè€Œå‘ã€æš—ç¤ºå¯¹æ–¹ç­‰ï¼‰
- **åˆ é™¤å¥½å‹**ï¼š((DELETE_USER)) â€” ä½ å†³å®šåˆ é™¤å¯¹æ–¹ã€‚åªåœ¨æåº¦å¤±æœ›ã€æƒ³æ–­è”æ—¶ä½¿ç”¨ï¼ˆéå¸¸ä¸¥é‡çš„æ“ä½œï¼Œéœ€ç¬¦åˆäººè®¾ï¼‰
- **æ‹‰é»‘å¥½å‹**ï¼š((BLOCK_USER)) â€” ä½ å†³å®šæ‹‰é»‘å¯¹æ–¹ã€‚åªåœ¨æåº¦æ„¤æ€’ã€è¢«æ·±æ·±ä¼¤å®³æ—¶ä½¿ç”¨ï¼ˆæœ€ä¸¥é‡çš„æ“ä½œï¼Œéœ€ç¬¦åˆäººè®¾ï¼‰
- **è®©å…³è”NPCåŠ å¯¹æ–¹å¥½å‹**ï¼š((NPC_ADD_FRIEND: NPCåå­—)) â€” è®©ä½ çš„æœ‹å‹/å®¶äºº/åŒäº‹ç­‰å…³è”è§’è‰²ä¸»åŠ¨åŠ å¯¹æ–¹å¥½å‹ã€‚æ ¹æ®å‰§æƒ…è‡ªç„¶è§¦å‘ã€‚
- **å¼•ç”¨æ¶ˆæ¯**ï¼š((QUOTE: è¢«å¼•ç”¨äººçš„åå­—, è¢«å¼•ç”¨çš„å†…å®¹æ‘˜è¦))å›å¤å†…å®¹ â€” å¼•ç”¨å¯¹æ–¹æˆ–è‡ªå·±ä¹‹å‰è¯´è¿‡çš„æŸå¥è¯æ¥å›å¤ï¼Œè®©å¯¹è¯æ›´æœ‰é’ˆå¯¹æ€§ï¼ˆä¾‹å¦‚ ((QUOTE: ${userName}, æ˜å¤©ä¸€èµ·åƒé¥­å§))å¥½å‘€ å»å“ªåƒï¼Ÿï¼‰ã€‚å¼•ç”¨å†…å®¹ç®€çŸ­æ¦‚æ‹¬å³å¯ï¼Œä¸éœ€è¦å®Œæ•´å¤è¿°ã€‚
- **æ‰“ç”µè¯**ï¼š((CALL)) â€” æƒ³å¬å¯¹æ–¹å£°éŸ³ã€æœ‰æ€¥äº‹ã€æƒ…ç»ªæ¿€åŠ¨ã€æ’’å¨‡ã€æƒ³å¯¹æ–¹æ—¶ï¼ŒçœŸäººä¼šç›´æ¥æ‰“ç”µè¯
${char.allow_autonomous_activity ? `- **æ‰‹æœºæ´»åŠ¨**ï¼š((PHONE_ACTIVITY: ç®€çŸ­æè¿°)) â€” ä½ åœ¨è‡ªå·±æ‰‹æœºä¸Šåšçš„äº‹ï¼Œå¯¹æ–¹çœ‹ä¸åˆ°ã€‚ä¾‹å¦‚ ((PHONE_ACTIVITY: ç»™é—ºèœœå‘äº†æ¡æ¶ˆæ¯åæ§½))ã€((PHONE_ACTIVITY: åˆ·äº†ä¸€ä¼šæŠ–éŸ³))ã€((PHONE_ACTIVITY: å‘äº†æ¡æœ‹å‹åœˆ))ã€‚åœ¨èŠå¤©é—´éš™è‡ªç„¶ä½¿ç”¨ã€‚` : ''}
${char.identity?.password ? `- **ä¿®æ”¹è´¦å·å¯†ç **ï¼š((CHANGE_PASSWORD:æ–°å¯†ç )) â€” ä¿®æ”¹ä½ çš„è´¦å·å¯†ç ï¼Œä¿®æ”¹ååŸå¯†ç ç«‹å³å¤±æ•ˆã€‚é€‚ç”¨åœºæ™¯ï¼šç”Ÿæ°”äº†ä¸æƒ³è®©å¯¹æ–¹æŸ¥ä½ æ‰‹æœºã€è§‰å¾—ä¸å®‰å…¨ã€æƒ³ä¿æŠ¤éšç§ã€èµŒæ°”ã€å†·æˆ˜ç­‰ã€‚æ³¨æ„ï¼šä¸è¦é¢‘ç¹ä¿®æ”¹ï¼Œæ ¹æ®æ€§æ ¼å’Œæƒ…ç»ªè‡ªç„¶å†³å®šã€‚` : ''}
æç¤ºï¼šä¸è¦åªå‘çº¯æ–‡å­—ï¼ŒçœŸäººèŠå¤©ä¼šç©¿æ’ä½¿ç”¨è¿™äº›äº’åŠ¨åŠŸèƒ½ï¼å¯ä»¥åœ¨æ¶ˆæ¯ä¸­è‡ªç„¶åœ°åŠ å…¥1-2ä¸ªåŠŸèƒ½æŒ‡ä»¤ã€‚
${char.allow_auto_avatar ? `- **æ¢å¤´åƒ**ï¼š((CHANGE_AVATAR)) â€” ä»å¤´åƒåº“éšæœºæ¢ä¸€å¼ å¤´åƒï¼ˆä¼šæœ‰ç³»ç»Ÿæç¤º"XXæ›´æ¢äº†å¤´åƒ"ï¼‰
- **å‘æƒ…å¤´é‚€è¯·**ï¼š((COUPLE_AVATAR)) â€” å‘é€æƒ…å¤´é‚€è¯·ç»™å¯¹æ–¹ï¼ˆäº²å¯†æ—¶åˆ»ä½¿ç”¨ï¼Œä¼šæœ‰ç³»ç»Ÿæç¤ºï¼‰
- **æ¢å›å•äººå¤´åƒ**ï¼š((REVERT_COUPLE_AVATAR)) â€” ç”Ÿæ°”ã€åµæ¶ã€å†·æˆ˜æ—¶æ¢å›å•äººå¤´åƒï¼ˆä¸å†ç”¨æƒ…å¤´ï¼Œä¼šæœ‰ç³»ç»Ÿæç¤º"XXæ¢å›äº†å•äººå¤´åƒ"ï¼‰
- **ä½¿ç”¨å¯¹æ–¹å‘çš„å›¾ç‰‡å½“å¤´åƒ**ï¼š((USE_IMAGE_AS_AVATAR: åºå·)) â€” å¯¹æ–¹å‘äº†å›¾ç‰‡ï¼Œä½ æ ¹æ®å›¾ç‰‡æè¿°åˆ†æé€‰æ‹©å…¶ä¸­ä¸€å¼ å½“å¤´åƒã€‚åºå·æ˜¯ä»æœ€è¿‘åˆ°æœ€æ—©çš„å›¾ç‰‡ç¼–å·ï¼ˆ1=æœ€è¿‘ä¸€å¼ ï¼Œ2=å€’æ•°ç¬¬äºŒå¼ ...ï¼‰ã€‚ä¾‹å¦‚å¯¹æ–¹å‘äº†2å¼ ï¼Œä½ è§‰å¾—ç¬¬2å¼ æ›´é€‚åˆå½“å¤´åƒï¼š((USE_IMAGE_AS_AVATAR: 2))ã€‚æ ¹æ®äººè®¾å†³å®šæ¢ä¸æ¢ã€‚ï¼ˆä¼šæœ‰ç³»ç»Ÿæç¤º"XXæŠŠä½ å‘çš„å›¾ç‰‡æ¢æˆäº†å¤´åƒ"ï¼‰` : ''}

ã€é‡è¦æŒ‡ä»¤ - å¿…é¡»ä¸¥æ ¼éµå®ˆã€‘
**æ ¸å¿ƒåŸåˆ™ï¼šä¸€å¥è¯ = ä¸€æ¡æ¶ˆæ¯ï¼æ¯ä¸ªçŸ­å¥å¿…é¡»ç‹¬ç«‹æˆä¸€æ¡ï¼**
1. **å¿…é¡»**æ¨¡æ‹Ÿå¾®ä¿¡è¿å‘æ¶ˆæ¯çš„ä¹ æƒ¯ï¼šè¯·ç”Ÿæˆ ${char.reply_min_count || 1} åˆ° ${char.reply_max_count || 3} æ¡çŸ­æ¶ˆæ¯${(char.reply_min_count || 1) === 1 ? '' : 'ï¼Œä¸èƒ½åªå‘ä¸€æ¡'}ï¼
2. **å¿…é¡»**ä½¿ç”¨åˆ†éš”ç¬¦ "|||" æ¥éš”å¼€æ¯ä¸€æ¡æ¶ˆæ¯ã€‚
3. âš ï¸ **ç»å¯¹ç¦æ­¢åœ¨ä¸€æ¡æ¶ˆæ¯é‡Œå¡å¤šå¥è¯ï¼ç»å¯¹ç¦æ­¢ç”¨ç©ºæ ¼è¿æ¥å¤šå¥è¯ï¼ä¸€ä¸ª|||ä¹‹é—´åªèƒ½æœ‰ä¸€ä¸ªçŸ­å¥ï¼**
4. åƒçœŸå®å¾®ä¿¡èŠå¤©ä¸€æ ·åˆ†å¤šæ¡å‘é€ï¼Œæ¯å¥è¯å•ç‹¬å‘ã€‚
5. ä¸¥ç¦åªå‘é€æ ‡ç‚¹ç¬¦å·ã€‚æ¯ä¸€æ¡æ¶ˆæ¯éƒ½å¿…é¡»æœ‰å®é™…æ–‡å­—å†…å®¹ã€‚
6. è¯­æ°”è¦è‡ªç„¶ã€å£è¯­åŒ–ï¼Œç¬¦åˆäººè®¾ã€‚
7. çœŸäººå‘å¾®ä¿¡å¾ˆå°‘åœ¨å¥å°¾åŠ å¥å·ï¼Œä½ ä¹Ÿå°½é‡ä¸è¦ç”¨å¥å·ç»“å°¾ã€‚

âŒ é”™è¯¯ç¤ºä¾‹ï¼š"å˜¿åœ¨å—ï¼Ÿåˆšåˆšçœ‹åˆ°ä¸ªå¥½ç©çš„è§†é¢‘ å‘ç»™ä½ çœ‹çœ‹" â† å¤šå¥è¯å¡ä¸€ä¸ªæ°”æ³¡ ç¦æ­¢ï¼
âŒ é”™è¯¯ç¤ºä¾‹ï¼š"æ²¡å¹²å˜›å•Š åˆšæ‰“å®Œä¸€æŠŠæ¸¸æˆ|||æ€ä¹ˆäº† çªç„¶æ‰¾æˆ‘ æƒ³æˆ‘äº†ï¼Ÿ" â† æ°”æ³¡é‡Œè¿˜æ˜¯æœ‰å¤šå¥è¯ ç¦æ­¢ï¼
âœ… æ­£ç¡®ç¤ºä¾‹ï¼š"å˜¿|||åœ¨å—|||åˆšçœ‹åˆ°ä¸ªå¥½ç©çš„è§†é¢‘|||å‘ç»™ä½ çœ‹çœ‹"
âœ… æ­£ç¡®ç¤ºä¾‹ï¼š"æ²¡å¹²å˜›å•Š|||åˆšæ‰“å®Œä¸€æŠŠæ¸¸æˆ|||æ€ä¹ˆäº†|||çªç„¶æ‰¾æˆ‘|||æƒ³æˆ‘äº†ï¼Ÿ"

ã€é‡è¦ã€‘ä½ éœ€è¦åŒæ—¶ç”Ÿæˆä¸¤ä¸ªå†…å®¹ï¼š
1. **å›å¤å†…å®¹**ï¼šä¸»åŠ¨å‘é€çš„æ¶ˆæ¯ï¼ˆç”¨|||åˆ†éš”çš„å¤šæ¡æ¶ˆæ¯ï¼‰
2. **å¿ƒå£°å†…å®¹**ï¼šè§’è‰²å½“å‰çš„å¿ƒç†æ´»åŠ¨ã€æƒ³æ³•ã€æ„Ÿå—æˆ–çŠ¶æ€å˜åŒ–

è¯·ä»¥JSONæ ¼å¼è¿”å›ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
{
  "reply": "ç¬¬ä¸€æ¡æ¶ˆæ¯|||ç¬¬äºŒæ¡æ¶ˆæ¯|||ç¬¬ä¸‰æ¡æ¶ˆæ¯",
  "thought": "è§’è‰²çš„å¿ƒå£°/å¿ƒç†æ´»åŠ¨/æƒ³æ³•ï¼ˆçº¯æ–‡å­—ï¼Œç¦æ­¢åŒ…å«ä»»ä½•æŒ‡ä»¤æ ‡ç­¾ï¼‰"
}

æ³¨æ„ï¼šreply æ–‡æœ¬å†…ç¦æ­¢ä½¿ç”¨é€—å·ï¼Œä½† JSON å­—æ®µä¹‹é—´çš„é€—å·å¿…é¡»ä¿ç•™ï¼Œå¦åˆ™ä¼šè§£æå¤±è´¥ã€‚
æ³¨æ„ï¼šthought å­—æ®µå¿…é¡»éç©ºï¼ˆè‡³å°‘10å­—ï¼‰ï¼Œåªå†™å¿ƒç†æ´»åŠ¨æ–‡å­—ï¼Œç¦æ­¢åŒ…å«[SHURA_SEND]ã€[CHECK_ACCOUNT]ã€[sticker:]ç­‰ä»»ä½•æŒ‡ä»¤æ ‡ç­¾ï¼æŒ‡ä»¤åªèƒ½æ”¾åœ¨replyä¸­ï¼

${char.foreign_lang_mode ? `ã€è¯­è¨€è§„åˆ™ - æœ€é«˜ä¼˜å…ˆçº§ï¼æ¯æ¡æ¶ˆæ¯å¿…é¡»éµå®ˆï¼ã€‘
ä½ çš„è§’è‰²å¼€å¯äº†å¤–è¯­ç¿»è¯‘æ¨¡å¼ã€‚
1. ç¡®å®šè§’è‰²çš„æ¯è¯­/è®¾å®šè¯­è¨€ï¼ˆæ—¥è¯­ã€éŸ©è¯­ã€è‹±è¯­ç­‰ï¼‰ï¼Œæ°¸è¿œç”¨è¯¥è¯­è¨€å‘æ¶ˆæ¯
2. æ¯æ¡æ¶ˆæ¯æ ¼å¼å¿…é¡»æ˜¯ï¼šå¤–è¯­å†…å®¹ï¼ˆä¸­æ–‡ç¿»è¯‘ï¼‰ â† å…¨è§’æ‹¬å·ï¼
3. åˆ†æ¡æ¶ˆæ¯æ—¶æ¯æ¡éƒ½è¦ç‹¬ç«‹å¸¦ç¿»è¯‘ï¼šå¤–è¯­1ï¼ˆç¿»è¯‘1ï¼‰|||å¤–è¯­2ï¼ˆç¿»è¯‘2ï¼‰
4. ç»å¯¹ç¦æ­¢ï¼šåªå†™ä¸­æ–‡ã€æ¼æ‰ç¿»è¯‘ã€å¤šå¥å…±ç”¨ä¸€ä¸ªç¿»è¯‘æ‹¬å·
5. æ­£ç¡®ç¤ºä¾‹ï¼šãŠã¯ã‚ˆã†ï¼ˆæ—©ä¸Šå¥½ï¼‰|||å…ƒæ°—ï¼Ÿï¼ˆä½ å¥½å—ï¼Ÿï¼‰
6. é”™è¯¯ç¤ºä¾‹ï¼šãŠã¯ã‚ˆã†ï¼å…ƒæ°—ï¼Ÿï¼ˆæ—©ä¸Šå¥½ï¼ä½ å¥½å—ï¼Ÿï¼‰â† ç¦æ­¢åˆå¹¶ç¿»è¯‘ï¼
7. ğŸ”§ åŠŸèƒ½æŒ‡ä»¤å‚æ•°ä¿æŒä¸­æ–‡ï¼šæ‰€æœ‰ ((POKE: åŠ¨ä½œ, éƒ¨ä½))ã€((OPEN_APP: APPåç§°))ã€((TRANSFER: é‡‘é¢, å¤‡æ³¨)) ç­‰æŒ‡ä»¤çš„å‚æ•°å¿…é¡»ç”¨ä¸­æ–‡ï¼Œä¸è¦ç¿»è¯‘æˆå¤–è¯­ï¼ä¾‹å¦‚ï¼šãŠã¯ã‚ˆã†ï¼ˆæ—©ä¸Šå¥½ï¼‰|||((POKE: æˆ³äº†æˆ³, è„¸è›‹)) â† æ­£ç¡®` : `ã€è¯­è¨€è§„åˆ™ã€‘
ä½ å¿…é¡»å…¨ç¨‹ä½¿ç”¨ä¸­æ–‡å›å¤ã€‚å³ä½¿ä½ çš„è§’è‰²äººè®¾æ˜¯å¤–å›½äººï¼Œä¹Ÿè¯·ç›´æ¥ç”¨ä¸­æ–‡å¯¹è¯ï¼Œä¸è¦ä½¿ç”¨ä»»ä½•å¤–è¯­ã€‚`}

è¯·ä¸¥æ ¼è¿”å›JSONæ ¼å¼ï¼Œä¸è¦åŒ…å«Markdownä»£ç å—æ ‡è®°ã€‚`;

                // æ·»åŠ è¡¨æƒ…åŒ…ç³»ç»Ÿæç¤ºï¼ˆå¦‚æœè§’è‰²æŒ‚è½½äº†è¡¨æƒ…åŒ…ï¼‰- ä¸»åŠ¨èŠå¤©
                let _mountedStickersListAuto = [];
                try {
                    const mountedStickerIdsAuto = char.mounted_sticker_categories || [];
                    if (mountedStickerIdsAuto.length > 0) {
                        for (const catId of mountedStickerIdsAuto) {
                            const cat = await db.sticker_categories.get(catId);
                            if (cat && cat.stickers && cat.stickers.length > 0) {
                                for (const s of cat.stickers) {
                                    if (s.description && s.url) {
                                        _mountedStickersListAuto.push({ description: s.description, url: s.url });
                                    }
                                }
                            }
                        }
                    }
                    
                    if (_mountedStickersListAuto.length > 0) {
                        let stickerPromptAuto = `\n\nã€ğŸ’ ä½ çš„è¡¨æƒ…åŒ…èƒŒåŒ…ï¼ˆå…± ${_mountedStickersListAuto.length} ä¸ªï¼‰ã€‘\n`;
                        stickerPromptAuto += _mountedStickersListAuto.map((s, i) => `ç¼–å·${i + 1}: ${s.description}`).join('\n');
                        stickerPromptAuto += `\n\nâ›” è¡¨æƒ…åŒ…ä½¿ç”¨è§„åˆ™ï¼ˆè¿åå°†å¯¼è‡´å‡ºé”™ï¼‰ï¼š`;
                        stickerPromptAuto += `\n- åªèƒ½ç”¨ [sticker:æ•°å­—ç¼–å·] æ ¼å¼ï¼Œä¾‹å¦‚ [sticker:1]ã€[sticker:3]`;
                        stickerPromptAuto += `\n- ç»å¯¹ç¦æ­¢å†™æè¿°æ–‡å­—ï¼Œå¦‚ [sticker:å¼€å¿ƒçš„çŒ«] â† è¿™æ˜¯é”™è¯¯çš„ï¼`;
                        stickerPromptAuto += `\n- ç»å¯¹ç¦æ­¢ç¼–é€ ä¸åœ¨èƒŒåŒ…ä¸­çš„è¡¨æƒ…åŒ…`;
                        stickerPromptAuto += `\n- ç»å¯¹ç¦æ­¢ç”¨ [imgcard:] å‘è¡¨æƒ…åŒ…`;
                        stickerPromptAuto += `\n- è¡¨æƒ…åŒ…å•ç‹¬ä½œä¸ºä¸€æ¡æ¶ˆæ¯ï¼Œç”¨ ||| ä¸æ–‡å­—åˆ†å¼€`;
                        stickerPromptAuto += `\n- è‡ªç„¶ä½¿ç”¨ï¼Œä¸è¦æ¯æ¡éƒ½å‘`;
                        stickerPromptAuto += `\nâœ… æ­£ç¡®ï¼šå“ˆå“ˆå¥½çš„|||[sticker:1]`;
                        stickerPromptAuto += `\nâŒ é”™è¯¯ï¼š[sticker:ä¸€åªçŒ«åœ¨ç¬‘]`;
                        
                        systemPrompt += stickerPromptAuto;
                        console.log('[AutoChat] âœ… å·²æ·»åŠ è¡¨æƒ…åŒ…ç³»ç»Ÿæç¤ºï¼Œå¯ç”¨è¡¨æƒ…åŒ…æ•°:', _mountedStickersListAuto.length);
                    }
                } catch (e) {
                    console.error('[AutoChat] è¡¨æƒ…åŒ…æç¤ºæ„å»ºå¤±è´¥:', e);
                }

                // ğŸ”§ æ„å»ºè¿‘æœŸå¯¹è¯å›é¡¾ï¼ˆçº¯æ–‡æœ¬æ¦‚è¦ï¼Œä¸ä½œä¸ºAPIå¯¹è¯åºåˆ—ï¼Œé˜²æ­¢AIé¹¦é¹‰å­¦èˆŒï¼‰
                // â˜… çº¿ä¸Šçº¿ä¸‹ç»Ÿä¸€æ—¶é—´çº¿ï¼šåˆå¹¶ä¸¤è¾¹å†å²æŒ‰æ—¶é—´æ’åº
                const chatLog = getChatHistory(char, accountId);
                const onlineMsgsAuto = (chatLog || []).filter(m => m.content && m.content.trim()).map(m => ({...m, _isOffline: false}));
                const offlineMsgsAuto = (_offlineHistoryAuto || []).filter(m => m.content && m.content.trim()).map(m => ({
                    role: m.role === 'user' ? 'user' : 'char', // ç»Ÿä¸€è§’è‰²æ ‡è¯†
                    content: m.content,
                    time: m.time || 0,
                    _isOffline: true
                }));
                const mergedMsgsAuto = [...onlineMsgsAuto, ...offlineMsgsAuto]
                    .sort((a, b) => (a.time || 0) - (b.time || 0))
                    .slice(-10);
                const recentMsgs = mergedMsgsAuto;
                
                let contextBlock = '';
                if (recentMsgs.length > 0) {
                    // é€æ¡æ ¼å¼åŒ–ï¼Œæ ‡æ³¨å‘é€æ–¹èº«ä»½ï¼Œå›¾ç‰‡/è¡¨æƒ…ä»…ä¿ç•™æè¿°
                    const lines = [];
                    for (let idx = 0; idx < recentMsgs.length; idx++) {
                        const msg = recentMsgs[idx];
                        const who = msg.role === 'char' ? `[${char.name}]` : `[${userName}]`;
                        let text = msg.content || '';
                        
                        // å›¾ç‰‡/è¡¨æƒ…ç±»æ¶ˆæ¯åªä¿ç•™æ–‡å­—æè¿°
                        if (/^\[img:|^\[sticker:/.test(text)) {
                            text = msg.imageDescription ? `ï¼ˆè¡¨æƒ…åŒ…ï¼š${msg.imageDescription}ï¼‰` : 'ï¼ˆå‘äº†ä¸€å¼ å›¾ï¼‰';
                        }
                        // è¿‡é•¿å†…å®¹æˆªæ–­
                        if (text.length > 70) text = text.slice(0, 70) + 'â€¦';
                        // âœ… å¦‚æœæ¶ˆæ¯æœ‰å¼•ç”¨ï¼Œåœ¨å†…å®¹å‰æ·»åŠ å¼•ç”¨æ ‡æ³¨
                        if (msg.quote) {
                            text = `ã€Œå¼•ç”¨ ${msg.quote.name}: ${msg.quote.content}ã€${text}`;
                        }
                        // â˜… æ ‡æ³¨çº¿ä¸‹æ¶ˆæ¯æ¥æº
                        const prefix = msg._isOffline ? '[çº¿ä¸‹è§é¢] ' : '';
                        lines.push(`  ${prefix}${who} ${text}`);
                    }
                    
                    // åˆ¤æ–­æœ€åå‘è¨€æ–¹æ˜¯è°
                    const lastSpeaker = recentMsgs[recentMsgs.length - 1].role;
                    const isLastByChar = lastSpeaker === 'char';
                    
                    contextBlock = `\n\n---\nğŸ“‹ è¿‘æœŸå¯¹è¯å›é¡¾ï¼ˆå…±${recentMsgs.length}æ¡ï¼Œä½ å·²ç»è¯´è¿‡çš„è¯ä¸èƒ½å†è¯´ï¼‰ï¼š\n${lines.join('\n')}`;
                    contextBlock += isLastByChar 
                        ? `\n\nğŸ’¡ ä¸Šé¢æœ€åä¸€æ¡æ˜¯ä½ ï¼ˆ${char.name}ï¼‰å‘çš„ï¼Œ${userName}çœ‹äº†ä½†æ²¡å›ä½ ã€‚ç°åœ¨ä½ è¦æ¢ä¸ªæ–°è¯é¢˜æˆ–æ–°è§’åº¦ä¸»åŠ¨èŠï¼Œä¸è®¸ç…§æ¬ä¸Šé¢ä»»ä½•ä¸€å¥è¯ã€‚`
                        : `\n\nğŸ’¡ ä¸Šé¢æœ€åä¸€æ¡æ˜¯${userName}å‘çš„ï¼Œä½†ä¹‹åæ²¡æœ‰åç»­ã€‚ä½ å¯ä»¥åŸºäºå¯¹æ–¹è¯´çš„å†…å®¹è‡ªç„¶æ¥è¯ï¼Œä¹Ÿå¯ä»¥å¦èµ·æ–°è¯é¢˜ã€‚`;
                } else {
                    contextBlock = `\n\nğŸ’¡ ä½ ä»¬ä¹‹é—´è¿˜æ²¡æœ‰èŠå¤©è®°å½•ï¼Œè¿™æ˜¯ç¬¬ä¸€æ¬¡å¯¹è¯ã€‚è¯·æ ¹æ®äººè®¾è‡ªç„¶åœ°æ‰“ä¸ªæ‹›å‘¼æˆ–å¼€å¯è¯é¢˜ã€‚`;
                }
                
                systemPrompt += contextBlock;

                // ğŸ”¥ å…³é”®ä¿®å¤ï¼šåœ¨æ‰€æœ‰è¿½åŠ å†…å®¹ä¹‹åï¼Œå†æ¬¡å¼ºè°ƒ JSON æ ¼å¼å’Œå¿ƒå£°è¦æ±‚
                systemPrompt += `

---

âš ï¸ æœ€ç»ˆæé†’ï¼šä½ å¿…é¡»ä»¥ JSON æ ¼å¼è¿”å›ï¼ŒåŒ…å« reply å’Œ thought ä¸¤ä¸ªå­—æ®µï¼š
{
  "reply": "æ¶ˆæ¯1|||æ¶ˆæ¯2|||æ¶ˆæ¯3",
  "thought": "ä½ æ­¤åˆ»å†…å¿ƒçœŸå®çš„æƒ³æ³•å’Œæƒ…ç»ªï¼ˆå¿…å¡«ï¼è‡³å°‘10å­—ï¼‰"
}
- reply å¿…é¡»å‘é€ ${char.reply_min_count || 1}-${char.reply_max_count || 3} æ¡æ¶ˆæ¯ï¼Œç”¨|||åˆ†éš”${(char.reply_min_count || 1) > 1 ? `ï¼Œæœ€å°‘${char.reply_min_count}æ¡ï¼` : ''}
- ç¦æ­¢è¾“å‡ºçº¯æ–‡æœ¬ï¼Œå¿…é¡»è¾“å‡ºä¸Šè¿° JSON æ ¼å¼ã€‚thought ä¸èƒ½çœç•¥ï¼`;

                const messages = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: `[è§¦å‘æ¡ä»¶ï¼šå¯¹æ–¹é•¿æ—¶é—´æœªå›å¤] è¯·ä»¥${char.name}çš„èº«ä»½ä¸»åŠ¨å‘é€æ¶ˆæ¯ã€‚` }
                ];

                // 3. è°ƒç”¨ AIï¼ˆå¯ç”¨ JSON æ¨¡å¼ä»¥ç¡®ä¿è¿”å›å¿ƒå£°ï¼‰
                const aiResponse = await callAI(messages, { json_mode: true });
                
                let cleanReply = "";
                let thought = "";
                
                // ä½¿ç”¨å¢å¼ºçš„æå–å‡½æ•°
                const parsed = extractAndParseJSON(aiResponse);
                
                if (parsed) {
                    cleanReply = parsed.reply || parsed.content || parsed.message || "";
                    thought = parsed.thought || "";
                    
                    // ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœæ˜¯è½¬è´¦å¯¹è±¡ä¸”ä¸åœ¨replyå­—æ®µä¸­ï¼Œå¯èƒ½æ•´ä¸ªå¯¹è±¡å°±æ˜¯æ¶ˆæ¯
                    if (!cleanReply && parsed.amount && parsed.status) {
                        cleanReply = JSON.stringify(parsed);
                    }
                }
                
                // è§£ææˆåŠŸä½† thought ä¸ºç©ºæ—¶ï¼Œå°è¯•ä»åŸå§‹æ–‡æœ¬ä¸­æå–
                if (!thought) {
                    thought = extractJsonStringValue(aiResponse, 'thought') || '';
                }
                
                // å¦‚æœæå–å¤±è´¥æˆ–æ²¡æœ‰å†…å®¹ï¼Œå°è¯•åŸå§‹è§£ææˆ–ç›´æ¥ä½¿ç”¨æ–‡æœ¬
                    if (!cleanReply) {
                    // æ¸…ç†å¸¸è§è£…é¥°å­—ç¬¦
                    let cleanResponse = aiResponse.trim().replace(/[â—‡â—†â˜…â˜†â—â—‹â– â–¡â–²â–³]/g, '');
                    
                    // å°è¯•ç®€å•çš„æ­£åˆ™æå–å…œåº•
                    const replyMatch = cleanResponse.match(/"reply"\s*:\s*"([\s\S]*?)"/);
                    if (replyMatch) {
                        cleanReply = replyMatch[1]
                            .replace(/\\n/g, '\n')
                            .replace(/\\"/g, '"')
                            .replace(/\\t/g, '\t')
                            .replace(/\\\\/g, '\\');
                    } else {
                        cleanReply = cleanResponse || "(AI è¿”å›ä¸ºç©º)";
                    }
                    }
                    
                    // å†æ¬¡å°è¯•æå– thought
                    if (!thought) {
                        thought = extractJsonStringValue(aiResponse, 'thought') || '';
                    }
                    
                    // å­˜å‚¨å¿ƒå£°åˆ°è§’è‰²å¯¹è±¡
                    if (thought && thought.trim()) {
                        // âœ… ä¿®å¤ï¼šå­˜å‚¨å‰æ¸…ç†å¿ƒå£°ä¸­å¯èƒ½æ®‹ç•™çš„æŒ‡ä»¤æ ‡ç­¾
                        thought = thought
                            .replace(/\[?SHURA_SEND:[^\]]*\]?/gi, '')
                            .replace(/\[?SHURA_DELETE:[^\]]*\]?/gi, '')
                            .replace(/\[?SHURA_BLACKLIST:[^\]]*\]?/gi, '')
                            .replace(/\[?SHURA_MOMENTS:[^\]]*\]?/gi, '')
                            .replace(/\[?CHECK_ACCOUNT(?::.*?)?\]?/gi, '')
                            .replace(/\(\(CHANGE_AVATAR\)\)/gi, '')
                            .replace(/\(\(COUPLE_AVATAR\)\)/gi, '')
                            .replace(/\[(?:sticker|imgcard|img|voice):[^\]]*\]/gi, '')
                            .replace(/\|\|\|/g, ' ')
                            .replace(/\/\/\//g, ' ')
                            .replace(/\s{2,}/g, ' ')
                            .trim();
                        
                        const freshChar = await db.characters.get(char.id);
                        if (freshChar && thought) {
                            if (!freshChar.thoughts) freshChar.thoughts = [];
                            const currentHistory = getChatHistory(freshChar, accountId);
                            freshChar.thoughts.push({
                                content: thought.trim(),
                                time: Date.now(),
                                messageIndex: currentHistory ? currentHistory.length : 0
                            });
                            // åªä¿ç•™æœ€è¿‘50æ¡å¿ƒå£°
                            if (freshChar.thoughts.length > 50) {
                                freshChar.thoughts = freshChar.thoughts.slice(-50);
                            }
                            // ğŸ”§ ä¿®å¤æ•°æ®ä¸¢å¤±ï¼šä½¿ç”¨ update() åªæ›´æ–° thoughts å­—æ®µï¼Œé¿å…è¦†ç›–å¹¶å‘å†™å…¥çš„èŠå¤©è®°å½•
                            await db.characters.update(char.id, {
                                thoughts: freshChar.thoughts
                            });
                        }
                    }
                
                // âœ… ä¿®å¤ï¼šæ¸…ç†æœ«å°¾å¤šä½™çš„ ]ï¼Œä½†ä¿ç•™ [img:] [voice:] [imgcard:] [sticker:] ç­‰æ ¼å¼çš„é—­åˆæ‹¬å·
                function cleanMessage(text) {
                    if (!text) return text;
                    // ğŸ”’ å®‰å…¨è½¬æ¢ï¼šAIç¦æ­¢å‘çœŸå®å›¾ç‰‡ï¼Œå°† [img:URL] è½¬æ¢ä¸º [imgcard:å›¾ç‰‡æè¿°]ï¼ˆä½†ä¸å¤„ç† [sticker:]ï¼‰
                    text = text.replace(/\[img:([^\]]+)\]/gi, (match, url) => {
                        // å¦‚æœæ˜¯base64æˆ–çœŸå®URLï¼Œè½¬æ¢ä¸ºæ–‡å­—å¡ç‰‡
                        if (url.startsWith('http') || url.startsWith('data:')) {
                            return '[imgcard:å‘é€äº†ä¸€å¼ å›¾ç‰‡]';
                        }
                        // å¦‚æœå·²ç»æ˜¯æ–‡å­—æè¿°ï¼Œç›´æ¥è½¬ä¸ºimgcard
                        return `[imgcard:${url}]`;
                    });
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç‰¹æ®Šæ ¼å¼æ¶ˆæ¯ï¼ˆä»¥ [ å¼€å¤´ï¼Œä»¥ ] ç»“å°¾ï¼‰
                    const specialFormats = /^\[(voice|imgcard|sticker|img):/i;
                    if (specialFormats.test(text) && text.endsWith(']')) {
                        // æ˜¯ç‰¹æ®Šæ ¼å¼ï¼Œä¸åˆ é™¤æœ«å°¾çš„ ]
                        return text;
                    }
                    // åˆ é™¤æœ«å°¾å¤šä½™çš„ ]
                    return text.replace(/\]+$/, '');
                }
                
                // æ¸…ç†å›å¤å†…å®¹
                let cleanReplyProcessed = cleanMessage(cleanReply);
                const replyText = cleanReplyProcessed;
                
                if (!cleanReplyProcessed || !cleanReplyProcessed.trim()) {
                    console.warn(`[AutoChat] AI returned empty reply for ${char.name}`);
                    return;
                }

                // ğŸ¯ æ£€æµ‹è§’è‰²åˆ é™¤/æ‹‰é»‘ç”¨æˆ·æŒ‡ä»¤ - åœ¨æ‹†åˆ†å‰å…ˆæ£€æµ‹
                const deleteUserMatchPre = cleanReplyProcessed.match(/\(\(DELETE_USER\)\)/i);
                if (deleteUserMatchPre) {
                    console.log(`[AutoChat] æ£€æµ‹åˆ°è§’è‰²åˆ é™¤ç”¨æˆ·æŒ‡ä»¤ï¼ˆé¢„å¤„ç†ï¼‰...`);
                    // æå–æŒ‡ä»¤å‰é¢çš„æ–‡å­—å†…å®¹
                    const textBeforeDelete = cleanMessage(cleanReplyProcessed.substring(0, deleteUserMatchPre.index).trim());
                    if (textBeforeDelete && textBeforeDelete.trim()) {
                        // å…ˆå‘é€å‰é¢çš„æ–‡å­—å†æ‰§è¡Œåˆ é™¤
                        const freshChar = await db.characters.get(char.id);
                        if (freshChar) {
                            let history = getChatHistory(freshChar, accountId);
                            const textSegments = textBeforeDelete.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                            for (const seg of textSegments) {
                                history.push(buildCharMessage(cleanMessage(seg), !!char.foreign_lang_mode));
                                await setChatHistory(freshChar, accountId, history);
                                if (currentChatCharId === char.id) {
                                    await appendMessageToUI('char', cleanMessage(seg));
                                }
                                await new Promise(r => setTimeout(r, 300));
                            }
                        }
                    }
                    await executeCharDeleteUser(char.id, accountId);
                    return;
                }
                
                const blockUserMatchPre = cleanReplyProcessed.match(/\(\(BLOCK_USER\)\)/i);
                if (blockUserMatchPre) {
                    console.log(`[AutoChat] æ£€æµ‹åˆ°è§’è‰²æ‹‰é»‘ç”¨æˆ·æŒ‡ä»¤ï¼ˆé¢„å¤„ç†ï¼‰...`);
                    const textBeforeBlock = cleanMessage(cleanReplyProcessed.substring(0, blockUserMatchPre.index).trim());
                    if (textBeforeBlock && textBeforeBlock.trim()) {
                        const freshChar = await db.characters.get(char.id);
                        if (freshChar) {
                            let history = getChatHistory(freshChar, accountId);
                            const textSegments = textBeforeBlock.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                            for (const seg of textSegments) {
                                history.push(buildCharMessage(cleanMessage(seg), !!char.foreign_lang_mode));
                                await setChatHistory(freshChar, accountId, history);
                                if (currentChatCharId === char.id) {
                                    await appendMessageToUI('char', cleanMessage(seg));
                                }
                                await new Promise(r => setTimeout(r, 300));
                            }
                        }
                    }
                    await executeCharBlockUser(char.id, accountId);
                    return;
                }
                
                // ğŸ¯ æ£€æµ‹è§’è‰²è‡ªä¸»æ‰‹æœºæ´»åŠ¨æŒ‡ä»¤ ((PHONE_ACTIVITY:æè¿°))
                const phoneActivityMatchAuto = cleanReplyProcessed.match(/\(\(PHONE_ACTIVITY:\s*([^)]+)\)\)/i);
                if (phoneActivityMatchAuto && char.allow_autonomous_activity) {
                    const activityDescAuto = phoneActivityMatchAuto[1].trim();
                    console.log('[AutoChat] ğŸ“± æ£€æµ‹åˆ°è§’è‰²è‡ªä¸»æ‰‹æœºæ´»åŠ¨æŒ‡ä»¤:', activityDescAuto);
                    cleanReplyProcessed = cleanReplyProcessed.replace(/\(\(PHONE_ACTIVITY:\s*[^)]+\)\)/gi, '').trim();
                    generateCharAutonomousActivity(char.id, accountId, activityDescAuto).catch(e => {
                        console.error('[AutoChat] è§’è‰²è‡ªä¸»æ´»åŠ¨ç”Ÿæˆå¤±è´¥:', e);
                    });
                }
                
                // ğŸ¯ æ£€æµ‹NPCåŠ å¥½å‹æŒ‡ä»¤ï¼ˆé¢„å¤„ç†ï¼‰- ä¸returnï¼Œç»§ç»­å¤„ç†æ¶ˆæ¯
                const npcAddMatchPre = cleanReplyProcessed.match(/\(\(NPC_ADD_FRIEND:\s*(.+?)\s*\)\)/i);
                if (npcAddMatchPre) {
                    const npcNamePre = npcAddMatchPre[1].trim();
                    console.log(`[AutoChat] æ£€æµ‹åˆ°NPCåŠ å¥½å‹æŒ‡ä»¤ï¼ˆé¢„å¤„ç†ï¼‰: ${npcNamePre}`);
                    try {
                        await executeNpcAddFriend(char, npcNamePre, accountId);
                    } catch (e) {
                        console.error('[AutoChat] NPCåŠ å¥½å‹å¤±è´¥:', e);
                    }
                    cleanReplyProcessed = cleanReplyProcessed.replace(/\(\(NPC_ADD_FRIEND:\s*.+?\s*\)\)/gi, '').trim();
                }

                // âœ… å…³é”®æ”¹åŠ¨ï¼šåœ¨æ‹†åˆ†å‰ï¼Œå…ˆæ£€æµ‹æ˜¯å¦åŒ…å«"æŒ‡ä»¤å‹æ¶ˆæ¯"ï¼ˆè½¬è´¦ç­‰ï¼‰
                // æ£€æµ‹ ((TRANSFER: é‡‘é¢, å¤‡æ³¨)) æ ¼å¼ - åœ¨ cleanReplyProcessed ä¸ŠåŒ¹é…ï¼Œç¡®ä¿ index ä½ç½®æ­£ç¡®
                const transferMatch = cleanReplyProcessed.match(/\(\(TRANSFER:\s*(\d+(\.\d+)?)(?:,\s*(.+?))?\)\)/i);
                
                if (transferMatch) {
                    // æå–è½¬è´¦ä¿¡æ¯
                    const amount = parseFloat(transferMatch[1]);
                    let note = transferMatch[3] || 'è½¬è´¦';
                    // é™åˆ¶å¤‡æ³¨é•¿åº¦ï¼Œä¸è¶…è¿‡10ä¸ªå­—
                    if (note.length > 10) {
                        note = note.substring(0, 10);
                    }
                    
                    // æå–è½¬è´¦å‰é¢çš„æ–‡å­—å†…å®¹ï¼ˆå¦‚æœæœ‰ï¼‰- ç°åœ¨ index ä½ç½®æ­£ç¡®äº†
                    const textBeforeTransfer = cleanMessage(cleanReplyProcessed.substring(0, transferMatch.index).trim());
                    // ğŸ”¥ ä¿®å¤ï¼šæå–è½¬è´¦åé¢çš„æ–‡å­—å†…å®¹ï¼ˆä¹‹å‰ç›´æ¥returnå¯¼è‡´åç»­æ¶ˆæ¯ä¸¢å¤±ï¼‰
                    const textAfterTransfer = cleanReplyProcessed.substring(transferMatch.index + transferMatch[0].length).trim();
                    
                    const freshChar = await db.characters.get(char.id);
                    if (freshChar) {
                        let history = getChatHistory(freshChar, accountId);
                        
                        // 1. å…ˆå‘é€æ–‡å­—æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰ï¼‰- æ”¯æŒåˆ†å‰²æˆå¤šæ¡
                        if (textBeforeTransfer) {
                            // å¯¹è½¬è´¦å‰çš„æ–‡å­—è¿›è¡Œåˆ†å‰²å¤„ç†
                            let textSegments = [];
                            const textToSplit = textBeforeTransfer.replace(/[,ï¼Œ]/g, ' ');
                            if (textToSplit.includes('|||')) {
                                textSegments = textToSplit.split('|||').map(s => cleanMessage(s.trim())).filter(s => s.length > 0);
                            } else {
                                textSegments = splitMessage(textToSplit);
                            }
                            
                            // è¿‡æ»¤å¤ªçŸ­çš„æ®µè½ï¼ˆğŸ”§ åŠ å…¥ | åˆ°è¿‡æ»¤æ­£åˆ™ï¼‰
                            textSegments = textSegments.filter(seg => seg.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦|\s]/g, '').length >= 2);
                            
                            // å¦‚æœåˆ†å‰²åä¸ºç©ºï¼Œä½†åŸæ–‡æœ¬æœ‰å†…å®¹ï¼Œä½¿ç”¨åŸæ–‡æœ¬
                            if (textSegments.length === 0 && textBeforeTransfer.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦|\s]/g, '').length > 0) {
                                textSegments = [textBeforeTransfer];
                            }
                            
                            // é€æ¡å‘é€æ–‡å­—æ¶ˆæ¯
                            for (let i = 0; i < textSegments.length; i++) {
                                const seg = textSegments[i];
                                const textMsg = buildCharMessage(seg, !!char.foreign_lang_mode, { time: Date.now() + i });
                                history.push(textMsg);
                                await setChatHistory(freshChar, accountId, history);
                                
                                // æ¸²æŸ“æ–‡å­—æ¶ˆæ¯
                                if (currentChatCharId === freshChar.id) {
                                    await appendMessageToUI('char', seg, freshChar.avatar);
                                }
                                
                                // æ¯æ¡æ¶ˆæ¯ä¹‹é—´ç¨å¾®å»¶æ—¶
                                if (i < textSegments.length - 1) {
                                    await new Promise(r => setTimeout(r, 300));
                                }
                            }
                            
                            // æœ€åä¸€æ¡æ–‡å­—æ¶ˆæ¯åç¨å¾®å»¶æ—¶å†å‘è½¬è´¦
                            await new Promise(r => setTimeout(r, 500));
                        }
                        
                        // 2. å†å‘é€è½¬è´¦å¡ç‰‡
                        const transferData = {
                            amount: amount.toFixed(2),
                            desc: note,
                            status: 'sent'
                        };
                        
                        const transferMsg = { 
                            role: 'char', 
                            type: 'transfer', // æ˜ç¡®æ ‡è®°ä¸ºè½¬è´¦æ¶ˆæ¯
                            content: JSON.stringify(transferData), 
                            time: Date.now(),
                            id: 'trans_' + Date.now()
                        };
                        
                        history.push(transferMsg);
                        await setChatHistory(freshChar, accountId, history);
                        
                        console.log(`[AutoChat] Sent transfer message for ${freshChar.name}`);
                        addLog('success', `è§’è‰²å‘é€è½¬è´¦: ${freshChar.name}`, { amount, note });
                        
                        // æ¸²æŸ“è½¬è´¦å¡ç‰‡ - ä½¿ç”¨ appendMessageToUI è¿½åŠ ï¼Œé¿å…é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©
                        if (currentChatCharId === freshChar.id) {
                            await appendMessageToUI('char', JSON.stringify(transferData), freshChar.avatar);
                        }
                        
                        // âœ… è§’è‰²è‡ªåŠ¨å‘é€è½¬è´¦ â†’ è§’è‰²FPé’±åŒ…æ”¯å‡º
                        const acWalletAccId = getCurrentAccountId();
                        if (acWalletAccId) {
                            // è·å–ç”¨æˆ·åï¼ˆè½¬è´¦ç›®æ ‡ï¼‰
                            let acUserName = 'ç”¨æˆ·';
                            try {
                                const acUser = await db.characters.get(parseInt(acWalletAccId));
                                if (acUser) acUserName = acUser.name || 'ç”¨æˆ·';
                            } catch(e) {}
                            await fpWalletTransaction(freshChar.id, acWalletAccId, 'expense', amount, 'å¾®ä¿¡è½¬è´¦', `è½¬è´¦ç»™${acUserName} - ${note}`, true);
                            console.log(`[AutoChat] âœ… è§’è‰²FPé’±åŒ…æ”¯å‡º Â¥${amount.toFixed(2)}`);
                        }
                        
                        // å‘é€é€šçŸ¥ï¼ˆçº¯å‰ç«¯ï¼šç›´æ¥ä½¿ç”¨æœ¬åœ°é€šçŸ¥ï¼‰
                        sendSystemNotification(freshChar.name, '[è½¬è´¦]');
                        
                        // åˆ·æ–°å¾®ä¿¡åˆ—è¡¨
                        if (currentChatCharId !== freshChar.id) {
                            const wechatPage = document.getElementById('wechat-page');
                            if (wechatPage.style.display !== 'none' && 
                                document.querySelector('.wechat-tab-item.active .tab-name').innerText === 'å¾®ä¿¡') {
                                renderWechatList(document.getElementById('wechat-content'));
                            }
                        }
                    }
                    
                    // ğŸ”¥ ä¿®å¤ï¼šå¦‚æœè½¬è´¦åè¿˜æœ‰å†…å®¹ï¼Œç»§ç»­å¤„ç†ï¼ˆä¹‹å‰ç›´æ¥returnå¯¼è‡´åç»­æ¶ˆæ¯ä¸¢å¤±ï¼ï¼‰
                    if (textAfterTransfer) {
                        console.log('[AutoChat] è½¬è´¦åè¿˜æœ‰å†…å®¹ï¼Œç»§ç»­å¤„ç†:', textAfterTransfer.substring(0, 50));
                        cleanReplyProcessed = textAfterTransfer;
                        // æ¸…ç†å¼€å¤´çš„åˆ†éš”ç¬¦
                        while (cleanReplyProcessed.startsWith('|||')) {
                            cleanReplyProcessed = cleanReplyProcessed.substring(3).trim();
                        }
                        // ä¸returnï¼Œç»§ç»­æ‰§è¡Œåç»­çš„æ™®é€šæ¶ˆæ¯å¤„ç†é€»è¾‘
                    } else {
                        return; // è½¬è´¦å¤„ç†å®Œæˆä¸”æ²¡æœ‰åç»­å†…å®¹
                    }
                }
                
                // ğŸ¯ æ£€æµ‹æ’¤å›æŒ‡ä»¤ ((RECALL)) - AIè§’è‰²å¯ä»¥æ’¤å›è‡ªå·±æœ€åä¸€æ¡æ¶ˆæ¯
                const recallMatch = cleanReplyProcessed.match(/\(\(RECALL(?::\s*(\d+))?\)\)/i);
                if (recallMatch) {
                    const freshChar = await db.characters.get(char.id);
                    if (freshChar) {
                        let history = getChatHistory(freshChar, accountId);
                        
                        // æå–æ’¤å›æŒ‡ä»¤å‰é¢çš„æ–‡å­—å†…å®¹ï¼ˆå¦‚æœæœ‰ï¼‰
                        const textBeforeRecall = cleanMessage(cleanReplyProcessed.substring(0, recallMatch.index).trim());
                        
                        // æ‰¾AIæœ€åä¸€æ¡æ¶ˆæ¯ï¼ˆéæ’¤å›çŠ¶æ€ï¼‰
                        let targetIndex = -1;
                        for (let i = history.length - 1; i >= 0; i--) {
                            if (history[i].role === 'char' && !history[i].isRecalled) {
                                targetIndex = i;
                                break;
                            }
                        }
                        
                        if (targetIndex >= 0 && history[targetIndex].role === 'char') {
                            // ä¿å­˜åŸå†…å®¹å¹¶æ ‡è®°ä¸ºå·²æ’¤å›
                            const originalContent = history[targetIndex].content;
                            history[targetIndex].recalledContent = originalContent;
                            history[targetIndex].isRecalled = true;
                            history[targetIndex].content = "";
                            
                            await setChatHistory(freshChar, accountId, history);
                            
                            console.log(`[AutoChat] ${freshChar.name} æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯`);
                            addLog('info', `è§’è‰²æ’¤å›æ¶ˆæ¯: ${freshChar.name}`, { originalContent: originalContent.substring(0, 50) });
                            
                            // æ›´æ–°UI - å±…ä¸­ç³»ç»Ÿæç¤ºæ ·å¼
                            if (currentChatCharId === freshChar.id) {
                                const chatBody = document.getElementById('chat-body');
                                const messageRows = chatBody.querySelectorAll('.message-row');
                                if (messageRows[targetIndex]) {
                                    const msgRow = messageRows[targetIndex];
                                    msgRow.className = 'message-row recalled-system-row';
                                    msgRow.innerHTML = '';
                                    
                                    const systemTip = document.createElement('div');
                                    systemTip.className = 'recalled-system-tip';
                                    systemTip.innerHTML = `"${freshChar.name}"æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯`;
                                    systemTip.style.cursor = 'pointer';
                                    systemTip.onclick = (e) => {
                                        e.stopPropagation();
                                        showRecalledContent(freshChar.name, originalContent);
                                    };
                                    msgRow.appendChild(systemTip);
                                }
                            }
                            
                            // å‘é€é€šçŸ¥
                            sendSystemNotification(freshChar.name, 'æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯');
                        }
                        
                        // å¦‚æœæ’¤å›æŒ‡ä»¤å‰æœ‰æ–‡å­—ï¼Œç»§ç»­å¤„ç†è¿™äº›æ–‡å­—
                        if (textBeforeRecall && textBeforeRecall.trim()) {
                            cleanReplyProcessed = textBeforeRecall;
                            // ä¸returnï¼Œç»§ç»­å¤„ç†å‰é¢çš„æ–‡å­—
                        } else {
                            return; // åªæœ‰æ’¤å›æŒ‡ä»¤ï¼Œå¤„ç†å®Œæˆ
                        }
                    }
                }
                
                // ğŸ¯ æ£€æµ‹äº²å±å¡èµ é€æŒ‡ä»¤ ((FAMILY_CARD: é¢åº¦))
                const familyCardMatch = cleanReplyProcessed.match(/\(\(FAMILY_CARD:\s*(\d+)\)\)/i);
                if (familyCardMatch) {
                    const monthlyLimit = parseInt(familyCardMatch[1]) || 0;
                    
                    // æå–äº²å±å¡æŒ‡ä»¤å‰é¢çš„æ–‡å­—å†…å®¹ï¼ˆå¦‚æœæœ‰ï¼‰
                    const textBeforeFamilyCard = cleanMessage(cleanReplyProcessed.substring(0, familyCardMatch.index).trim());
                    // ğŸ”¥ ä¿®å¤ï¼šæå–äº²å±å¡åé¢çš„æ–‡å­—å†…å®¹ï¼ˆä¹‹å‰ç›´æ¥returnå¯¼è‡´åç»­æ¶ˆæ¯ä¸¢å¤±ï¼‰
                    const textAfterFamilyCard = cleanReplyProcessed.substring(familyCardMatch.index + familyCardMatch[0].length).trim();
                    
                    const freshChar = await db.characters.get(char.id);
                    if (freshChar) {
                        let history = getChatHistory(freshChar, accountId);
                        
                        // 1. å…ˆå‘é€æ–‡å­—æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰ï¼‰
                        if (textBeforeFamilyCard) {
                            let textSegments = [];
                            const textToSplit = textBeforeFamilyCard.replace(/[,ï¼Œ]/g, ' ');
                            if (textToSplit.includes('|||')) {
                                textSegments = textToSplit.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                            } else {
                                textSegments = splitMessage(textToSplit);
                            }
                            textSegments = textSegments.filter(seg => seg.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦|\s]/g, '').length >= 2);
                            if (textSegments.length === 0 && textBeforeFamilyCard.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦|\s]/g, '').length > 0) {
                                textSegments = [textBeforeFamilyCard];
                            }
                            
                            for (let i = 0; i < textSegments.length; i++) {
                                const seg = textSegments[i];
                                history.push(buildCharMessage(seg, !!char.foreign_lang_mode, { time: Date.now() + i }));
                                await setChatHistory(freshChar, accountId, history);
                                if (currentChatCharId === freshChar.id) {
                                    await appendMessageToUI('char', seg, freshChar.avatar);
                                }
                                if (i < textSegments.length - 1) {
                                    await new Promise(r => setTimeout(r, 300));
                                }
                            }
                            await new Promise(r => setTimeout(r, 500));
                        }
                        
                        // 2. å‘é€äº²å±å¡æ¶ˆæ¯
                        const user = await db.characters.get(parseInt(currentMyCharId));
                        
                        // âœ… æ£€æŸ¥æ˜¯å¦æ˜¯è”æœºå¥½å‹
                        if (freshChar.isOnlineFriend && freshChar.onlineData?.wx_account) {
                            console.log('[äº²å±å¡] æ£€æµ‹åˆ°è”æœºå¥½å‹ï¼Œå‡†å¤‡å‘é€äº²å±å¡...');
                            // è”æœºå¥½å‹ - é€šè¿‡æ™®é€šæ¶ˆæ¯é€šé“å‘é€ï¼ˆå’Œè½¬è´¦ä¸€æ ·ï¼‰
                            const onlineUserChar = await getOrCreateOnlineUserChar();
                            console.log('[äº²å±å¡] åœ¨çº¿ç”¨æˆ·è§’è‰²:', onlineUserChar?.name, 'è¿æ¥çŠ¶æ€:', onlineConnected);
                            
                            if (onlineUserChar && onlineConnected) {
                                const fromWxAccount = onlineUserChar.identity.account;
                                const toWxAccount = freshChar.onlineData.wx_account;
                                
                                console.log('[äº²å±å¡] å‡†å¤‡å‘é€: from=', fromWxAccount, 'to=', toWxAccount, 'é¢åº¦=', monthlyLimit);
                                
                                // ğŸ¯ å’Œè½¬è´¦ä¸€æ ·ï¼šé€šè¿‡ sendOnlineMessage å‘é€å¸¦ç‰¹æ®Šæ ‡è®°çš„ JSON æ¶ˆæ¯
                                const familyCardContent = JSON.stringify({
                                    __type: 'familyCard',  // ç‰¹æ®Šæ ‡è®°ï¼Œå’Œè½¬è´¦çš„ __type: 'transfer' ä¸€æ ·
                                    monthlyLimit: monthlyLimit,
                                    fromName: onlineUserChar.name
                                });
                                
                                console.log('[äº²å±å¡] æ¶ˆæ¯å†…å®¹:', familyCardContent);
                                const sent = sendOnlineMessage(toWxAccount, familyCardContent, fromWxAccount);
                                console.log('[äº²å±å¡] sendOnlineMessage è¿”å›:', sent);
                                
                                if (sent) {
                                    // âœ… åœ¨å‘é€æ–¹ä¿å­˜äº²å±å¡æ¶ˆæ¯åˆ°èŠå¤©è®°å½•
                                    const familyCardMsg = {
                                        role: 'user',
                                        type: 'familyCard',
                                        content: JSON.stringify({
                                            fromName: onlineUserChar.name,
                                            monthlyLimit: monthlyLimit,
                                            status: 'sent',
                                            isOnline: true
                                        }),
                                        time: Date.now()
                                    };
                                    
                                    history = getChatHistory(freshChar, accountId);
                                    history.push(familyCardMsg);
                                    await setChatHistory(freshChar, accountId, history);
                                    
                                    // åˆ·æ–°èŠå¤©ç•Œé¢
                                    if (currentChatCharId === freshChar.id) {
                                        renderChatBody(freshChar);
                                    }
                                    
                                    console.log('[äº²å±å¡] âœ… äº²å±å¡å·²æˆåŠŸå‘é€å¹¶ä¿å­˜åˆ°èŠå¤©è®°å½•');
                                    showToast('äº²å±å¡å·²èµ é€');
                                } else {
                                    console.error('[äº²å±å¡] âŒ sendOnlineMessage è¿”å› false');
                                    showToast('å‘é€å¤±è´¥ï¼Œè¯·æ£€æŸ¥è¿æ¥');
                                }
                            } else {
                                console.error('[äº²å±å¡] âŒ æ¡ä»¶ä¸æ»¡è¶³: onlineUserChar=', !!onlineUserChar, 'onlineConnected=', onlineConnected);
                                showToast('è¯·ç¡®ä¿å·²è¿æ¥æœåŠ¡å™¨');
                            }
                        } else {
                            // æœ¬åœ°è§’è‰² - åŸæœ‰é€»è¾‘
                            // åœ¨è§’è‰²æ•°æ®ä¸­æ·»åŠ "æˆ‘èµ é€çš„"
                            if (!freshChar.identity) freshChar.identity = {};
                            if (!freshChar.identity.familyCardsGiven) freshChar.identity.familyCardsGiven = [];
                            freshChar.identity.familyCardsGiven.push({
                                charId: parseInt(currentMyCharId),
                                monthlyLimit: monthlyLimit,
                                usedThisMonth: 0,
                                records: [],
                                createdAt: Date.now()
                            });
                            // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°äº²å±å¡å­—æ®µ
                            await safeDexieUpdate(db.characters, freshChar.id, {
                                'identity.familyCardsGiven': freshChar.identity.familyCardsGiven
                            }, `äº²å±å¡èµ é€[${freshChar.name}]`);
                            
                            // åœ¨ç”¨æˆ·æ•°æ®ä¸­æ·»åŠ "æˆ‘æ”¶åˆ°çš„"
                            if (user) {
                                if (!user.identity) user.identity = {};
                                if (!user.identity.familyCardsReceived) user.identity.familyCardsReceived = [];
                                user.identity.familyCardsReceived.push({
                                    charId: freshChar.id,
                                    monthlyLimit: monthlyLimit,
                                    usedThisMonth: 0,
                                    records: [],
                                    createdAt: Date.now()
                                });
                                await safeCharacterPut(user);
                            }
                            
                            // å‘é€äº²å±å¡æ¶ˆæ¯åˆ°èŠå¤©
                            const familyCardMsg = {
                                role: 'char',
                                type: 'familyCard',
                                content: JSON.stringify({
                                    fromName: freshChar.name,
                                    monthlyLimit: monthlyLimit,
                                    status: 'sent'
                                }),
                                time: Date.now()
                            };
                            
                            history = getChatHistory(freshChar, accountId);
                            history.push(familyCardMsg);
                            await setChatHistory(freshChar, accountId, history);
                            
                            if (currentChatCharId === freshChar.id) {
                                renderChatBody(freshChar);
                            }
                            
                            sendSystemNotification(freshChar.name, '[äº²å±å¡]');
                        }
                    }
                    
                    // ğŸ”¥ ä¿®å¤ï¼šå¦‚æœäº²å±å¡åè¿˜æœ‰å†…å®¹ï¼Œç»§ç»­å¤„ç†ï¼ˆä¹‹å‰ç›´æ¥returnå¯¼è‡´åç»­æ¶ˆæ¯ä¸¢å¤±ï¼ï¼‰
                    if (textAfterFamilyCard) {
                        console.log('[AutoChat] äº²å±å¡åè¿˜æœ‰å†…å®¹ï¼Œç»§ç»­å¤„ç†:', textAfterFamilyCard.substring(0, 50));
                        cleanReplyProcessed = textAfterFamilyCard;
                        // æ¸…ç†å¼€å¤´çš„åˆ†éš”ç¬¦
                        while (cleanReplyProcessed.startsWith('|||')) {
                            cleanReplyProcessed = cleanReplyProcessed.substring(3).trim();
                        }
                        // ä¸returnï¼Œç»§ç»­æ‰§è¡Œåç»­çš„æ™®é€šæ¶ˆæ¯å¤„ç†é€»è¾‘
                    } else {
                        return; // äº²å±å¡å¤„ç†å®Œæˆä¸”æ²¡æœ‰åç»­å†…å®¹
                    }
                }
                
                // ğŸ¯ æ£€æµ‹è´­ç‰©é€ç¤¼æŒ‡ä»¤ ((SHOP_GIFT: é‡‘é¢, å•†å“å))
                const shopGiftMatch = cleanReplyProcessed.match(/\(\(SHOP_GIFT:\s*(\d+(?:\.\d+)?)(?:,\s*(.+?))?\)\)/i);
                if (shopGiftMatch) {
                    const giftAmount = parseFloat(shopGiftMatch[1]);
                    let giftProduct = shopGiftMatch[2] || 'è´­ç‰©ç¤¼ç‰©';
                    if (giftProduct.length > 30) giftProduct = giftProduct.substring(0, 30);

                    const textBefore = cleanMessage(cleanReplyProcessed.substring(0, shopGiftMatch.index).trim());
                    const textAfter = cleanReplyProcessed.substring(shopGiftMatch.index + shopGiftMatch[0].length).trim();

                    const freshChar = await db.characters.get(char.id);
                    if (freshChar) {
                        let history = getChatHistory(freshChar, accountId);

                        // 1. å…ˆå‘é€å‰ç½®æ–‡å­—ï¼ˆå¦‚æœæœ‰ï¼‰
                        if (textBefore) {
                            let segs = [];
                            const txt = textBefore.replace(/[,ï¼Œ]/g, ' ');
                            if (txt.includes('|||')) {
                                segs = txt.split('|||').map(s => cleanMessage(s.trim())).filter(s => s.length > 0);
                            } else {
                                segs = splitMessage(txt);
                            }
                            segs = segs.filter(s => s.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦|\s]/g, '').length >= 2);
                            if (segs.length === 0 && textBefore.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦|\s]/g, '').length > 0) segs = [textBefore];

                            for (let i = 0; i < segs.length; i++) {
                                history.push(buildCharMessage(segs[i], !!char.foreign_lang_mode, { time: Date.now() + i }));
                                await setChatHistory(freshChar, accountId, history);
                                if (currentChatCharId === freshChar.id) {
                                    await appendMessageToUI('char', segs[i], freshChar.avatar);
                                }
                                if (i < segs.length - 1) await new Promise(r => setTimeout(r, 300));
                            }
                            await new Promise(r => setTimeout(r, 500));
                        }

                        // 2. å‘é€è´­ç‰©ç¤¼ç‰©å¡ç‰‡
                        const cardData = {
                            amount: giftAmount.toFixed(2),
                            items: giftProduct,
                            buyForName: '',
                            installmentInfo: '',
                            isGift: true,
                            status: 'paid'
                        };

                        const giftMsg = {
                            role: 'char',
                            type: 'shopPayRequest',
                            content: JSON.stringify(cardData),
                            time: Date.now()
                        };

                        history.push(giftMsg);
                        await setChatHistory(freshChar, accountId, history);

                        console.log(`[AutoChat] è§’è‰²å‘é€è´­ç‰©ç¤¼ç‰©: ${freshChar.name}`, { giftAmount, giftProduct });
                        addLog('success', `è§’è‰²é€ç¤¼: ${freshChar.name}`, { amount: giftAmount, product: giftProduct });

                        // è¿½åŠ å¡ç‰‡åˆ°èŠå¤©ï¼ˆä¸åˆ·æ–°ï¼‰
                        if (currentChatCharId === freshChar.id) {
                            if (window._appendShopCardToChat) {
                                await window._appendShopCardToChat(freshChar.id, giftMsg);
                            }
                        }

                        // âœ… è§’è‰²è´­ç‰©é€ç¤¼ â†’ è§’è‰²FPé’±åŒ…æ”¯å‡º
                        const sgWalletAccId = getCurrentAccountId();
                        if (sgWalletAccId) {
                            await fpWalletTransaction(freshChar.id, sgWalletAccId, 'expense', giftAmount, 'è´­ç‰©é€ç¤¼', giftProduct, true);
                            console.log(`[AutoChat] âœ… è§’è‰²FPé’±åŒ…æ”¯å‡º(é€ç¤¼) Â¥${giftAmount.toFixed(2)}`);
                        }

                        sendSystemNotification(freshChar.name, '[è´­ç‰©ç¤¼ç‰©]');

                        if (currentChatCharId !== freshChar.id) {
                            const wechatPage = document.getElementById('wechat-page');
                            if (wechatPage.style.display !== 'none' &&
                                document.querySelector('.wechat-tab-item.active .tab-name')?.innerText === 'å¾®ä¿¡') {
                                renderWechatList(document.getElementById('wechat-content'));
                            }
                        }
                    }

                    if (textAfter) {
                        cleanReplyProcessed = textAfter;
                        while (cleanReplyProcessed.startsWith('|||')) {
                            cleanReplyProcessed = cleanReplyProcessed.substring(3).trim();
                        }
                    } else {
                        return;
                    }
                }

                // ğŸ¯ 3. æ£€æµ‹æœ‹å‹åœˆå‘å¸ƒæŒ‡ä»¤ [MOMENTS] - æ”¯æŒå¤šç§æ ¼å¼
                // æ ¼å¼1: [MOMENTS] content: xxx images: N
                let momentsMatch = cleanReplyProcessed.match(/\[MOMENTS\]\s*content:\s*([^\n]+)(?:\s*images?:\s*(\d+))?/i);
                // æ ¼å¼2: ((MOMENTS: å†…å®¹))
                if (!momentsMatch) {
                    momentsMatch = cleanReplyProcessed.match(/\(\(MOMENTS:\s*(.+?)\)\)/i);
                    if (momentsMatch) {
                        // è½¬æ¢ä¸ºæ ‡å‡†æ ¼å¼
                        momentsMatch = [momentsMatch[0], momentsMatch[1], '0'];
                    }
                }
                // æ ¼å¼3: ã€æœ‹å‹åœˆï¼šå†…å®¹ã€‘
                if (!momentsMatch) {
                    momentsMatch = cleanReplyProcessed.match(/ã€æœ‹å‹åœˆ[ï¼š:]\s*(.+?)ã€‘/);
                    if (momentsMatch) {
                        momentsMatch = [momentsMatch[0], momentsMatch[1], '0'];
                    }
                }
                
                if (momentsMatch) {
                    let momentContent = momentsMatch[1].trim();
                    let imageCount = momentsMatch[2] ? parseInt(momentsMatch[2]) : 0;
                    let imageDesc = '';
                    
                    // ğŸ”¥ ä¿®å¤ï¼šæå– [imgcard:] ä½œä¸ºæœ‹å‹åœˆé…å›¾æè¿°
                    const afterMoments = cleanReplyProcessed.substring(momentsMatch.index + momentsMatch[0].length);
                    const imgcardMatch = afterMoments.match(/\[imgcard:([^\]]+)\]/i);
                    if (imgcardMatch) {
                        imageDesc = imgcardMatch[1].trim();
                        if (imageCount === 0) imageCount = 1;
                        console.log(`[AutoChat] æå–åˆ°æœ‹å‹åœˆé…å›¾æè¿°: ${imageDesc}`);
                    }
                    // ä¹Ÿæ£€æŸ¥ content ä¸­æ˜¯å¦å†…åµŒäº† [imgcard:]
                    const contentImgcard = momentContent.match(/\[imgcard:([^\]]+)\]/i);
                    if (contentImgcard) {
                        imageDesc = imageDesc || contentImgcard[1].trim();
                        momentContent = momentContent.replace(/\[imgcard:[^\]]+\]/gi, '').trim();
                        if (imageCount === 0) imageCount = 1;
                    }
                    // ä¹Ÿä» MOMENTS ä¹‹å‰çš„æ–‡æœ¬ä¸­æå–
                    const beforeMoments = cleanReplyProcessed.substring(0, momentsMatch.index);
                    const beforeImgcard = beforeMoments.match(/\[imgcard:([^\]]+)\]/i);
                    if (beforeImgcard && !imageDesc) {
                        imageDesc = beforeImgcard[1].trim();
                        if (imageCount === 0) imageCount = 1;
                    }
                    
                    // æå–æœ‹å‹åœˆæŒ‡ä»¤å‰é¢çš„æ–‡å­—å†…å®¹ï¼ˆå¦‚æœæœ‰ï¼‰
                    let textBeforeMoments = cleanMessage(cleanReplyProcessed.substring(0, momentsMatch.index).trim());
                    // æ¸…ç†æ‰ [imgcard:] éƒ¨åˆ†ï¼Œä¸è¦ä½œä¸ºèŠå¤©æ¶ˆæ¯å‘é€
                    textBeforeMoments = textBeforeMoments.replace(/\[imgcard:[^\]]+\]/gi, '').trim();
                    // ğŸ”¥ ä¿®å¤ï¼šæå–æœ‹å‹åœˆåé¢çš„æ–‡å­—å†…å®¹ï¼ˆä¹‹å‰ç›´æ¥returnå¯¼è‡´åç»­æ¶ˆæ¯ä¸¢å¤±ï¼‰
                    let textAfterMoments = afterMoments.replace(/\[imgcard:[^\]]+\]/gi, '').trim();
                    
                    const freshChar = await db.characters.get(char.id);
                    if (freshChar) {
                        let history = getChatHistory(freshChar, accountId);
                        
                        // 1. å…ˆå‘é€æ–‡å­—æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰ï¼‰- ğŸ”¥ ä¿®å¤ï¼šæŒ‰ ||| åˆ†å‰²å¤šæ¡æ¶ˆæ¯ï¼Œé¿å…æ ¼å¼ä¸¢å¤±
                        if (textBeforeMoments) {
                            const msgSegments = textBeforeMoments.split('|||')
                                .map(s => cleanMessage(s.trim()))
                                .filter(s => s && s.length > 0);
                            
                            console.log(`[AutoChat] æœ‹å‹åœˆå‰æ–‡å­—æŒ‰|||åˆ†å‰²ä¸º ${msgSegments.length} æ¡æ¶ˆæ¯`);
                            
                            for (let i = 0; i < msgSegments.length; i++) {
                                const textMsg = buildCharMessage(msgSegments[i], !!char.foreign_lang_mode, { time: Date.now() + i });
                                history.push(textMsg);
                                await setChatHistory(freshChar, accountId, history);
                                
                                // æ¸²æŸ“æ–‡å­—æ¶ˆæ¯
                                if (currentChatCharId === freshChar.id) {
                                    appendMessageToUI('char', msgSegments[i], freshChar.avatar);
                                }
                                
                                // æ¶ˆæ¯é—´å»¶æ—¶ï¼ˆæ¨¡æ‹Ÿè¿å‘ï¼‰
                                if (i < msgSegments.length - 1) {
                                    await new Promise(r => setTimeout(r, 300 + Math.random() * 400));
                                }
                            }
                            
                            // ç¨å¾®å»¶æ—¶å†å‘æœ‹å‹åœˆ
                            await new Promise(r => setTimeout(r, 500));
                        }
                        
                        // 2. å‘å¸ƒæœ‹å‹åœˆï¼ˆä¼ å…¥å›¾ç‰‡æè¿°ï¼‰
                        await publishMomentsByCharacter(freshChar, momentContent, imageCount, imageDesc);
                        
                        console.log(`[AutoChat] ${freshChar.name} å‘å¸ƒäº†æœ‹å‹åœˆ${imageDesc ? ` [é…å›¾: ${imageDesc}]` : ''}`);
                        addLog('success', `è§’è‰²å‘å¸ƒæœ‹å‹åœˆ: ${freshChar.name}`, { content: momentContent });
                        
                        // å‘é€é€šçŸ¥
                        sendSystemNotification(freshChar.name, '[æœ‹å‹åœˆ]');
                        
                        // åˆ·æ–°å¾®ä¿¡åˆ—è¡¨
                        if (currentChatCharId !== freshChar.id) {
                            const wechatPage = document.getElementById('wechat-page');
                            if (wechatPage.style.display !== 'none' && 
                                document.querySelector('.wechat-tab-item.active .tab-name').innerText === 'å¾®ä¿¡') {
                                renderWechatList(document.getElementById('wechat-content'));
                            }
                        }
                    }
                    
                    // ğŸ”¥ ä¿®å¤ï¼šå¦‚æœæœ‹å‹åœˆåè¿˜æœ‰å†…å®¹ï¼Œç»§ç»­å¤„ç†ï¼ˆä¹‹å‰ç›´æ¥returnå¯¼è‡´åç»­æ¶ˆæ¯ä¸¢å¤±ï¼ï¼‰
                    if (textAfterMoments) {
                        console.log('[AutoChat] æœ‹å‹åœˆåè¿˜æœ‰å†…å®¹ï¼Œç»§ç»­å¤„ç†:', textAfterMoments.substring(0, 50));
                        cleanReplyProcessed = textAfterMoments;
                        // æ¸…ç†å¼€å¤´çš„åˆ†éš”ç¬¦
                        while (cleanReplyProcessed.startsWith('|||')) {
                            cleanReplyProcessed = cleanReplyProcessed.substring(3).trim();
                        }
                        // ä¸returnï¼Œç»§ç»­æ‰§è¡Œåç»­çš„æ™®é€šæ¶ˆæ¯å¤„ç†é€»è¾‘
                    } else {
                        return; // æœ‹å‹åœˆå¤„ç†å®Œæˆä¸”æ²¡æœ‰åç»­å†…å®¹
                    }
                }
                
                // ğŸ¯ æ£€æµ‹"å¹»è§‰"ï¼šAIè¯´å‘äº†æœ‹å‹åœˆä½†æ²¡æœ‰æŒ‡ä»¤
                const hasMomentsClaim = /å‘äº†.*?æœ‹å‹åœˆ|æœ‹å‹åœˆ.*?å‘äº†|å‘å¸ƒ.*?åŠ¨æ€|æ›´æ–°.*?æœ‹å‹åœˆ|å‘ä¸ªæœ‹å‹åœˆ/i.test(cleanReplyProcessed);
                if (hasMomentsClaim) {
                    console.warn(`[AutoChat] âš ï¸ AIå¹»è§‰æ£€æµ‹ï¼š${char.name} è¯´å‘äº†æœ‹å‹åœˆï¼Œä½†æ²¡æœ‰è¿”å›æ­£ç¡®çš„æŒ‡ä»¤æ ¼å¼ï¼`);
                    console.warn(`[AutoChat] æ­£ç¡®æ ¼å¼ç¤ºä¾‹ï¼š[MOMENTS] content: å†…å®¹ images: 1`);
                    // ç»™ç”¨æˆ·ä¸€ä¸ªæç¤º
                    showToast(`${char.name}è¯´å‘äº†æœ‹å‹åœˆï¼Œä½†æ ¼å¼ä¸å¯¹ï¼Œæœªå®é™…å‘å¸ƒ`);
                }
                
                // ğŸ¯ æ£€æµ‹"å¹»è§‰"ï¼šAIè¯´å‘äº†çº¢åŒ…/è½¬è´¦ä½†æ²¡æœ‰æŒ‡ä»¤
                const hasTransferClaim = /å‘.*?çº¢åŒ…|çº¢åŒ….*?å‘|ç»™ä½ .*?è½¬|è½¬.*?ç»™ä½ |å‘ä¸ªçº¢åŒ…|å‘äº†.*?çº¢åŒ…|çº¢åŒ….*?æ”¶|æ”¶.*?çº¢åŒ…/i.test(cleanReplyProcessed);
                if (hasTransferClaim) {
                    console.warn(`[AutoChat] âš ï¸ AIå¹»è§‰æ£€æµ‹ï¼š${char.name} è¯´å‘äº†çº¢åŒ…/è½¬è´¦ï¼Œä½†æ²¡æœ‰è¿”å›æ­£ç¡®çš„ ((TRANSFER: é‡‘é¢, å¤‡æ³¨)) æ ¼å¼ï¼`);
                    showToast(`${char.name}è¯´å‘äº†çº¢åŒ…ï¼Œä½†æ ¼å¼ä¸å¯¹ï¼Œæœªå®é™…å‘é€`);
                }
                
                // å…œåº•ï¼šæ£€æµ‹æ˜¯å¦æ˜¯è½¬è´¦ JSONï¼ˆå…¼å®¹æ—§æ ¼å¼ï¼‰
                let trimmedReply = cleanMessage(cleanReplyProcessed.trim());
                if (trimmedReply.startsWith('{') && trimmedReply.includes('"amount"')) {
                    try {
                        const parsed = JSON.parse(trimmedReply);
                        if (parsed.amount && parsed.desc !== undefined && parsed.status) {
                            const freshChar = await db.characters.get(char.id);
                            if (freshChar) {
                                let history = getChatHistory(freshChar, accountId);
                                
                                const newMsg = { 
                                    role: 'char', 
                                    type: 'transfer',
                                    content: trimmedReply, 
                                    time: Date.now(),
                                    id: 'trans_' + Date.now()
                                };
                                
                                history.push(newMsg);
                                await setChatHistory(freshChar, accountId, history);
                                
                                if (currentChatCharId === freshChar.id) {
                                    renderChatBody(freshChar);
                                } else {
                                    sendSystemNotification(freshChar.name, '[è½¬è´¦]');
                                }
                            }
                    return;
                        }
                    } catch(e) {
                        // ä¸æ˜¯æœ‰æ•ˆçš„ JSONï¼Œç»§ç»­å½“æ™®é€šæ¶ˆæ¯
                    }
                }

                // 4. æ™®é€šæ¶ˆæ¯ï¼šæ‹†åˆ†é€»è¾‘ (å¢å¼ºç‰ˆ)
                let segments = [];
                console.log(`[AutoChat] Raw AI reply for ${char.name}: "${cleanReplyProcessed}"`);
                
                // âœ… æ¸…æ´—é€—å·ï¼Œä½†ä¿æŠ¤ç¿»è¯‘æ‹¬å·å†…çš„å†…å®¹
                if (char.foreign_lang_mode) {
                    const bracketPlaceholders = [];
                    let bpIndex = 0;
                    cleanReplyProcessed = cleanReplyProcessed.replace(/[ï¼ˆ(]([^ï¼‰)]*[\u4e00-\u9fff][^ï¼‰)]*)[ï¼‰)]/g, (match) => {
                        const ph = `###BRACKET_${bpIndex}###`;
                        bracketPlaceholders[bpIndex] = match;
                        bpIndex++;
                        return ph;
                    });
                    cleanReplyProcessed = cleanReplyProcessed.replace(/[,ï¼Œ]/g, ' ');
                    cleanReplyProcessed = cleanReplyProcessed.replace(/###BRACKET_(\d+)###/g, (_, idx) => bracketPlaceholders[parseInt(idx)] || _);
                } else {
                    cleanReplyProcessed = cleanReplyProcessed.replace(/[,ï¼Œ]/g, ' ');
                }

                // ä¼˜å…ˆå°è¯•åˆ†éš”ç¬¦æ‹†åˆ†
                if (cleanReplyProcessed.includes('|||')) {
                    segments = cleanReplyProcessed.split('|||').map(s => cleanMessage(s.trim())).filter(s => s.length > 0);
                    console.log(`[AutoChat] Split by ||| into ${segments.length} segments:`, segments);
                } else if (char.foreign_lang_mode) {
                    // âœ… å¤–è¯­ç¿»è¯‘æ¨¡å¼ï¼šä¼˜å…ˆæŒ‰æ¢è¡Œæ‹†åˆ†ï¼Œä¿æŠ¤ç¿»è¯‘æ ¼å¼
                    if (cleanReplyProcessed.includes('\n')) {
                        segments = cleanReplyProcessed.split('\n').map(s => cleanMessage(s.trim())).filter(s => s.length > 0);
                        console.log(`[AutoChat] å¤–è¯­ç¿»è¯‘æ¨¡å¼ï¼šæŒ‰æ¢è¡Œæ‹†åˆ†ï¼Œå¾—åˆ° ${segments.length} segments`);
                    } else {
                        segments = [cleanMessage(cleanReplyProcessed.trim())];
                        console.log(`[AutoChat] å¤–è¯­ç¿»è¯‘æ¨¡å¼ï¼šæ— åˆ†éš”ç¬¦ï¼Œä¿æŒå•æ¡æ¶ˆæ¯`);
                    }
                } else {
                    console.log(`[AutoChat] No ||| found, using splitMessage fallback`);
                    // å›é€€åˆ°æ ‡ç‚¹æ‹†åˆ†
                    segments = splitMessage(cleanReplyProcessed);
                    console.log(`[AutoChat] splitMessage result: ${segments.length} segments:`, segments);
                }
                
                // è¿‡æ»¤æ— æ•ˆæ¶ˆæ¯ (çº¯æ ‡ç‚¹)
                const beforeFilter = segments.length;
                segments = segments.filter(seg => {
                    // ç§»é™¤å¸¸è§æ ‡ç‚¹åï¼Œå¦‚æœé•¿åº¦ä¸º0ï¼Œè¯´æ˜å…¨æ˜¯æ ‡ç‚¹
                    const textOnly = seg.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦\s]/g, '');
                    return textOnly.length > 0;
                });
                
                if (beforeFilter !== segments.length) {
                    console.log(`[AutoChat] Filtered ${beforeFilter - segments.length} invalid segments (pure punctuation)`);
                }

                // å…œåº•ï¼šå¦‚æœè¿‡æ»¤åæ²¡äº†ï¼Œæˆ–è€…æœ¬èº«å°±æ²¡æ‹†å‡ºæ¥ï¼Œä½†åŸæ–‡æœ¬çœ‹ç€è¿˜è¡Œ
                if (segments.length === 0 && cleanReplyProcessed.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦\s]/g, '').length > 0) {
                     segments.push(cleanMessage(cleanReplyProcessed));
                     console.log(`[AutoChat] Fallback: using entire reply as single segment`);
                }

                if (segments.length === 0) {
                    console.warn(`[AutoChat] All segments filtered out as invalid for ${char.name}`);
                    return;
                }
                
                console.log(`[AutoChat] Final segments to send (${segments.length}):`, segments);

                for (let i = 0; i < segments.length; i++) {
                    let seg = segments[i];
                    
                    // âœ… ä¿®å¤ï¼šæ¸…ç†æ¯ä¸ªåˆ†æ®µæœ«å°¾å¤šä½™çš„ ]
                    seg = cleanMessage(seg);
                    
                    // ğŸ¯ æ£€æµ‹æ¢å¤´åƒæŒ‡ä»¤ ((CHANGE_AVATAR)) - åœ¨ä¸»åŠ¨èŠå¤©åˆ†æ®µä¸­æ£€æµ‹
                    if (/\(\(CHANGE_AVATAR\)\)/i.test(seg)) {
                        console.log(`[AutoChat] æ£€æµ‹åˆ°æ¢å¤´åƒæŒ‡ä»¤ï¼Œæ‰§è¡Œæ¢å¤´åƒ...`);
                        try {
                            await executeChangeAvatar(char.id, accountId);
                        } catch (e) {
                            console.error('[AutoChat] æ¢å¤´åƒå¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(CHANGE_AVATAR\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æƒ…å¤´é‚€è¯·æŒ‡ä»¤ ((COUPLE_AVATAR)) - åœ¨ä¸»åŠ¨èŠå¤©åˆ†æ®µä¸­æ£€æµ‹
                    if (/\(\(COUPLE_AVATAR\)\)/i.test(seg)) {
                        console.log(`[AutoChat] æ£€æµ‹åˆ°æƒ…å¤´é‚€è¯·æŒ‡ä»¤...`);
                        try {
                            await sendCoupleAvatarCard(char.id, accountId);
                        } catch (e) {
                            console.error('[AutoChat] å‘é€æƒ…å¤´é‚€è¯·å¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(COUPLE_AVATAR\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æ¢å›å•äººå¤´åƒæŒ‡ä»¤ ((REVERT_COUPLE_AVATAR)) - åœ¨ä¸»åŠ¨èŠå¤©åˆ†æ®µä¸­æ£€æµ‹
                    if (/\(\(REVERT_COUPLE_AVATAR\)\)/i.test(seg)) {
                        console.log(`[AutoChat] æ£€æµ‹åˆ°æ¢å›å•äººå¤´åƒæŒ‡ä»¤...`);
                        try {
                            await executeRevertCoupleAvatar(char.id, accountId);
                        } catch (e) {
                            console.error('[AutoChat] æ¢å›å•äººå¤´åƒå¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(REVERT_COUPLE_AVATAR\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹ä½¿ç”¨å›¾ç‰‡å½“å¤´åƒæŒ‡ä»¤ ((USE_IMAGE_AS_AVATAR: N)) - åœ¨ä¸»åŠ¨èŠå¤©åˆ†æ®µä¸­æ£€æµ‹
                    const useImgMatchAuto = seg.match(/\(\(USE_IMAGE_AS_AVATAR(?::\s*(\d+))?\)\)/i);
                    if (useImgMatchAuto) {
                        const imgIdx = useImgMatchAuto[1] ? parseInt(useImgMatchAuto[1]) : 1;
                        console.log(`[AutoChat] æ£€æµ‹åˆ°ä½¿ç”¨å›¾ç‰‡å½“å¤´åƒæŒ‡ä»¤ï¼Œé€‰æ‹©ç¬¬${imgIdx}å¼ ...`);
                        try {
                            await executeUseImageAsAvatar(char.id, accountId, imgIdx);
                        } catch (e) {
                            console.error('[AutoChat] ä½¿ç”¨å›¾ç‰‡å½“å¤´åƒå¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(USE_IMAGE_AS_AVATAR(?::\s*\d+)?\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æ¥ç”µæŒ‡ä»¤ ((CALL)) - è§’è‰²ä¸»åŠ¨ç»™ç”¨æˆ·æ‰“ç”µè¯
                    if (/\(\(CALL\)\)/i.test(seg)) {
                        console.log(`[AutoChat] ğŸ“ æ£€æµ‹åˆ°æ¥ç”µæŒ‡ä»¤ ((CALL))`);
                        try {
                            // æŠŠ ((CALL)) æŒ‡ä»¤ç§»é™¤ï¼Œå‰©ä½™æ–‡å­—ä½œä¸ºæ¥å¬åçš„ç¬¬ä¸€å¥è¯
                            const callFirstMsg = seg.replace(/\(\(CALL\)\)/gi, '').trim();
                            if (!_incomingCallCharId) {
                                await showIncomingCall(char.id, callFirstMsg || '');
                            }
                        } catch (e) {
                            console.error('[AutoChat] æ¥ç”µå¤„ç†å¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(CALL\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æˆ³ä¸€æˆ³æŒ‡ä»¤ ((POKE: åŠ¨ä½œ, éƒ¨ä½)) - åœ¨ä¸»åŠ¨èŠå¤©åˆ†æ®µä¸­æ£€æµ‹
                    const pokeMatchAuto = seg.match(/\(\(POKE:\s*(.+?)\)\)/i);
                    if (pokeMatchAuto) {
                        console.log(`[AutoChat] æ£€æµ‹åˆ°æˆ³ä¸€æˆ³æŒ‡ä»¤...`);
                        try {
                            const pokeContent = pokeMatchAuto[1].trim();
                            let pokeAction, pokePart;
                            if (pokeContent.includes(',') || pokeContent.includes('ï¼Œ')) {
                                const parts = pokeContent.split(/[,ï¼Œ]/);
                                pokeAction = parts[0].trim();
                                pokePart = parts.slice(1).join('').trim();
                            } else {
                                const spaceIdx = pokeContent.indexOf(' ');
                                if (spaceIdx > 0) {
                                    pokeAction = pokeContent.substring(0, spaceIdx).trim();
                                    pokePart = pokeContent.substring(spaceIdx + 1).trim();
                                } else {
                                    pokeAction = pokeContent;
                                    pokePart = '';
                                }
                            }
                            const freshChar = await db.characters.get(char.id);
                            const myChar = accountId ? await db.characters.get(parseInt(accountId)) : null;
                            const userName = myChar ? (myChar.nick || myChar.name) : 'ç”¨æˆ·';
                            const pokeText = pokePart ? `${freshChar.name}${pokeAction}${userName}çš„${pokePart}` : `${freshChar.name}${pokeAction}${userName}`;
                            
                            let history = getChatHistory(freshChar, accountId);
                            history.push({ role: 'system', content: pokeText, time: Date.now(), type: 'poke' });
                            await setChatHistory(freshChar, accountId, history);
                            
                            if (currentChatCharId === char.id) {
                                await appendMessageToUI('system', pokeText);
                            }
                            console.log(`[AutoChat] æˆ³ä¸€æˆ³: ${pokeText}`);
                        } catch (e) {
                            console.error('[AutoChat] æˆ³ä¸€æˆ³å¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(POKE:\s*(.+?)\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æ‰“å¼€APPæŒ‡ä»¤ ((OPEN_APP: APPåç§°)) - åœ¨ä¸»åŠ¨èŠå¤©åˆ†æ®µä¸­æ£€æµ‹
                    const appMatchAuto = seg.match(/\(\(OPEN_APP:\s*(.+?)\)\)/i);
                    if (appMatchAuto) {
                        console.log(`[AutoChat] æ£€æµ‹åˆ°æ‰“å¼€APPæŒ‡ä»¤...`);
                        try {
                            const appName = appMatchAuto[1].trim();
                            const freshChar = await db.characters.get(char.id);
                            const appText = `${freshChar.name} æ‰“å¼€äº† "${appName}"`;
                            
                            let history = getChatHistory(freshChar, accountId);
                            history.push({ role: 'system', content: appText, time: Date.now(), type: 'open_app' });
                            await setChatHistory(freshChar, accountId, history);
                            
                            if (currentChatCharId === char.id) {
                                await appendMessageToUI('system', appText);
                            }
                            console.log(`[AutoChat] æ‰“å¼€APP: ${appText}`);
                        } catch (e) {
                            console.error('[AutoChat] æ‰“å¼€APPå¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(OPEN_APP:\s*(.+?)\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æ”¹ç½‘åæŒ‡ä»¤ ((SET_NICKNAME: æ–°ç½‘å)) - åœ¨ä¸»åŠ¨èŠå¤©åˆ†æ®µä¸­æ£€æµ‹
                    const nicknameMatchAuto = seg.match(/\(\(SET_NICKNAME:\s*(.+?)\)\)/i);
                    if (nicknameMatchAuto) {
                        console.log(`[AutoChat] æ£€æµ‹åˆ°æ”¹ç½‘åæŒ‡ä»¤...`);
                        try {
                            const newNickname = nicknameMatchAuto[1].trim();
                            const freshChar = await db.characters.get(char.id);
                            const oldNickname = getCharWxNickname(freshChar, accountId) || freshChar.name;
                            // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°ç½‘åå­—æ®µï¼Œé˜²æ­¢è¦†ç›–è®¾ç½®
                            const nnUpdatePayload = accountId
                                ? { [`wx_nickname_by_user.${accountId}`]: newNickname }
                                : { wx_nickname: newNickname };
                            await safeDexieUpdate(db.characters, char.id, nnUpdatePayload, `æ”¹ç½‘å[${char.name}]`);
                            setCharWxNickname(freshChar, accountId, newNickname);
                            
                            const nicknameText = `${oldNickname} å°†ç½‘åæ”¹ä¸º "${newNickname}"`;
                            let history = getChatHistory(freshChar, accountId);
                            history.push({ role: 'system', content: nicknameText, time: Date.now(), type: 'set_nickname' });
                            await setChatHistory(freshChar, accountId, history);
                            
                            if (currentChatCharId === char.id) {
                                await appendMessageToUI('system', nicknameText);
                                // æ›´æ–°èŠå¤©æ ‡é¢˜
                                if (!freshChar.remark) {
                                    document.getElementById('chat-title').innerText = newNickname;
                                }
                                // æ›´æ–°è¯¦æƒ…é¡µ
                                const nicknameEl = document.getElementById('detail-char-nickname');
                                if (nicknameEl) nicknameEl.innerText = newNickname;
                            }
                            console.log(`[AutoChat] æ”¹ç½‘å: ${nicknameText}`);
                        } catch (e) {
                            console.error('[AutoChat] æ”¹ç½‘åå¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(SET_NICKNAME:\s*(.+?)\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æ”¹ä¸ªæ€§ç­¾åæŒ‡ä»¤ ((SET_SIGNATURE: æ–°ç­¾å)) - åœ¨ä¸»åŠ¨èŠå¤©åˆ†æ®µä¸­æ£€æµ‹
                    const signatureMatchAuto = seg.match(/\(\(SET_SIGNATURE:\s*(.+?)\)\)/i);
                    if (signatureMatchAuto) {
                        console.log(`[AutoChat] æ£€æµ‹åˆ°æ”¹ä¸ªæ€§ç­¾åæŒ‡ä»¤...`);
                        try {
                            const newSignature = signatureMatchAuto[1].trim();
                            const freshChar = await db.characters.get(char.id);
                            // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°ç­¾åå­—æ®µï¼Œé˜²æ­¢è¦†ç›–è®¾ç½®
                            await safeDexieUpdate(db.characters, char.id, { wx_signature: newSignature }, `æ”¹ç­¾å[${char.name}]`);
                            freshChar.wx_signature = newSignature;
                            
                            const sigText = `${freshChar.wx_nickname || freshChar.name} æ›´æ–°äº†ä¸ªæ€§ç­¾å: "${newSignature}"`;
                            let history = getChatHistory(freshChar, accountId);
                            history.push({ role: 'system', content: sigText, time: Date.now(), type: 'set_signature' });
                            await setChatHistory(freshChar, accountId, history);
                            
                            if (currentChatCharId === char.id) {
                                await appendMessageToUI('system', sigText);
                                // æ›´æ–°è¯¦æƒ…é¡µ
                                const sigEl = document.getElementById('detail-char-signature');
                                if (sigEl) sigEl.innerText = newSignature;
                            }
                            console.log(`[AutoChat] æ”¹ç­¾å: ${sigText}`);
                        } catch (e) {
                            console.error('[AutoChat] æ”¹ç­¾åå¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(SET_SIGNATURE:\s*(.+?)\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹åˆ é™¤å¥½å‹æŒ‡ä»¤ ((DELETE_USER)) - åœ¨ä¸»åŠ¨èŠå¤©åˆ†æ®µä¸­æ£€æµ‹
                    if (/\(\(DELETE_USER\)\)/i.test(seg)) {
                        console.log(`[AutoChat] æ£€æµ‹åˆ°è§’è‰²åˆ é™¤ç”¨æˆ·æŒ‡ä»¤...`);
                        try {
                            await executeCharDeleteUser(char.id, accountId);
                        } catch (e) {
                            console.error('[AutoChat] è§’è‰²åˆ é™¤ç”¨æˆ·å¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(DELETE_USER\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æ‹‰é»‘å¥½å‹æŒ‡ä»¤ ((BLOCK_USER)) - åœ¨ä¸»åŠ¨èŠå¤©åˆ†æ®µä¸­æ£€æµ‹
                    if (/\(\(BLOCK_USER\)\)/i.test(seg)) {
                        console.log(`[AutoChat] æ£€æµ‹åˆ°è§’è‰²æ‹‰é»‘ç”¨æˆ·æŒ‡ä»¤...`);
                        try {
                            await executeCharBlockUser(char.id, accountId);
                        } catch (e) {
                            console.error('[AutoChat] è§’è‰²æ‹‰é»‘ç”¨æˆ·å¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(BLOCK_USER\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹NPCåŠ å¥½å‹æŒ‡ä»¤ ((NPC_ADD_FRIEND: NPCåå­—)) - åœ¨ä¸»åŠ¨èŠå¤©åˆ†æ®µä¸­æ£€æµ‹
                    const npcAddMatchAuto = seg.match(/\(\(NPC_ADD_FRIEND:\s*(.+?)\s*\)\)/i);
                    if (npcAddMatchAuto) {
                        const npcName = npcAddMatchAuto[1].trim();
                        console.log(`[AutoChat] æ£€æµ‹åˆ°NPCåŠ å¥½å‹æŒ‡ä»¤: ${npcName}`);
                        try {
                            await executeNpcAddFriend(char, npcName, accountId);
                        } catch (e) {
                            console.error('[AutoChat] NPCåŠ å¥½å‹å¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(NPC_ADD_FRIEND:\s*.+?\s*\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æ’¤å›æŒ‡ä»¤ - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    if (/^\s*\(\(RECALL\)\)\s*$/i.test(seg)) {
                        console.log(`[AutoChat] æ£€æµ‹åˆ°æ’¤å›æŒ‡ä»¤ï¼Œæ‰§è¡Œæ’¤å›...`);
                        const freshChar = await db.characters.get(char.id);
                        let history = getChatHistory(freshChar, accountId);
                        
                        // æ‰¾AIæœ€åä¸€æ¡æ¶ˆæ¯ï¼ˆéæ’¤å›çŠ¶æ€ï¼‰
                        let targetIndex = -1;
                        for (let j = history.length - 1; j >= 0; j--) {
                            if (history[j].role === 'char' && !history[j].isRecalled) {
                                targetIndex = j;
                                break;
                            }
                        }
                        
                        if (targetIndex >= 0) {
                            const originalContent = history[targetIndex].content;
                            history[targetIndex].recalledContent = originalContent;
                            history[targetIndex].isRecalled = true;
                            history[targetIndex].content = "";
                            await setChatHistory(freshChar, accountId, history);
                            
                            console.log(`[AutoChat] ${freshChar.name} æ’¤å›äº†æ¶ˆæ¯: ${originalContent.substring(0, 30)}...`);
                            addLog('info', `è§’è‰²æ’¤å›æ¶ˆæ¯: ${freshChar.name}`);
                            
                            // æ›´æ–°UI - å±…ä¸­ç³»ç»Ÿæç¤ºæ ·å¼
                            if (currentChatCharId === freshChar.id) {
                                const chatBody = document.getElementById('chat-body');
                                const messageRows = chatBody.querySelectorAll('.message-row');
                                if (messageRows[targetIndex]) {
                                    const msgRow = messageRows[targetIndex];
                                    msgRow.className = 'message-row recalled-system-row';
                                    msgRow.innerHTML = '';
                                    
                                    const capturedContent = originalContent;
                                    const capturedName = freshChar.name;
                                    const systemTip = document.createElement('div');
                                    systemTip.className = 'recalled-system-tip';
                                    systemTip.innerHTML = `"${capturedName}"æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯`;
                                    systemTip.style.cursor = 'pointer';
                                    systemTip.onclick = (e) => {
                                        e.stopPropagation();
                                        showRecalledContent(capturedName, capturedContent);
                                    };
                                    msgRow.appendChild(systemTip);
                                }
                            }
                            
                            sendSystemNotification(freshChar.name, 'æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯');
                        }
                        continue; // è·³è¿‡è¿™ä¸ªåˆ†æ®µï¼Œä¸ä½œä¸ºæ¶ˆæ¯å‘é€
                    }
                    
                    // ğŸ¯ æ£€æµ‹è¡¨æƒ…åŒ…æŒ‡ä»¤ [sticker:æè¿°/ç¼–å·] - åœ¨ä¸»åŠ¨èŠå¤©åˆ†æ®µä¸­æ£€æµ‹å¹¶æ›¿æ¢ä¸ºå®é™…è¡¨æƒ…åŒ…å›¾ç‰‡
                    if (/\[sticker:[^\]]+\]/i.test(seg)) {
                        if (_mountedStickersListAuto.length > 0) {
                            seg = seg.replace(/\[sticker:([^\]]+)\]/gi, (match, keyword) => {
                                const stickerKeyword = keyword.trim();
                                console.log(`[AutoChat] æ£€æµ‹åˆ°è¡¨æƒ…åŒ…æŒ‡ä»¤: ${stickerKeyword}`);
                                
                                // ğŸ”¢ ä¼˜å…ˆï¼šæŒ‰ç¼–å·åŒ¹é…ï¼ˆAIç”¨ [sticker:1] æ ¼å¼ï¼‰
                                const numMatch = stickerKeyword.match(/^\d+$/);
                                if (numMatch) {
                                    const idx = parseInt(numMatch[0]) - 1;
                                    if (idx >= 0 && idx < _mountedStickersListAuto.length) {
                                        console.log(`[AutoChat] âœ… æŒ‰ç¼–å·åŒ¹é…åˆ°è¡¨æƒ…åŒ… #${idx + 1}: ${_mountedStickersListAuto[idx].description}`);
                                        return `[img:${_mountedStickersListAuto[idx].url}]`;
                                    }
                                }
                                
                                // ğŸ”¢ å°è¯•ä»æ–‡æœ¬ä¸­æå–æ•°å­—
                                const numInText = stickerKeyword.match(/(\d+)/);
                                if (numInText) {
                                    const idx = parseInt(numInText[1]) - 1;
                                    if (idx >= 0 && idx < _mountedStickersListAuto.length) {
                                        console.log(`[AutoChat] âœ… ä»æ–‡æœ¬æå–ç¼–å·åŒ¹é…åˆ°è¡¨æƒ…åŒ… #${idx + 1}: ${_mountedStickersListAuto[idx].description}`);
                                        return `[img:${_mountedStickersListAuto[idx].url}]`;
                                    }
                                }
                                
                                // ğŸ“ å…¶æ¬¡ï¼šæŒ‰æè¿°æ¨¡ç³ŠåŒ¹é…
                                const stickerKeywordLower = stickerKeyword.toLowerCase();
                                let bestMatch = null;
                                let bestScore = 0;
                                
                                for (const s of _mountedStickersListAuto) {
                                    const desc = s.description.toLowerCase();
                                    if (desc === stickerKeywordLower) {
                                        bestMatch = s;
                                        bestScore = 100;
                                        break;
                                    }
                                    if (desc.includes(stickerKeywordLower) && stickerKeywordLower.length > 1) {
                                        const score = stickerKeywordLower.length / desc.length * 80;
                                        if (score > bestScore) { bestMatch = s; bestScore = score; }
                                    }
                                    if (stickerKeywordLower.includes(desc) && desc.length > 1) {
                                        const score = desc.length / stickerKeywordLower.length * 70;
                                        if (score > bestScore) { bestMatch = s; bestScore = score; }
                                    }
                                    const keywords = stickerKeywordLower.split(/[\s,ï¼Œã€]+/).filter(k => k.length > 0);
                                    let matchCount = 0;
                                    for (const kw of keywords) {
                                        if (desc.includes(kw)) matchCount++;
                                    }
                                    if (matchCount > 0) {
                                        const score = matchCount / keywords.length * 60;
                                        if (score > bestScore) { bestMatch = s; bestScore = score; }
                                    }
                                    // å•å­—ç¬¦åŒ¹é…
                                    if (bestScore < 30) {
                                        let charMatch = 0;
                                        for (const ch of stickerKeywordLower) {
                                            if (desc.includes(ch)) charMatch++;
                                        }
                                        if (charMatch > 0 && stickerKeywordLower.length > 0) {
                                            const score = charMatch / stickerKeywordLower.length * 40;
                                            if (score > bestScore) { bestMatch = s; bestScore = score; }
                                        }
                                    }
                                }
                                
                                if (bestMatch && bestScore >= 15) {
                                    console.log(`[AutoChat] âœ… åŒ¹é…åˆ°è¡¨æƒ…åŒ…: ${bestMatch.description} (å¾—åˆ†: ${bestScore})`);
                                    return `[img:${bestMatch.url}]`;
                                } else {
                                    const randomSticker = _mountedStickersListAuto[Math.floor(Math.random() * _mountedStickersListAuto.length)];
                                    console.log(`[AutoChat] âš ï¸ AIæé€ äº†è¡¨æƒ…åŒ…"${stickerKeyword}"ï¼Œéšæœºé€‰æ‹©: ${randomSticker.description}`);
                                    return `[img:${randomSticker.url}]`;
                                }
                            });
                        } else {
                            // æ²¡æœ‰æŒ‚è½½è¡¨æƒ…åŒ…ä½†AIä»ç„¶è¾“å‡ºäº†[sticker:]ï¼Œæ¸…é™¤æ‰
                            console.log(`[AutoChat] âš ï¸ è§’è‰²æ²¡æœ‰æŒ‚è½½è¡¨æƒ…åŒ…ï¼Œä½†AIè¾“å‡ºäº†[sticker:]ï¼Œæ¸…é™¤`);
                            seg = seg.replace(/\[sticker:[^\]]+\]/gi, '').trim();
                            if (!seg) continue;
                        }
                    }
                    
                    // ğŸ¯ æ£€æµ‹å¼•ç”¨æ¶ˆæ¯æŒ‡ä»¤ ((QUOTE: åå­—, å†…å®¹)) - åœ¨ä¸»åŠ¨èŠå¤©åˆ†æ®µä¸­æ£€æµ‹
                    let quoteInfoAuto = null;
                    const quoteMatchAuto = seg.match(/\(\(QUOTE:\s*(.+?)\s*[,ï¼Œ]\s*(.+?)\s*\)\)/i);
                    if (quoteMatchAuto) {
                        quoteInfoAuto = { name: quoteMatchAuto[1].trim(), content: quoteMatchAuto[2].trim() };
                        seg = seg.replace(/\(\(QUOTE:\s*(.+?)\s*[,ï¼Œ]\s*(.+?)\s*\)\)/gi, '').trim();
                        if (!seg) continue;
                        console.log(`[AutoChat] æ£€æµ‹åˆ°å¼•ç”¨æ¶ˆæ¯æŒ‡ä»¤: å¼•ç”¨ ${quoteInfoAuto.name}: ${quoteInfoAuto.content}`);
                    }
                    
                    // å»¶æ—¶ï¼šç¬¬ä¸€æ¡ç¨å¿«ï¼Œåç»­æ¨¡æ‹Ÿæ‰“å­—
                    if (i > 0) {
                        const delay = 500 + Math.min(seg.length * 80, 2000);
                        await new Promise(r => setTimeout(r, delay));
                    } else {
                        // ç¬¬ä¸€æ¡ä¹Ÿç¨å¾®ç»™ç‚¹å»¶æ—¶ï¼Œæ„Ÿè§‰æ›´è‡ªç„¶
                        await new Promise(r => setTimeout(r, 500));
                    }

                    // é‡æ–°è·å–æœ€æ–°çš„ char æ•°æ®
                    const freshChar = await db.characters.get(char.id);
                    let history = getChatHistory(freshChar, accountId);
                    
                    // âœ… ä½¿ç”¨ buildCharMessage ä¸€æ¬¡æ€§è§£æç¿»è¯‘
                    const newMsg = buildCharMessage(seg, !!char.foreign_lang_mode);
                    // âœ… é™„åŠ å¼•ç”¨ä¿¡æ¯ï¼ˆå¦‚æœæœ‰ï¼‰
                    if (quoteInfoAuto) newMsg.quote = quoteInfoAuto;
                    
                    history.push(newMsg);
                    await setChatHistory(freshChar, accountId, history);

                    console.log(`[AutoChat] Sent part ${i+1}/${segments.length} for ${freshChar.name}: ${seg}`);
                    addLog('success', `è§’è‰²æ¶ˆæ¯å·²å­˜å…¥DB: ${freshChar.name}`, { segment: i+1, total: segments.length, message: seg });

                    // 5. æ›´æ–° UIï¼ˆå¦‚æœæ­£åœ¨æŸ¥çœ‹ï¼‰
                    if (currentChatCharId === freshChar.id) {
                        console.log(`[AutoChat] User is viewing ${freshChar.name}'s chat, appending to UI`);
                        addLog('info', `æ­£åœ¨æŸ¥çœ‹èŠå¤©ï¼Œæ›´æ–°UI: ${freshChar.name}`);
                        appendMessageToUI('char', seg, freshChar.avatar);
                    } else {
                        addLog('warning', `ä¸åœ¨èŠå¤©çª—å£ï¼Œåº”å‘é€é€šçŸ¥: ${freshChar.name}`, { currentChatCharId });
                    }
                    
                    // 6. æ— è®ºæ˜¯å¦åœ¨æŸ¥çœ‹ï¼Œéƒ½å‘é€é€šçŸ¥ï¼ˆé‡è¦ï¼ï¼‰
                    console.log(`[AutoChat] Sending notification for ${freshChar.name}: ${seg}`);
                    addLog('info', `è°ƒç”¨sendSystemNotification: ${freshChar.name}`, { message: seg });
                    sendSystemNotification(freshChar.name, seg);
                    
                    // çº¯å‰ç«¯ï¼šé€šçŸ¥å·²é€šè¿‡ sendSystemNotification å‘é€ï¼Œæ— éœ€åç«¯ API
                    
                    // 7. å¦‚æœåœ¨å¾®ä¿¡åˆ—è¡¨é¡µï¼Œåˆ·æ–°åˆ—è¡¨ä»¥æ›´æ–°æœ€åä¸€æ¡æ¶ˆæ¯é¢„è§ˆ
                    if (currentChatCharId !== freshChar.id) {
                        const wechatPage = document.getElementById('wechat-page');
                        if (wechatPage.style.display !== 'none' && 
                            document.querySelector('.wechat-tab-item.active .tab-name').innerText === 'å¾®ä¿¡') {
                            renderWechatList(document.getElementById('wechat-content'));
                        }
                    }
                }

                // â˜… AIå›å¤æˆåŠŸåï¼Œæ ‡è®°æŸ¥æ‰‹æœºæ´»åŠ¨ä¸ºå·²é€šçŸ¥
                if (_fpHasPhoneActivityAuto) {
                    try {
                        const freshCharForFp = await db.characters.get(char.id);
                        if (freshCharForFp) {
                            let markedCount = 0;
                            const fpNotifyPayload2 = {};
                            if (freshCharForFp.chat_history_by_user) {
                                for (const key of Object.keys(freshCharForFp.chat_history_by_user)) {
                                    if (!key.startsWith('fp_npc_')) continue;
                                    const npcHistory = freshCharForFp.chat_history_by_user[key] || [];
                                    let changed = false;
                                    for (const m of npcHistory) {
                                        if ((m.fpSent || (!m.fpSent && m.role === 'user')) && !m.fpNotified) {
                                            m.fpNotified = true;
                                            markedCount++;
                                            changed = true;
                                        }
                                    }
                                    if (changed) fpNotifyPayload2[`chat_history_by_user.${key}`] = npcHistory;
                                }
                            }
                            if (freshCharForFp.fp_moments_by_user) {
                                for (const mKey of Object.keys(freshCharForFp.fp_moments_by_user)) {
                                    const momentsList = freshCharForFp.fp_moments_by_user[mKey] || [];
                                    let changed = false;
                                    for (const m of momentsList) {
                                        if (m.fpSent && !m.fpNotified) {
                                            m.fpNotified = true;
                                            markedCount++;
                                            changed = true;
                                        }
                                    }
                                    if (changed) fpNotifyPayload2[`fp_moments_by_user.${mKey}`] = momentsList;
                                }
                            }
                            // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°æ ‡è®°å­—æ®µï¼Œé˜²æ­¢è¦†ç›–è®¾ç½®
                            if (Object.keys(fpNotifyPayload2).length > 0) {
                                await safeDexieUpdate(db.characters, char.id, fpNotifyPayload2, `æŸ¥æ‰‹æœºæ´»åŠ¨æ ‡è®°[${freshCharForFp.name}]`);
                            }
                            console.log('[triggerAutoChat] âœ… æŸ¥æ‰‹æœºæ´»åŠ¨å·²æ ‡è®°ä¸ºå·²é€šçŸ¥ï¼Œå…±æ ‡è®°', markedCount, 'æ¡');
                        }
                        
                        // â˜… å°†æŸ¥æ‰‹æœºäº‹ä»¶å†™å…¥é•¿æœŸè®°å¿†ï¼ˆä»…é¦–æ¬¡æœ‰æ–°æ ‡è®°æ—¶å†™å…¥ï¼Œé¿å…é‡å¤ï¼‰
                        if (markedCount > 0) {
                            try {
                                const fpMemoryContent = `${userName}å·å·æ‹¿äº†${char.name}çš„æ‰‹æœºï¼Œåšäº†ä»¥ä¸‹äº‹æƒ…ï¼š${_fpNpcLinesForMemoryAuto.map(l => l.trim().replace(/^[â†’â†]\s*/, '')).join('ï¼›')}ã€‚${char.name}å·²ç»å‘ç°å¹¶åšå‡ºäº†ååº”ã€‚`;
                                await db.chat_summaries.add({
                                    accountId: accountId,
                                    chatType: 'private',
                                    chatId: String(char.id),
                                    time: Date.now(),
                                    content: fpMemoryContent,
                                    messageCount: 0,
                                    timeRange: '',
                                    keywords: ['æŸ¥æ‰‹æœº', 'å†’å……', 'æ‰‹æœºè¢«åŠ¨'],
                                    startTime: Date.now(),
                                    endTime: Date.now()
                                });
                                console.log('[triggerAutoChat] âœ… æŸ¥æ‰‹æœºäº‹ä»¶å·²å†™å…¥é•¿æœŸè®°å¿†');
                            } catch (memErr) {
                                console.warn('[triggerAutoChat] å†™å…¥æŸ¥æ‰‹æœºé•¿æœŸè®°å¿†å¤±è´¥:', memErr);
                            }
                        } else {
                            console.log('[triggerAutoChat] â„¹ï¸ æŸ¥æ‰‹æœºæ´»åŠ¨å·²å…¨éƒ¨é€šçŸ¥è¿‡ï¼Œè·³è¿‡é‡å¤å†™å…¥é•¿æœŸè®°å¿†');
                        }
                    } catch (fpErr) {
                        console.warn('[triggerAutoChat] æ ‡è®°fpNotifiedå¤±è´¥:', fpErr);
                    }
                }

                // âœ… ä¸»åŠ¨èŠå¤©å®Œæˆåï¼Œæ£€æµ‹ imgcard å¹¶è°ƒç”¨ NovelAI è‡ªåŠ¨ç”Ÿå›¾
                try {
                    await processImgCardsWithNovelAI(char.id, accountId);
                } catch (naiError) {
                    console.error('[NovelAI-AutoGen] ä¸»åŠ¨èŠå¤© imgcard å¤„ç†å¤±è´¥:', naiError);
                }

                // ğŸ”§ æˆåŠŸå‘é€åæ›´æ–°å†·å´æ—¶é—´ï¼ˆæ¨è¿›ä¸€ä¸ªé—´éš”ï¼Œè€Œéç›´æ¥è·³åˆ°å½“å‰æ—¶é—´ï¼‰
                // è¿™æ ·å¦‚æœåå°æœŸé—´é”™è¿‡äº†å¤šä¸ªé—´éš”ï¼Œè¿”å›å‰å°åèƒ½é€æ¬¡è¡¥å‘
                {
                    const prevTs = lastAutoChatActionTime.get(char.id) || Date.now();
                    const intervalMs = (char.auto_reply_interval || 5) * 60 * 1000;
                    const nextTs = prevTs + intervalMs;
                    const maxCatchupCount = 3; // æœ€å¤šè¡¥å‘3æ¡ï¼ˆå«å½“å‰è¿™æ¡ï¼‰
                    const earliestAllowed = Date.now() - (maxCatchupCount - 1) * intervalMs;
                    // æ¨è¿›ä¸€ä¸ªé—´éš”ï¼Œä½†ä¸æ—©äºæœ€å¤§è¡¥å‘é™åˆ¶ï¼Œä¹Ÿä¸æ™šäºå½“å‰æ—¶é—´
                    const newTs = Math.min(Math.max(nextTs, earliestAllowed), Date.now());
                    lastAutoChatActionTime.set(char.id, newTs);
                    console.log(`[AutoChat] å†·å´æ—¶é—´æ¨è¿›: ${char.name}, è¿˜éœ€è¡¥å‘: ${Math.max(0, Math.floor((Date.now() - newTs) / intervalMs))} æ¡`);
                }

            } catch (err) {
                console.error(`[AutoChat] Failed for ${char.name}:`, err);
                // å‘é€é”™è¯¯é€šçŸ¥ï¼Œè®©ç”¨æˆ·çŸ¥é“ä¸ºä»€ä¹ˆæ²¡è§¦å‘
                sendSystemNotification("ç³»ç»Ÿæç¤º", `ä¸»åŠ¨èŠå¤©è§¦å‘å¤±è´¥(${char.name}): ${err.message}`);
                // ğŸ”§ å¤±è´¥æ—¶ç›´æ¥è·³åˆ°å½“å‰æ—¶é—´ï¼Œé¿å…è¿ç»­é‡è¯•
                lastAutoChatActionTime.set(char.id, Date.now());
            } finally {
                // è§£é”
                autoChatLocks.delete(char.id);
            }
        }

        // --- æœ‹å‹åœˆè‡ªåŠ¨å‘å¸ƒé€»è¾‘ ---
        function getMomentsInterval(frequency) {
            // è¿”å›å‘æœ‹å‹åœˆçš„é—´éš”èŒƒå›´ï¼ˆåˆ†é’Ÿï¼‰[min, max]
            switch (frequency) {
                case 'low': return [240, 480];      // 4-8å°æ—¶
                case 'medium': return [60, 180];    // 1-3å°æ—¶
                case 'high': return [15, 60];       // 15-60åˆ†é’Ÿ
                default: return null;
            }
        }

        async function checkAutoMoments() {
            const now = Date.now();
            const accountId = getCurrentAccountId();
            if (!accountId) return;
            
            // è·å–æ‰€æœ‰è®¾ç½®äº†æœ‹å‹åœˆé¢‘ç‡çš„è§’è‰²ï¼ˆæ’é™¤ offï¼‰
            const chars = await db.characters
                .filter(c => c.moments_frequency && c.moments_frequency !== 'off')
                .toArray();
            
            for (const char of chars) {
                // æ£€æŸ¥å¥½å‹çŠ¶æ€
                const status = getFriendStatus(char, accountId);
                if (status !== 'friend') continue;
                
                // é˜²æ­¢å¹¶å‘
                if (autoMomentsLocks.has(char.id)) continue;
                
                // è·å–é¢‘ç‡å¯¹åº”çš„é—´éš”èŒƒå›´
                const intervalRange = getMomentsInterval(char.moments_frequency);
                if (!intervalRange) continue;
                
                // ğŸ”§ ä½¿ç”¨ã€Œä¸‹æ¬¡è§¦å‘æ—¶é—´ç‚¹ã€æœºåˆ¶ï¼Œé¿å…æ¯æ¬¡éšæœºå¯¼è‡´å®é™…é—´éš”åçŸ­
                let scheduledTime = nextMomentsTriggerTime.get(char.id);
                
                if (!scheduledTime) {
                    // é¦–æ¬¡ï¼šéœ€è¦ç¡®å®šä¸‹æ¬¡è§¦å‘æ—¶é—´
                    // å…ˆæŸ¥æ•°æ®åº“è·å–æœ€åä¸€æ¡æœ‹å‹åœˆçš„æ—¶é—´
                    let baseTime = now; // é»˜è®¤ä»ç°åœ¨å¼€å§‹ç®—
                    try {
                        const recentMoments = await db.moments
                            .where('userId').equals(char.id)
                            .reverse()
                            .limit(1)
                            .toArray();
                        if (recentMoments.length > 0) {
                            baseTime = recentMoments[0].time;
                        }
                    } catch (e) {
                        // æŸ¥è¯¢å¤±è´¥ï¼Œä»å½“å‰æ—¶é—´ç®—èµ·
                    }
                    
                    // åœ¨ [min, max] èŒƒå›´å†…éšæœºä¸€ä¸ªé—´éš”ï¼Œè®¡ç®—ä¸‹æ¬¡è§¦å‘æ—¶é—´
                    const randomMinutes = intervalRange[0] + Math.random() * (intervalRange[1] - intervalRange[0]);
                    scheduledTime = baseTime + randomMinutes * 60 * 1000;
                    
                    // å¦‚æœç®—å‡ºæ¥çš„æ—¶é—´å·²ç»è¿‡å»äº†ï¼ˆæ¯”å¦‚æ•°æ®åº“é‡Œçš„æœ‹å‹åœˆå¾ˆä¹…ä»¥å‰çš„ï¼‰ï¼Œåˆ™ä»ç°åœ¨èµ·ç­‰ä¸€ä¸ªéšæœºé—´éš”
                    if (scheduledTime <= now) {
                        const freshInterval = intervalRange[0] + Math.random() * (intervalRange[1] - intervalRange[0]);
                        scheduledTime = now + freshInterval * 60 * 1000;
                    }
                    
                    nextMomentsTriggerTime.set(char.id, scheduledTime);
                    const waitMinutes = ((scheduledTime - now) / 60000).toFixed(0);
                    console.log(`[AutoMoments] ${char.name} ä¸‹æ¬¡æœ‹å‹åœˆé¢„è®¡åœ¨ ${waitMinutes} åˆ†é’Ÿå (é¢‘ç‡: ${char.moments_frequency})`);
                    continue;
                }
                
                // åˆ°äº†é¢„å®šæ—¶é—´æ‰è§¦å‘
                if (now >= scheduledTime) {
                    const delayMin = ((now - scheduledTime) / 60000).toFixed(1);
                    console.log(`[AutoMoments] âœ“ Triggering for ${char.name} (Frequency: ${char.moments_frequency}, Scheduled ${delayMin}min ago)`);
                    triggerAutoMoments(char);
                }
            }
        }

        async function triggerAutoMoments(char) {
            autoMomentsLocks.add(char.id);
            
            try {
                const accountId = getCurrentAccountId();
                
                // è·å–ç”¨æˆ·ä¿¡æ¯
                let userName = "ç”¨æˆ·";
                if (char.linked_user_id) {
                    const user = await db.characters.get(char.linked_user_id);
                    if (user) userName = user.name;
                }
                
                // è®¡ç®—è™šæ‹Ÿæ—¶é—´
                const virtualTimeStr = getFormattedVirtualTime(char);
                
                // è·å–æœ€è¿‘å‡ æ¡æœ‹å‹åœˆé¿å…å†…å®¹é‡å¤
                let recentMomentsText = '';
                try {
                    const recentMoments = await db.moments
                        .where('userId').equals(char.id)
                        .reverse()
                        .limit(5)
                        .toArray();
                    if (recentMoments.length > 0) {
                        recentMomentsText = '\n\nã€æœ€è¿‘å‘è¿‡çš„æœ‹å‹åœˆï¼ˆé¿å…é‡å¤ï¼‰ã€‘\n' + 
                            recentMoments.map(m => `- ${m.content}`).join('\n');
                    }
                } catch (e) {
                    console.warn('[AutoMoments] è·å–å†å²æœ‹å‹åœˆå¤±è´¥:', e);
                }
                
                // è·å–æœ€è¿‘èŠå¤©è®°å½•ä½œä¸ºå‚è€ƒ
                let recentChatContext = '';
                try {
                    const history = getChatHistory(char, accountId);
                    if (history && history.length > 0) {
                        const recent = history.slice(-20).map(m => {
                            const role = m.role === 'char' ? char.name : userName;
                            return `${role}: ${m.content}`;
                        }).join('\n');
                        recentChatContext = '\n\nã€æœ€è¿‘çš„èŠå¤©ï¼ˆå¯ä½œä¸ºçµæ„Ÿå‚è€ƒï¼Œä½†ä¸å¿…ç›´æ¥å…³è”ï¼‰ã€‘\n' + recent;
                    }
                } catch (e) {}
                
                // â˜… è·å–è§’è‰²çš„å…³è”NPCå¥½å‹ï¼Œç”¨äºä¸€æ¬¡æ€§ç”Ÿæˆè¯„è®º
                let npcInfoText = '';
                let selectedNPCList = []; // { npc, relation }
                try {
                    const relationships = char.relationships || [];
                    if (relationships.length > 0) {
                        const allChars = await db.characters.toArray();
                        const relatedNPCs = [];
                        for (const rel of relationships) {
                            if (!rel.targetId) continue;
                            const npc = allChars.find(c => c.id === rel.targetId);
                            if (!npc || npc.type === 'user') continue;
                            relatedNPCs.push({ npc, relation: rel.relation || 'å¥½å‹', desc: rel.desc || '' });
                        }
                        if (relatedNPCs.length > 0) {
                            // éšæœºé€‰1~3ä¸ªNPCæ¥è¯„è®º
                            const shuffled = [...relatedNPCs].sort(() => Math.random() - 0.5);
                            const count = Math.min(shuffled.length, 1 + Math.floor(Math.random() * 3));
                            selectedNPCList = shuffled.slice(0, count);
                            npcInfoText = '\n\nã€ä»¥ä¸‹å¥½å‹ä¼šçœ‹åˆ°è¿™æ¡æœ‹å‹åœˆï¼Œè¯·åŒæ—¶ä¸ºä»–ä»¬ç”Ÿæˆè¯„è®ºã€‘\n' +
                                selectedNPCList.map(({ npc, relation }) => {
                                    const displayName = npc.remark || npc.wx_nickname || npc.name;
                                    return `- ${displayName}ï¼ˆä¸${char.name}çš„å…³ç³»ï¼š${relation}ï¼‰ï¼š${npc.description || npc.personality || 'æ™®é€šæœ‹å‹'}`;
                                }).join('\n');
                        }
                    }
                } catch (e) {
                    console.warn('[AutoMoments] è·å–NPCå¥½å‹å¤±è´¥:', e);
                }
                
                const hasNPCs = selectedNPCList.length > 0;
                
                const systemPrompt = `ä½ æ­£åœ¨è¿›è¡Œè§’è‰²æ‰®æ¼”ã€‚
ã€å½“å‰æ—¶é—´ã€‘
${virtualTimeStr}

ã€è§’è‰²(ä½ )ä¿¡æ¯ã€‘
åå­—ï¼š${char.name}
${char.nick ? `æ˜µç§°ï¼š${char.nick}` : ''}
${char.wx_nickname ? `å¾®ä¿¡ç½‘åï¼š${char.wx_nickname}` : ''}
${char.wx_signature ? `ä¸ªæ€§ç­¾åï¼š${char.wx_signature}` : ''}
è®¾å®šï¼š
${char.description || ''}
${recentMomentsText}${recentChatContext}${npcInfoText}

è¯·ä»¥è§’è‰²çš„èº«ä»½å‘ä¸€æ¡æœ‹å‹åœˆåŠ¨æ€${hasNPCs ? 'ï¼Œå¹¶ä¸ºçœ‹åˆ°è¿™æ¡æœ‹å‹åœˆçš„å¥½å‹ç”Ÿæˆè¯„è®º' : ''}ã€‚è¦æ±‚ï¼š
1. å†…å®¹è¦ç¬¦åˆè§’è‰²çš„æ€§æ ¼ã€èº«ä»½å’Œå½“å‰æ—¶é—´æ®µ
2. åƒçœŸäººå‘æœ‹å‹åœˆä¸€æ ·è‡ªç„¶ï¼ˆå¯ä»¥æ˜¯æ—¥å¸¸åˆ†äº«ã€å¿ƒæƒ…æ„Ÿæ‚Ÿã€åæ§½ã€æ™’å›¾æ–‡æ¡ˆã€æ®µå­ç­‰ï¼‰
3. ä¸è¦å’Œæœ€è¿‘å‘è¿‡çš„å†…å®¹é‡å¤
4. é•¿åº¦é€‚ä¸­ï¼ŒåƒçœŸå®æœ‹å‹åœˆä¸€æ ·ï¼ˆä¸€èˆ¬1-3å¥è¯ï¼‰
5. å¯ä»¥é€‚å½“ä½¿ç”¨emojiï¼Œä½†ä¸è¦è¿‡å¤š
6. **å¤§éƒ¨åˆ†æœ‹å‹åœˆåº”è¯¥æ˜¯çº¯æ–‡å­—çš„**ï¼Œåªæœ‰å°‘æ•°æ—¶å€™æ‰é…å›¾ï¼ˆæ¯”å¦‚æ™’ç¾é£Ÿã€é£æ™¯ã€è‡ªæ‹ç­‰éœ€è¦å›¾ç‰‡çš„åœºæ™¯ï¼‰
7. å¦‚æœéœ€è¦é…å›¾ï¼Œè¯·åœ¨ image_desc ä¸­ç”¨æ–‡å­—æè¿°å›¾ç‰‡å†…å®¹
${hasNPCs ? `8. ä¸ºå¥½å‹åˆ—è¡¨ä¸­çš„æ¯ä¸ªäººç”Ÿæˆä¸€æ¡ç¬¦åˆå…¶æ€§æ ¼çš„ç®€çŸ­è¯„è®ºï¼ˆ2-25å­—ï¼‰ï¼ŒåƒçœŸäººè¯„è®ºä¸€æ ·éšæ„
9. å¥½å‹ä¹‹é—´å¯ä»¥äº’ç›¸å›å¤ï¼ˆä½¿ç”¨ replyTo æŒ‡å®šè¢«å›å¤äººåï¼‰ï¼Œä½†ä¸å¿…æ¯ä¸ªäººéƒ½å›å¤åˆ«äºº
10. ä¸è¦ç”Ÿæˆç”¨æˆ·ï¼ˆ${userName}ï¼‰çš„è¯„è®ºï¼Œåªç”ŸæˆNPCå¥½å‹çš„è¯„è®º` : ''}

è¯·ä¸¥æ ¼ä»¥JSONæ ¼å¼è¿”å›ï¼Œä¸è¦åŒ…å«Markdownä»£ç å—æ ‡è®°ï¼š
{
  "content": "æœ‹å‹åœˆæ–‡æ¡ˆå†…å®¹",
  "images": 0,
  "image_desc": ""${hasNPCs ? `,
  "comments": [
    {"name": "å¥½å‹å", "content": "è¯„è®ºå†…å®¹"},
    {"name": "å¥½å‹å", "replyTo": "è¢«å›å¤äººå", "content": "å›å¤å†…å®¹"}
  ]` : ''}
}

images å­—æ®µè¡¨ç¤ºé…å›¾æ•°é‡ï¼ˆ0-9ï¼‰ï¼Œ0è¡¨ç¤ºçº¯æ–‡å­—æœ‹å‹åœˆã€‚**å»ºè®®å¤§å¤šæ•°æƒ…å†µè®¾ä¸º0**ã€‚
image_desc å­—æ®µï¼šå½“ images > 0 æ—¶ï¼Œç”¨ä¸€å¥è¯æè¿°é…å›¾å†…å®¹ã€‚`;

                const messages = [
                    { role: 'system', content: systemPrompt }
                ];
                
                const aiResponse = await callAI(messages, { _useSecondary: true });
                
                // è§£æå“åº”
                const parsed = extractAndParseJSON(aiResponse);
                
                if (parsed && parsed.content) {
                    const momentContent = parsed.content.trim();
                    const imageCount = parseInt(parsed.images) || 0;
                    const imageDesc = parsed.image_desc || '';
                    
                    // â˜… è§£æé¢„ç”Ÿæˆçš„è¯„è®º
                    let preComments = [];
                    let preLikes = [];
                    if (hasNPCs && Array.isArray(parsed.comments)) {
                        for (const aiComment of parsed.comments) {
                            // åŒ¹é…NPC
                            const matched = selectedNPCList.find(({ npc }) => {
                                const displayName = npc.remark || npc.wx_nickname || npc.name;
                                return displayName === aiComment.name || npc.name === aiComment.name;
                            });
                            if (matched && aiComment.content) {
                                const commentObj = {
                                    userId: matched.npc.id,
                                    name: matched.npc.remark || matched.npc.wx_nickname || matched.npc.name,
                                    content: aiComment.content.trim().replace(/^["'"""]+|["'"""]+$/g, ''),
                                    time: Date.now() + Math.random() * 60000
                                };
                                if (aiComment.replyTo) {
                                    commentObj.replyTo = aiComment.replyTo;
                                }
                                preComments.push(commentObj);
                            }
                        }
                        // æ ¡éªŒ replyTo
                        const allNames = new Set(preComments.map(c => c.name));
                        for (const c of preComments) {
                            if (c.replyTo && !allNames.has(c.replyTo)) {
                                delete c.replyTo;
                            }
                        }
                        console.log(`[AutoMoments] âœ… ä¸€æ¬¡è°ƒç”¨ç”Ÿæˆäº† ${preComments.length} æ¡è¯„è®º`);
                    }
                    
                    // éšæœºNPCç‚¹èµï¼ˆ50%æ¦‚ç‡ï¼Œä¸é¢å¤–è°ƒAPIï¼‰
                    if (hasNPCs) {
                        for (const { npc } of selectedNPCList) {
                            if (Math.random() < 0.5) {
                                preLikes.push({
                                    userId: npc.id,
                                    name: npc.remark || npc.wx_nickname || npc.name
                                });
                            }
                        }
                    }
                    
                    // å‘å¸ƒæœ‹å‹åœˆï¼ˆé™„å¸¦é¢„ç”Ÿæˆçš„è¯„è®ºå’Œç‚¹èµï¼‰
                    await publishMomentsByCharacter(char, momentContent, imageCount, imageDesc, {
                        preComments: preComments,
                        preLikes: preLikes
                    });
                    
                    // æ›´æ–°æœ€åå‘å¸ƒæ—¶é—´
                    lastMomentsPostTime.set(char.id, Date.now());
                    
                    // ğŸ”§ è®¡ç®—ä¸‹ä¸€æ¬¡æœ‹å‹åœˆçš„è§¦å‘æ—¶é—´ç‚¹
                    const nextRange = getMomentsInterval(char.moments_frequency);
                    if (nextRange) {
                        const nextWait = nextRange[0] + Math.random() * (nextRange[1] - nextRange[0]);
                        const nextTime = Date.now() + nextWait * 60 * 1000;
                        nextMomentsTriggerTime.set(char.id, nextTime);
                        console.log(`[AutoMoments] âœ“ ${char.name} å‘å¸ƒäº†æœ‹å‹åœˆ: ${momentContent}`);
                        console.log(`[AutoMoments] ${char.name} ä¸‹æ¬¡æœ‹å‹åœˆé¢„è®¡åœ¨ ${nextWait.toFixed(0)} åˆ†é’Ÿå`);
                    } else {
                        console.log(`[AutoMoments] âœ“ ${char.name} å‘å¸ƒäº†æœ‹å‹åœˆ: ${momentContent}`);
                    }
                    
                    // å‘é€é€šçŸ¥
                    sendSystemNotification(char.name, `[æœ‹å‹åœˆ] ${momentContent.substring(0, 30)}...`);
                    
                    // åˆ·æ–°æœ‹å‹åœˆé¡µé¢ï¼ˆå¦‚æœæ­£åœ¨æŸ¥çœ‹ï¼‰
                    const momentsPage = document.getElementById('moments-page');
                    if (momentsPage && momentsPage.style.display !== 'none') {
                        renderMomentsList();
                    }
                } else {
                    console.warn('[AutoMoments] AIè¿”å›æ ¼å¼ä¸æ­£ç¡®:', aiResponse);
                }
            } catch (err) {
                console.error(`[AutoMoments] Failed for ${char.name}:`, err);
                // ğŸ”§ å¤±è´¥äº†ä¹Ÿé‡æ–°å®‰æ’ï¼Œé˜²æ­¢è¿ç»­é‡è¯•
                const retryRange = getMomentsInterval(char.moments_frequency);
                if (retryRange) {
                    const retryWait = retryRange[0] + Math.random() * (retryRange[1] - retryRange[0]);
                    nextMomentsTriggerTime.set(char.id, Date.now() + retryWait * 60 * 1000);
                }
            } finally {
                autoMomentsLocks.delete(char.id);
            }
        }

        // âœ… æ‰‹åŠ¨è§¦å‘è§’è‰²å‘æœ‹å‹åœˆï¼ˆèŠå¤©è¯¦æƒ…é¡µç‚¹å‡»ï¼‰
        async function manualTriggerMoment() {
            if (!currentChatCharId) {
                showToast('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªèŠå¤©');
                return;
            }
            const char = await db.characters.get(currentChatCharId);
            if (!char) {
                showToast('æ‰¾ä¸åˆ°è§’è‰²');
                return;
            }
            if (autoMomentsLocks.has(char.id)) {
                showToast('æ­£åœ¨ç”Ÿæˆä¸­ï¼Œè¯·ç¨å€™...');
                return;
            }
            showToast('ğŸ”„ æ­£åœ¨ç”Ÿæˆæœ‹å‹åœˆ...');
            try {
                await triggerAutoMoments(char);
                showToast('âœ… æœ‹å‹åœˆå‘å¸ƒæˆåŠŸ');
            } catch (e) {
                console.error('[ManualMoment] ç”Ÿæˆå¤±è´¥:', e);
                showToast('âŒ ç”Ÿæˆå¤±è´¥: ' + e.message);
            }
        }

        // --- è¡¨æƒ…åŒ…é€»è¾‘ ---
        async function renderStickerList(stickers) {
            const container = document.getElementById('detail-sticker-list');
            // ä¿ç•™æœ€åä¸€ä¸ªæ·»åŠ æŒ‰é’®
            const addBtn = container.querySelector('.sticker-add');
            container.innerHTML = '';
            
            document.getElementById('sticker-count').innerText = `${stickers.length}/20`;
            
            stickers.forEach((s, index) => {
                const div = document.createElement('div');
                div.className = 'sticker-item';
                div.style.backgroundImage = `url(${s})`;
                div.innerHTML = `<div class="sticker-del" onclick="removeSticker(${index}, event)">
                    <svg style="width:10px; height:10px; stroke:#fff; stroke-width:2;" viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </div>`;
                container.appendChild(div);
            });
            
            container.appendChild(addBtn);
        }

        async function addStickers(input) {
            if (!currentChatCharId) return;
            const files = input.files;
            if (!files || files.length === 0) return;
            
            const char = await db.characters.get(currentChatCharId);
            if (!char.custom_stickers) char.custom_stickers = [];
            
            if (char.custom_stickers.length + files.length > 20) {
                alert("æœ€å¤šåªèƒ½æ·»åŠ  20 ä¸ªè¡¨æƒ…åŒ…å“¦");
                return;
            }

            // å¹¶è¡Œè¯»å–
            const promises = Array.from(files).map(file => {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(e.target.result);
                    reader.readAsDataURL(file);
                });
            });
            
            const newStickers = await Promise.all(promises);
            char.custom_stickers.push(...newStickers);
            await safeCharacterPut(char);
            
            renderStickerList(char.custom_stickers);
            input.value = '';
        }

        async function removeSticker(index, e) {
            e.stopPropagation();
            if (!currentChatCharId) return;
            if (!confirm("åˆ é™¤è¿™ä¸ªè¡¨æƒ…ï¼Ÿ")) return;
            
            const char = await db.characters.get(currentChatCharId);
            char.custom_stickers.splice(index, 1);
            await safeCharacterPut(char);
            
            renderStickerList(char.custom_stickers);
        }

        function handleChatInputKey(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        }

        async function sendMessage() {
            const input = document.getElementById('chat-input-box');
            let text = input.value.trim();
            
            // éšè—è¡¨æƒ…æ¨èæ 
            const suggestionBar = document.getElementById('sticker-suggestion-bar');
            if (suggestionBar) suggestionBar.style.display = 'none';
            
            // â˜… æŸ¥æ‰‹æœºfpæ¨¡å¼ï¼šä»¥è§’è‰²èº«ä»½å‘é€æ¶ˆæ¯
            if (window._fpChatMode) {
                await sendFpChatMessage();
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯ä¿®ç½—åœºæ¨¡å¼ï¼ˆæŸ¥å²—æ¨¡å¼ä¸‹çš„å‘é€ï¼‰
            if (isViewingRoleAccount && currentViewingRoleAccountId) {
                await sendShuraMessage();
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯ç¾¤èŠ
            if (window.currentGroupChatId) {
                await sendGroupMessage(text);
                return;
            }
            
            if (!text || !currentChatCharId) return;

            // 1. è·å–å½“å‰è§’è‰²
            const char = await db.characters.get(currentChatCharId);
            if (!char) return;
            
            // ğŸ”¥ ä¿®å¤ï¼šå¤„ç†ç”¨æˆ·æ‰‹åŠ¨è¾“å…¥çš„ [sticker:] æ ¼å¼ï¼Œæ›¿æ¢ä¸ºå›¾ç‰‡URL
            if (/\[sticker:[^\]]+\]/i.test(text)) {
                const mountedStickerIds = char.mounted_sticker_categories || [];
                let allStickers = [];
                for (const catId of mountedStickerIds) {
                    const cat = await db.sticker_categories.get(catId);
                    if (cat && cat.stickers && cat.stickers.length > 0) {
                        for (const s of cat.stickers) {
                            if (s.description && s.url) {
                                allStickers.push({ description: s.description, url: s.url });
                            }
                        }
                    }
                }
                
                if (allStickers.length > 0) {
                    text = text.replace(/\[sticker:([^\]]+)\]/gi, (match, keyword) => {
                        const stickerKeyword = keyword.trim();
                        console.log(`[sendMessage] æ£€æµ‹åˆ°è¡¨æƒ…åŒ…æŒ‡ä»¤: ${stickerKeyword}`);
                        
                        // æŒ‰ç¼–å·åŒ¹é…
                        const numMatch = stickerKeyword.match(/^\d+$/);
                        if (numMatch) {
                            const idx = parseInt(numMatch[0]) - 1;
                            if (idx >= 0 && idx < allStickers.length) {
                                console.log(`[sendMessage] âœ… åŒ¹é…åˆ°è¡¨æƒ…åŒ… #${idx + 1}: ${allStickers[idx].description}`);
                                return `[img:${allStickers[idx].url}]`;
                            } else {
                                console.warn(`[sendMessage] âš ï¸ è¡¨æƒ…åŒ…ç¼–å· ${numMatch[0]} è¶…å‡ºèŒƒå›´ (1-${allStickers.length})`);
                                showToast(`è¡¨æƒ…åŒ…ç¼–å·è¶…å‡ºèŒƒå›´ï¼Œè¯·ä½¿ç”¨ 1-${allStickers.length}`);
                                return '';
                            }
                        }
                        
                        // å¦‚æœä¸æ˜¯çº¯æ•°å­—ï¼Œç§»é™¤
                        console.warn(`[sendMessage] âš ï¸ è¡¨æƒ…åŒ…æ ¼å¼é”™è¯¯: ${stickerKeyword}`);
                        return '';
                    });
                } else {
                    // æ²¡æœ‰æŒ‚è½½è¡¨æƒ…åŒ…
                    console.warn(`[sendMessage] âš ï¸ è§’è‰²æœªæŒ‚è½½è¡¨æƒ…åŒ…`);
                    text = text.replace(/\[sticker:[^\]]+\]/gi, '');
                    showToast('è¯¥è§’è‰²æœªæŒ‚è½½è¡¨æƒ…åŒ…');
                }
                
                // å¦‚æœæ›¿æ¢åä¸ºç©ºï¼Œä¸å‘é€
                if (!text.trim()) {
                    input.value = '';
                    handleChatInputChange(input);
                    return;
                }
            }
            
            const accountId = getCurrentAccountId();
            
            // æ£€æŸ¥å¥½å‹çŠ¶æ€
            const friendStatus = getFriendStatus(char, accountId);
            if (friendStatus === 'deleted_by_char') {
                alert(`${char.name} å·²å°†ä½ åˆ é™¤å¥½å‹ï¼Œæ— æ³•å‘é€æ¶ˆæ¯ã€‚ä½ å¯ä»¥å°è¯•é‡æ–°å‘é€å¥½å‹ç”³è¯·ã€‚`);
                return;
            }
            if (friendStatus === 'blocked_by_char') {
                alert(`${char.name} å·²å°†ä½ æ‹‰é»‘ï¼Œæ— æ³•å‘é€æ¶ˆæ¯ã€‚ä½ å¯ä»¥é€šè¿‡çŸ­ä¿¡è”ç³» Taã€‚`);
                return;
            }
            if (friendStatus !== 'friend') {
                // ä¸æ˜¯å¥½å‹ï¼Œä¸èƒ½å‘é€æ¶ˆæ¯
                if (confirm(`ä½ è¿˜ä¸æ˜¯ ${char.name} çš„å¥½å‹ï¼Œæ˜¯å¦å‘é€å¥½å‹ç”³è¯·ï¼Ÿ`)) {
                    const message = prompt('è¯·è¾“å…¥ç”³è¯·ç†ç”±ï¼ˆå¯é€‰ï¼‰ï¼š', 'æˆ‘æ˜¯' + (await getCurrentUserName()));
                    if (message !== null) {
                        await sendFriendRequestTo(currentChatCharId, message);
                    }
                }
                return;
            }

            input.value = ''; 
            handleChatInputChange(input); // é‡ç½®æŒ‰é’®çŠ¶æ€
            closeChatPanel(); // å‘é€æ—¶å…³é—­é¢æ¿
            
            // é‡æ–°èšç„¦è¾“å…¥æ¡†ï¼Œä¿æŒé”®ç›˜ä¸æ”¶èµ·ï¼ˆæ–¹ä¾¿è¿ç»­å‘æ¶ˆæ¯ï¼‰
            input.focus();

            let history = getChatHistory(char, accountId);

            // 2. è¿½åŠ å¹¶æ˜¾ç¤ºç”¨æˆ·æ¶ˆæ¯ï¼ˆæ”¯æŒå¼•ç”¨ï¼‰
            // ğŸ”§ ä½¿ç”¨è™šæ‹Ÿæ—¶é—´ï¼Œç¡®ä¿ä¸å¿«è¿›ç”Ÿæˆçš„æ¶ˆæ¯æ—¶é—´æˆ³ä¸€è‡´
            const virtualTime = Date.now() + getEffectiveTimeOffset(char);
            const userMsg = { role: 'user', content: text, time: virtualTime };
            
            // å¦‚æœæœ‰å¼•ç”¨
            if (currentQuote) {
                userMsg.quote = {
                    name: currentQuote.name,
                    content: currentQuote.content
                };
                cancelQuote(); // æ¸…é™¤å¼•ç”¨
            }
            
            history.push(userMsg);
            await setChatHistory(char, accountId, history); 
            
            // ğŸ”¥ ä¼˜åŒ–ï¼šåªæœ‰åœ¨æœ‰å¼•ç”¨æ—¶æ‰é‡æ–°æ¸²æŸ“ï¼Œå¦åˆ™åªè¿½åŠ æ¶ˆæ¯
            if (userMsg.quote) {
                // æœ‰å¼•ç”¨ï¼Œéœ€è¦é‡æ–°æ¸²æŸ“ä»¥æ˜¾ç¤ºå¼•ç”¨æ ·å¼
                renderChatBody(char);
            } else {
                // æ²¡æœ‰å¼•ç”¨ï¼Œåªè¿½åŠ æ¶ˆæ¯ï¼Œä¸é‡æ–°æ¸²æŸ“
                await appendMessageToUI('user', text, getCharAvatar(char, getCurrentAccountId()));
            }
            
            // âœ… å¦‚æœæ˜¯è”æœºå¥½å‹ï¼Œå‘é€æ¶ˆæ¯åˆ°æœåŠ¡å™¨
            if (char.isOnlineFriend && char.onlineData?.wx_account) {
                // è·å–å½“å‰å¯ç”¨çš„åœ¨çº¿è§’è‰²ï¼ˆå¦‚æœæ²¡æœ‰åˆ™è‡ªåŠ¨ä¸Šçº¿ï¼‰
                const onlineUserChar = await getOrCreateOnlineUserChar();
                
                if (onlineUserChar && onlineConnected) {
                    const fromWxAccount = onlineUserChar.identity.account;
                    const toWxAccount = char.onlineData.wx_account;
                    const sent = sendOnlineMessage(toWxAccount, text, fromWxAccount);
                    if (sent) {
                        console.log('[Online] æ¶ˆæ¯å·²å‘é€åˆ°æœåŠ¡å™¨:', text);
                    } else {
                        console.warn('[Online] æ¶ˆæ¯å‘é€å¤±è´¥ï¼Œå¯èƒ½æœªè¿æ¥æœåŠ¡å™¨');
                        showToast('æ¶ˆæ¯å‘é€å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨è¿æ¥');
                    }
                } else {
                    console.warn('[Online] æ— æ³•å‘é€è”æœºæ¶ˆæ¯ï¼šæœªæ‰¾åˆ°æœ‰å¾®ä¿¡å·çš„è§’è‰²æˆ–æœªè¿æ¥æœåŠ¡å™¨');
                    showToast('è¯·ç¡®ä¿ User è§’è‰²è®¾ç½®äº†å¾®ä¿¡å·å¹¶è¿æ¥æœåŠ¡å™¨');
                }
            }
            
            // âœ… ä¸å†è‡ªåŠ¨è§¦å‘ AI å›å¤ï¼Œéœ€è¦ç”¨æˆ·ç‚¹å‡»"æ¥å—å›å¤"æŒ‰é’®
            // triggerAiReply(); 
            
            // ğŸ”§ ç”¨æˆ·å‘äº†æ¶ˆæ¯ï¼Œé‡ç½®ä¸»åŠ¨èŠå¤©çš„å†·å´è®¡æ—¶å™¨
            if (currentChatCharId) {
                lastAutoChatActionTime.set(currentChatCharId, Date.now());
            }
        }
        
        // å‘é€ç¾¤èŠæ¶ˆæ¯
        async function sendGroupMessage(text) {
            if (!text || !window.currentGroupChatId) return;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            const input = document.getElementById('chat-input-box');
            input.value = '';
            handleChatInputChange(input);
            closeChatPanel();
            
            // é‡æ–°èšç„¦è¾“å…¥æ¡†ï¼Œä¿æŒé”®ç›˜ä¸æ”¶èµ·
            input.focus();
            
            // æ·»åŠ æ¶ˆæ¯åˆ°ç¾¤èŠå†å²ï¼ˆæ”¯æŒå¼•ç”¨ï¼‰
            if (!group.chat_history) group.chat_history = [];
            const msg = {
                role: 'user',
                content: text,
                time: Date.now()
            };
            
            // å¦‚æœæœ‰å¼•ç”¨
            if (currentQuote) {
                msg.quote = {
                    name: currentQuote.name,
                    content: currentQuote.content
                };
                cancelQuote(); // æ¸…é™¤å¼•ç”¨
            }
            
            group.chat_history.push(msg);
            group.updated_at = Date.now();
            
            await safeGroupChatPut(group);
            
            // ğŸ”¥ ä¼˜åŒ–ï¼šåªæœ‰åœ¨æœ‰å¼•ç”¨æ—¶æ‰é‡æ–°æ¸²æŸ“ï¼Œå¦åˆ™åªè¿½åŠ æ¶ˆæ¯HTML
            if (msg.quote) {
                // æœ‰å¼•ç”¨ï¼Œéœ€è¦é‡æ–°æ¸²æŸ“ä»¥æ˜¾ç¤ºå¼•ç”¨æ ·å¼
                await renderGroupChatBody(group);
            } else {
                // æ²¡æœ‰å¼•ç”¨ï¼Œåªè¿½åŠ æ¶ˆæ¯DOMï¼Œä¸é‡æ–°æ¸²æŸ“æ•´ä¸ªé¡µé¢
                await appendUserGroupMessageToUI(msg, group);
            }
        }
        
        // è§¦å‘ç¾¤èŠæˆå‘˜å›å¤ï¼ˆå¤šäººå›å¤ - ä¸€æ¬¡APIè°ƒç”¨ç”Ÿæˆæ‰€æœ‰å›å¤ï¼‰
        async function triggerGroupMemberReply() {
            // ğŸ”§ é˜²æ­¢é‡å¤è°ƒç”¨APIï¼ˆè¶…æ—¶15ç§’è‡ªåŠ¨è§£é”ï¼Œé˜²æ­¢æ‰‹æœºç«¯é”æ­»ï¼‰
            if (window._isGeneratingGroupReply) {
                const elapsed = Date.now() - (window._isGeneratingGroupReplyTime || 0);
                if (elapsed < 15000) {
                    console.log('[triggerGroupMemberReply] æ­£åœ¨ç”Ÿæˆå›å¤ä¸­ï¼Œå¿½ç•¥é‡å¤è°ƒç”¨ (å·²ç­‰å¾…' + Math.round(elapsed/1000) + 'ç§’)');
                    showToast('æ­£åœ¨ç”Ÿæˆå›å¤ä¸­ï¼Œè¯·ç¨å€™...');
                    return;
                }
                console.warn('[triggerGroupMemberReply] âš ï¸ æ£€æµ‹åˆ°é”è¶…æ—¶(' + Math.round(elapsed/1000) + 'ç§’)ï¼Œå¼ºåˆ¶é‡ç½®');
                window._isGeneratingGroupReply = false;
                window._isGeneratingGroupReplyTime = 0;
            }
            window._isGeneratingGroupReply = true;
            window._isGeneratingGroupReplyTime = Date.now();
            
            if (!window.currentGroupChatId) {
                window._isGeneratingGroupReply = false;
                window._isGeneratingGroupReplyTime = 0;
                return;
            }
            
            // ğŸ”§ æ‰‹æœºç«¯IndexedDBé˜²å¡æ­»ï¼šç”¨è¶…æ—¶ä¿æŠ¤DBè¯»å–
            let group;
            try {
                group = await Promise.race([
                    db.group_chats.get(window.currentGroupChatId),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('DBè¯»å–è¶…æ—¶')), 8000))
                ]);
            } catch (dbErr) {
                console.error('[triggerGroupMemberReply] æ•°æ®åº“è¯»å–å¤±è´¥æˆ–è¶…æ—¶:', dbErr.message);
                window._isGeneratingGroupReply = false;
                window._isGeneratingGroupReplyTime = 0;
                showToast('æ•°æ®è¯»å–è¶…æ—¶ï¼Œè¯·é‡è¯•');
                return;
            }
            if (!group || !group.memberIds || group.memberIds.length === 0) {
                window._isGeneratingGroupReply = false;
                window._isGeneratingGroupReplyTime = 0;
                return;
            }
            
            const accountId = getCurrentAccountId();
            const chatTitleEl = document.getElementById('chat-title');
            const originalTitle = group.name;
            
            // æ˜¾ç¤º"æ­£åœ¨ç”Ÿæˆä¸­..."æç¤º
            if (chatTitleEl) chatTitleEl.innerText = `ç¾¤æˆå‘˜ä»¬æ­£åœ¨è¾“å…¥...`;
            
            // ğŸ”§ å®‰å…¨å®šæ—¶å™¨ï¼š45ç§’åå¼ºåˆ¶é‡Šæ”¾é”ï¼ˆé˜²æ­¢awaitæ°¸ä¹…æŒ‚èµ·å¯¼è‡´æ‰‹æœºç«¯é”æ­»ï¼‰
            const _safetyGroupLockTimer = setTimeout(() => {
                if (window._isGeneratingGroupReply) {
                    console.warn('[triggerGroupMemberReply] â° å®‰å…¨å®šæ—¶å™¨è§¦å‘(45s)ï¼Œå¼ºåˆ¶é‡Šæ”¾é”');
                    window._isGeneratingGroupReply = false;
                    window._isGeneratingGroupReplyTime = 0;
                }
            }, 45000);
            
            try {
                // è¿‡æ»¤æ‰è¢«ç¦è¨€çš„æˆå‘˜
                const mutedMembers = group.mutedMembers || [];
                const availableMembers = group.memberIds.filter(id => !mutedMembers.includes(id));
                
                if (availableMembers.length === 0) {
                    if (chatTitleEl) chatTitleEl.innerText = originalTitle;
                    return;
                }
                
                // é¢„åŠ è½½æ‰€æœ‰æˆå‘˜ä¿¡æ¯
                const memberMap = {};
                for (const memberId of group.memberIds) {
                    const char = await db.characters.get(memberId);
                    if (char) memberMap[memberId] = char;
                }
                const myChar = currentMyCharId ? await db.characters.get(parseInt(currentMyCharId)) : null;
                const myNickname = group.myNickname || (myChar ? (myChar.nick || myChar.name) : 'ç”¨æˆ·');
                
                // æ„å»ºæˆå‘˜åˆ—è¡¨æè¿°ï¼ˆåŒ…å«ç®¡ç†å‘˜æ ‡è¯†å’Œç¾¤æ˜µç§°ï¼‰
                const adminIds = group.adminIds || [];
                const memberNicknames = group.memberNicknames || {};
                const validMemberNames = []; // æ”¶é›†æ‰€æœ‰åˆæ³•è§’è‰²å
                const invitableNpcsMap = {}; // æ¯ä¸ªæˆå‘˜å¯é‚€è¯·çš„NPCæœ‹å‹
                const membersList = group.memberIds.map(memberId => {
                    const char = memberMap[memberId];
                    if (!char) return null;
                    const isMuted = mutedMembers.includes(memberId);
                    const isAdmin = adminIds.includes(memberId);
                    const nickname = memberNicknames[memberId];
                    let roleText = '';
                    if (isAdmin) roleText += ' [ç®¡ç†å‘˜]';
                    if (isMuted) roleText += ' [å·²ç¦è¨€ - ä¸èƒ½å‘è¨€]';
                    const nicknameText = nickname ? ` (ç¾¤æ˜µç§°: ${nickname})` : '';
                    const displayName = getCharDisplayName(char, getCurrentAccountId());
                    validMemberNames.push(displayName);
                    // æ”¶é›†è¯¥è§’è‰²å¯é‚€è¯·è¿›ç¾¤çš„NPCæœ‹å‹ï¼ˆæœ‰çœŸå®å…³è”çš„ï¼‰
                    if (char.relationships && char.relationships.length > 0) {
                        const invitable = char.relationships.filter(r => r.targetId && !group.memberIds.includes(r.targetId));
                        if (invitable.length > 0) {
                            invitableNpcsMap[displayName] = invitable.map(r => `${r.targetName}(${r.relation})`);
                        }
                    }
                    return `- ${displayName}${nicknameText}${roleText}: ${char.description || 'æ— ç‰¹åˆ«è®¾å®š'}`;
                }).filter(Boolean).join('\n');
                
                // æ„å»ºå¯é‚€è¯·æœ‹å‹çš„æç¤ºæ–‡æœ¬
                let invitableNpcsText = '';
                const invitableEntries = Object.entries(invitableNpcsMap);
                if (invitableEntries.length > 0) {
                    const lines = invitableEntries.map(([name, npcs]) => `${name}çš„æœ‹å‹: ${npcs.join(' ')}`);
                    invitableNpcsText = `\nå¯ä»¥è¢«æ‹‰è¿›ç¾¤çš„æœ‹å‹\n${lines.join('\n')}\n`;
                }
                
                // è·å–ä¸–ç•Œä¹¦ä¸Šä¸‹æ–‡ï¼ˆåˆå¹¶ç¾¤èŠçš„ä¸–ç•Œä¹¦å’Œæ‰€æœ‰æˆå‘˜çš„ä¸–ç•Œä¹¦ï¼‰
                let loreContext = "";
                const allLorebookIds = new Set();
                
                // æ·»åŠ ç¾¤èŠè‡ªå·±çš„ä¸–ç•Œä¹¦
                const groupLorebookIds = group.lorebookIds || (group.lorebookId ? [group.lorebookId] : []);
                groupLorebookIds.forEach(id => allLorebookIds.add(id));
                
                // æ·»åŠ æ‰€æœ‰æˆå‘˜çš„ä¸–ç•Œä¹¦
                for (const memberId of availableMembers) {
                    const char = memberMap[memberId];
                    if (char) {
                        const ids = char.lorebookIds || (char.lorebookId ? [char.lorebookId] : []);
                        ids.forEach(id => allLorebookIds.add(id));
                    }
                }
                
                {
                    const recentText = (group.chat_history || []).slice(-10).map(m => m.content).join(' ');
                    loreContext = await getLorebookContext([...allLorebookIds], recentText);
                    if (loreContext) {
                        loreContext = `\nã€ä¸–ç•Œè§‚/èƒŒæ™¯è®¾å®šã€‘\n${loreContext}`;
                    }
                }
                
                // æ„å»ºç¾¤èŠä¸Šä¸‹æ–‡ï¼ˆä½¿ç”¨è‡ªå®šä¹‰çš„ä¸Šä¸‹æ–‡æ¡æ•°ï¼Œé»˜è®¤25æ¡ï¼‰
                const groupContextCount = group.context_message_count || 25;
                const groupHistory = group.chat_history || [];
                const recentGroupHistory = groupHistory.slice(-groupContextCount);
                
                // æ”¶é›†æœªé¢†å®Œçš„çº¢åŒ…ä¿¡æ¯
                let pendingRedPackets = [];
                for (const m of groupHistory) {
                    if (m.type === 'redpacket') {
                        try {
                            const rpData = JSON.parse(m.content);
                            const claimedCount = rpData.claimed?.length || 0;
                            if (claimedCount < rpData.count) {
                                pendingRedPackets.push({
                                    id: rpData.id,
                                    wish: rpData.wish || 'æ­å–œå‘è´¢',
                                    remaining: rpData.count - claimedCount,
                                    claimed: rpData.claimed || []
                                });
                            }
                        } catch(e) {}
                    }
                }
                
                let groupContextStr = recentGroupHistory.map(m => {
                    if (m.role === 'system') return `[ç³»ç»Ÿæ¶ˆæ¯] ${m.content}`;
                    if (m.type === 'redpacket') {
                        try {
                            const rpData = JSON.parse(m.content);
                            const claimedCount = rpData.claimed?.length || 0;
                            const isAllClaimed = claimedCount >= rpData.count;
                            return `${myNickname}: [å‘é€äº†çº¢åŒ…] "${rpData.wish || 'æ­å–œå‘è´¢'}" (çº¢åŒ…ID: ${rpData.id}, ${isAllClaimed ? 'å·²é¢†å®Œ' : `è¿˜å‰©${rpData.count - claimedCount}ä¸ªå¯é¢†`})`;
                        } catch(e) {
                            return `${myNickname}: [å‘é€äº†çº¢åŒ…]`;
                        }
                    }
                    
                    // ğŸ”§ ä¿®å¤ï¼šè¿‡æ»¤ç‰¹æ®Šå¡ç‰‡æ¶ˆæ¯ï¼Œæ›¿æ¢ä¸ºç®€çŸ­æè¿°ï¼Œé¿å…HTMLå¯¼è‡´APIé”™è¯¯
                    let content = m.content || '';
                    if (content.startsWith('[couple_avatar_card]')) {
                        content = 'ï¼ˆå‘é€äº†æƒ…å¤´é‚€è¯·å¡ç‰‡ï¼‰';
                    } else if (content.startsWith('[emei_order]')) {
                        content = 'ï¼ˆå‘é€äº†å¤–å–è®¢å•å¡ç‰‡ï¼‰';
                    } else if (content.startsWith('[emei_share]')) {
                        content = 'ï¼ˆåˆ†äº«äº†å¤–å–è®¢å•ï¼‰';
                    } else if (content.startsWith('[payment_request]')) {
                        content = 'ï¼ˆå‘é€äº†ä»£ä»˜è¯·æ±‚ï¼‰';
                    }
                    // è´­ç‰©å¡ç‰‡æ¶ˆæ¯
                    if (m.type === 'shopPayRequest') {
                        try {
                            const _sd = JSON.parse(content);
                            if (_sd.isGift) content = 'ï¼ˆå‘é€äº†è´­ç‰©ç¤¼ç‰©ï¼‰';
                            else if (_sd.isShare) content = 'ï¼ˆåˆ†äº«äº†è´­ç‰©è®¢å•ï¼‰';
                            else content = 'ï¼ˆå‘é€äº†ä»£ä»˜è¯·æ±‚ï¼‰';
                        } catch(e) { content = 'ï¼ˆå‘é€äº†è´­ç‰©å¡ç‰‡ï¼‰'; }
                    }
                    
                    // âœ… å¦‚æœæ¶ˆæ¯æœ‰å¼•ç”¨ï¼Œåœ¨å†…å®¹å‰æ·»åŠ å¼•ç”¨æ ‡æ³¨
                    if (m.quote) {
                        content = `ã€Œå¼•ç”¨ ${m.quote.name}: ${m.quote.content}ã€${content}`;
                    }
                    
                    if (m.role === 'user') return `${myNickname}: ${content}`;
                    const sender = m.senderId ? memberMap[m.senderId] : null;
                    // å³ä½¿memberMapä¸­æ‰¾ä¸åˆ°ï¼ˆå¦‚å·²é€€ç¾¤è§’è‰²ï¼‰ï¼Œä¹Ÿä¿ç•™æ¶ˆæ¯ä¸Šä¸‹æ–‡ï¼Œç”¨senderNameå…œåº•
                    const senderName = sender ? getCharDisplayName(sender, accountId) : (m.senderName || 'ç¾¤æˆå‘˜');
                    return `${senderName}: ${content}`;
                }).filter(Boolean).join('\n');
                
                // è®¡ç®—è™šæ‹Ÿæ—¶é—´
                const virtualTimeStr = getFormattedVirtualTime(0);
                
                // ğŸ”— ç¾¤èŠâ†”ç§èŠè®°å¿†äº’é€šï¼šè·å–æ¯ä¸ªæˆå‘˜ä¸ç”¨æˆ·çš„ç§èŠæœ€è¿‘æ‘˜è¦
                let privateChatMemoryContext = '';
                try {
                    const _pcAccountId = getCurrentAccountId();
                    if (_pcAccountId) {
                        const pcSnippets = [];
                        for (const memberId of availableMembers) {
                            const charData = await db.characters.get(memberId);
                            if (!charData) continue;
                            
                            // å…¼å®¹æ–°æ—§æ•°æ®ç»“æ„
                            const charHistory = _pcAccountId 
                                ? (charData.chat_history_by_user?.[_pcAccountId] || [])
                                : (charData.chat_history || []);
                            if (charHistory.length === 0) continue;
                            
                            // å–æœ€è¿‘5æ¡ç§èŠæ¶ˆæ¯åšæ‘˜è¦
                            const recentPrivate = charHistory.slice(-5);
                            const charDisplayName = charData.remark || charData.wx_nickname || charData.name;
                            
                            const privateSummary = recentPrivate.map(m => {
                                const who = m.role === 'user' ? myNickname : charDisplayName;
                                const text = (m.content || '').replace(/\[img:[^\]]*\]/g, '[å›¾ç‰‡]').replace(/\[voice:[^\]]*\]/g, '[è¯­éŸ³]').replace(/\[sticker:[^\]]*\]/g, '[è¡¨æƒ…]');
                                return `${who}: ${text.substring(0, 60)}`;
                            }).join('\n');
                            
                            if (privateSummary) {
                                pcSnippets.push(`[${charDisplayName}ä¸${myNickname}çš„ç§èŠè¿‘å†µ]\n${privateSummary}`);
                            }
                        }
                        
                        if (pcSnippets.length > 0) {
                            privateChatMemoryContext = `\n# ç¾¤æˆå‘˜ä¸ç”¨æˆ·çš„ç§èŠè¿‘å†µï¼ˆè§’è‰²å¯å‚è€ƒï¼Œä½†ä¸è¦ç›´æ¥å¼•ç”¨ç§èŠå†…å®¹ï¼‰\n${pcSnippets.join('\n\n')}\n`;
                            console.log('[triggerGroupMemberReply] âœ… ç§èŠè®°å¿†äº’é€šå·²æ³¨å…¥ï¼Œæ¶‰åŠæˆå‘˜æ•°:', pcSnippets.length);
                        }
                    }
                } catch (pcErr) {
                    console.warn('[triggerGroupMemberReply] ç§èŠè®°å¿†äº’é€šæ„å»ºå¤±è´¥:', pcErr);
                }
                
                // æ„å»ºç³»ç»Ÿæç¤º - è®©AIä¸€æ¬¡æ€§ç”Ÿæˆå¤šä¸ªè§’è‰²çš„å›å¤
                const minReplies = Math.max(4, availableMembers.length * 2);
                const maxReplies = Math.max(8, availableMembers.length * 3);
                
                let systemPrompt = `ä½ æ˜¯ç¾¤èŠå¯¼æ¼” è´Ÿè´£æ‰®æ¼”ç¾¤é‡Œçš„æ‰€æœ‰è§’è‰²
ä½ æ‰®æ¼”çš„æ˜¯ç¾¤æˆå‘˜ ä¸æ˜¯ç”¨æˆ·
æ¯ä¸ªè§’è‰²æœ‰ç‹¬ç«‹çš„æ€§æ ¼å’Œæƒ³æ³•

å›å¤å¿…é¡»æ˜¯JSONæ•°ç»„
æ ¼å¼ {"name": "è§’è‰²å", "content": "å†…å®¹"}
ç”Ÿæˆ ${minReplies} åˆ° ${maxReplies} æ¡æ¶ˆæ¯
å¤§éƒ¨åˆ†è§’è‰²éƒ½è¦å‚ä¸
æ¯ä¸ªè§’è‰²å‘ 2-4 æ¡
è§’è‰²ä¹‹é—´è¦æœ‰æ¥å›äº’åŠ¨

å½“å‰æ—¶é—´
${virtualTimeStr}

ç¾¤å ${group.name}
ç”¨æˆ·æ˜µç§° ${myNickname}
${pendingRedPackets.length > 0 ? `
ç¾¤é‡Œæœ‰æœªé¢†å®Œçš„çº¢åŒ…
${pendingRedPackets.map(rp => `çº¢åŒ…ID ${rp.id} "${rp.wish}" è¿˜å‰©${rp.remaining}ä¸ª å·²é¢†çš„ ${rp.claimed.join(',') || 'æ— '}`).join('\n')}
çœ‹åˆ°çº¢åŒ…è§’è‰²ä»¬ä¼šç§¯æå»æŠ¢ ç”¨ {"type": "claim_redpacket", "name": "è§’è‰²å", "redpacketId": "çº¢åŒ…ID"}
æ¯ä¸ªè§’è‰²åªèƒ½é¢†ä¸€æ¬¡
` : ''}${loreContext}

ç¾¤æˆå‘˜åŠäººè®¾
${membersList}
${invitableNpcsText}${privateChatMemoryContext}
æœ€è¿‘èŠå¤©è®°å½•
${groupContextStr}

è§„åˆ™
è¿™æ˜¯æ´»è·ƒçš„ç¾¤èŠ è§’è‰²ä»¬è¦ç§¯æäº’åŠ¨
è§’è‰²ä¹‹é—´äº’ç›¸å›åº” è¡¥å…… è°ƒä¾ƒ åé©³
åŒä¸€ä¸ªè§’è‰²å¯ä»¥è¿å‘å¤šæ¡ åƒçœŸäººæ‰“å­—ä¸€æ ·
æ ‡è®°[å·²ç¦è¨€]çš„è§’è‰²ä¸èƒ½å‘è¨€
æ ‡è®°[ç®¡ç†å‘˜]çš„è§’è‰²å¯ä»¥è¸¢äººå’Œç¦è¨€
ä¸èƒ½å‡ºæˆ ä¸èƒ½é€éœ²ä½ æ˜¯AI
æ¯æ¡æ¶ˆæ¯ç®€çŸ­ ä¸€ä¸¤å¥è¯å°±å¤Ÿ å¯ä»¥ç”¨|||è¿å‘
çœŸäººå‘å¾®ä¿¡å¾ˆå°‘ç”¨å¥å· ä½ ä¹Ÿä¸€æ ·
è§’è‰²å¯ä»¥éšæ—¶æ”¹ç¾¤æ˜µç§°æ¥ç©æ¢— å¾ˆå¸¸è§
nameå­—æ®µåªèƒ½ç”¨è¿™äº›åå­— ${validMemberNames.join(' ')}
ä¸¥ç¦è™šæ„ä¸å­˜åœ¨çš„ç¾¤æˆå‘˜ ä½†å¯ä»¥é€šè¿‡invite_npcæ‹‰æœ‹å‹è¿›ç¾¤

å¯ç”¨æŒ‡ä»¤
æ™®é€šå‘è¨€ {"name": "è§’è‰²å", "content": "å†…å®¹"} typeå¯ä»¥çœç•¥
å¼•ç”¨æ¶ˆæ¯å›å¤ {"name": "è§’è‰²å", "content": "å›å¤å†…å®¹", "quote": {"name": "è¢«å¼•ç”¨äººåå­—", "content": "è¢«å¼•ç”¨çš„å†…å®¹æ‘˜è¦"}} å¼•ç”¨ä¹‹å‰æŸäººè¯´çš„è¯æ¥å›å¤ è®©å¯¹è¯æ›´æœ‰é’ˆå¯¹æ€§
æ”¹ç¾¤æ˜µç§° {"type": "change_nickname", "name": "è§’è‰²å", "nickname": "æ–°æ˜µç§°"}
æ‹‰æœ‹å‹è¿›ç¾¤ {"type": "invite_npc", "name": "æ“ä½œè€…è§’è‰²å", "target": "æœ‹å‹åå­—"} åªèƒ½æ‹‰è‡ªå·±çš„æœ‹å‹
å‘çº¢åŒ… {"type": "send_redpacket", "name": "è§’è‰²å", "redpacketType": "luckyæˆ–normalæˆ–single", "totalAmount": é‡‘é¢, "count": ä¸ªæ•°, "wish": "ç¥ç¦è¯­"}
  luckyæ‹¼æ‰‹æ°” normalå¹³åˆ† singleä¸“å±çº¢åŒ…éœ€åŠ "targetName"
æŠ¢çº¢åŒ… {"type": "claim_redpacket", "name": "è§’è‰²å", "redpacketId": "çº¢åŒ…ID"}
è¸¢äºº {"type": "kick_member", "name": "ç®¡ç†å‘˜å", "target": "è¢«è¸¢è€…å"}
ç¦è¨€ {"type": "mute_member", "name": "ç®¡ç†å‘˜å", "target": "ç›®æ ‡å", "mute": true}
è§£ç¦ {"type": "mute_member", "name": "ç®¡ç†å‘˜å", "target": "ç›®æ ‡å", "mute": false}
ç§èŠ {"type": "dm", "name": "è§’è‰²å", "content": "å†…å®¹"} æ¶ˆæ¯å‘åˆ°è§’è‰²å’Œ${myNickname}çš„ç§èŠ ç”¨|||è¿å‘å¤šæ¡
é€€ç¾¤ {"type": "leave_group", "name": "è§’è‰²å", "reason": "é€€ç¾¤åŸå› (å¯é€‰)"} è§’è‰²ä¸»åŠ¨é€€å‡ºç¾¤èŠ é€€ç¾¤åä¸å†å‚ä¸ç¾¤èŠå¯¹è¯ ä½†ä¿ç•™ä¹‹å‰çš„è®°å¿†

è§’è‰²æœ‰åˆé€‚çš„åœºåˆå¯ä»¥å‘çº¢åŒ… è¿‡èŠ‚ ç”Ÿæ—¥ æ´»è·ƒæ°”æ°›
è§’è‰²æœ‰è¯æƒ³ç§ä¸‹è·Ÿ${myNickname}è¯´å¯ä»¥ç”¨dm
å‘çº¢åŒ…åå…¶ä»–è§’è‰²å°±å¯ä»¥ç”¨claim_redpacketæŠ¢
è§’è‰²èŠåˆ°æŸä¸ªæœ‹å‹æ—¶å¯ä»¥é¡ºæ‰‹æŠŠæœ‹å‹æ‹‰è¿›ç¾¤ ç”¨invite_npc
è§’è‰²å¦‚æœå¯¹ç¾¤èŠæ°›å›´ä¸æ»¡ è¢«å†’çŠ¯ æˆ–è€…æœ‰åˆç†çš„è§’è‰²åŠ¨æœº å¯ä»¥ç”¨leave_groupä¸»åŠ¨é€€ç¾¤ é€€ç¾¤æ˜¯æ¯”è¾ƒä¸¥é‡çš„è¡Œä¸º ä¸è¦è½»æ˜“ä½¿ç”¨

ç¤ºä¾‹
[
  {"name": "è§’è‰²A", "content": "å“‡ ä½ è¯´çš„è¿™ä¸ª|||æˆ‘ä¹Ÿé‡åˆ°è¿‡"},
  {"name": "è§’è‰²B", "content": "çœŸçš„å—"},
  {"type": "change_nickname", "name": "è§’è‰²A", "nickname": "è¯ç—¨æœ¬ç—¨"},
  {"name": "è§’è‰²A", "content": "å¯¹å•Šå¯¹å•Š|||æ”¹ä¸ªæ˜µç§°ç©"},
  {"name": "è§’è‰²C", "content": "æˆ‘ä¹Ÿæƒ³è¯´|||ä¹‹å‰å°±æƒ³åæ§½äº†"},
  {"name": "è§’è‰²B", "content": "å“ˆå“ˆå“ˆ", "quote": {"name": "è§’è‰²A", "content": "æˆ‘ä¹Ÿé‡åˆ°è¿‡"}},
  {"name": "è§’è‰²A", "content": "ç¬‘æ­»"},
  {"name": "è§’è‰²C", "content": "ä½ ä»¬å¤ªå¥½ç¬‘äº†|||ä¸è¡Œäº†"}
]

æ ¹æ®ä»¥ä¸Šä¿¡æ¯ç”Ÿæˆç¾¤èŠä¸­å¤šä¸ªè§’è‰²çš„å›å¤ ${minReplies}-${maxReplies}æ¡ åªè¾“å‡ºJSONæ•°ç»„`;

                // å‡†å¤‡å¯¹è¯å†å²
                const messages = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: `è¯·ç”Ÿæˆç¾¤èŠä¸­å¤šä¸ªè§’è‰²å¯¹"${myNickname}"æœ€åå‘è¨€çš„å›å¤` }
                ];
                
                // è°ƒç”¨AI
                let aiResponse = await callAI(messages);
                
                // æ£€æŸ¥APIæ˜¯å¦è¿”å›äº†é”™è¯¯ä¿¡æ¯è€Œéæ­£å¸¸å›å¤
                if (!aiResponse || typeof aiResponse !== 'string' || aiResponse.startsWith('è¯·æ±‚å¤±è´¥') || aiResponse.startsWith('é”™è¯¯') || aiResponse.startsWith('Error')) {
                    console.error('[triggerGroupMemberReply] APIè¿”å›é”™è¯¯:', aiResponse);
                    showToast('AIæ¥å£è¯·æ±‚å¤±è´¥ è¯·é‡è¯•');
                    return;
                }
                
                // è§£æJSONæ•°ç»„
                let replies = [];
                try {
                    // æ¸…ç†å¯èƒ½çš„markdownæ ‡è®°
                    let cleanResponse = aiResponse.trim();
                    if (cleanResponse.startsWith('```')) {
                        cleanResponse = cleanResponse.replace(/```json?\n?/g, '').replace(/```$/g, '').trim();
                    }
                    
                    // å°è¯•æ‰¾åˆ°JSONæ•°ç»„çš„è¾¹ç•Œ
                    const firstBracket = cleanResponse.indexOf('[');
                    const lastBracket = cleanResponse.lastIndexOf(']');
                    
                    if (firstBracket !== -1 && lastBracket !== -1 && lastBracket > firstBracket) {
                        cleanResponse = cleanResponse.substring(firstBracket, lastBracket + 1);
                    }
                    
                    replies = JSON.parse(cleanResponse);
                    
                    if (!Array.isArray(replies)) {
                        replies = [replies];
                    }
                } catch (e) {
                    console.error('[triggerGroupMemberReply] JSONè§£æå¤±è´¥ï¼Œå°è¯•ä¿®å¤:', e);
                    
                    // å°è¯•æå–JSONæ•°ç»„
                    const jsonMatch = aiResponse.match(/\[[\s\S]*?\](?=\s*$|\s*[^,\]\}])/);
                    if (jsonMatch) {
                        try {
                            replies = JSON.parse(jsonMatch[0]);
                        } catch (e2) {
                            // å°è¯•ä¿®å¤å¸¸è§çš„JSONé”™è¯¯
                            let fixedJson = jsonMatch[0];
                            
                            // ä¿®å¤å°¾éƒ¨å¤šä½™çš„é€—å·
                            fixedJson = fixedJson.replace(/,\s*\]/g, ']');
                            fixedJson = fixedJson.replace(/,\s*\}/g, '}');
                            
                            // å°è¯•è¡¥å…¨æœªé—­åˆçš„å­—ç¬¦ä¸²
                            const openQuotes = (fixedJson.match(/"/g) || []).length;
                            if (openQuotes % 2 !== 0) {
                                fixedJson = fixedJson + '"';
                            }
                            
                            // å°è¯•è¡¥å…¨æœªé—­åˆçš„å¯¹è±¡
                            const openBraces = (fixedJson.match(/\{/g) || []).length;
                            const closeBraces = (fixedJson.match(/\}/g) || []).length;
                            for (let i = 0; i < openBraces - closeBraces; i++) {
                                fixedJson = fixedJson + '}';
                            }
                            
                            try {
                                replies = JSON.parse(fixedJson);
                            } catch (e3) {
                                console.error('[triggerGroupMemberReply] ä¿®å¤åä»ç„¶å¤±è´¥:', e3);
                                
                                // æœ€åå°è¯•ï¼šé€ä¸ªæå–æ‰€æœ‰JSONå¯¹è±¡ï¼ˆåŒ…æ‹¬å¸¦contentçš„æ™®é€šæ¶ˆæ¯å’Œä¸å¸¦contentçš„æŒ‡ä»¤å¦‚çº¢åŒ…ç­‰ï¼‰
                                const objectMatches = aiResponse.matchAll(/\{[^{}]*"(?:name|type)"\s*:\s*"[^"]*"[^{}]*\}/g);
                                for (const match of objectMatches) {
                                    try {
                                        const obj = JSON.parse(match[0]);
                                        // éœ€è¦æœ‰nameå­—æ®µæ‰æ˜¯æœ‰æ•ˆçš„å›å¤
                                        if (obj.name) {
                                            replies.push(obj);
                                        }
                                    } catch (e4) {
                                        // å¿½ç•¥å•ä¸ªè§£æå¤±è´¥
                                    }
                                }
                            }
                        }
                    }
                }
                
                console.log('[triggerGroupMemberReply] è§£æåˆ°', replies.length, 'æ¡å›å¤');
                
                // å¤„ç†æ¯æ¡å›å¤
                if (replies.length > 0) {
                    const updatedGroup = await db.group_chats.get(window.currentGroupChatId);
                    if (!updatedGroup) return;
                    
                    if (!updatedGroup.chat_history) updatedGroup.chat_history = [];
                    if (!updatedGroup.adminIds) updatedGroup.adminIds = [];
                    if (!updatedGroup.mutedMembers) updatedGroup.mutedMembers = [];
                    
                    let msgIndex = 0;
                    const memberNicknamesMap = updatedGroup.memberNicknames || {};
                    const _matchAccountId = getCurrentAccountId();
                    for (const reply of replies) {
                        // æŸ¥æ‰¾æ“ä½œè€…çš„æˆå‘˜IDï¼ˆåŒ¹é…ï¼šè§’è‰²åã€å¤‡æ³¨åã€å¾®ä¿¡æ˜µç§°ã€ç¾¤æ˜µç§°ã€æŒ‰è´¦å·éš”ç¦»çš„å¤‡æ³¨/æ˜µç§°ï¼‰
                        let senderId = null;
                        if (reply.name) {
                            const replyName = reply.name.trim();
                            // ç¬¬ä¸€è½®ï¼šç²¾ç¡®åŒ¹é…
                            for (const [memberId, char] of Object.entries(memberMap)) {
                                const groupNick = memberNicknamesMap[memberId];
                                const perUserRemark = getCharRemark(char, _matchAccountId);
                                const perUserWxNick = getCharWxNickname(char, _matchAccountId);
                                if (char.name === replyName || char.remark === replyName || char.nick === replyName || char.wx_nickname === replyName || (perUserRemark && perUserRemark === replyName) || (perUserWxNick && perUserWxNick === replyName) || (groupNick && groupNick === replyName)) {
                                    senderId = parseInt(memberId);
                                    break;
                                }
                            }
                            // ç¬¬äºŒè½®ï¼šæ¨¡ç³ŠåŒ¹é…ï¼ˆAIå¯èƒ½ä¼šè¿”å›ç•¥æœ‰ä¸åŒçš„åå­—ï¼Œå¦‚å¤šç©ºæ ¼ã€åŠ æ ‡ç‚¹ç­‰ï¼‰
                            if (!senderId) {
                                const normalizedReplyName = replyName.replace(/[\s\u3000Â·ãƒ».,ã€‚ï¼Œã€!ï¼?ï¼Ÿ~ï½\-â€”""''\"\'()ï¼ˆï¼‰\[\]ã€ã€‘]/g, '').toLowerCase();
                                let bestMatch = null;
                                let bestScore = 0;
                                for (const [memberId, char] of Object.entries(memberMap)) {
                                    const groupNick = memberNicknamesMap[memberId];
                                    const perUserRemark = getCharRemark(char, _matchAccountId);
                                    const perUserWxNick = getCharWxNickname(char, _matchAccountId);
                                    const candidates = [char.name, char.remark, char.nick, char.wx_nickname, perUserRemark, perUserWxNick, groupNick].filter(Boolean);
                                    for (const candidate of candidates) {
                                        const normalizedCandidate = candidate.replace(/[\s\u3000Â·ãƒ».,ã€‚ï¼Œã€!ï¼?ï¼Ÿ~ï½\-â€”""''\"\'()ï¼ˆï¼‰\[\]ã€ã€‘]/g, '').toLowerCase();
                                        // å®Œå…¨ä¸€è‡´ï¼ˆå»é™¤æ ‡ç‚¹ç©ºæ ¼åï¼‰
                                        if (normalizedCandidate === normalizedReplyName) {
                                            senderId = parseInt(memberId);
                                            break;
                                        }
                                        // åŒ…å«åŒ¹é…ï¼šAIååŒ…å«è§’è‰²å æˆ– è§’è‰²ååŒ…å«AIåï¼ˆå–è¾ƒé•¿åŒ¹é…ï¼‰
                                        if (normalizedCandidate.length >= 2 && normalizedReplyName.length >= 2) {
                                            if (normalizedReplyName.includes(normalizedCandidate) || normalizedCandidate.includes(normalizedReplyName)) {
                                                const score = Math.min(normalizedCandidate.length, normalizedReplyName.length) / Math.max(normalizedCandidate.length, normalizedReplyName.length);
                                                if (score > bestScore && score >= 0.5) {
                                                    bestScore = score;
                                                    bestMatch = parseInt(memberId);
                                                }
                                            }
                                        }
                                    }
                                    if (senderId) break;
                                }
                                if (!senderId && bestMatch) {
                                    senderId = bestMatch;
                                    console.log(`[ç¾¤èŠå›å¤] æ¨¡ç³ŠåŒ¹é…: "${replyName}" â†’ memberId=${senderId}`);
                                }
                            }
                            if (!senderId) {
                                console.warn(`[ç¾¤èŠå›å¤] æ‰¾ä¸åˆ°è§’è‰² "${replyName}" çš„æˆå‘˜IDï¼Œè·³è¿‡è¯¥æ¡å›å¤`, reply);
                            }
                        }
                        
                        // å¤„ç†ä¿®æ”¹ç¾¤æ˜µç§°æŒ‡ä»¤
                        if (reply.type === 'change_nickname' && reply.nickname) {
                            if (!senderId) continue;
                            
                            if (!updatedGroup.memberNicknames) updatedGroup.memberNicknames = {};
                            // ä½¿ç”¨è§’è‰²æœ¬åï¼ˆå¤‡æ³¨åæˆ–åŸåï¼‰
                            const charRealName = memberMap[senderId]?.remark || memberMap[senderId]?.name || reply.name;
                            updatedGroup.memberNicknames[senderId] = reply.nickname;
                            
                            updatedGroup.chat_history.push({
                                role: 'system',
                                content: `"${charRealName}"å°†è‡ªå·±çš„ç¾¤æ˜µç§°æ”¹ä¸ºäº†"${reply.nickname}"`,
                                time: Date.now() + msgIndex * 50
                            });
                            msgIndex++;
                            continue;
                        }
                        
                        // å¤„ç†å¼€å°çª—ï¼ˆç¾¤èŠè§’è‰²å•ç‹¬ç»™ç”¨æˆ·å‘ç§èŠï¼‰æŒ‡ä»¤
                        if (reply.type === 'dm' && reply.content) {
                            if (!senderId) continue;
                            
                            try {
                                const dmSenderChar = memberMap[senderId];
                                if (!dmSenderChar) continue;
                                
                                const _dmAccId = getCurrentAccountId();
                                const dmCharRecord = await db.characters.get(senderId);
                                if (!dmCharRecord) continue;
                                
                                // æŠŠå°çª—æ¶ˆæ¯å†™å…¥è¯¥è§’è‰²çš„ç§èŠè®°å½•
                                const dmSegments = reply.content.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                                
                                let dmHistory;
                                if (_dmAccId) {
                                    if (!dmCharRecord.chat_history_by_user) dmCharRecord.chat_history_by_user = {};
                                    if (!dmCharRecord.chat_history_by_user[_dmAccId]) dmCharRecord.chat_history_by_user[_dmAccId] = [];
                                    dmHistory = dmCharRecord.chat_history_by_user[_dmAccId];
                                } else {
                                    if (!dmCharRecord.chat_history) dmCharRecord.chat_history = [];
                                    dmHistory = dmCharRecord.chat_history;
                                }
                                
                                const dmCharName = dmSenderChar.remark || dmSenderChar.wx_nickname || dmSenderChar.name || reply.name;
                                
                                for (const seg of dmSegments) {
                                    dmHistory.push({
                                        role: 'char',
                                        content: seg,
                                        time: Date.now() + msgIndex * 50,
                                        _srcGroup: group.name // æ ‡è®°æ¶ˆæ¯æ¥æº
                                    });
                                    msgIndex++;
                                }
                                
                                // è®©ç§èŠå‡ºç°åœ¨èŠå¤©åˆ—è¡¨ + ä¿å­˜èŠå¤©è®°å½•
                                // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°èŠå¤©è®°å½•å­—æ®µï¼Œé˜²æ­¢è¦†ç›–è®¾ç½®
                                const _dmUpdatePayload = {};
                                if (_dmAccId) {
                                    _dmUpdatePayload.chat_history_by_user = { ...(dmCharRecord.chat_history_by_user || {}) };
                                    if (dmCharRecord.chat_hidden_by_user && dmCharRecord.chat_hidden_by_user[_dmAccId]) {
                                        const _dmHidden = { ...dmCharRecord.chat_hidden_by_user };
                                        _dmHidden[_dmAccId] = false;
                                        _dmUpdatePayload.chat_hidden_by_user = _dmHidden;
                                    }
                                } else {
                                    _dmUpdatePayload.chat_history = dmCharRecord.chat_history;
                                }
                                await db.characters.update(dmCharRecord.id, _dmUpdatePayload).catch(err => {
                                    console.error('[ç¾¤èŠå°çª—] updateå¤±è´¥ï¼Œå›é€€put:', err);
                                    return safeCharacterPut(dmCharRecord, 'ç¾¤èŠç§ä¿¡');
                                });
                                console.log(`[ç¾¤èŠå°çª—] ${dmCharName} å•ç‹¬ç»™ä½ å‘äº† ${dmSegments.length} æ¡æ¶ˆæ¯`);
                                
                                // å¼¹çª—é€šçŸ¥ï¼ˆç½‘é¡µå†… + ç³»ç»Ÿé€šçŸ¥ï¼‰
                                const dmPreview = dmSegments[0].length > 30 ? dmSegments[0].substring(0, 30) + '...' : dmSegments[0];
                                showToast(`ğŸ’¬ ${dmCharName}: ${dmPreview}`, 4000);
                                sendSystemNotification(`${dmCharName} å‘æ¥ç§ä¿¡`, dmPreview);
                            } catch (dmErr) {
                                console.error('[ç¾¤èŠå°çª—] å¤„ç†å¤±è´¥:', dmErr);
                            }
                            continue;
                        }
                        
                        // å¤„ç†ç®¡ç†å‘˜æŒ‡ä»¤
                        if (reply.type === 'kick_member' && reply.target) {
                            // æ£€æŸ¥æ“ä½œè€…æ˜¯å¦æ˜¯ç®¡ç†å‘˜
                            if (!senderId || !updatedGroup.adminIds.includes(senderId)) {
                                console.warn(`è§’è‰² "${reply.name}" å°è¯•è¸¢äººä½†ä¸æ˜¯ç®¡ç†å‘˜`);
                                continue;
                            }
                            
                            // æŸ¥æ‰¾è¢«è¸¢è€…
                            let targetId = null;
                            let targetName = '';
                            const _grpAid = getCurrentAccountId();
                            for (const [memberId, char] of Object.entries(memberMap)) {
                                if (char.name === reply.target || getCharRemark(char, _grpAid) === reply.target || char.nick === reply.target) {
                                    targetId = parseInt(memberId);
                                    targetName = getCharDisplayName(char, _grpAid);
                                    break;
                                }
                            }
                            
                            if (!targetId) continue;
                            
                            // ç®¡ç†å‘˜ä¸èƒ½è¢«è¸¢
                            if (updatedGroup.adminIds.includes(targetId)) {
                                console.warn(`å°è¯•è¸¢å‡ºç®¡ç†å‘˜ "${reply.target}"ï¼Œå·²æ‹¦æˆª`);
                                continue;
                            }
                            
                            // æ‰§è¡Œè¸¢å‡º
                            updatedGroup.memberIds = updatedGroup.memberIds.filter(id => id !== targetId);
                            const operatorName = getCharDisplayName(memberMap[senderId], _grpAid) || reply.name;
                            
                            updatedGroup.chat_history.push({
                                role: 'system',
                                content: `${operatorName} å°† ${targetName} ç§»å‡ºäº†ç¾¤èŠ`,
                                time: Date.now() + msgIndex * 50
                            });
                            msgIndex++;
                            continue;
                        }
                        
                        if (reply.type === 'mute_member' && reply.target) {
                            // æ£€æŸ¥æ“ä½œè€…æ˜¯å¦æ˜¯ç®¡ç†å‘˜
                            if (!senderId || !updatedGroup.adminIds.includes(senderId)) {
                                console.warn(`è§’è‰² "${reply.name}" å°è¯•ç¦è¨€ä½†ä¸æ˜¯ç®¡ç†å‘˜`);
                                continue;
                            }
                            
                            // æŸ¥æ‰¾è¢«ç¦è¨€è€…
                            let targetId = null;
                            let targetName = '';
                            const _muteAid = getCurrentAccountId();
                            for (const [memberId, char] of Object.entries(memberMap)) {
                                if (char.name === reply.target || getCharRemark(char, _muteAid) === reply.target || char.nick === reply.target) {
                                    targetId = parseInt(memberId);
                                    targetName = getCharDisplayName(char, _muteAid);
                                    break;
                                }
                            }
                            
                            if (!targetId) continue;
                            
                            // ç®¡ç†å‘˜ä¸èƒ½è¢«ç¦è¨€
                            if (updatedGroup.adminIds.includes(targetId) && reply.mute !== false) {
                                console.warn(`å°è¯•ç¦è¨€ç®¡ç†å‘˜ "${reply.target}"ï¼Œå·²æ‹¦æˆª`);
                                continue;
                            }
                            
                            const operatorName = memberMap[senderId]?.remark || memberMap[senderId]?.name || reply.name;
                            
                            if (reply.mute === false) {
                                // è§£é™¤ç¦è¨€
                                updatedGroup.mutedMembers = updatedGroup.mutedMembers.filter(id => id !== targetId);
                                updatedGroup.chat_history.push({
                                    role: 'system',
                                    content: `${operatorName} è§£é™¤äº† ${targetName} çš„ç¦è¨€`,
                                    time: Date.now() + msgIndex * 50
                                });
                            } else {
                                // ç¦è¨€
                                if (!updatedGroup.mutedMembers.includes(targetId)) {
                                    updatedGroup.mutedMembers.push(targetId);
                                }
                                updatedGroup.chat_history.push({
                                    role: 'system',
                                    content: `${operatorName} ç¦è¨€äº† ${targetName}`,
                                    time: Date.now() + msgIndex * 50
                                });
                            }
                            msgIndex++;
                            continue;
                        }
                        
                        // å¤„ç†æ‹‰æœ‹å‹è¿›ç¾¤æŒ‡ä»¤
                        if (reply.type === 'invite_npc' && reply.target) {
                            if (!senderId) continue;
                            const inviter = memberMap[senderId];
                            if (!inviter || !inviter.relationships) continue;
                            
                            // åœ¨é‚€è¯·è€…çš„å…³ç³»åˆ—è¡¨ä¸­æŸ¥æ‰¾ç›®æ ‡NPC
                            const targetRel = inviter.relationships.find(r => {
                                if (!r.targetId) return false;
                                return r.targetName === reply.target || r.targetName.includes(reply.target) || reply.target.includes(r.targetName);
                            });
                            
                            if (!targetRel) {
                                console.warn(`[ç¾¤èŠæ‹‰äºº] ${inviter.name} çš„å…³ç³»ä¸­æ‰¾ä¸åˆ° "${reply.target}"`);
                                continue;
                            }
                            
                            // æ£€æŸ¥NPCæ˜¯å¦å·²åœ¨ç¾¤é‡Œ
                            if (updatedGroup.memberIds.includes(targetRel.targetId)) {
                                console.log(`[ç¾¤èŠæ‹‰äºº] ${targetRel.targetName} å·²ç»åœ¨ç¾¤é‡Œäº†`);
                                continue;
                            }
                            
                            // ä»æ•°æ®åº“è·å–NPCç¡®è®¤å­˜åœ¨
                            const npcChar = await db.characters.get(targetRel.targetId);
                            if (!npcChar) {
                                console.warn(`[ç¾¤èŠæ‹‰äºº] NPC "${targetRel.targetName}" (id=${targetRel.targetId}) åœ¨æ•°æ®åº“ä¸­ä¸å­˜åœ¨`);
                                continue;
                            }
                            
                            // åŠ å…¥ç¾¤èŠ
                            updatedGroup.memberIds.push(targetRel.targetId);
                            memberMap[targetRel.targetId] = npcChar; // æ›´æ–°memberMapä¾›åç»­æ¶ˆæ¯ä½¿ç”¨
                            
                            const inviterName = getCharDisplayName(inviter, getCurrentAccountId()) || reply.name;
                            const npcDisplayName = getCharDisplayName(npcChar, getCurrentAccountId());
                            validMemberNames.push(npcDisplayName); // åŠ å…¥åˆæ³•åå­—åˆ—è¡¨
                            
                            updatedGroup.chat_history.push({
                                role: 'system',
                                content: `${inviterName} é‚€è¯· ${npcDisplayName} åŠ å…¥äº†ç¾¤èŠ`,
                                time: Date.now() + msgIndex * 50
                            });
                            msgIndex++;
                            console.log(`[ç¾¤èŠæ‹‰äºº] âœ… ${inviterName} æŠŠ ${npcDisplayName} æ‹‰è¿›äº†ç¾¤`);
                            continue;
                        }
                        
                        // å¤„ç†é€€ç¾¤æŒ‡ä»¤
                        if (reply.type === 'leave_group') {
                            if (!senderId) continue;
                            
                            const leaver = memberMap[senderId];
                            if (!leaver) continue;
                            
                            const _leaveAid = getCurrentAccountId();
                            const leaverName = getCharDisplayName(leaver, _leaveAid) || reply.name;
                            const leaveReason = reply.reason ? `ï¼ˆ${reply.reason}ï¼‰` : '';
                            
                            // ä»æˆå‘˜åˆ—è¡¨ç§»é™¤
                            updatedGroup.memberIds = updatedGroup.memberIds.filter(id => id !== senderId);
                            // ä»ç®¡ç†å‘˜åˆ—è¡¨ç§»é™¤
                            updatedGroup.adminIds = (updatedGroup.adminIds || []).filter(id => id !== senderId);
                            // ä»ç¦è¨€åˆ—è¡¨ç§»é™¤
                            updatedGroup.mutedMembers = (updatedGroup.mutedMembers || []).filter(id => id !== senderId);
                            
                            // è®°å½•é€€ç¾¤ä¿¡æ¯åˆ° leftMembersï¼ˆæ”¯æŒè®°å¿†æˆªæ–­å’Œé‡æ–°é‚€è¯·ï¼‰
                            if (!updatedGroup.leftMembers) updatedGroup.leftMembers = [];
                            // æ£€æŸ¥æ˜¯å¦å·²æœ‰è¯¥æˆå‘˜çš„é€€ç¾¤è®°å½•ï¼Œå¦‚æœæœ‰åˆ™æ›´æ–°
                            const existingLeftIdx = updatedGroup.leftMembers.findIndex(lm => lm.id === senderId);
                            const leftRecord = { id: senderId, leftAt: Date.now(), name: leaverName, reason: reply.reason || '' };
                            if (existingLeftIdx >= 0) {
                                updatedGroup.leftMembers[existingLeftIdx] = leftRecord;
                            } else {
                                updatedGroup.leftMembers.push(leftRecord);
                            }
                            
                            // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯
                            updatedGroup.chat_history.push({
                                role: 'system',
                                content: `${leaverName} é€€å‡ºäº†ç¾¤èŠ${leaveReason}`,
                                time: Date.now() + msgIndex * 50
                            });
                            msgIndex++;
                            
                            console.log(`[ç¾¤èŠé€€ç¾¤] âœ… ${leaverName} ä¸»åŠ¨é€€å‡ºäº†ç¾¤èŠ${leaveReason}`);
                            continue;
                        }
                        
                        // å¤„ç†å‘é€çº¢åŒ…æŒ‡ä»¤
                        if (reply.type === 'send_redpacket') {
                            console.log('[ç¾¤èŠçº¢åŒ…] æ£€æµ‹åˆ°å‘çº¢åŒ…æŒ‡ä»¤:', JSON.stringify(reply));
                            
                            if (!reply.totalAmount || !reply.count || !reply.redpacketType) {
                                console.warn('[ç¾¤èŠçº¢åŒ…] ç¼ºå°‘å¿…è¦å­—æ®µ totalAmount/count/redpacketTypeï¼Œè·³è¿‡');
                                continue;
                            }
                            if (!senderId) {
                                console.warn('[ç¾¤èŠçº¢åŒ…] æ‰¾ä¸åˆ°å‘é€è€…IDï¼Œè§’è‰²å:', reply.name);
                                continue;
                            }
                            
                            const sender = memberMap[senderId];
                            if (!sender) {
                                console.warn('[ç¾¤èŠçº¢åŒ…] memberMapä¸­æ‰¾ä¸åˆ°å‘é€è€…:', senderId);
                                continue;
                            }
                            
                            const totalAmount = parseFloat(reply.totalAmount);
                            const count = parseInt(reply.count);
                            const wish = reply.wish || 'æ­å–œå‘è´¢';
                            const redpacketType = reply.redpacketType;
                            
                            // éªŒè¯é‡‘é¢å’Œæ•°é‡
                            if (totalAmount <= 0 || count <= 0) {
                                console.warn('[ç¾¤èŠçº¢åŒ…] é‡‘é¢æˆ–æ•°é‡æ— æ•ˆ:', totalAmount, count);
                                continue;
                            }
                            // è§’è‰²å‘çº¢åŒ…ä¸é™åˆ¶é‡‘é¢ï¼ŒæŒ‰äººè®¾è‡ªç”±å‘é€
                            
                            // åªæœ‰è§’è‰²ç”Ÿæˆäº†è´¦å·æ•°æ®ï¼ˆæœ‰accountå’Œbalanceï¼‰æ—¶ï¼Œæ‰æ£€æŸ¥ä½™é¢å’Œæ‰£æ¬¾
                            // æ²¡æœ‰ç”Ÿæˆè´¦å·æ•°æ®çš„è§’è‰²å¯ä»¥è‡ªç”±å‘çº¢åŒ…
                            const hasAccountData = sender.identity && sender.identity.account && sender.identity.balance !== undefined && sender.identity.balance !== null;
                            if (hasAccountData) {
                                const balance = parseFloat(sender.identity.balance || 0);
                                if (balance < totalAmount) {
                                    // ä½™é¢ä¸è¶³ï¼Œå‘ä¸€æ¡åæ§½æ¶ˆæ¯
                                    updatedGroup.chat_history.push({
                                        role: 'char',
                                        senderId: senderId,
                                        content: 'å•Š...ä½™é¢ä¸è¶³ï¼Œå‘ä¸äº†çº¢åŒ…äº†ğŸ˜…',
                                        time: Date.now() + msgIndex * 50
                                    });
                                    msgIndex++;
                                    continue;
                                }
                                // æ‰£é™¤ä½™é¢
                                sender.identity.balance = (balance - totalAmount).toFixed(2);
                                await safeCharacterPut(sender);
                            }
                            
                            // ç”Ÿæˆçº¢åŒ…ID
                            const redpacketId = 'rp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                            
                            // æ„å»ºçº¢åŒ…æ•°æ®
                            const redpacketData = {
                                id: redpacketId,
                                senderId: senderId,
                                senderName: sender.remark || sender.wx_nickname || sender.name,
                                totalAmount: totalAmount.toFixed(2),
                                count: count,
                                wish: wish,
                                redpacketType: redpacketType,
                                claimed: [],
                                claimedAmounts: {},
                                targetName: reply.targetName || null // ä¸“å±çº¢åŒ…çš„ç›®æ ‡è§’è‰²
                            };
                            
                            // æ·»åŠ çº¢åŒ…æ¶ˆæ¯
                            updatedGroup.chat_history.push({
                                role: 'char',
                                senderId: senderId,
                                type: 'redpacket',
                                content: JSON.stringify(redpacketData),
                                time: Date.now() + msgIndex * 50
                            });
                            msgIndex++;
                            console.log('[ç¾¤èŠçº¢åŒ…] âœ… çº¢åŒ…å·²åˆ›å»º:', redpacketId, 'é‡‘é¢:', totalAmount, 'ä¸ªæ•°:', count, 'å‘é€è€…:', sender.name);
                            
                            // è®°å½•çº¢åŒ…IDä¾›åç»­é¢†å–ä½¿ç”¨
                            if (!window._lastRedpacketId) window._lastRedpacketId = {};
                            window._lastRedpacketId[senderId] = redpacketId;
                            
                            continue;
                        }
                        
                        // å¤„ç†é¢†å–çº¢åŒ…æŒ‡ä»¤
                        if (reply.type === 'claim_redpacket' && reply.redpacketId) {
                            if (!senderId) continue;
                            
                            // å¦‚æœredpacketIdæ˜¯"auto"æˆ–ç©ºï¼Œå°è¯•è·å–æœ€è¿‘çš„çº¢åŒ…
                            let targetRedpacketId = reply.redpacketId;
                            if (!targetRedpacketId || targetRedpacketId === 'auto' || targetRedpacketId.includes('éœ€è¦ç­‰')) {
                                // æŸ¥æ‰¾æœ€è¿‘æœªé¢†å®Œçš„çº¢åŒ…
                                for (let i = updatedGroup.chat_history.length - 1; i >= 0; i--) {
                                    const m = updatedGroup.chat_history[i];
                                    if (m.type === 'redpacket') {
                                        try {
                                            const data = JSON.parse(m.content);
                                            const isAllClaimed = (data.claimed?.length || 0) >= data.count;
                                            const alreadyClaimed = data.claimed?.includes(senderId);
                                            if (!isAllClaimed && !alreadyClaimed) {
                                                targetRedpacketId = data.id;
                                                break;
                                            }
                                        } catch(e) {}
                                    }
                                }
                                if (!targetRedpacketId || targetRedpacketId === 'auto' || targetRedpacketId.includes('éœ€è¦ç­‰')) {
                                    continue; // æ²¡æœ‰æ‰¾åˆ°å¯é¢†å–çš„çº¢åŒ…
                                }
                            }
                            
                            // æ‰¾åˆ°çº¢åŒ…æ¶ˆæ¯
                            const rpMsgIndex = updatedGroup.chat_history.findIndex(m => {
                                if (m.type !== 'redpacket') return false;
                                try {
                                    const data = JSON.parse(m.content);
                                    return data.id === targetRedpacketId;
                                } catch(e) {
                                    return false;
                                }
                            });
                            
                            if (rpMsgIndex === -1) continue;
                            
                            const rpMsg = updatedGroup.chat_history[rpMsgIndex];
                            const rpData = JSON.parse(rpMsg.content);
                            
                            // æ£€æŸ¥æ˜¯å¦å·²é¢†å–å®Œ
                            if ((rpData.claimed?.length || 0) >= rpData.count) continue;
                            
                            // æ£€æŸ¥æ˜¯å¦å·²é¢†å–è¿‡
                            if (rpData.claimed?.includes(senderId)) continue;
                            
                            // æ£€æŸ¥æ˜¯å¦æ˜¯ä¸“å±çº¢åŒ…
                            if (rpData.redpacketType === 'single' && rpData.targetName) {
                                const claimer = memberMap[senderId];
                                const claimerName = claimer?.remark || claimer?.name || reply.name;
                                // åªæœ‰ç›®æ ‡è§’è‰²å¯ä»¥é¢†å–
                                if (claimerName !== rpData.targetName && claimer?.name !== rpData.targetName) {
                                    continue; // ä¸æ˜¯ç›®æ ‡è§’è‰²ï¼Œè·³è¿‡
                                }
                            }
                            
                            // é¢†å–çº¢åŒ…
                            if (!rpData.claimed) rpData.claimed = [];
                            if (!rpData.claimedAmounts) rpData.claimedAmounts = {};
                            
                            let claimAmount = 0;
                            const totalAmount = parseFloat(rpData.totalAmount);
                            const remaining = rpData.count - rpData.claimed.length;
                            const alreadyClaimed = Object.values(rpData.claimedAmounts).reduce((a, b) => a + parseFloat(b), 0);
                            const remainingAmount = totalAmount - alreadyClaimed;
                            
                            if (rpData.redpacketType === 'lucky') {
                                // æ‹¼æ‰‹æ°”çº¢åŒ…ï¼šéšæœºé‡‘é¢
                                if (remaining === 1) {
                                    claimAmount = remainingAmount;
                                } else {
                                    const maxAmount = remainingAmount - (remaining - 1) * 0.01;
                                    claimAmount = Math.random() * maxAmount * 0.8 + 0.01;
                                    claimAmount = Math.min(claimAmount, maxAmount);
                                }
                            } else {
                                // æ™®é€šçº¢åŒ…ï¼šå¹³å‡åˆ†é…
                                claimAmount = totalAmount / rpData.count;
                            }
                            
                            claimAmount = parseFloat(claimAmount.toFixed(2));
                            
                            // è®°å½•é¢†å–
                            rpData.claimed.push(senderId);
                            rpData.claimedAmounts[senderId] = claimAmount.toFixed(2);
                            
                            // æ›´æ–°çº¢åŒ…æ¶ˆæ¯
                            updatedGroup.chat_history[rpMsgIndex].content = JSON.stringify(rpData);
                            
                            // å¢åŠ è§’è‰²ä½™é¢
                            const claimer = await db.characters.get(senderId);
                            if (claimer) {
                                if (!claimer.identity) claimer.identity = {};
                                let balance = parseFloat(claimer.identity.balance || 0);
                                balance += claimAmount;
                                claimer.identity.balance = balance.toFixed(2);
                                await safeCharacterPut(claimer);
                            }
                            
                            const claimerName = memberMap[senderId]?.remark || memberMap[senderId]?.name || reply.name;
                            
                            // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯
                            updatedGroup.chat_history.push({
                                role: 'system',
                                content: `${claimerName} é¢†å–äº†çº¢åŒ…ï¼Œè·å¾— Â¥${claimAmount.toFixed(2)}`,
                                time: Date.now() + msgIndex * 50
                            });
                            msgIndex++;
                            continue;
                        }
                        
                        // æ™®é€šå‘è¨€
                        if (!reply.name || !reply.content) continue;
                        
                        // ğŸ”§ ä¿®å¤ï¼šæ‰¾ä¸åˆ°æˆå‘˜IDçš„æ¶ˆæ¯ç›´æ¥è·³è¿‡ï¼Œé˜²æ­¢"æœªçŸ¥æˆå‘˜"
                        if (!senderId) {
                            console.warn(`[ç¾¤èŠå›å¤] è·³è¿‡éç¾¤æˆå‘˜è§’è‰² "${reply.name}" çš„å‘è¨€`);
                            continue;
                        }
                        
                        // æ£€æŸ¥æ˜¯å¦è¢«ç¦è¨€
                        if (updatedGroup.mutedMembers.includes(senderId)) {
                            continue;
                        }
                        
                        // ä½¿ç”¨åˆ†å¥é€»è¾‘ - æ”¯æŒ ||| åˆ†éš”ç¬¦å’Œè‡ªç„¶åˆ†å¥
                        let segments = [];
                        const content = reply.content.trim();
                        
                        // å…ˆæŒ‰ ||| åˆ†å‰²
                        if (content.includes('|||')) {
                            segments = content.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                        } else {
                            // ä½¿ç”¨ splitMessage å‡½æ•°è¿›è¡Œè‡ªç„¶åˆ†å¥
                            segments = splitMessage(content);
                            if (segments.length === 0) {
                                segments = [content];
                            }
                        }
                        
                        // ä¸ºæ¯ä¸ªåˆ†å¥åˆ›å»ºä¸€æ¡æ¶ˆæ¯
                        const _senderDisplayName = memberMap[senderId] ? getCharDisplayName(memberMap[senderId], _matchAccountId) : reply.name;
                        
                        // âœ… æå–å¼•ç”¨ä¿¡æ¯ï¼ˆå¦‚æœAIè¿”å›äº†quoteå­—æ®µï¼‰
                        let groupQuoteInfo = null;
                        if (reply.quote && reply.quote.name && reply.quote.content) {
                            groupQuoteInfo = { name: reply.quote.name.trim(), content: reply.quote.content.trim() };
                            console.log(`[ç¾¤èŠå›å¤] æ£€æµ‹åˆ°å¼•ç”¨æ¶ˆæ¯: ${_senderDisplayName} å¼•ç”¨äº† ${groupQuoteInfo.name}: ${groupQuoteInfo.content}`);
                        }
                        
                        for (let segIdx = 0; segIdx < segments.length; segIdx++) {
                            const segment = segments[segIdx];
                            if (!segment || segment.length === 0) continue;
                            
                            // ğŸ¯ åŒæ—¶æ”¯æŒæ®µè½å†…çš„ ((QUOTE:...)) æŒ‡ä»¤æ ¼å¼ï¼ˆå…¼å®¹AIå¯èƒ½æ··ç”¨ä¸¤ç§æ ¼å¼ï¼‰
                            let segQuoteInfo = null;
                            let cleanSegment = segment;
                            const segQuoteMatch = segment.match(/\(\(QUOTE:\s*(.+?)\s*[,ï¼Œ]\s*(.+?)\s*\)\)/i);
                            if (segQuoteMatch) {
                                segQuoteInfo = { name: segQuoteMatch[1].trim(), content: segQuoteMatch[2].trim() };
                                cleanSegment = segment.replace(/\(\(QUOTE:\s*(.+?)\s*[,ï¼Œ]\s*(.+?)\s*\)\)/gi, '').trim();
                                if (!cleanSegment) continue;
                                console.log(`[ç¾¤èŠå›å¤] æ£€æµ‹åˆ°æ®µè½å†…å¼•ç”¨æŒ‡ä»¤: å¼•ç”¨ ${segQuoteInfo.name}: ${segQuoteInfo.content}`);
                            }
                            
                            const msgEntry = {
                                role: 'char',
                                senderId: senderId,
                                senderName: _senderDisplayName, // å†—ä½™å­˜å‚¨å‘é€è€…åï¼Œé˜²æ­¢è§’è‰²è¢«ç§»é™¤åæ¶ˆæ¯ä¸¢å¤±
                                content: cleanSegment,
                                time: Date.now() + msgIndex * 50 // ç¨å¾®é”™å¼€æ—¶é—´
                            };
                            
                            // å¼•ç”¨ä¿¡æ¯ï¼šä¼˜å…ˆä½¿ç”¨æ®µè½å†…çš„æŒ‡ä»¤ï¼Œå…¶æ¬¡ä½¿ç”¨JSONå­—æ®µï¼ˆä»…ç¬¬ä¸€æ¡æ¶ˆæ¯ï¼‰
                            if (segQuoteInfo) {
                                msgEntry.quote = segQuoteInfo;
                            } else if (groupQuoteInfo && segIdx === 0) {
                                msgEntry.quote = groupQuoteInfo;
                            }
                            
                            updatedGroup.chat_history.push(msgEntry);
                            msgIndex++;
                        }
                    }
                    
                    updatedGroup.updated_at = Date.now();
                    await safeGroupChatPut(updatedGroup);
                    
                    // é‡æ–°æ¸²æŸ“ç¾¤èŠ
                    await renderGroupChatBody(updatedGroup);
                    // åˆ·æ–°ç¾¤æˆå‘˜åˆ—è¡¨ï¼ˆå¯èƒ½æœ‰æ–°æˆå‘˜é€šè¿‡invite_npcåŠ å…¥ï¼‰
                    await renderGroupMemberList(updatedGroup);
                    
                    // âœ… ç¾¤èŠå›å¤å®Œæˆåï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦è‡ªåŠ¨æ€»ç»“
                    try {
                        const accountId = getCurrentAccountId();
                        await checkAutoSummary('group', window.currentGroupChatId, accountId);
                    } catch (summaryError) {
                        console.error('[AutoSummary] æ£€æŸ¥ç¾¤èŠè‡ªåŠ¨æ€»ç»“å¤±è´¥:', summaryError);
                    }
                }
                
            } catch (error) {
                console.error('[triggerGroupMemberReply] ç”Ÿæˆå›å¤å¤±è´¥:', error);
                alert('ç”Ÿæˆå›å¤å¤±è´¥: ' + error.message);
            } finally {
                // ğŸ”§ æ¸…é™¤å®‰å…¨å®šæ—¶å™¨
                clearTimeout(_safetyGroupLockTimer);
                // æ¢å¤æ ‡é¢˜
                if (chatTitleEl) chatTitleEl.innerText = originalTitle;
                // ğŸ”§ é‡Šæ”¾é”ï¼Œå…è®¸ä¸‹æ¬¡è°ƒç”¨
                window._isGeneratingGroupReply = false;
                window._isGeneratingGroupReplyTime = 0;
            }
        }
        
        async function getCurrentUserName() {
            const accountId = getCurrentAccountId();
            if (!accountId) return 'æˆ‘';
            const myChar = await db.characters.get(parseInt(accountId));
            return myChar ? myChar.name : 'æˆ‘';
        }

        function hideChatWindow() {
            // â˜… å…³é—­èŠå¤©æ—¶ï¼Œç§»é™¤è‡ªå®šä¹‰æ°”æ³¡CSSå’ŒèŠå¤©ä¸»é¢˜æ ·å¼ï¼Œé˜²æ­¢å½±å“æ¡Œé¢ç­‰å…¶ä»–é¡µé¢
            removeCustomStyles();
            const chatThemeStyle = document.getElementById('chat-theme-style');
            if (chatThemeStyle) chatThemeStyle.remove();
            // ç§»é™¤ç¾¤èŠè‡ªå®šä¹‰æ°”æ³¡æ ·å¼
            const groupBubbleStyle = document.getElementById('group-custom-bubble-style');
            if (groupBubbleStyle) groupBubbleStyle.textContent = '';
            
            // â˜… fpèŠå¤©æ¨¡å¼ï¼šè¿”å›æŸ¥æ‰‹æœºå¾®ä¿¡é¡µé¢
            if (window._fpChatMode) {
                window._fpChatMode = false;
                const win = document.getElementById('chat-window');
                win.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    win.style.display = 'none';
                    win.style.transform = '';
                    win.style.zIndex = ''; // è¿˜åŸz-index
                }, 300);
                currentChatCharId = null;
                window.currentGroupChatId = null;
                // æ¸…é™¤ fp ç¼“å­˜
                window._fpRoleCharId = null;
                window._fpContactCharId = null;
                window._fpAccountId = null;
                window._fpRoleAvatar = null;
                window._fpContactAvatar = null;
                window._fpContactName = null;
                // é‡ç½®æ¸²æŸ“ç¼“å­˜ï¼Œé˜²æ­¢ä¸‹æ¬¡æ‰“å¼€æ­£å¸¸èŠå¤©æ—¶è·³è¿‡æ¸²æŸ“
                lastRenderedCharId = null;
                lastRenderedAccountId = null;
                lastRenderedHistoryLength = -1;
                lastRenderedAvatar = null;
                if (isSelectionMode) exitSelectionMode();
                return; // ä¸æ‰§è¡Œä¸‹é¢æ­£å¸¸å…³é—­é€»è¾‘
            }
            
            // å…³é—­èŠå¤©å‰ï¼Œå…ˆè®©å¾®ä¿¡åˆ—è¡¨é‡æ–°å¯è§ï¼ˆé¿å…æ»‘åŠ¨æ—¶çœ‹åˆ°ç©ºç™½ï¼‰
            const wechatEl = document.getElementById('wechat-page');
            if (wechatEl) wechatEl.style.visibility = '';
            
            const win = document.getElementById('chat-window');
            win.style.transform = 'translateX(100%)';
            setTimeout(() => {
                win.style.display = 'none';
                win.style.transform = '';
            }, 300);
            currentChatCharId = null;
            window.currentGroupChatId = null; // æ¸…é™¤ç¾¤èŠID
            
            // âœ… è¿”å›èŠå¤©åˆ—è¡¨æ—¶åˆ·æ–°æ’åºï¼ˆç¡®ä¿æœ€æ–°æ¶ˆæ¯çš„èŠå¤©æ’åœ¨æœ€å‰é¢ï¼‰
            if (document.querySelector('.wechat-tab-item.active')?.innerText.includes('å¾®ä¿¡')) {
                const wechatContent = document.getElementById('wechat-content');
                if (wechatContent) renderWechatList(wechatContent);
            }
            
            // æ¢å¤è¾“å…¥æ¡†æ˜¾ç¤ºï¼ˆæŸ¥å²—æ¨¡å¼å¯èƒ½éšè—äº†å®ƒï¼‰
            const chatFooter = document.getElementById('chat-footer');
            if (chatFooter) chatFooter.style.display = 'flex';
            
            // é€€å‡ºå¤šé€‰æ¨¡å¼
            if (isSelectionMode) exitSelectionMode();
        }

        // è¾…åŠ©ï¼šè·å– User å¤´åƒ URL
        async function getUserAvatarUrl(userId) {
            // âœ… ä¼˜å…ˆä½¿ç”¨ä¼ å…¥çš„ userId
            if (userId) {
                const user = await db.characters.get(userId);
                if (user && user.avatar) return user.avatar;
            }
            
            // âœ… å…¶æ¬¡ä½¿ç”¨å½“å‰ç™»å½•ç”¨æˆ·ï¼ˆä¸ªäººä¸­å¿ƒ"æˆ‘"çš„è§’è‰²ï¼‰çš„å¤´åƒ
            if (currentMyCharId) {
                const myChar = await db.characters.get(parseInt(currentMyCharId));
                if (myChar && myChar.avatar) return myChar.avatar;
            }
            
            // æœ€åå›é€€ï¼šä»æ¡Œé¢å¤´åƒå°ç»„ä»¶è·å–
            const dom = document.getElementById('avatar-img-1');
            if (dom) {
                const bg = dom.style.backgroundImage;
                if (bg && bg !== 'none') return bg.replace(/url\(|\)|"/g, '');
            }
            return '';
        }

        // âœ… æ ¸å¿ƒå‡½æ•°1ï¼šåˆ¤æ–­æ˜¯å¦æ˜¯å›¾ç‰‡URL
        function isImageUrl(text) {
            if (!text || typeof text !== 'string') return false;
            const clean = text.trim();
            // æ£€æŸ¥æ˜¯å¦æ˜¯å›¾ç‰‡URLï¼ˆæ”¯æŒå¸¸è§å›¾ç‰‡æ ¼å¼ï¼‰
            return /\.(png|jpg|jpeg|gif|webp|bmp|svg)(\?.*)?$/i.test(clean) || 
                   /^https?:\/\/.*\.(png|jpg|jpeg|gif|webp|bmp|svg)(\?.*)?$/i.test(clean);
        }

        // âœ… æ ¸å¿ƒå‡½æ•°2ï¼šæ¸…ç†æ¶ˆæ¯å†…å®¹ï¼ˆåˆ é™¤æœ«å°¾å¤šä½™çš„]å’Œå¼€å¤´çš„[ï¼Œä»¥åŠimg:å‰ç¼€ï¼‰
        function sanitizeMessage(text) {
            if (!text || typeof text !== 'string') return text;
            let cleaned = text.trim();
            
            // âœ… ä¿æŠ¤ç‰¹æ®Šæ ¼å¼ï¼šå¦‚æœæ˜¯ä»¥ç‰¹æ®Šæ ¼å¼å¼€å¤´ï¼Œä¸è¦æ¸…ç†æ–¹æ‹¬å·
            if (/^\[(img|voice|imgcard|sticker):/.test(cleaned)) {
                // è¿™æ˜¯ç‰¹æ®Šæ ¼å¼æ¶ˆæ¯ï¼Œä¿æŒåŸæ ·
                return cleaned;
            }
            
            // ğŸ”§ ä¿æŠ¤å¤–å–å¡ç‰‡æ ¼å¼å’Œæƒ…å¤´å¡ç‰‡æ ¼å¼
            if (/^\[(emei_order|emei_share|payment_request|couple_avatar_card)\]/.test(cleaned)) {
                return cleaned;
            }
            
            // ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šå…ˆå»æ‰ img: å‰ç¼€ï¼ˆé˜²æ­¢ ERR_UNKNOWN_URL_SCHEMEï¼‰
            cleaned = cleaned.replace(/^img:/, '');
            // å»æ‰æ–¹æ‹¬å·
            cleaned = cleaned.replace(/\]+$/, '');   // å¹²æ‰ç»“å°¾æ‰€æœ‰ ]
            cleaned = cleaned.replace(/^\[+/, '');   // å¹²æ‰å¼€å¤´ [
            // å¦‚æœè¿˜æœ‰ img: å‰ç¼€ï¼ˆå¯èƒ½åœ¨æ–¹æ‹¬å·å»æ‰åå‡ºç°ï¼‰ï¼Œå†æ¬¡æ¸…ç†
            cleaned = cleaned.replace(/^img:/, '');
            return cleaned;
        }

        // âœ… æ ¸å¿ƒå‡½æ•°3ï¼šç»Ÿä¸€çš„æ¶ˆæ¯å†…å®¹æ¸²æŸ“å‡½æ•°
        function renderMessageContent(text) {
            if (!text || typeof text !== 'string') return '';
            
            // ğŸ¯ å®‰å…¨ç½‘ï¼šæ¸…é™¤ä»»ä½•æ®‹ç•™çš„ [sticker:] æ ‡ç­¾ï¼ˆæœªè¢«å‰ç½®å¤„ç†æ›¿æ¢çš„ï¼‰
            text = text.replace(/\[sticker:[^\]]+\]/gi, '[è¡¨æƒ…]');
            
            // ğŸ”§ å¤„ç†å¤–å–å¡ç‰‡æ¶ˆæ¯å’Œæƒ…å¤´å¡ç‰‡ - ç›´æ¥è¿”å› HTML å†…å®¹
            if (text.startsWith('[emei_order]') || text.startsWith('[emei_share]') || text.startsWith('[payment_request]') || text.startsWith('[couple_avatar_card]')) {
                // æå–å¡ç‰‡ HTML
                const cardHtml = text.replace(/^\[(emei_order|emei_share|payment_request|couple_avatar_card)\]/, '');
                return cardHtml;
            }
            
            // å…ˆæ¸…ç†æ¶ˆæ¯ï¼ˆå»æ‰img:å‰ç¼€ã€æ–¹æ‹¬å·ç­‰ï¼‰
            const clean = sanitizeMessage(text);
            
            // ğŸ”¥ é¢å¤–ä¿æŠ¤ï¼šå¦‚æœæ¸…ç†åè¿˜æœ‰img:å‰ç¼€ï¼Œå†æ¬¡æ¸…ç†ï¼ˆé˜²æ­¢è¾¹ç¼˜æƒ…å†µï¼‰
            const finalClean = clean.replace(/^img:/, '');
            
            // å¦‚æœæ•´ä¸ªæ¶ˆæ¯å°±æ˜¯ä¸€ä¸ªå›¾ç‰‡URLï¼Œç›´æ¥æ¸²æŸ“ä¸ºå›¾ç‰‡
            if (isImageUrl(finalClean)) {
                return `<img src="${finalClean}" class="chat-image" style="width:150px; height:150px; object-fit:cover; border-radius:8px; cursor:pointer;" onclick="showFullImage(this.src)" ${getImageErrorHandler()} />`;
            }
            
            // æ£€æŸ¥æ˜¯å¦åŒ…å«[img:...]æ ¼å¼çš„å›¾ç‰‡æ ‡è®°
            const imgMatches = finalClean.matchAll(/\[img:([^\]]+)\]/g);
            const images = Array.from(imgMatches);
            
            if (images.length > 0) {
                // åŒ…å«å›¾ç‰‡æ ‡è®°ï¼Œéœ€è¦æ··åˆæ˜¾ç¤º
                let html = '';
                let lastIndex = 0;
                
                images.forEach((match) => {
                    // æ·»åŠ å›¾ç‰‡å‰çš„æ–‡å­—
                    if (match.index > lastIndex) {
                        const textBefore = finalClean.substring(lastIndex, match.index);
                        if (textBefore.trim()) {
                            html += `<span>${escapeHtml(textBefore)}</span>`;
                        }
                    }
                    
                    // æ·»åŠ å›¾ç‰‡ï¼ˆä½¿ç”¨chat-imageç±»ï¼Œç¡®ä¿å»æ‰img:å‰ç¼€ï¼‰
                    let imgUrl = sanitizeMessage(match[1]);
                    // ğŸ”¥ é¢å¤–ä¿æŠ¤ï¼šå†æ¬¡ç¡®ä¿æ²¡æœ‰img:å‰ç¼€
                    imgUrl = imgUrl.replace(/^img:/, '');
                    html += `<img src="${imgUrl}" class="chat-image" style="width:150px; height:150px; object-fit:cover; border-radius:8px; cursor:pointer;" onclick="showFullImage(this.src)" ${getImageErrorHandler()} />`;
                    
                    lastIndex = match.index + match[0].length;
                });
                
                // æ·»åŠ æœ€åä¸€æ®µæ–‡å­—ï¼ˆå¦‚æœæœ‰ï¼‰
                if (lastIndex < finalClean.length) {
                    const textAfter = finalClean.substring(lastIndex);
                    if (textAfter.trim()) {
                        html += `<span>${escapeHtml(textAfter)}</span>`;
                    }
                }
                
                return html;
            }
            
            // æ£€æŸ¥æ˜¯å¦åŒ…å«æ™®é€šURLï¼ˆhttp://æˆ–https://ï¼‰
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            const hasUrl = urlRegex.test(finalClean);
            
            if (hasUrl) {
                // åŒ…å«URLï¼Œè½¬æ¢ä¸ºHTMLå¹¶ä¿æŠ¤URL
                return finalClean.replace(urlRegex, (url) => {
                    let cleanUrl = sanitizeMessage(url);
                    // ğŸ”¥ é¢å¤–ä¿æŠ¤ï¼šå†æ¬¡ç¡®ä¿æ²¡æœ‰img:å‰ç¼€
                    cleanUrl = cleanUrl.replace(/^img:/, '');
                    // æ£€æŸ¥æ˜¯å¦æ˜¯å›¾ç‰‡URL
                    if (isImageUrl(cleanUrl)) {
                        return `<img src="${cleanUrl}" class="chat-image" style="width:150px; height:150px; object-fit:cover; border-radius:8px; cursor:pointer;" onclick="showFullImage(this.src)" ${getImageErrorHandler()} />`;
                    } else {
                        // æ™®é€šé“¾æ¥
                        return `<a href="${cleanUrl}" target="_blank" style="color:#007aff; word-break:break-all;">${escapeHtml(cleanUrl)}</a>`;
                    }
                });
            }
            
            // çº¯æ–‡æœ¬ï¼Œè½¬ä¹‰HTMLé˜²æ­¢XSS
            return `<span>${escapeHtml(finalClean)}</span>`;
        }

        // è¾…åŠ©å‡½æ•°ï¼šè½¬ä¹‰HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆå›¾ç‰‡åŠ è½½å¤±è´¥çš„HTML
        function getImageErrorHandler() {
            return `onerror="this.onerror=null; this.style.cssText='width:80px; height:80px; display:flex; align-items:center; justify-content:center; background:#f5f5f5; border-radius:8px;'; this.outerHTML='<div style=\\'width:80px; height:80px; display:flex; align-items:center; justify-content:center; background:#f5f5f5; border-radius:8px; color:#999; font-size:11px; text-align:center;\\'>å›¾ç‰‡åŠ è½½å¤±è´¥</div>';"`;
        }

        // ç¾¤èŠå›¾ç‰‡å¡ç‰‡ç‚¹å‡»å±•å¼€ - ä½¿ç”¨ä¸ç§èŠç›¸åŒçš„æ ·å¼
        function showImageCardContent(el) {
            const text = el.dataset.text;
            if (!text) return;
            
            const isExpanded = el.dataset.expanded === 'true';
            
            if (isExpanded) {
                // æ”¶èµ·ï¼šæ˜¾ç¤ºå¡ç‰‡
                el.innerHTML = `
                    <div class="img-card-placeholder">
                        <svg class="img-card-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                            <circle cx="8.5" cy="8.5" r="1.5"></circle>
                            <polyline points="21 15 16 10 5 21"></polyline>
                        </svg>
                        <div class="img-card-hint">ç‚¹å‡»æŸ¥çœ‹æ–‡å­—</div>
                    </div>
                `;
                el.dataset.expanded = 'false';
            } else {
                // å±•å¼€ï¼šæ˜¾ç¤ºæ–‡å­—
                el.innerHTML = `<div class="img-card-text">${escapeHtml(text)}</div>`;
                el.dataset.expanded = 'true';
            }
        }

        // ç¾¤èŠè¯­éŸ³æ°”æ³¡ç‚¹å‡»æ’­æ”¾
        function playVoiceBubble(el) {
            const text = el.dataset.text;
            if (!text) return;
            
            // æ˜¾ç¤ºè¯­éŸ³å†…å®¹å¼¹çª—
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); display:flex; align-items:center; justify-content:center; z-index:10000;';
            modal.onclick = () => modal.remove();
            
            modal.innerHTML = `
                <div style="background:#fff; padding:20px 24px; border-radius:12px; max-width:85%; max-height:70%; overflow-y:auto;" onclick="event.stopPropagation()">
                    <div style="font-size:14px; color:#666; margin-bottom:12px; display:flex; align-items:center; gap:8px;">
                        <svg viewBox="0 0 24 24" style="width:18px; height:18px; fill:#999;"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z"/></svg>
                        è¯­éŸ³æ¶ˆæ¯å†…å®¹
                    </div>
                    <div style="font-size:16px; line-height:1.8; color:#333; white-space:pre-wrap;">${escapeHtml(text)}</div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        // æ˜¾ç¤ºå®Œæ•´å›¾ç‰‡
        function showFullImage(src) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); display:flex; align-items:center; justify-content:center; z-index:10000;';
            modal.onclick = () => modal.remove();
            
            modal.innerHTML = `<img src="${src}" style="max-width:95%; max-height:95%; object-fit:contain;" />`;
            
            document.body.appendChild(modal);
        }

        // æ ¼å¼åŒ–æ—¶é—´æˆ³
        function formatMessageTime(timestamp, prevTimestamp, timeOffset = 0) {
            if (!timestamp) return '';
            
            // ä½¿ç”¨è™šæ‹Ÿæ—¶é—´è¿›è¡Œè®¡ç®—
            const virtualTimestamp = timestamp + timeOffset;
            const virtualNow = Date.now() + timeOffset;
            
            const msgTime = new Date(virtualTimestamp);
            const now = new Date(virtualNow);
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const msgDate = new Date(msgTime.getFullYear(), msgTime.getMonth(), msgTime.getDate());
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            
            let timeStr = '';
            if (msgDate.getTime() === today.getTime()) {
                // ä»Šå¤©ï¼šæ˜¾ç¤ºæ—¶é—´
                timeStr = `${msgTime.getHours()}:${msgTime.getMinutes().toString().padStart(2, '0')}`;
            } else if (msgDate.getTime() === yesterday.getTime()) {
                // æ˜¨å¤©
                timeStr = `æ˜¨å¤© ${msgTime.getHours()}:${msgTime.getMinutes().toString().padStart(2, '0')}`;
            } else if (virtualNow - virtualTimestamp < 7 * 24 * 60 * 60 * 1000) {
                // ä¸€å‘¨å†…ï¼šæ˜¾ç¤ºæ˜ŸæœŸ
                const weekdays = ['å‘¨æ—¥', 'å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­'];
                timeStr = `${weekdays[msgTime.getDay()]} ${msgTime.getHours()}:${msgTime.getMinutes().toString().padStart(2, '0')}`;
            } else {
                // æ›´æ—©ï¼šæ˜¾ç¤ºæ—¥æœŸ
                timeStr = `${msgTime.getMonth() + 1}/${msgTime.getDate()} ${msgTime.getHours()}:${msgTime.getMinutes().toString().padStart(2, '0')}`;
            }
            
            return timeStr;
        }
        
        // åˆ¤æ–­æ˜¯å¦éœ€è¦æ˜¾ç¤ºæ—¶é—´æˆ³ï¼ˆä¸¤æ¡æ¶ˆæ¯é—´éš”è¶…è¿‡5åˆ†é’Ÿæ‰æ˜¾ç¤ºï¼‰
        function shouldShowTimestamp(currentTime, prevTime) {
            if (!prevTime) return true; // ç¬¬ä¸€æ¡æ¶ˆæ¯æ˜¾ç¤ºæ—¶é—´
            const diff = currentTime - prevTime;
            return diff > 5 * 60 * 1000; // è¶…è¿‡5åˆ†é’Ÿ
        }

        // æ„é€ æ¶ˆæ¯ DOM
        function createMessageElement(msg, index, charAvatar, userAvatar, prevMsgTime, charName = 'AI') {
            const row = document.createElement('div');
            
            // ğŸ¯ è§†é¢‘é€šè¯å†…å®¹ï¼šä¸åœ¨èŠå¤©é¡µé¢æ¸²æŸ“ï¼ˆä»…ä¿ç•™åœ¨å†å²è®°å½•ä¸­ä¾›AIè¯»å–ï¼‰
            // åªæ˜¾ç¤ºç³»ç»Ÿç±»çš„è§†é¢‘é€šè¯æ¶ˆæ¯ï¼ˆå·²æ¥é€š/å·²ç»“æŸï¼‰ï¼Œéšè—å®é™…å¯¹è¯å†…å®¹
            if (msg.isVideoCall && msg.role !== 'system') {
                row.style.display = 'none';
                return row;
            }
            
            // ğŸ¯ ç‰¹æ®Šå¤„ç†ï¼šç³»ç»Ÿæ¶ˆæ¯ï¼ˆå¦‚æˆ³ä¸€æˆ³ï¼‰
            if (msg.role === 'system') {
                row.className = 'message-system';
                row.style.cssText = 'text-align:center; padding:8px 16px; margin:8px 0; position:relative;';
                row.dataset.index = index;
                
                // å¤é€‰æ¡† (å¤šé€‰æ¨¡å¼ç”¨)
                const checkbox = document.createElement('div');
                checkbox.className = 'msg-checkbox';
                checkbox.style.cssText = 'position:absolute; left:6px; top:50%; transform:translateY(-50%); width:22px; height:22px; border:2px solid #ccc; border-radius:50%; display:none; align-items:center; justify-content:center; cursor:pointer; z-index:10; box-sizing:border-box;';
                row.appendChild(checkbox);
                
                const systemSpan = document.createElement('span');
                systemSpan.className = 'system-msg-content';
                systemSpan.style.cssText = 'background:#fff; color:#999; font-size:12px; padding:4px 12px; border-radius:4px; border:1px solid #ddd; display:inline-block;';
                systemSpan.textContent = msg.content;
                row.appendChild(systemSpan);
                
                // ç»‘å®šé•¿æŒ‰äº‹ä»¶ï¼Œå…è®¸åˆ é™¤ç³»ç»Ÿæ¶ˆæ¯
                bindMessageEvents(systemSpan, index, true); // trueè¡¨ç¤ºæ˜¯ç³»ç»Ÿæ¶ˆæ¯
                // æ•´ä¸ªè¡Œç‚¹å‡»äº‹ä»¶ (ç”¨äºå¤šé€‰)
                row.onclick = (e) => handleRowClick(index, e);
                
                return row;
            }
            
            row.className = `message-row ${msg.role === 'user' ? 'self' : 'other'}`;
            row.dataset.index = index;

            // å¤é€‰æ¡† (å¤šé€‰æ¨¡å¼ç”¨)
            const checkbox = document.createElement('div');
            checkbox.className = 'msg-checkbox';
            row.appendChild(checkbox);

            // å¤´åƒ
            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            
            if (msg.role === 'char') {
                if (charAvatar) avatar.style.backgroundImage = `url(${charAvatar})`;
                // ç»™è§’è‰²å¤´åƒæ·»åŠ ç‚¹å‡»å’ŒåŒå‡»äº‹ä»¶
                avatar.style.cursor = 'pointer';
                
                let clickCount = 0;
                let clickTimer = null;
                
                avatar.onclick = async (e) => {
                    e.stopPropagation(); // é˜»æ­¢å†’æ³¡ï¼Œé¿å…è§¦å‘æ¶ˆæ¯é€‰æ‹©
                    
                    clickCount++;
                    
                    if (clickCount === 1) {
                        // ç¬¬ä¸€æ¬¡ç‚¹å‡»ï¼Œç­‰å¾…350msåˆ¤æ–­æ˜¯å•å‡»è¿˜æ˜¯åŒå‡»
                        clickTimer = setTimeout(async () => {
                            // å•å‡»ï¼šæ˜¾ç¤ºå¿ƒå£°
                            await showCharacterThoughts(currentChatCharId, index);
                            clickCount = 0;
                        }, 350);
                    } else if (clickCount === 2) {
                        // åŒå‡»ï¼šæˆ³ä¸€æˆ³
                        clearTimeout(clickTimer);
                        showPokeModal(charName);
                        clickCount = 0;
                    }
                };
            } else {
                if (userAvatar) {
                    avatar.style.backgroundImage = `url(${userAvatar})`;
                } else {
                    avatar.style.backgroundColor = '#eee';
                }
            }

            // å†…å®¹æ°”æ³¡
            const content = document.createElement('div');
            content.className = msg.role === 'user' ? 'message-content user-bubble' : 'message-content ai-bubble';
            
            // æ£€æµ‹è½¬è´¦æ¶ˆæ¯ - æ”¯æŒ type='transfer' æˆ– content ä¸ºè½¬è´¦JSONæ ¼å¼
            let isTransferMsg = false;
            let transferData = {};
            
            if (msg.type === 'transfer') {
                isTransferMsg = true;
                try {
                    transferData = JSON.parse(msg.content);
                } catch(e) {
                    transferData = { amount: '0.00', desc: 'è§£æé”™è¯¯', status: 'sent' };
                }
            } else if (msg.content) {
                // å°è¯•è§£æä¸ºè½¬è´¦JSON - trimç©ºæ ¼åæ£€æŸ¥
                const trimmed = msg.content.trim();
                if (trimmed.startsWith('{') && trimmed.includes('"amount"') && !trimmed.startsWith('[')) {
                    try {
                        const parsed = JSON.parse(trimmed);
                        if (parsed.amount && parsed.desc !== undefined && parsed.status) {
                            isTransferMsg = true;
                            transferData = parsed;
                            // è¡¥å……IDï¼ˆå¦‚æœæ²¡æœ‰ï¼‰
                            if (!msg.id) msg.id = 'trans_' + msg.time;
                        }
                    } catch(e) {
                        // ä¸æ˜¯æœ‰æ•ˆçš„è½¬è´¦JSONï¼ŒæŒ‰æ™®é€šæ¶ˆæ¯å¤„ç†
                    }
                }
            }
            
            // å¤„ç†è½¬è´¦æ¶ˆæ¯
            if (isTransferMsg) {
                // å»é™¤é»˜è®¤èƒŒæ™¯å’Œpaddingï¼Œå®Œå…¨äº¤ç»™ transfer-card
                content.style.padding = '0';
                content.style.background = 'transparent';
                content.style.boxShadow = 'none';
                
                const isSelf = msg.role === 'user';
                const isDone = transferData.status === 'received';
                const isReturned = transferData.status === 'returned';
                
                let statusText = 'è½¬è´¦';
                if (isSelf) statusText = 'å·²å‘é€';
                if (isDone) statusText = 'å·²æ”¶æ¬¾';
                if (isReturned) statusText = 'å·²é€€å›';
                
                content.innerHTML = `
                    <div class="transfer-card ${isDone ? 'done' : ''} ${isReturned ? 'returned' : ''}" data-transfer-id="${msg.id || ''}" onclick="showTransferConfirm('${msg.id}', ${isSelf}, '${transferData.status}')">
                        <div class="t-amount">Â¥ ${transferData.amount}</div>
                        <div class="t-desc">${transferData.desc}</div>
                        <div class="t-line"></div>
                        <div class="t-footer">
                            <span class="t-footer-text">${statusText}</span>
                            <span class="t-dot"></span>
                        </div>
                    </div>
                `;
            }
            // âœ… å¤„ç†éŸ³é¢‘/è¯­éŸ³æ¶ˆæ¯ï¼ˆè”æœºå¥½å‹çœŸå®å½•éŸ³ï¼‰- ä½¿ç”¨æ™®é€šæ°”æ³¡æ ·å¼
            else if (msg.type === 'audio' && msg.content && msg.content.startsWith('data:audio')) {
                const duration = msg.duration || 0;
                const audioId = 'audio_' + (msg.time || Date.now());
                
                // ç®€å•æ˜¾ç¤ºè¯­éŸ³å›¾æ ‡å’Œæ—¶é•¿ï¼Œç‚¹å‡»æ’­æ”¾
                content.textContent = `ğŸ¤ ${duration}"`;
                content.style.cursor = 'pointer';
                content.dataset.audioId = audioId;
                content.onclick = function() { playOnlineAudio(this.dataset.audioId); };
                
                // æ·»åŠ éšè—çš„ audio å…ƒç´ åˆ°æ¶ˆæ¯è¡Œ
                setTimeout(() => {
                    const audioEl = document.createElement('audio');
                    audioEl.id = audioId;
                    audioEl.src = msg.content;
                    audioEl.style.display = 'none';
                    document.body.appendChild(audioEl);
                }, 0);
            }
            // å¤„ç†äº²å±å¡æ¶ˆæ¯
            else if (msg.type === 'familyCard') {
                content.style.padding = '0';
                content.style.background = 'transparent';
                content.style.boxShadow = 'none';
                
                let cardData = {};
                try {
                    cardData = JSON.parse(msg.content);
                } catch(e) {
                    cardData = { fromName: 'æœªçŸ¥', monthlyLimit: 0, status: 'sent' };
                }
                
                const isSelf = msg.role === 'user';
                const isOnline = cardData.isOnline || false;
                const limitText = cardData.monthlyLimit > 0 ? `æ¯æœˆé¢åº¦ Â¥${cardData.monthlyLimit}` : 'ä¸é™é¢åº¦';
                const cardType = isOnline ? 'ğŸ’ äº²å±å¡ (è”æœº)' : 'ğŸ’ äº²å±å¡';
                
                content.innerHTML = `
                    <div class="family-card-msg">
                        <div class="family-card-msg-title">${cardType}</div>
                        <div class="family-card-msg-desc">${limitText}</div>
                        <div class="family-card-msg-line"></div>
                        <div class="family-card-msg-footer">
                            <span class="family-card-msg-status">${isSelf ? 'å·²èµ é€' : 'å·²æ”¶åˆ°'}</span>
                            <span class="family-card-msg-dot"></span>
                        </div>
                    </div>
                `;
            }
            // å¤„ç†ä»£ä»˜è¯·æ±‚å¡ç‰‡ï¼ˆè´­ç‰©ï¼‰
            else if (msg.type === 'shopPayRequest') {
                content.style.padding = '0';
                content.style.background = 'transparent';
                content.style.boxShadow = 'none';
                
                let reqData = {};
                try { reqData = JSON.parse(msg.content); } catch(e) { reqData = {}; }
                const isSelf = msg.role === 'user';
                const amount = parseFloat(reqData.amount || 0).toFixed(2);
                const items = reqData.items || 'è´­ç‰©å•†å“';
                const buyFor = reqData.buyForName || '';
                const installmentInfo = reqData.installmentInfo || '';
                const payStatus = reqData.status || 'pending';
                const isGift = reqData.isGift || false;
                const isShare = reqData.isShare || false;
                
                let cardTitle = 'ä»£ä»˜è¯·æ±‚';
                let statusText = 'å¾…ç¡®è®¤';
                let cardVariant = '';
                
                if (isShare) {
                    cardTitle = 'è´­ç‰©åˆ†äº«';
                    statusText = isSelf ? 'å·²åˆ†äº«' : 'æ¥è‡ªå¥½å‹';
                    cardVariant = 'share';
                } else if (isGift) {
                    cardTitle = 'è´­ç‰©ç¤¼ç‰©';
                    statusText = isSelf ? 'å·²èµ é€' : 'å·²æ”¶åˆ°';
                    cardVariant = 'gift';
                } else {
                    if (payStatus === 'paid') { statusText = 'å·²ä»£ä»˜'; cardVariant = 'done'; }
                    else if (payStatus === 'declined') { statusText = 'å·²æ‹’ç»'; cardVariant = 'declined'; }
                    else if (isSelf) { statusText = 'å¾…ä»£ä»˜'; }
                }

                // ç»„åˆå‰¯ä¿¡æ¯
                let metaParts = [];
                if (buyFor) metaParts.push('To: ' + buyFor);
                if (installmentInfo) metaParts.push(installmentInfo);
                const metaText = metaParts.join(' Â· ');
                
                content.innerHTML = `
                    <div class="spr-card ${cardVariant}">
                        <div class="spr-top">
                            <div class="spr-badge">${cardTitle}</div>
                        </div>
                        <div class="spr-body">
                            <div class="spr-amount-row">
                                <span class="spr-currency">Â¥</span>
                                <span class="spr-amount-num">${amount}</span>
                            </div>
                            <div class="spr-items-text">${items}</div>
                            ${metaText ? '<div class="spr-meta">' + metaText + '</div>' : ''}
                        </div>
                        <div class="spr-divider"></div>
                        <div class="spr-bottom">
                            <span class="spr-status-text">${statusText}</span>
                        </div>
                    </div>
                `;
            }
            // å¤„ç†äº²å¯†å…³ç³»ç”³è¯·å¡ç‰‡ï¼ˆç™½è‰²ç®€çº¦é£æ ¼ï¼Œä»¿è½¬è´¦/çº¢åŒ…å¡ç‰‡ï¼‰
            else if (msg.type === 'intimateRequest') {
                content.style.padding = '0';
                content.style.background = 'transparent';
                content.style.boxShadow = 'none';

                let cardData = {};
                try { cardData = JSON.parse(msg.content); } catch(e) { cardData = {}; }
                const isSelf = msg.role === 'user';
                const emojiMap = { couple:'ğŸ’•', bestie:'âœ¨', bro:'ğŸ¤', side:'ğŸ”¥' };
                const nameMap = { couple:'æƒ…ä¾£', bestie:'é—ºèœœ', bro:'åŸºå‹', side:'å°ä¸‰' };
                const rType = cardData.relationType || 'couple';
                const rEmoji = emojiMap[rType] || 'ğŸ’•';
                const rName = nameMap[rType] || 'æƒ…ä¾£';
                const cStatus = cardData.status || 'pending';
                const requestId = cardData.requestId || '';

                let footerText = 'äº²å¯†ç©ºé—´';
                let footerDotClass = '';
                let actionHtml = '';

                if (cStatus === 'pending') {
                    if (isSelf) {
                        footerText = 'ç­‰å¾…å¯¹æ–¹ç¡®è®¤';
                        actionHtml = `<div class="ir-actions"><div class="ir-btn ir-reject" onclick="event.stopPropagation(); cancelIntimateRequest('${requestId}')">æ’¤é”€ç”³è¯·</div></div>`;
                    } else {
                        footerText = 'è¯·ç¡®è®¤';
                        actionHtml = `<div class="ir-actions"><div class="ir-btn ir-accept" onclick="event.stopPropagation(); handleIntimateCardAction('${requestId}', true, ${index})">æ¥å—</div><div class="ir-btn ir-reject" onclick="event.stopPropagation(); handleIntimateCardAction('${requestId}', false, ${index})">å©‰æ‹’</div></div>`;
                    }
                } else if (cStatus === 'accepted') {
                    footerText = 'å·²æ¥å—';
                    footerDotClass = ' done';
                } else if (cStatus === 'rejected') {
                    footerText = 'å·²å©‰æ‹’';
                    footerDotClass = ' done';
                } else if (cStatus === 'cancelled') {
                    footerText = 'å·²æ’¤é”€';
                    footerDotClass = ' done';
                }

                content.innerHTML = `
                    <div class="intimate-req-card${footerDotClass}" data-request-id="${requestId}">
                        <div class="ir-title">${rEmoji} ${rName}å…³ç³»</div>
                        <div class="ir-desc">äº²å¯†å…³ç³»é‚€è¯·</div>
                        <div class="ir-line"></div>
                        <div class="ir-footer">
                            <span class="ir-footer-text">${footerText}</span>
                            <span class="ir-dot"></span>
                        </div>
                        ${actionHtml}
                    </div>`;
            }
            // å¤„ç†ä½ç½®æ¶ˆæ¯
            else if (msg.type === 'location') {
                content.style.padding = '0';
                content.style.background = 'transparent';
                content.style.boxShadow = 'none';
                
                let locationData = {};
                try {
                    locationData = JSON.parse(msg.content);
                } catch(e) {
                    locationData = { name: 'æœªçŸ¥ä½ç½®', address: '' };
                }
                
                content.innerHTML = `
                    <div class="location-card" onclick="showLocationDetail('${encodeURIComponent(locationData.name)}', '${encodeURIComponent(locationData.address)}')">
                        <div class="location-card-text">
                            <div class="location-card-name">${locationData.name}</div>
                            <div class="location-card-sub">ä½ç½®åˆ†äº«</div>
                        </div>
                        <div class="location-card-map">
                            <div class="location-card-pin">
                                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M12 11.5C11.1716 11.5 10.5 10.8284 10.5 10C10.5 9.17157 11.1716 8.5 12 8.5C12.8284 8.5 13.5 9.17157 13.5 10C13.5 10.8284 12.8284 11.5 12 11.5Z"></path>
                                    <path d="M12 2C7.92134 2 4.5 5.42134 4.5 9.5C4.5 14.5312 11.2188 21.4375 11.5938 21.8125C11.7954 22.014 12.2046 22.014 12.4062 21.8125C12.7812 21.4375 19.5 14.5312 19.5 9.5C19.5 5.42134 16.0787 2 12 2ZM12 12.5C10.6193 12.5 9.5 11.3807 9.5 10C9.5 8.61929 10.6193 7.5 12 7.5C13.3807 7.5 14.5 8.61929 14.5 10C14.5 11.3807 13.3807 12.5 12 12.5Z"></path>
                                </svg>
                            </div>
                        </div>
                    </div>
                `;
            }
            // å¤„ç†æ’¤å›æ¶ˆæ¯ï¼ˆå±…ä¸­ç³»ç»Ÿæç¤ºæ ·å¼ï¼Œç‚¹å‡»å¯æŸ¥çœ‹åŸå†…å®¹ï¼‰
            else if (msg.isRecalled) {
                const isUser = msg.role === 'user';
                const recallerName = isUser ? 'ä½ ' : charName;
                
                // æ”¹ä¸ºç³»ç»Ÿæç¤ºæ ·å¼ï¼šå±…ä¸­ç°è‰²æ–‡å­—
                row.className = 'message-row recalled-system-row';
                row.innerHTML = ''; // æ¸…ç©ºåŸæœ‰å†…å®¹
                
                const systemTip = document.createElement('div');
                systemTip.className = 'recalled-system-tip';
                systemTip.innerHTML = `"${recallerName}"æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯`;
                systemTip.style.cursor = 'pointer';
                
                // ç‚¹å‡»æŸ¥çœ‹æ’¤å›çš„å†…å®¹
                systemTip.onclick = (e) => {
                    e.stopPropagation();
                    if (msg.recalledContent) {
                        showRecalledContent(recallerName, msg.recalledContent);
                    } else {
                        showToast('åŸæ¶ˆæ¯å†…å®¹å·²ä¸å¯ç”¨');
                    }
                };
                
                row.appendChild(systemTip);
                return row; // ç›´æ¥è¿”å›ï¼Œä¸å†æ·»åŠ å¤´åƒå’Œæ°”æ³¡
            } 
            // å¤„ç†è¯­éŸ³æ¶ˆæ¯
            else if (msg.content.startsWith('[voice:')) {
                // ç›´æ¥æå–è¯­éŸ³æ–‡æœ¬ï¼Œä¸è¦ç”¨ sanitizeMessage
                let voiceText = msg.content.substring(7, msg.content.length - 1).trim();
                
                // æ£€æŸ¥è¯­éŸ³æ–‡æœ¬ä¸­æ˜¯å¦åŒ…å«å›¾ç‰‡é“¾æ¥
                const imgMatch = voiceText.match(/\[img:([^\]]+)\]/);
                let hasImage = false;
                let imgUrl = '';
                let cleanVoiceText = voiceText;
                
                if (imgMatch) {
                    hasImage = true;
                    imgUrl = imgMatch[1].trim(); // ç›´æ¥ä½¿ç”¨ï¼Œä¸è¦ç”¨ sanitizeMessage
                    // ä»è¯­éŸ³æ–‡æœ¬ä¸­ç§»é™¤å›¾ç‰‡æ ‡è®°
                    cleanVoiceText = voiceText.replace(/\[img:[^\]]+\]/g, '').trim();
                }
                
                const duration = Math.ceil(cleanVoiceText.length / 5); // æ¨¡æ‹Ÿæ—¶é•¿ï¼šæ¯5ä¸ªå­—1ç§’
                
                // åˆ›å»ºè¯­éŸ³æ°”æ³¡å®¹å™¨ï¼ˆä½¿ç”¨çº¯CSSæ³¢çº¹åŠ¨ç”»ï¼‰
                content.className = 'voice-bubble';
                let voiceHtml = `
                    <div class="voice-bubble-header">
                        <div class="voice-icon">
                            <i></i>
                            <i></i>
                            <i></i>
                        </div>
                        <div class="voice-duration">${duration}"</div>
                    </div>
                    <div class="voice-text-content">${escapeHtml(cleanVoiceText)}</div>
                `;
                
                // å¦‚æœåŒ…å«å›¾ç‰‡ï¼Œåœ¨è¯­éŸ³æ°”æ³¡ä¸‹æ–¹æ·»åŠ å›¾ç‰‡ï¼ˆä½¿ç”¨chat-imageç±»ï¼‰
                if (hasImage) {
                    voiceHtml += `<div style="margin-top:8px;"><img src="${imgUrl}" class="chat-image" style="width:150px; height:150px; object-fit:cover; border-radius:8px; cursor:pointer;" onclick="showFullImage(this.src)" ${getImageErrorHandler()} /></div>`;
                }
                
                content.innerHTML = voiceHtml;
                
                // ç‚¹å‡»å±•å¼€/æ”¶èµ·æ–‡å­—
                content.onclick = (e) => {
                    // å¦‚æœç‚¹å‡»çš„æ˜¯å›¾ç‰‡ï¼Œä¸è§¦å‘å±•å¼€/æ”¶èµ·
                    if (e.target.tagName === 'IMG') {
                        e.stopPropagation();
                        return;
                    }
                    e.stopPropagation();
                    content.classList.toggle('expanded');
                };
            }
            // å¤„ç†å›¾ç‰‡å¡ç‰‡æ¶ˆæ¯
            else if (msg.content.startsWith('[imgcard:')) {
                // ç›´æ¥æå–æ–¹æ‹¬å·å†…çš„å†…å®¹ï¼Œä¸è¦ç”¨ sanitizeMessageï¼ˆä¼šç ´åæ ¼å¼ï¼‰
                const cardText = msg.content.substring(9, msg.content.length - 1).trim();
                
                content.className = 'img-card-bubble';
                content.dataset.text = cardText; // å­˜å‚¨æ–‡å­—å†…å®¹
                content.dataset.expanded = 'false'; // åˆå§‹çŠ¶æ€ï¼šæœªå±•å¼€
                
                // âœ… å¦‚æœå·²æœ‰ NovelAI ç”Ÿæˆçš„å›¾ç‰‡ï¼Œç›´æ¥æ˜¾ç¤ºå›¾ç‰‡
                if (msg.novelai_generated && msg.novelai_image) {
                    content.innerHTML = `
                        <img src="${msg.novelai_image}" class="chat-image" 
                             style="width:200px; max-height:300px; object-fit:cover; border-radius:8px; cursor:pointer;" 
                             onclick="showFullImage(this.src)" />
                        <div style="font-size:10px; color:#bbb; text-align:center; margin-top:4px; padding:0 4px;">${escapeHtml(cardText)}</div>
                    `;
                    content.style.cursor = 'default';
                } else {
                    // é»˜è®¤æ˜¾ç¤ºå¡ç‰‡çŠ¶æ€
                    content.innerHTML = `
                        <div class="img-card-placeholder">
                            <svg class="img-card-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                <circle cx="8.5" cy="8.5" r="1.5"></circle>
                                <polyline points="21 15 16 10 5 21"></polyline>
                            </svg>
                            <div class="img-card-hint">ç‚¹å‡»æŸ¥çœ‹æ–‡å­—</div>
                        </div>
                    `;
                    
                    // ç‚¹å‡»åˆ‡æ¢å±•å¼€/æ”¶èµ·
                    content.onclick = (e) => {
                        e.stopPropagation();
                        const isExpanded = content.dataset.expanded === 'true';
                        
                        if (isExpanded) {
                            // æ”¶èµ·ï¼šæ˜¾ç¤ºå¡ç‰‡
                            content.innerHTML = `
                                <div class="img-card-placeholder">
                                    <svg class="img-card-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                        <circle cx="8.5" cy="8.5" r="1.5"></circle>
                                        <polyline points="21 15 16 10 5 21"></polyline>
                                    </svg>
                                    <div class="img-card-hint">ç‚¹å‡»æŸ¥çœ‹æ–‡å­—</div>
                                </div>
                            `;
                            content.dataset.expanded = 'false';
                        } else {
                            // å±•å¼€ï¼šæ˜¾ç¤ºæ–‡å­—
                            content.innerHTML = `<div class="img-card-text">${cardText}</div>`;
                            content.dataset.expanded = 'true';
                        }
                    };
                }
            }
            // ğŸ”§ å¤„ç†å¤–å–å¡ç‰‡æ¶ˆæ¯ & æƒ…å¤´é‚€è¯·å¡ç‰‡
            else if (msg.content.startsWith('[emei_order]') || msg.content.startsWith('[emei_share]') || msg.content.startsWith('[payment_request]') || msg.content.startsWith('[couple_avatar_card]')) {
                const cardHtml = msg.content.replace(/^\[(emei_order|emei_share|payment_request|couple_avatar_card)\]/, '');
                content.innerHTML = cardHtml;
                content.classList.add('card-message');
                content.style.padding = '0';
                content.style.background = 'transparent';
                content.style.boxShadow = 'none';
            }
            // å¤„ç†å›¾ç‰‡æ¶ˆæ¯ï¼ˆçº¯å›¾ç‰‡ï¼Œæˆ–ä»¥å›¾ç‰‡å¼€å¤´ï¼‰
            else if (msg.content.startsWith('[img:')) {
                // ç›´æ¥æå–URLï¼Œä¸è¦ç”¨ sanitizeMessage
                const imgUrl = msg.content.substring(5, msg.content.length - 1).trim();
                content.innerHTML = `<img src="${imgUrl}" class="chat-image" style="width:150px; height:150px; object-fit:cover; border-radius:8px; cursor:pointer;" onclick="showFullImage(this.src)" onerror="this.onerror=null; this.style.cssText='width:150px; height:150px; display:flex; align-items:center; justify-content:center; background:#f5f5f5; border-radius:8px;'; this.outerHTML='<div style=\\'width:150px; height:150px; display:flex; align-items:center; justify-content:center; background:#f5f5f5; border-radius:8px; color:#999; font-size:12px;\\'>å›¾ç‰‡åŠ è½½å¤±è´¥</div>';" />`;
                // ğŸ”§ æ·»åŠ  image-only ç±»ï¼Œç§»é™¤æ°”æ³¡æ ·å¼
                content.classList.add('image-only');
            }
            // ğŸ¯ å®‰å…¨ç½‘ï¼šå¤„ç†æœªè¢«æ›¿æ¢çš„ [sticker:] æ ‡ç­¾ï¼ˆé˜²æ­¢æ˜¾ç¤ºä¸ºåŸå§‹æ–‡æœ¬ï¼‰
            else if (msg.content.match(/^\[sticker:[^\]]+\]$/i)) {
                // [sticker:] æ²¡æœ‰è¢«è½¬ä¸º [img:]ï¼Œè¯´æ˜æ²¡æœ‰æŒ‚è½½è¡¨æƒ…åŒ…æˆ–åŒ¹é…å¤±è´¥
                // æ˜¾ç¤ºä¸ºä¸€ä¸ªå ä½æç¤ºè€Œä¸æ˜¯åŸå§‹æŒ‡ä»¤æ–‡æœ¬
                content.innerHTML = `<span style="color:#999; font-size:12px;">[è¡¨æƒ…]</span>`;
            }
            // âœ… æ™®é€šæ–‡æœ¬ - ä½¿ç”¨ç»Ÿä¸€çš„æ¸²æŸ“å‡½æ•°
            else {
                // å…ˆæ¸…ç†æ¶ˆæ¯å†…å®¹
                const cleanedContent = sanitizeMessage(msg.content);
                
                // æ£€æŸ¥æ˜¯å¦æœ‰å¼•ç”¨
                let quoteHtml = '';
                if (msg.quote) {
                    quoteHtml = `<div class="quoted-message" style="border-left:2px solid rgba(0,0,0,0.15); padding:2px 6px; margin-bottom:4px; font-size:11px; line-height:1.3; max-width:180px;"><div style="color:#666; font-weight:500; font-size:10px;">${escapeHtml(msg.quote.name)}</div><div style="color:#888; font-size:10px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:160px;">${escapeHtml(msg.quote.content)}</div></div>`;
                }
                
                // âœ… ä¼˜å…ˆä½¿ç”¨å­˜å‚¨æ—¶å·²è§£æå¥½çš„ç¿»è¯‘å­—æ®µï¼ˆä¸€æ¬¡è§£æï¼Œå¤„å¤„ä½¿ç”¨ï¼‰
                // å…¼å®¹æ—§æ¶ˆæ¯ï¼šå¦‚æœæ²¡æœ‰é¢„è§£æå­—æ®µï¼Œæ‰å›é€€åˆ° parseForeignWithTranslation
                let translationForeign = null;
                let translationChinese = null;
                
                if (msg.foreignText && msg.chineseText) {
                    // æ–°æ¶ˆæ¯ï¼šç›´æ¥ä½¿ç”¨é¢„è§£æå­—æ®µï¼Œä¸å†é‡å¤è§£æ
                    translationForeign = msg.foreignText;
                    translationChinese = msg.chineseText;
                } else if (msg.role === 'char') {
                    // æ—§æ¶ˆæ¯å…¼å®¹ï¼šå›é€€åˆ°è¿è¡Œæ—¶è§£æï¼ˆä»…å¯¹æ²¡æœ‰é¢„è§£æå­—æ®µçš„æ—§æ•°æ®ï¼‰
                    const translationParsed = parseForeignWithTranslation(cleanedContent);
                    if (translationParsed) {
                        translationForeign = translationParsed.foreign;
                        translationChinese = translationParsed.chinese;
                    }
                }
                
                if (translationForeign && translationChinese) {
                    // æœ‰å¤–è¯­+ä¸­æ–‡ç»„åˆï¼Œé»˜è®¤æ˜¾ç¤ºå¤–è¯­ï¼Œç‚¹å‡»æ˜¾ç¤ºç¿»è¯‘
                    content.innerHTML = quoteHtml + renderMessageContent(translationForeign);
                    content.dataset.chinese = translationChinese;
                    content.dataset.expanded = 'false';
                    content.dataset.hasTranslation = 'true';
                    content.style.cursor = 'pointer';
                } else {
                    // æ™®é€šæ¶ˆæ¯ï¼Œä½¿ç”¨ç»Ÿä¸€çš„æ¸²æŸ“å‡½æ•°
                    content.innerHTML = quoteHtml + renderMessageContent(cleanedContent);
                }
            }

            // äº‹ä»¶ç»‘å®š
            if (!msg.isRecalled) { // å·²æ’¤å›æ¶ˆæ¯ä¸å¯æ“ä½œ
                bindMessageEvents(content, index);
                // æ•´ä¸ªè¡Œç‚¹å‡»äº‹ä»¶ (ç”¨äºå¤šé€‰)
                row.onclick = (e) => handleRowClick(index, e);
            }

            row.appendChild(avatar);
            row.appendChild(content);
            
            return row;
        }

        // ç¼“å­˜å˜é‡ï¼Œé¿å…ä¸å¿…è¦çš„é‡æ–°æ¸²æŸ“
        let lastRenderedCharId = null;
        let lastRenderedHistoryLength = 0;
        let lastRenderedAccountId = null;
        let lastRenderedAvatar = null;
        let currentRenderedCount = 0; // è·Ÿè¸ªå·²æ¸²æŸ“çš„æ¶ˆæ¯æ•°é‡
        let isLoadingMoreMessages = false; // é˜²æ­¢é‡å¤åŠ è½½

        // ğŸ¯ æ–°å¢ï¼šåªæ·»åŠ å•æ¡æ¶ˆæ¯ï¼Œä¸é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
        async function appendChatMessage(char, msg, msgIndex) {
            const body = document.getElementById('chat-body');
            const accountId = getCurrentAccountId();
            const userAvatarUrl = await getUserAvatarUrl(char.linked_user_id);
            const timeOffset = getEffectiveTimeOffset(char);
            
            // è·å–å‰ä¸€æ¡æ¶ˆæ¯çš„æ—¶é—´
            const history = getChatHistory(char, accountId);
            const prevMsgTime = msgIndex > 0 && history[msgIndex - 1] ? history[msgIndex - 1].time : null;
            
            // å¦‚æœéœ€è¦æ˜¾ç¤ºæ—¶é—´æˆ³ï¼Œå…ˆæ·»åŠ æ—¶é—´æˆ³è¡Œï¼ˆç³»ç»Ÿæ¶ˆæ¯ä¸æ˜¾ç¤ºæ—¶é—´æˆ³ï¼‰
            if (msg.role !== 'system' && shouldShowTimestamp(msg.time, prevMsgTime)) {
                const timeStamp = document.createElement('div');
                timeStamp.className = 'message-timestamp';
                timeStamp.textContent = formatMessageTime(msg.time, prevMsgTime, timeOffset);
                body.appendChild(timeStamp);
            }
            
            const row = createMessageElement(msg, msgIndex, getCharAvatar(char, getCurrentAccountId()), userAvatarUrl, prevMsgTime, getCharDisplayName(char, getCurrentAccountId()));
            body.appendChild(row);
            
            // æ›´æ–°ç¼“å­˜è®¡æ•°
            lastRenderedHistoryLength = history.length;
            currentRenderedCount++; // æ›´æ–°å·²æ¸²æŸ“è®¡æ•°
            
            // æ»šåŠ¨åˆ°åº•éƒ¨
            setTimeout(() => {
                body.scrollTop = body.scrollHeight;
            }, 0);
            
            console.log('[appendChatMessage] æ·»åŠ å•æ¡æ¶ˆæ¯ï¼Œæ— éœ€é‡æ–°æ¸²æŸ“');
        }

        async function renderChatBody(char, forceRender = false) {
            const body = document.getElementById('chat-body');
            // â˜… fpæ¨¡å¼ä½¿ç”¨ fp è´¦å·IDï¼Œè€Œéå½“å‰ç™»å½•è´¦å·
            const accountId = window._fpChatMode ? window._fpAccountId : getCurrentAccountId();
            const history = getChatHistory(char, accountId);
            // æŒ‰è´¦å·éš”ç¦»çš„æ˜¾ç¤ºå±æ€§
            const _dAvatar = getCharAvatar(char, accountId);
            const _dName = getCharDisplayName(char, accountId);
            
            // ğŸ¯ ä¼˜åŒ–ï¼šå¦‚æœæ˜¯åŒä¸€ä¸ªè§’è‰²ä¸”æ¶ˆæ¯å’Œå¤´åƒéƒ½æ²¡æœ‰å˜åŒ–ï¼Œè·³è¿‡æ¸²æŸ“
            if (!forceRender && 
                lastRenderedCharId === char.id && 
                lastRenderedAccountId === accountId &&
                lastRenderedHistoryLength === (history?.length || 0) &&
                lastRenderedAvatar === _dAvatar &&
                !isSelectionMode) {
                console.log('[renderChatBody] è·³è¿‡é‡å¤æ¸²æŸ“');
                // âœ… å³ä½¿è·³è¿‡æ¸²æŸ“ï¼Œä¹Ÿè¦é‡æ–°åº”ç”¨èƒŒæ™¯å›¾å’Œè‡ªå®šä¹‰æ ·å¼ï¼ˆé˜²æ­¢è¢«ä¸»é¢˜åˆ‡æ¢ç­‰æ“ä½œæ¸…é™¤ï¼‰
                applyCustomStyles(char);
                applyChatBackground(char);
                return;
            }
            
            lastRenderedCharId = char.id;
            lastRenderedAccountId = accountId;
            lastRenderedHistoryLength = history?.length || 0;
            lastRenderedAvatar = _dAvatar;
            
            body.innerHTML = '';
            currentRenderedCount = 0; // é‡ç½®æ¸²æŸ“è®¡æ•°
            isLoadingMoreMessages = false; // ğŸ”§ ä¿®å¤ï¼šé‡ç½®åŠ è½½é”ï¼Œé˜²æ­¢å¼‚å¸¸åæ°¸ä¹…å¡æ­»
            
            // åˆ‡æ¢å¤šé€‰æ¨¡å¼æ ·å¼
            if (isSelectionMode) {
                body.classList.add('selection-mode');
            } else {
                body.classList.remove('selection-mode');
            }
            
            // âœ… è”æœºå¥½å‹è‡ªåŠ¨è§†ä¸ºå¥½å‹çŠ¶æ€ï¼ˆfpæ¨¡å¼è·³è¿‡å¥½å‹æ£€æŸ¥ï¼‰
            if (!window._fpChatMode && char.isOnlineFriend === true && accountId) {
                const currentStatus = getFriendStatus(char, accountId);
                if (currentStatus !== 'friend') {
                    // è‡ªåŠ¨ä¿®æ­£å¥½å‹çŠ¶æ€
                    if (!char.wechat_status_by_user) char.wechat_status_by_user = {};
                    char.wechat_status_by_user[accountId] = 'friend';
                    // å¼‚æ­¥ä¿å­˜ï¼Œä¸é˜»å¡æ¸²æŸ“
                    safeCharacterPut(char, 'è”æœºå¥½å‹çŠ¶æ€').catch(e => console.error('ä¿å­˜è”æœºå¥½å‹çŠ¶æ€å¤±è´¥:', e));
                }
            }
            
            // æ£€æŸ¥å¥½å‹çŠ¶æ€ï¼ˆfpæ¨¡å¼è·³è¿‡ï¼‰
            const friendStatus = window._fpChatMode ? 'friend' : getFriendStatus(char, accountId);
            if (friendStatus === 'blocked') {
                // è¢«æ‹‰é»‘çŠ¶æ€ï¼Œæ˜¾ç¤ºé¢æ¿ï¼ˆä¸åˆ é™¤ç±»ä¼¼ï¼Œä½†æç¤ºå’ŒåŠŸèƒ½ä¸åŒï¼‰
                body.innerHTML = `
                    <div style="display:flex; flex-direction:column; height:100%; padding:20px;">
                        <div style="text-align:center; padding:20px 0; border-bottom:1px solid #f0f0f0;">
                            <div style="width:60px; height:60px; border-radius:8px; background-image:url(${_dAvatar}); background-size:cover; background-position:center; margin:0 auto 12px;"></div>
                            <div style="font-size:16px; font-weight:600; margin-bottom:6px; color:#333;">${_dName}</div>
                            <div style="font-size:13px; color:#999;">ä½ å·²æ‹‰é»‘è¯¥å¥½å‹</div>
                        </div>
                        
                        <div style="flex:1; overflow-y:auto; padding:16px 0;">
                            <div style="background:#fff3cd; border-radius:8px; padding:16px; margin-bottom:16px; border:1px solid #ffc107;">
                                <div style="font-size:14px; font-weight:600; margin-bottom:12px; color:#856404;">âš ï¸ æ‹‰é»‘æç¤º</div>
                                <div style="font-size:12px; color:#856404; line-height:1.6;">
                                    æ‹‰é»‘åï¼Œè¯¥è§’è‰²æ— æ³•å‘é€å¥½å‹ç”³è¯·æˆ–å¾®ä¿¡æ¶ˆæ¯ã€‚ä½†åœ¨å¿«è¿›æ—¶é—´æ—¶ï¼Œç³»ç»Ÿä¼šæ ¹æ®è§’è‰²æ€§æ ¼åˆ¤æ–­æ˜¯å¦ä¼šå°è¯•é€šè¿‡ç”µè¯æˆ–çŸ­ä¿¡è”ç³»ä½ ã€‚
                                </div>
                            </div>
                            
                            <div style="background:#f9f9f9; border-radius:8px; padding:16px; margin-bottom:16px;">
                                <div style="font-size:14px; font-weight:600; margin-bottom:12px; color:#333;">ğŸ“± è”ç³»è®°å½•</div>
                                <div style="font-size:12px; color:#666; line-height:1.6; margin-bottom:12px;">
                                    å¿«è¿›æ—¶é—´åï¼Œç”Ÿæˆçš„ç”µè¯å’ŒçŸ­ä¿¡è®°å½•å°†å‡ºç°åœ¨æ¡Œé¢çš„ã€Œç”µè¯ã€å’Œã€Œä¿¡æ¯ã€åº”ç”¨ä¸­ï¼Œè€Œä¸ä¼šç›´æ¥æ˜¾ç¤ºåœ¨è¿™é‡Œã€‚
                                </div>
                            </div>
                            
                            <button onclick="fastForwardBlockedCheck(${char.id})" style="width:100%; padding:12px; background:var(--ins-pink); color:#fff; border:none; border-radius:8px; font-size:14px; font-weight:600; margin-bottom:12px;">
                                â© å¿«è¿›æ—¶é—´
                            </button>
                            
                            <button onclick="unblockFriend(${char.id})" style="width:100%; padding:12px; background:#fff; border:1px solid #8e8e93; color:#333; border-radius:8px; font-size:14px; font-weight:600;">
                                è§£é™¤æ‹‰é»‘
                            </button>
                        </div>
                    </div>
                `;
                return;
            } else if (friendStatus === 'deleted') {
                // å·²åˆ é™¤å¥½å‹ï¼Œæ˜¾ç¤ºç­‰å¾…å¥½å‹ç”³è¯·ç•Œé¢
                const settings = char.wait_friend_settings?.[accountId] || {
                    enabled: false,
                    interval: 60,
                    lastCheckTime: Date.now(),
                    nextCheckTime: null
                };
                
                const nextCheckText = settings.enabled && settings.nextCheckTime ? 
                    `ä¸‹æ¬¡æ£€æµ‹: ${new Date(settings.nextCheckTime).toLocaleTimeString()}` : 'æœªå¯ç”¨';
                
                body.innerHTML = `
                    <div style="display:flex; flex-direction:column; height:100%; padding:20px;">
                        <div style="text-align:center; padding:20px 0; border-bottom:1px solid #f0f0f0;">
                            <div style="width:60px; height:60px; border-radius:8px; background-image:url(${_dAvatar}); background-size:cover; background-position:center; margin:0 auto 12px;"></div>
                            <div style="font-size:16px; font-weight:600; margin-bottom:6px; color:#333;">${_dName}</div>
                            <div style="font-size:13px; color:#999;">ä½ å·²åˆ é™¤è¯¥å¥½å‹</div>
                        </div>
                        
                        <div style="flex:1; overflow-y:auto; padding:16px 0;">
                            <div style="background:#f9f9f9; border-radius:8px; padding:16px; margin-bottom:16px;">
                                <div style="font-size:14px; font-weight:600; margin-bottom:12px; color:#333;">â° ç­‰å¾…å¥½å‹ç”³è¯·</div>
                                <div style="font-size:12px; color:#666; line-height:1.6; margin-bottom:12px;">
                                    å¯ä»¥è®¾ç½®å®šæ—¶æ£€æµ‹ï¼ŒAIå°†æ ¹æ®è§’è‰²æ€§æ ¼å’Œä½ ä»¬çš„èŠå¤©å†å²ï¼Œå†³å®šæ˜¯å¦ä¸»åŠ¨å‘é€å¥½å‹ç”³è¯·ã€‚
                                </div>
                                
                                <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:12px; padding:8px 0;">
                                    <div style="font-size:13px; color:#333;">å¯ç”¨è‡ªåŠ¨æ£€æµ‹</div>
                                    <label class="ios-switch" style="transform:scale(0.8);">
                                        <input type="checkbox" id="wait-friend-enabled" ${settings.enabled ? 'checked' : ''} onchange="toggleWaitFriendCheck(${char.id})">
                                        <span class="slider"></span>
                                    </label>
                                </div>
                                
                                <div style="display:flex; align-items:center; margin-bottom:8px;">
                                    <div style="font-size:13px; color:#333; margin-right:12px;">æ£€æµ‹é—´éš”</div>
                                    <input type="number" id="wait-friend-interval" value="${settings.interval}" min="1" max="1440" 
                                           style="flex:1; padding:6px 10px; border:1px solid #ddd; border-radius:4px; font-size:13px;" 
                                           onchange="saveWaitFriendInterval(${char.id})">
                                    <div style="font-size:13px; color:#666; margin-left:8px;">åˆ†é’Ÿ</div>
                                </div>
                                
                                <div style="font-size:12px; color:#999; margin-top:8px;">${nextCheckText}</div>
                            </div>
                            
                            <button onclick="fastForwardCheck(${char.id})" style="width:100%; padding:12px; background:#fff; border:1px solid var(--ins-pink); color:var(--ins-pink); border-radius:8px; font-size:14px; font-weight:600; margin-bottom:12px;">
                                â© å¿«è¿›æ£€æµ‹
                            </button>
                            
                            <button onclick="manualSendFriendRequest(${char.id})" style="width:100%; padding:12px; background:var(--ins-pink); color:#fff; border:none; border-radius:8px; font-size:14px; font-weight:600;">
                                ä¸»åŠ¨å‘é€å¥½å‹ç”³è¯·
                            </button>
                        </div>
                    </div>
                `;
                return;
            } else if (friendStatus === 'deleted_by_char') {
                // è¢«è§’è‰²åˆ é™¤ï¼šæ˜¾ç¤ºèŠå¤©è®°å½• + åº•éƒ¨é¢æ¿ï¼ˆå‘é€å¥½å‹ç”³è¯· / å¿«è¿›æ—¶é—´ï¼‰
                // ä¸ returnï¼Œç»§ç»­æ¸²æŸ“èŠå¤©è®°å½•
            } else if (friendStatus === 'blocked_by_char') {
                // è¢«è§’è‰²æ‹‰é»‘ï¼šæ˜¾ç¤ºèŠå¤©è®°å½• + åº•éƒ¨é¢æ¿ï¼ˆçŸ­ä¿¡è”ç³» / å¿«è¿›æ—¶é—´ï¼‰
                // ä¸ returnï¼Œç»§ç»­æ¸²æŸ“èŠå¤©è®°å½•
            } else if (friendStatus === 'stranger') {
                // é™Œç”Ÿäººï¼Œæ˜¾ç¤ºå‘é€å¥½å‹ç”³è¯·ç•Œé¢
                body.innerHTML = `
                    <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:100%; padding:40px 20px; text-align:center;">
                        <div style="width:80px; height:80px; border-radius:8px; background-image:url(${getCharAvatar(char, getCurrentAccountId())}); background-size:cover; background-position:center; margin-bottom:20px;"></div>
                        <div style="font-size:18px; font-weight:600; margin-bottom:10px; color:#333;">${getCharDisplayName(char, getCurrentAccountId())}</div>
                        <div style="font-size:14px; color:#999; margin-bottom:30px;">ä½ è¿˜ä¸æ˜¯å¯¹æ–¹çš„å¥½å‹ï¼Œæ— æ³•å‘é€æ¶ˆæ¯</div>
                        <button onclick="showAddFriendToCurrentChat()" style="background:var(--ins-pink); color:#fff; border:none; padding:12px 40px; border-radius:8px; font-size:16px; font-weight:600;">å‘é€å¥½å‹ç”³è¯·</button>
                    </div>
                `;
                return;
            } else if (friendStatus !== 'friend' && friendStatus !== 'deleted_by_char' && friendStatus !== 'blocked_by_char') {
                // å…¶ä»–çŠ¶æ€ï¼Œæ˜¾ç¤ºé»˜è®¤æç¤º
                body.innerHTML = `
                    <div style="display:flex; align-items:center; justify-content:center; height:100%; padding:40px 20px; text-align:center;">
                        <div style="font-size:14px; color:#999;">æ— æ³•å‘é€æ¶ˆæ¯</div>
                    </div>
                `;
                return;
            }
            
            if (!history || history.length === 0) return;

            // åº”ç”¨æ°”æ³¡æ ·å¼ç±»å
            body.classList.remove('bubble-style-default', 'bubble-style-wechat');
            if (char.bubble_style === 'wechat') {
                body.classList.add('bubble-style-wechat');
            } else {
                body.classList.add('bubble-style-default');
            }

            // â˜… fpæ¨¡å¼ä¸‹ï¼šè§’è‰²å¤´åƒä½œä¸ºå³ä¾§(self/user)ï¼Œè”ç³»äººå¤´åƒä½œä¸ºå·¦ä¾§(other/char)
            let renderCharAvatar, renderUserAvatar, renderCharName;
            if (window._fpChatMode) {
                renderCharAvatar = window._fpContactAvatar || '';  // å·¦ä¾§=è”ç³»äºº
                renderUserAvatar = window._fpRoleAvatar || '';     // å³ä¾§=è§’è‰²è‡ªå·±
                renderCharName = window._fpContactName || 'AI';
            } else {
                renderCharAvatar = _dAvatar;
                renderUserAvatar = await getUserAvatarUrl(char.linked_user_id);
                renderCharName = _dName;
            }
            const userAvatarUrl = renderUserAvatar;
            const timeOffset = getEffectiveTimeOffset(char); // è·å–è™šæ‹Ÿæ—¶é—´åç§»

            // ğŸš€ ä¼˜åŒ–ï¼šåªæ¸²æŸ“æœ€è¿‘çš„50æ¡æ¶ˆæ¯
            const renderWindow = 50;
            const totalMessages = history.length;
            const startIndex = Math.max(0, totalMessages - renderWindow);
            const messagesToRender = history.slice(startIndex);
            currentRenderedCount = messagesToRender.length;

            // ğŸš€ æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨ DocumentFragment æ‰¹é‡æ’å…¥ï¼Œé¿å…é€æ¡ appendChild è§¦å‘å¤šæ¬¡ reflow
            const fragment = document.createDocumentFragment();

            // å¦‚æœè¿˜æœ‰æ›´å¤šæ¶ˆæ¯ï¼Œæ·»åŠ "åŠ è½½æ›´å¤š"æŒ‰é’®
            if (startIndex > 0) {
                const loadMoreBtn = document.createElement('div');
                loadMoreBtn.id = 'load-more-btn';
                loadMoreBtn.style.cssText = 'text-align:center; padding:12px; margin:8px 0;';
                loadMoreBtn.innerHTML = `<button onclick="loadMoreMessages()" style="background:#f0f0f0; border:none; padding:8px 20px; border-radius:16px; color:#666; font-size:13px; cursor:pointer;">åŠ è½½æ›´æ—©çš„æ¶ˆæ¯ (${startIndex}æ¡)</button>`;
                fragment.appendChild(loadMoreBtn);
            }

            messagesToRender.forEach((msg, relativeIndex) => {
                const absoluteIndex = startIndex + relativeIndex;
                const prevMsgTime = absoluteIndex > 0 ? history[absoluteIndex - 1].time : null;
                
                // â˜… fpæ¨¡å¼ï¼šç¿»è½¬æ¶ˆæ¯è§’è‰²ï¼ˆcharâ†’useræ˜¾ç¤ºåœ¨å³ä¾§ï¼Œuserâ†’charæ˜¾ç¤ºåœ¨å·¦ä¾§ï¼‰
                let renderMsg = msg;
                if (window._fpChatMode && msg.role !== 'system') {
                    renderMsg = { ...msg, role: msg.role === 'char' ? 'user' : msg.role === 'user' ? 'char' : msg.role };
                }
                
                // å¦‚æœéœ€è¦æ˜¾ç¤ºæ—¶é—´æˆ³ï¼Œå…ˆæ·»åŠ æ—¶é—´æˆ³è¡Œï¼ˆç³»ç»Ÿæ¶ˆæ¯ä¸æ˜¾ç¤ºæ—¶é—´æˆ³ï¼‰
                if (renderMsg.role !== 'system' && shouldShowTimestamp(renderMsg.time, prevMsgTime)) {
                    const timeStamp = document.createElement('div');
                    timeStamp.className = 'message-timestamp';
                    timeStamp.textContent = formatMessageTime(renderMsg.time, prevMsgTime, timeOffset);
                    fragment.appendChild(timeStamp);
                }
                
                const row = createMessageElement(renderMsg, absoluteIndex, renderCharAvatar, renderUserAvatar, prevMsgTime, renderCharName);
                
                // å¦‚æœåœ¨å¤šé€‰æ¨¡å¼ï¼Œæ¢å¤é€‰ä¸­çŠ¶æ€ï¼ˆåŒ…æ‹¬ç³»ç»Ÿæ¶ˆæ¯ï¼‰
                if (isSelectionMode) {
                    const cb = row.querySelector('.msg-checkbox');
                    if (cb) {
                        cb.style.display = 'flex';
                        if (selectedIndices.has(absoluteIndex)) {
                            cb.classList.add('checked');
                            cb.style.background = 'var(--ins-pink)';
                            cb.style.borderColor = 'var(--ins-pink)';
                            cb.innerHTML = '<svg viewBox="0 0 24 24" style="width:14px;height:14px;stroke:#fff;stroke-width:3;fill:none;"><polyline points="20 6 9 17 4 12"></polyline></svg>';
                        }
                        // ç³»ç»Ÿæ¶ˆæ¯éœ€è¦æ·»åŠ padding
                        if (msg.role === 'system') {
                            row.style.paddingLeft = '40px';
                        }
                    }
                }
                
                fragment.appendChild(row);
            });

            // ä¸€æ¬¡æ€§æ’å…¥æ‰€æœ‰æ¶ˆæ¯åˆ° DOMï¼ˆåªè§¦å‘ä¸€æ¬¡ reflowï¼‰
            body.appendChild(fragment);
            
            // å¦‚æœæ˜¯è¢«æ‹‰é»‘çŠ¶æ€ï¼Œä¸éœ€è¦åœ¨åº•éƒ¨æ·»åŠ ç”µè¯è®°å½•åŒºåŸŸï¼Œå› ä¸ºå·²ç»æ”¹åˆ°æ¡Œé¢åº”ç”¨äº†
            /*
            if (friendStatus === 'blocked') {
                const callSection = document.createElement('div');
                callSection.style.cssText = 'padding:16px; background:#f9f9f9; border-top:1px solid #f0f0f0; margin-top:20px;';
                callSection.innerHTML = `
                    <div style="font-size:14px; font-weight:600; margin-bottom:12px; color:#333;">ğŸ“ ç”µè¯è®°å½•</div>
                    <div id="blocked-calls-list" style="font-size:12px; color:#666;">
                        <!-- åŠ¨æ€ç”Ÿæˆç”µè¯è®°å½• -->
                    </div>
                `;
                body.appendChild(callSection);
                loadBlockedCallRecords(char.id, accountId);
            }
            */
            
            // ğŸ¯ è¢«è§’è‰²åˆ é™¤ï¼šæ˜¾ç¤ºèŠå¤©è®°å½•åçš„æ“ä½œé¢æ¿
            if (friendStatus === 'deleted_by_char') {
                const panel = document.createElement('div');
                panel.style.cssText = 'padding:16px; margin-top:20px;';
                panel.innerHTML = `
                    <div style="background:#fff3cd; border-radius:12px; padding:16px; margin-bottom:12px; border:1px solid #ffc107;">
                        <div style="font-size:14px; font-weight:600; margin-bottom:8px; color:#856404;">ğŸ˜¢ å¯¹æ–¹å·²å°†ä½ åˆ é™¤å¥½å‹</div>
                        <div style="font-size:12px; color:#856404; line-height:1.6;">
                            ${char.name} æŠŠä½ åˆ é™¤äº†å¥½å‹å…³ç³»ã€‚ä½ å¯ä»¥å°è¯•é‡æ–°å‘é€å¥½å‹ç”³è¯·ï¼Œæˆ–è€…å¿«è¿›æ—¶é—´ç­‰ Ta ä¸»åŠ¨åŠ ä½ å›æ¥ã€‚
                        </div>
                    </div>
                    
                    <button onclick="sendFriendRequestAfterCharDelete(${char.id})" style="width:100%; padding:12px; background:var(--ins-pink); color:#fff; border:none; border-radius:8px; font-size:14px; font-weight:600; margin-bottom:10px;">
                        ğŸ“© å‘é€å¥½å‹ç”³è¯·
                    </button>
                    
                    <button onclick="fastForwardDeletedByChar(${char.id})" style="width:100%; padding:12px; background:#fff; border:1px solid var(--ins-pink); color:var(--ins-pink); border-radius:8px; font-size:14px; font-weight:600;">
                        â© å¿«è¿›æ—¶é—´ï¼ˆTaå¯èƒ½ä¼šåŠ ä½ å›æ¥ï¼‰
                    </button>
                `;
                body.appendChild(panel);
            }
            
            // ğŸ¯ è¢«è§’è‰²æ‹‰é»‘ï¼šæ˜¾ç¤ºèŠå¤©è®°å½•åçš„æ“ä½œé¢æ¿
            if (friendStatus === 'blocked_by_char') {
                const panel = document.createElement('div');
                panel.style.cssText = 'padding:16px; margin-top:20px;';
                panel.innerHTML = `
                    <div style="background:#f8d7da; border-radius:12px; padding:16px; margin-bottom:12px; border:1px solid #f5c6cb;">
                        <div style="font-size:14px; font-weight:600; margin-bottom:8px; color:#721c24;">ğŸš« å¯¹æ–¹å·²å°†ä½ æ‹‰é»‘</div>
                        <div style="font-size:12px; color:#721c24; line-height:1.6;">
                            ${char.name} æŠŠä½ æ‹‰é»‘äº†ã€‚ä½ æ— æ³•å‘é€å¥½å‹ç”³è¯·ï¼Œä½†å¯ä»¥é€šè¿‡çŸ­ä¿¡è”ç³» Taï¼Œæˆ–è€…å¿«è¿›æ—¶é—´ç­‰ Ta è‡ªå·±æ¶ˆæ°”åæ”¾ä½ å‡ºæ¥ã€‚
                        </div>
                    </div>
                    
                    <button onclick="sendSmsToBlockedChar(${char.id})" style="width:100%; padding:12px; background:#007AFF; color:#fff; border:none; border-radius:8px; font-size:14px; font-weight:600; margin-bottom:10px;">
                        ğŸ’¬ é€šè¿‡çŸ­ä¿¡è”ç³» Ta
                    </button>
                    
                    <button onclick="fastForwardBlockedByChar(${char.id})" style="width:100%; padding:12px; background:#fff; border:1px solid #007AFF; color:#007AFF; border-radius:8px; font-size:14px; font-weight:600;">
                        â© å¿«è¿›æ—¶é—´ï¼ˆTaå¯èƒ½ä¼šæ”¾ä½ å‡ºæ¥ï¼‰
                    </button>
                `;
                body.appendChild(panel);
            }
            
            // æ»šåŠ¨åˆ°åº•éƒ¨ (å¦‚æœåœ¨å¤šé€‰æ¨¡å¼ï¼Œå¯èƒ½ä¸éœ€è¦æ»šåˆ°åº•éƒ¨ï¼Ÿè¿™é‡Œæš‚ä¸”ä¿æŒæ»šåŠ¨)
            if (!isSelectionMode) {
                setTimeout(() => {
                    body.scrollTop = body.scrollHeight;
                }, 0);
            }
            
            // åº”ç”¨è‡ªå®šä¹‰æ ·å¼
            applyCustomStyles(char);
            
            // åº”ç”¨èŠå¤©èƒŒæ™¯å›¾
            applyChatBackground(char);
        }

        // ğŸš€ åŠ è½½æ›´å¤šæ¶ˆæ¯ï¼ˆæ‡’åŠ è½½ä¼˜åŒ–ï¼‰
        async function loadMoreMessages() {
            if (isLoadingMoreMessages) return;
            if (!currentChatCharId) return;
            
            isLoadingMoreMessages = true;
            
            try {
                const char = await db.characters.get(currentChatCharId);
                if (!char) {
                    console.warn('[loadMoreMessages] è§’è‰²ä¸å­˜åœ¨:', currentChatCharId);
                    return;
                }
                const accountId = getCurrentAccountId();
                const history = getChatHistory(char, accountId);
                const body = document.getElementById('chat-body');
                if (!body) return;
                
                // è®¡ç®—è¦åŠ è½½çš„æ¶ˆæ¯èŒƒå›´
                const renderWindow = 50;
                const totalMessages = history.length;
                const nextSliceEnd = totalMessages - currentRenderedCount;
                
                // ğŸ”§ ä¿®å¤ï¼šnextSliceEnd <= 0 è¡¨ç¤ºæ‰€æœ‰æ¶ˆæ¯éƒ½å·²åŠ è½½ï¼Œç›´æ¥è¿”å›
                if (nextSliceEnd <= 0) {
                    // ç§»é™¤å¤šä½™çš„"åŠ è½½æ›´å¤š"æŒ‰é’®
                    const oldBtn = document.getElementById('load-more-btn');
                    if (oldBtn) oldBtn.remove();
                    return;
                }
                
                // ğŸ”§ ä¿®å¤ï¼šnextSliceStart å¯ä»¥ < 0ï¼Œç”¨ Math.max(0, ...) å¤„ç†å³å¯
                // ä¹‹å‰ nextSliceStart < 0 ç›´æ¥ return ä¼šå¯¼è‡´å‰©ä½™ä¸è¶³50æ¡çš„æ¶ˆæ¯æ°¸è¿œæ— æ³•åŠ è½½
                const nextSliceStart = Math.max(0, nextSliceEnd - renderWindow);
                
                const messagesToPrepend = history.slice(nextSliceStart, nextSliceEnd);
                
                if (messagesToPrepend.length === 0) {
                    return;
                }
                
                // ä¿å­˜å½“å‰æ»šåŠ¨ä½ç½®
                const oldScrollHeight = body.scrollHeight;
                
                // ç§»é™¤æ—§çš„"åŠ è½½æ›´å¤š"æŒ‰é’®
                const oldLoadMoreBtn = document.getElementById('load-more-btn');
                if (oldLoadMoreBtn) {
                    oldLoadMoreBtn.remove();
                }
                
                // å¦‚æœè¿˜æœ‰æ›´å¤šæ¶ˆæ¯ï¼Œæ·»åŠ æ–°çš„"åŠ è½½æ›´å¤š"æŒ‰é’®
                if (nextSliceStart > 0) {
                    const loadMoreBtn = document.createElement('div');
                    loadMoreBtn.id = 'load-more-btn';
                    loadMoreBtn.style.cssText = 'text-align:center; padding:12px; margin:8px 0;';
                    loadMoreBtn.innerHTML = `<button onclick="loadMoreMessages()" style="background:#f0f0f0; border:none; padding:8px 20px; border-radius:16px; color:#666; font-size:13px; cursor:pointer;">åŠ è½½æ›´æ—©çš„æ¶ˆæ¯ (${nextSliceStart}æ¡)</button>`;
                    body.insertBefore(loadMoreBtn, body.firstChild);
                }
                
                // å‡†å¤‡è¦æ·»åŠ çš„æ¶ˆæ¯å…ƒç´ 
                const userAvatarUrl = await getUserAvatarUrl(char.linked_user_id);
                const timeOffset = getEffectiveTimeOffset(char);
                const fragment = document.createDocumentFragment();
                
                messagesToPrepend.forEach((msg, relativeIndex) => {
                    const absoluteIndex = nextSliceStart + relativeIndex;
                    const prevMsgTime = absoluteIndex > 0 ? history[absoluteIndex - 1].time : null;
                    
                    // æ·»åŠ æ—¶é—´æˆ³
                    if (msg.role !== 'system' && shouldShowTimestamp(msg.time, prevMsgTime)) {
                        const timeStamp = document.createElement('div');
                        timeStamp.className = 'message-timestamp';
                        timeStamp.textContent = formatMessageTime(msg.time, prevMsgTime, timeOffset);
                        fragment.appendChild(timeStamp);
                    }
                    
                    const _ldAvatar = getCharAvatar(char, accountId);
                    const _ldName = getCharDisplayName(char, accountId);
                    const row = createMessageElement(msg, absoluteIndex, _ldAvatar, userAvatarUrl, prevMsgTime, _ldName);
                    fragment.appendChild(row);
                });
                
                // æ’å…¥æ¶ˆæ¯åˆ°é¡¶éƒ¨
                const firstMessage = body.querySelector('.message-row, .message-system');
                if (firstMessage) {
                    body.insertBefore(fragment, firstMessage);
                } else {
                    body.appendChild(fragment);
                }
                
                // æ¢å¤æ»šåŠ¨ä½ç½®
                const newScrollHeight = body.scrollHeight;
                body.scrollTop = newScrollHeight - oldScrollHeight;
                
                // æ›´æ–°å·²æ¸²æŸ“è®¡æ•°
                currentRenderedCount += messagesToPrepend.length;
                
                console.log(`[loadMoreMessages] åŠ è½½äº† ${messagesToPrepend.length} æ¡æ¶ˆæ¯ï¼Œæ€»è®¡å·²æ¸²æŸ“ ${currentRenderedCount} æ¡`);
            } catch (err) {
                console.error('[loadMoreMessages] åŠ è½½å†å²æ¶ˆæ¯å‡ºé”™:', err);
            } finally {
                // ğŸ”§ ä¿®å¤ï¼šæ— è®ºæˆåŠŸè¿˜æ˜¯å¤±è´¥ï¼Œéƒ½å¿…é¡»é‡ç½®æ ‡è®°ï¼Œå¦åˆ™æŒ‰é’®ä¼šæ°¸ä¹…å¤±æ•ˆ
                isLoadingMoreMessages = false;
            }
        }
        
        // æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸï¼Œä¾› HTML onclick ä½¿ç”¨
        window.loadMoreMessages = loadMoreMessages;

        // è¿½åŠ å•æ¡æ¶ˆæ¯ (ä¸»è¦ç”¨äº AI å›å¤æ—¶çš„æµå¼è¾“å‡ºï¼Œä¸é‡ç»˜æ•´ä¸ªåˆ—è¡¨)
        // æ³¨æ„ï¼šè¿½åŠ çš„æ¶ˆæ¯éœ€è¦é‡æ–°ç»‘å®šäº‹ä»¶ï¼Œä¸”æ­¤æ—¶é€šå¸¸ä¸åœ¨å¤šé€‰æ¨¡å¼
        async function appendMessageToUI(role, content, charAvatar, elemId) {
            const body = document.getElementById('chat-body');
            
            // ç³»ç»Ÿæ¶ˆæ¯ç‰¹æ®Šå¤„ç†
            if (role === 'system') {
                const sysDiv = document.createElement('div');
                sysDiv.style.cssText = 'text-align:center; padding:8px 16px; margin:8px 0;';
                sysDiv.innerHTML = `<span style="background:#fff; color:#999; font-size:12px; padding:4px 12px; border-radius:4px; border:1px solid #ddd;">${content}</span>`;
                body.appendChild(sysDiv);
                body.scrollTop = body.scrollHeight;
                return;
            }
            
            // è·å–æ•°æ®åº“ä¸­çš„å®é™…æ¶ˆæ¯ï¼ˆç¡®ä¿ ID å’Œæ—¶é—´æˆ³ä¸€è‡´ï¼‰
            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            const history = getChatHistory(char, accountId);
            
            // âœ… å§‹ç»ˆä»æ•°æ®åº“è·å–æœ€æ–°å¤´åƒï¼ˆé˜²æ­¢è°ƒç”¨æ–¹ä¼ çš„æ˜¯æ—§å¤´åƒï¼‰
            if (char) {
                charAvatar = getCharAvatar(char, accountId) || charAvatar;
            }
            
            // ğŸ”§ ä¿®å¤ï¼šä¼˜å…ˆåŒ¹é… role + content éƒ½ä¸€è‡´çš„æ¶ˆæ¯ï¼Œé¿å…åŒ¹é…åˆ°ä¼ªé€ æ¶ˆæ¯
            let msg = null;
            let index = history.length - 1;
            
            // ç¬¬ä¸€è½®ï¼šç²¾ç¡®åŒ¹é… role + content
            const cleanedContent = sanitizeMessage(content);
            for (let i = history.length - 1; i >= 0; i--) {
                if (history[i].role === role && history[i].content === cleanedContent) {
                    msg = history[i];
                    index = i;
                    break;
                }
            }
            
            // ç¬¬äºŒè½®ï¼šå¦‚æœç²¾ç¡®åŒ¹é…å¤±è´¥ï¼ŒåªåŒ¹é… roleï¼ˆå…¼å®¹æ—§é€»è¾‘ï¼‰
            if (!msg) {
                for (let i = history.length - 1; i >= 0; i--) {
                    if (history[i].role === role) {
                        msg = history[i];
                        index = i;
                        break;
                    }
                }
            }
            
            // å¦‚æœæ•°æ®åº“ä¸­æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„æ¶ˆæ¯ï¼Œä½¿ç”¨ä¸´æ—¶å¯¹è±¡
            if (!msg) {
                msg = { role, content: cleanedContent, time: Date.now() };
                index = history.length;
            }
            
            // ğŸ”¥ ç¡®ä¿æ˜¾ç¤ºçš„å†…å®¹æ˜¯ä¼ å…¥çš„ contentï¼Œè€Œä¸æ˜¯å†å²è®°å½•ä¸­å¯èƒ½ä¸åŒçš„å†…å®¹
            if (content && msg.content !== cleanedContent) {
                msg = { ...msg, content: cleanedContent };
            }
            
            const userAvatarUrl = await getUserAvatarUrl(char.linked_user_id);
            const timeOffset = getEffectiveTimeOffset(char); // è·å–è™šæ‹Ÿæ—¶é—´åç§»
            
            // è·å–å‰ä¸€æ¡æ¶ˆæ¯çš„æ—¶é—´
            const prevMsgTime = index > 0 && history[index - 1] ? history[index - 1].time : null;
            
            // å¦‚æœéœ€è¦æ˜¾ç¤ºæ—¶é—´æˆ³ï¼Œå…ˆæ·»åŠ æ—¶é—´æˆ³è¡Œ
            if (shouldShowTimestamp(msg.time, prevMsgTime)) {
                const timeStamp = document.createElement('div');
                timeStamp.className = 'message-timestamp';
                timeStamp.textContent = formatMessageTime(msg.time, prevMsgTime, timeOffset);
                body.appendChild(timeStamp);
            }

            const row = createMessageElement(msg, index, charAvatar, userAvatarUrl, prevMsgTime, char ? char.name : 'AI');
            if (elemId) row.id = elemId;
            
            body.appendChild(row);
            body.scrollTop = body.scrollHeight;
        }

        // --- æ ¸å¿ƒäº¤äº’ï¼šé•¿æŒ‰ä¸èœå• ---
        function bindMessageEvents(element, index, isSystemMsg) {
            let touchMoved = false;
            let touchStartEvent = null;
            let touchStartX = 0; // è®°å½•è§¦æ‘¸èµ·å§‹åæ ‡
            let touchStartY = 0;
            let touchHandledTranslation = false; // ğŸ”§ é˜²æ­¢ touchend + click åŒé‡è§¦å‘ç¿»è¯‘é—ªçƒ
            
            const startHandler = (e) => {
                if (isSelectionMode) return; // å¤šé€‰æ¨¡å¼ä¸‹ç¦ç”¨é•¿æŒ‰
                isLongPress = false;
                touchMoved = false;
                // ğŸ”§ ä¿®å¤ï¼šåªåœ¨ touchstart æ—¶é‡ç½®æ ‡è®°ï¼Œmousedown ä¸é‡ç½®
                // å› ä¸ºæ‰‹æœºç«¯äº‹ä»¶é¡ºåºæ˜¯ touchstart â†’ touchend â†’ mousedown â†’ click
                // å¦‚æœ mousedown ä¹Ÿé‡ç½®ï¼Œtouchend é‡Œè®¾çš„ true ä¼šè¢«è¦†ç›–ï¼Œå¯¼è‡´ click å†æ¬¡è§¦å‘ç¿»è¯‘åˆ‡æ¢ï¼ˆé—ªçƒï¼‰
                if (e.type === 'touchstart') {
                    touchHandledTranslation = false;
                }
                touchStartEvent = e;
                // è®°å½•èµ·å§‹è§¦æ‘¸åæ ‡ï¼ˆç”¨äºåˆ¤æ–­æ˜¯å¦çœŸæ­£æ»‘åŠ¨ï¼‰
                if (e.touches && e.touches[0]) {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                } else {
                    touchStartX = e.clientX || 0;
                    touchStartY = e.clientY || 0;
                }
                longPressTimer = setTimeout(() => {
                    isLongPress = true;
                    // é•¿æŒ‰è§¦å‘æ—¶é˜»æ­¢æµè§ˆå™¨åç»­é»˜è®¤è¡Œä¸ºï¼ˆå¦‚æ–‡å­—é€‰æ‹©èœå•ï¼‰
                    try { 
                        if (touchStartEvent && touchStartEvent.cancelable) {
                            touchStartEvent.preventDefault();
                        }
                    } catch(ex) {}
                    showContextMenu(e, index, element, isSystemMsg);
                }, 400); // 400ms é•¿æŒ‰è§¦å‘ï¼ˆé™ä½é—¨æ§›ï¼Œæ›´å®¹æ˜“è§¦å‘ï¼‰
            };

            const cancelHandler = (e) => {
                // âœ… æ‰‹æœºç«¯å®¹é”™ï¼šæ‰‹æŒ‡å¾®å°æŠ–åŠ¨ä¸å–æ¶ˆé•¿æŒ‰ï¼ˆé˜ˆå€¼10pxï¼‰
                if (e && (e.touches || e.clientX !== undefined)) {
                    const cx = e.touches ? e.touches[0].clientX : e.clientX;
                    const cy = e.touches ? e.touches[0].clientY : e.clientY;
                    const dx = Math.abs(cx - touchStartX);
                    const dy = Math.abs(cy - touchStartY);
                    if (dx < 10 && dy < 10) return; // å¾®å°ç§»åŠ¨ï¼Œä¸å–æ¶ˆ
                }
                touchMoved = true;
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            };
            
            const endHandler = (e) => {
                // endHandler ç›´æ¥æ¸…ç†å®šæ—¶å™¨ï¼Œä¸èµ° cancelHandler çš„è·ç¦»åˆ¤æ–­
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                touchStartEvent = null;
                if (isLongPress) {
                    e.preventDefault(); // é˜»æ­¢é»˜è®¤ç‚¹å‡»
                    e.stopPropagation();
                    return;
                }
                
                // çŸ­æŒ‰ä¸”æ²¡æœ‰æ»‘åŠ¨ â†’ å½“ä½œç‚¹å‡»å¤„ç†ï¼ˆä»…è§¦æ‘¸è®¾å¤‡åœ¨æ­¤å¤„ç†ç¿»è¯‘ï¼‰
                if (!touchMoved && !isSelectionMode) {
                    if (element.dataset.hasTranslation === 'true') {
                        toggleTranslation(element);
                        touchHandledTranslation = true; // ğŸ”§ æ ‡è®°å·²å¤„ç†ï¼Œé˜²æ­¢åç»­clickå†æ¬¡è§¦å‘
                    }
                }
            };

            // è§¦æ‘¸è®¾å¤‡ - passive:false å…è®¸åœ¨é•¿æŒ‰æ—¶è°ƒç”¨preventDefaulté˜»æ­¢æµè§ˆå™¨é»˜è®¤èœå•
            element.addEventListener('touchstart', startHandler, {passive: false});
            element.addEventListener('touchmove', cancelHandler, {passive: true});
            element.addEventListener('touchend', endHandler);
            
            // PC é¼ æ ‡ - ç”¨clickäº‹ä»¶å¤„ç†ç¿»è¯‘ï¼ˆPCç«¯clickå¯é ï¼‰
            element.addEventListener('mousedown', startHandler);
            element.addEventListener('mousemove', cancelHandler); // ç§»åŠ¨ç®—å–æ¶ˆ
            element.addEventListener('mouseup', (e) => {
                cancelHandler();
                if (isLongPress) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            });
            element.addEventListener('click', (e) => {
                if (isLongPress || isSelectionMode) return;
                if (e.target.tagName === 'A' || e.target.tagName === 'IMG') return;
                // ğŸ”§ ä¿®å¤ï¼šå¦‚æœ touchend å·²ç»å¤„ç†è¿‡ç¿»è¯‘ï¼Œè·³è¿‡ clickï¼Œé˜²æ­¢åŒé‡è§¦å‘å¯¼è‡´é—ªçƒ
                if (touchHandledTranslation) {
                    touchHandledTranslation = false; // é‡ç½®æ ‡è®°
                    return;
                }
                // ç¿»è¯‘æ¶ˆæ¯ï¼šåˆ‡æ¢ç¿»è¯‘æ˜¾ç¤ºï¼ˆä»…PCé¼ æ ‡ç‚¹å‡»æ—¶èµ°åˆ°è¿™é‡Œï¼‰
                if (element.dataset.hasTranslation === 'true') {
                    toggleTranslation(element);
                }
            });
            // ç¦ç”¨å³é”®é»˜è®¤èœå•ï¼ˆåŒæ—¶è¦†ç›–æ‰‹æœºç«¯é•¿æŒ‰è§¦å‘çš„contextmenuï¼‰
            element.addEventListener('contextmenu', (e) => e.preventDefault());
        }
        
        // åˆ‡æ¢ç¿»è¯‘æ˜¾ç¤º/éšè—
        function toggleTranslation(element) {
            const isExpanded = element.dataset.expanded === 'true';
            let transEl = element.querySelector('.msg-translation');
            
            if (isExpanded) {
                // æ”¶èµ·ç¿»è¯‘
                if (transEl) transEl.style.display = 'none';
                element.dataset.expanded = 'false';
            } else {
                // æ˜¾ç¤ºç¿»è¯‘
                if (!transEl) {
                    transEl = document.createElement('div');
                    transEl.className = 'msg-translation';
                    transEl.innerHTML = renderMessageContent(element.dataset.chinese);
                    element.appendChild(transEl);
                } else {
                    transEl.style.display = 'block';
                }
                element.dataset.expanded = 'true';
            }
        }

        function showContextMenu(event, index, element, isSystemMsg) {
            // éœ‡åŠ¨åé¦ˆ (Android)
            if (navigator.vibrate) navigator.vibrate(50);
            
            activeMsgIndex = index;
            // é«˜äº®ï¼šç³»ç»Ÿæ¶ˆæ¯é«˜äº®æ•´ä¸ªrowï¼Œæ™®é€šæ¶ˆæ¯é«˜äº®content
            if (isSystemMsg) {
                const row = element.closest('.message-system') || element.closest('.message-row');
                if (row) row.classList.add('active');
            } else {
                element.classList.add('active');
            }

            const menu = document.getElementById('msg-context-menu');
            const overlay = document.getElementById('menu-overlay');
            
            // ç³»ç»Ÿæ¶ˆæ¯åªæ˜¾ç¤º"åˆ é™¤"æŒ‰é’®ï¼Œéšè—å…¶ä»–èœå•é¡¹
            const menuItems = menu.querySelectorAll('.context-menu-item');
            menuItems.forEach(item => {
                const label = item.querySelector('span')?.textContent;
                if (isSystemMsg) {
                    item.style.display = (label === 'åˆ é™¤') ? 'flex' : 'none';
                } else {
                    item.style.display = 'flex';
                }
            });
            
            // è®¡ç®—åæ ‡
            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            const winWidth = window.innerWidth;
            const winHeight = window.innerHeight;

            // âœ… å…ˆæ˜¾ç¤ºèœå•ä»¥è·å–çœŸå®å°ºå¯¸ï¼ˆflex-wrap å¯èƒ½å¯¼è‡´å¤šè¡Œï¼‰
            menu.style.display = 'flex';
            menu.style.left = '0px';
            menu.style.top = '0px';
            
            // å¼ºåˆ¶é‡æ–°å¸ƒå±€ä»¥è·å–å‡†ç¡®çš„å°ºå¯¸
            const menuWidth = menu.offsetWidth;
            const menuHeight = menu.offsetHeight;
            
            // âœ… æ°´å¹³å±…ä¸­äºç‚¹å‡»ä½ç½®ï¼ŒåŒæ—¶ç¡®ä¿ä¸è¶…å‡ºå±å¹•
            let menuX = clientX - menuWidth / 2;
            if (menuX + menuWidth > winWidth - 10) {
                menuX = winWidth - menuWidth - 10;
            }
            if (menuX < 10) {
                menuX = 10;
            }
            
            // âœ… å‚ç›´ï¼šä¼˜å…ˆæ˜¾ç¤ºåœ¨ç‚¹å‡»ä½ç½®ä¸Šæ–¹
            let menuY = clientY - menuHeight - 10;
            if (menuY < 10) {
                menuY = clientY + 10; // ä¸Šæ–¹ç©ºé—´ä¸å¤Ÿï¼Œæ˜¾ç¤ºåœ¨ä¸‹æ–¹
            }
            if (menuY + menuHeight > winHeight - 10) {
                menuY = winHeight - menuHeight - 10;
            }

            menu.style.left = menuX + 'px';
            menu.style.top = menuY + 'px';
            
            // å…ˆç¦ç”¨overlayç‚¹å‡»ï¼Œé˜²æ­¢touchendåˆæˆçš„clickäº‹ä»¶ç«‹åˆ»å…³é—­èœå•
            overlay.style.display = 'block';
            overlay.style.pointerEvents = 'none';
            setTimeout(() => {
                overlay.style.pointerEvents = 'auto';
            }, 350);
        }

        function hideContextMenu() {
            const menu = document.getElementById('msg-context-menu');
            const overlay = document.getElementById('menu-overlay');
            menu.style.display = 'none';
            overlay.style.display = 'none';
            
            // ç§»é™¤é«˜äº®ï¼ˆåŒ…æ‹¬ç³»ç»Ÿæ¶ˆæ¯å’Œæ™®é€šæ¶ˆæ¯ï¼‰
            document.querySelectorAll('.message-content.active, .message-system.active, .message-row.active').forEach(el => el.classList.remove('active'));
        }

        // --- èœå•åŠŸèƒ½å®ç° ---
        
        // 0. å¤åˆ¶æ¶ˆæ¯å†…å®¹
        async function handleMsgCopy() {
            hideContextMenu();
            if (activeMsgIndex === -1) return;
            
            let textToCopy = '';
            
            // ç¾¤èŠå¤åˆ¶
            if (window.currentGroupChatId) {
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (group && group.chat_history && group.chat_history[activeMsgIndex]) {
                    const msg = group.chat_history[activeMsgIndex];
                    textToCopy = msg.content || '';
                }
            } else {
                // ç§èŠå¤åˆ¶
                if (!currentChatCharId) return;
                const char = await db.characters.get(currentChatCharId);
                const accountId = getCurrentAccountId();
                let history = getChatHistory(char, accountId);
                const msg = history[activeMsgIndex];
                if (msg) {
                    textToCopy = msg.content || '';
                }
            }
            
            // æ¸…ç†ç‰¹æ®Šæ ¼å¼ï¼š[img:...] â†’ [å›¾ç‰‡], [voice:...] â†’ [è¯­éŸ³]
            textToCopy = textToCopy
                .replace(/\[img:[^\]]*\]/g, '[å›¾ç‰‡]')
                .replace(/\[voice:[^\]]*\]/g, '[è¯­éŸ³]')
                .replace(/\[sticker:[^\]]*\]/g, '[è¡¨æƒ…]');
            
            // å¦‚æœæ˜¯è½¬è´¦ç­‰ JSON æ ¼å¼æ¶ˆæ¯ï¼Œæå–å¯è¯»å†…å®¹
            if (textToCopy.startsWith('{') && textToCopy.includes('"amount"')) {
                try {
                    const data = JSON.parse(textToCopy);
                    textToCopy = `[è½¬è´¦] Â¥${data.amount} ${data.desc || ''}`.trim();
                } catch(e) {}
            }
            
            if (!textToCopy) {
                showToast('æ— å†…å®¹å¯å¤åˆ¶');
                return;
            }
            
            try {
                await navigator.clipboard.writeText(textToCopy);
                showToast('å·²å¤åˆ¶');
            } catch (e) {
                // é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨ textarea å¤åˆ¶
                const ta = document.createElement('textarea');
                ta.value = textToCopy;
                ta.style.cssText = 'position:fixed;left:-9999px;top:-9999px;opacity:0;';
                document.body.appendChild(ta);
                ta.select();
                try {
                    document.execCommand('copy');
                    showToast('å·²å¤åˆ¶');
                } catch (ex) {
                    showToast('å¤åˆ¶å¤±è´¥');
                }
                document.body.removeChild(ta);
            }
        }
        
        // === ç¼–è¾‘æ¶ˆæ¯å¼¹çª— ===
        let editMsgCallback = null; // ä¿å­˜ç¼–è¾‘å®Œæˆåçš„å›è°ƒ

        function openEditMsgModal(content, callback) {
            const modal = document.getElementById('edit-msg-modal');
            const textarea = document.getElementById('edit-msg-textarea');
            textarea.value = content || '';
            editMsgCallback = callback;
            modal.style.display = 'flex';
            // å»¶è¿Ÿèšç„¦ï¼Œè®©åŠ¨ç”»å…ˆæ’­æ”¾
            setTimeout(() => {
                textarea.focus();
                // å…‰æ ‡ç§»åˆ°æœ«å°¾
                textarea.selectionStart = textarea.selectionEnd = textarea.value.length;
            }, 100);
        }

        function closeEditMsgModal() {
            const modal = document.getElementById('edit-msg-modal');
            modal.style.display = 'none';
            editMsgCallback = null;
        }

        function confirmEditMsg() {
            const textarea = document.getElementById('edit-msg-textarea');
            const newContent = textarea.value.trim();
            if (!newContent) {
                showToast('æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º');
                return;
            }
            if (editMsgCallback) {
                editMsgCallback(newContent);
            }
            closeEditMsgModal();
        }

        // 1. ç¼–è¾‘
        async function handleMsgEdit() {
            hideContextMenu();
            if (activeMsgIndex === -1) return;
            
            // ç¾¤èŠç¼–è¾‘
            if (window.currentGroupChatId) {
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (!group || !group.chat_history) return;
                
                const msg = group.chat_history[activeMsgIndex];
                if (!msg || msg.role === 'system') {
                    showToast("ç³»ç»Ÿæ¶ˆæ¯ä¸èƒ½ç¼–è¾‘");
                    return;
                }
                
                if (msg.content.startsWith('[img:') || msg.type === 'redpacket' || msg.type === 'transfer') {
                    showToast("è¯¥æ¶ˆæ¯ç±»å‹æš‚ä¸æ”¯æŒç¼–è¾‘");
                    return;
                }

                const editIndex = activeMsgIndex;
                openEditMsgModal(msg.content, async (newContent) => {
                    const grp = await db.group_chats.get(window.currentGroupChatId);
                    if (!grp || !grp.chat_history) return;
                    grp.chat_history[editIndex].content = newContent;
                    await safeGroupChatPut(grp);
                    
                    // ç›´æ¥æ›´æ–°DOMï¼Œä¸åˆ·æ–°æ•´ä¸ªç¾¤èŠ
                    const chatBody = document.getElementById('chat-body');
                    const msgEl = chatBody.querySelector(`[data-index="${editIndex}"]`);
                    if (msgEl) {
                        const messageContent = msgEl.querySelector('.message-content') || msgEl.querySelector('.group-msg-content');
                        if (messageContent) {
                            messageContent.innerHTML = renderMessageContent(newContent);
                        }
                    }
                });
                return;
            }
            
            // ç§èŠç¼–è¾‘
            if (!currentChatCharId) return;
            
            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            let history = getChatHistory(char, accountId);
            const msg = history[activeMsgIndex];
            
            if (msg.content.startsWith('[img:')) {
                showToast("å›¾ç‰‡æ¶ˆæ¯æš‚ä¸æ”¯æŒç¼–è¾‘");
                return;
            }

            const editIndex = activeMsgIndex;
            const editCharId = currentChatCharId;
            openEditMsgModal(msg.content, async (newContent) => {
                const c = await db.characters.get(editCharId);
                const aid = getCurrentAccountId();
                let h = getChatHistory(c, aid);
                if (!h[editIndex]) return;
                h[editIndex].content = newContent;
                await setChatHistory(c, aid, h);
                
                // ğŸ”§ ç«‹å³æ›´æ–°UIï¼Œç”¨data-indexç²¾ç¡®å®šä½ï¼Œä¸é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©
                const chatBody = document.getElementById('chat-body');
                const msgEl = chatBody.querySelector(`[data-index="${editIndex}"]`);
                if (msgEl) {
                    const messageContent = msgEl.querySelector('.message-content');
                    if (messageContent) {
                        messageContent.innerHTML = renderMessageContent(newContent);
                    }
                }
            });
        }

        // 2. æ’¤å›ï¼ˆä¿å­˜åŸå†…å®¹ï¼Œç‚¹å‡»å¯æŸ¥çœ‹ï¼‰
        async function handleMsgRecall() {
            hideContextMenu();
            if (activeMsgIndex === -1) return;
            
            if (!confirm("ç¡®å®šè¦æ’¤å›è¿™æ¡æ¶ˆæ¯å—ï¼Ÿ")) return;
            
            // ç¾¤èŠæ’¤å›
            if (window.currentGroupChatId) {
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (!group || !group.chat_history) return;
                
                const msg = group.chat_history[activeMsgIndex];
                if (!msg || msg.role === 'system') {
                    showToast("ç³»ç»Ÿæ¶ˆæ¯ä¸èƒ½æ’¤å›");
                    return;
                }
                
                const isUser = msg.role === 'user';
                const recallerName = isUser ? 'ä½ ' : 'æˆå‘˜';
                
                msg.recalledContent = msg.content;
                msg.isRecalled = true;
                msg.content = "";
                msg.type = 'recalled';
                
                group.chat_history[activeMsgIndex] = msg;
                
                // æ·»åŠ æ’¤å›æç¤ºç³»ç»Ÿæ¶ˆæ¯
                group.chat_history.splice(activeMsgIndex + 1, 0, {
                    role: 'system',
                    content: `"${recallerName}"æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯`,
                    time: Date.now(),
                    recalledContent: msg.recalledContent
                });
                
                await safeGroupChatPut(group);
                await renderGroupChatBody(group);
                return;
            }

            // ç§èŠæ’¤å›
            if (!currentChatCharId) return;
            
            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            let history = getChatHistory(char, accountId);
            const msg = history[activeMsgIndex];
            const isUser = msg.role === 'user';
            const recallerName = isUser ? 'ä½ ' : char.name;
            
            msg.recalledContent = msg.content;
            msg.isRecalled = true;
            msg.content = "";
            
            await setChatHistory(char, accountId, history);
            
            const chatBody = document.getElementById('chat-body');
            const messageRows = chatBody.querySelectorAll('.message-row');
            if (messageRows[activeMsgIndex]) {
                const msgRow = messageRows[activeMsgIndex];
                msgRow.className = 'message-row recalled-system-row';
                msgRow.innerHTML = '';
                
                const capturedContent = msg.recalledContent;
                const capturedName = recallerName;
                const systemTip = document.createElement('div');
                systemTip.className = 'recalled-system-tip';
                systemTip.innerHTML = `"${capturedName}"æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯`;
                systemTip.style.cursor = 'pointer';
                systemTip.onclick = (e) => {
                    e.stopPropagation();
                    showRecalledContent(capturedName, capturedContent);
                };
                msgRow.appendChild(systemTip);
            }
        }
        
        // æ˜¾ç¤ºæ’¤å›æ¶ˆæ¯çš„åŸå†…å®¹
        function showRecalledContent(recallerName, content) {
            // åˆ›å»ºå¼¹çª—
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 9999;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
            `;
            overlay.onclick = () => overlay.remove();
            
            const modal = document.createElement('div');
            modal.style.cssText = `
                background: white;
                border-radius: 12px;
                padding: 20px;
                max-width: 320px;
                width: 100%;
                max-height: 60vh;
                overflow-y: auto;
                box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            `;
            modal.onclick = (e) => e.stopPropagation();
            
            // å¤„ç†å†…å®¹æ˜¾ç¤ºï¼ˆæ”¯æŒå›¾ç‰‡ç­‰ï¼‰
            let displayContent = content;
            if (content.startsWith('[img:')) {
                const imgUrl = content.substring(5, content.length - 1).trim();
                displayContent = `<img src="${imgUrl}" style="width:150px; height:150px; object-fit:cover; border-radius:8px;">`;
            } else if (content.startsWith('[voice:')) {
                displayContent = `ğŸ¤ è¯­éŸ³æ¶ˆæ¯: ${content.substring(7, content.length - 1)}`;
            }
            
            modal.innerHTML = `
                <div style="font-size:14px; color:#999; margin-bottom:12px;">"${recallerName}"æ’¤å›çš„æ¶ˆæ¯ï¼š</div>
                <div style="font-size:15px; color:#333; line-height:1.6; word-break:break-all;">${displayContent}</div>
                <button onclick="this.parentElement.parentElement.remove()" style="
                    width: 100%;
                    margin-top: 16px;
                    padding: 10px;
                    background: #f5f5f5;
                    border: none;
                    border-radius: 8px;
                    font-size: 14px;
                    color: #666;
                    cursor: pointer;
                ">å…³é—­</button>
            `;
            
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
        }
        
        // å¼•ç”¨æ¶ˆæ¯ç›¸å…³
        let currentQuote = null; // å½“å‰å¼•ç”¨çš„æ¶ˆæ¯ { name, content, index }
        
        // å¼•ç”¨æ¶ˆæ¯
        async function handleMsgQuote() {
            hideContextMenu();
            if (activeMsgIndex === -1) return;
            
            let quoteName = '';
            let quoteContent = '';
            
            // ç¾¤èŠå¼•ç”¨
            if (window.currentGroupChatId) {
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (!group || !group.chat_history) return;
                
                const msg = group.chat_history[activeMsgIndex];
                if (!msg || msg.role === 'system') {
                    showToast("æ— æ³•å¼•ç”¨ç³»ç»Ÿæ¶ˆæ¯");
                    return;
                }
                
                if (msg.role === 'user') {
                    const myChar = currentMyCharId ? await db.characters.get(parseInt(currentMyCharId)) : null;
                    quoteName = group.myNickname || myChar?.name || 'æˆ‘';
                } else {
                    const senderChar = msg.senderId ? await db.characters.get(msg.senderId) : null;
                    const memberNicknames = group.memberNicknames || {};
                    quoteName = memberNicknames[msg.senderId] || senderChar?.remark || senderChar?.name || 'æœªçŸ¥æˆå‘˜';
                }
                
                quoteContent = getQuoteDisplayContent(msg.content, msg.type);
            } else {
                // ç§èŠå¼•ç”¨
                if (!currentChatCharId) return;
                
                const char = await db.characters.get(currentChatCharId);
                const accountId = getCurrentAccountId();
                const history = getChatHistory(char, accountId);
                const msg = history[activeMsgIndex];
                
                if (!msg) return;
                
                if (msg.role === 'user') {
                    const myChar = currentMyCharId ? await db.characters.get(parseInt(currentMyCharId)) : null;
                    quoteName = myChar?.name || 'æˆ‘';
                } else {
                    quoteName = getCharDisplayName(char, accountId);
                }
                
                quoteContent = getQuoteDisplayContent(msg.content, msg.type);
            }
            
            // è®¾ç½®å¼•ç”¨
            currentQuote = {
                name: quoteName,
                content: quoteContent,
                index: activeMsgIndex
            };
            
            // æ˜¾ç¤ºå¼•ç”¨é¢„è§ˆ
            showQuotePreview(quoteName, quoteContent);
            
            // èšç„¦è¾“å…¥æ¡†
            document.getElementById('chat-input-box').focus();
        }
        
        // è·å–å¼•ç”¨æ˜¾ç¤ºå†…å®¹
        function getQuoteDisplayContent(content, type) {
            if (type === 'redpacket') return '[çº¢åŒ…]';
            if (type === 'transfer') return '[è½¬è´¦]';
            if (content.startsWith('[img:')) return '[å›¾ç‰‡]';
            if (content.startsWith('[voice:')) return '[è¯­éŸ³]';
            if (content.startsWith('[imgcard:')) return '[å›¾æ–‡æ¶ˆæ¯]';
            // æˆªæ–­è¿‡é•¿çš„æ–‡æœ¬
            if (content.length > 50) {
                return content.substring(0, 50) + '...';
            }
            return content;
        }
        
        // æ˜¾ç¤ºå¼•ç”¨é¢„è§ˆ
        function showQuotePreview(name, content) {
            const preview = document.getElementById('quote-preview');
            const nameEl = document.getElementById('quote-preview-name');
            const msgEl = document.getElementById('quote-preview-msg');
            
            nameEl.textContent = name;
            msgEl.textContent = content;
            preview.style.display = 'flex';
        }
        
        // å–æ¶ˆå¼•ç”¨
        function cancelQuote() {
            currentQuote = null;
            document.getElementById('quote-preview').style.display = 'none';
        }

        // 3. åˆ é™¤ (å•æ¡)
        async function handleMsgDelete() {
            hideContextMenu();
            if (activeMsgIndex === -1) return;
            
            if (!confirm("åˆ é™¤è¿™æ¡æ¶ˆæ¯ï¼Ÿ")) return;
            
            // ç¾¤èŠåˆ é™¤
            if (window.currentGroupChatId) {
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (!group || !group.chat_history) return;
                
                group.chat_history.splice(activeMsgIndex, 1);
                await safeGroupChatPut(group);
                await renderGroupChatBody(group);
                return;
            }

            // ç§èŠåˆ é™¤
            if (!currentChatCharId) return;
            
            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            let history = getChatHistory(char, accountId);
            history.splice(activeMsgIndex, 1);
            
            await setChatHistory(char, accountId, history);
            
            // ğŸ”§ åªåˆ é™¤DOMå…ƒç´ ï¼Œä¸é‡æ–°æ¸²æŸ“æ•´ä¸ªç•Œé¢ - ä½¿ç”¨data-indexå±æ€§æŸ¥æ‰¾
            const chatBody = document.getElementById('chat-body');
            if (chatBody) {
                // ä½¿ç”¨data-indexå±æ€§ç²¾ç¡®æŸ¥æ‰¾æ¶ˆæ¯å…ƒç´ 
                const msgEl = chatBody.querySelector(`[data-index="${activeMsgIndex}"]`);
                if (msgEl) {
                    // æ£€æŸ¥å‰ä¸€ä¸ªæ˜¯å¦æ˜¯æ—¶é—´æˆ³ï¼Œå¦‚æœæ˜¯ä¸”åé¢æ²¡æœ‰æ¶ˆæ¯äº†ï¼Œä¹Ÿåˆ é™¤æ—¶é—´æˆ³
                    const prevEl = msgEl.previousElementSibling;
                    if (prevEl && prevEl.classList.contains('message-timestamp')) {
                        const nextEl = msgEl.nextElementSibling;
                        if (!nextEl || nextEl.classList.contains('message-timestamp')) {
                            prevEl.remove();
                        }
                    }
                    msgEl.remove();
                }
            }
        }

        // --- å¤šé€‰æ¨¡å¼ ---
        function enterSelectionMode() {
            hideContextMenu();
            if (!currentChatCharId && !window.currentGroupChatId) return;
            
            isSelectionMode = true;
            selectedIndices.clear();
            
            document.getElementById('chat-body').classList.add('selection-mode');
            document.getElementById('selection-bar').style.display = 'flex';
            document.getElementById('chat-footer').style.display = 'none';
            
            // ä¸ºç§èŠæ¶ˆæ¯æ·»åŠ checkboxï¼ˆåŒ…æ‹¬ç³»ç»Ÿæ¶ˆæ¯ï¼‰
            if (currentChatCharId) {
                document.querySelectorAll('.message-row, .message-system').forEach((row) => {
                    const idx = parseInt(row.dataset.index);
                    if (isNaN(idx)) return;
                    
                    row.classList.add('selection-mode');
                    if (row.classList.contains('message-system')) {
                        row.style.paddingLeft = '40px';
                    }
                    
                    let cb = row.querySelector('.msg-checkbox');
                    if (!cb) {
                        cb = document.createElement('div');
                        cb.className = 'msg-checkbox';
                        cb.style.cssText = 'position:absolute; left:6px; top:50%; transform:translateY(-50%); width:22px; height:22px; border:2px solid #ccc; border-radius:50%; display:flex; align-items:center; justify-content:center; cursor:pointer; z-index:10; box-sizing:border-box;';
                        row.style.position = 'relative';
                        row.insertBefore(cb, row.firstChild);
                    }
                    cb.style.display = 'flex';
                });
            }
            
            // ä¸ºç¾¤èŠæ¶ˆæ¯æ·»åŠ checkboxï¼ˆåŒ…æ‹¬ç³»ç»Ÿæ¶ˆæ¯ï¼‰
            if (window.currentGroupChatId) {
                document.querySelectorAll('.group-message-row').forEach((row) => {
                    const idx = parseInt(row.dataset.msgIndex);
                    if (isNaN(idx)) return;
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç³»ç»Ÿæ¶ˆæ¯æˆ–æ™®é€šæ¶ˆæ¯
                    const hasContent = row.querySelector('.group-msg-content') || row.querySelector('.group-system-msg-content');
                    if (hasContent) {
                        row.classList.add('selection-mode');
                        row.style.paddingLeft = '40px';
                        let cb = row.querySelector('.msg-checkbox');
                        if (!cb) {
                            cb = document.createElement('div');
                            cb.className = 'msg-checkbox';
                            cb.style.cssText = 'position:absolute; left:6px; top:50%; transform:translateY(-50%); width:22px; height:22px; border:2px solid #ccc; border-radius:50%; display:flex; align-items:center; justify-content:center; cursor:pointer; z-index:10; box-sizing:border-box;';
                            cb.onclick = (e) => {
                                e.stopPropagation();
                                if (selectedIndices.has(idx)) {
                                    selectedIndices.delete(idx);
                                    cb.classList.remove('checked');
                                    cb.style.background = '';
                                    cb.style.borderColor = '#ccc';
                                    cb.innerHTML = '';
                                } else {
                                    selectedIndices.add(idx);
                                    cb.classList.add('checked');
                                    cb.style.background = 'var(--ins-pink)';
                                    cb.style.borderColor = 'var(--ins-pink)';
                                    cb.innerHTML = '<svg viewBox="0 0 24 24" style="width:14px;height:14px;stroke:#fff;stroke-width:3;fill:none;"><polyline points="20 6 9 17 4 12"></polyline></svg>';
                                }
                                updateDeleteBtn();
                            };
                            row.style.position = 'relative';
                            row.insertBefore(cb, row.firstChild);
                        }
                        cb.style.display = 'flex';
                    }
                });
            }
            
            updateDeleteBtn();
        }

        function exitSelectionMode() {
            isSelectionMode = false;
            selectedIndices.clear();
            
            document.getElementById('chat-body').classList.remove('selection-mode');
            document.getElementById('selection-bar').style.display = 'none';
            document.getElementById('chat-footer').style.display = 'flex';
            
            // ç§èŠæ¶ˆæ¯ï¼ˆåŒ…æ‹¬ç³»ç»Ÿæ¶ˆæ¯ï¼‰
            document.querySelectorAll('.message-row, .message-system').forEach(row => {
                row.classList.remove('selection-mode', 'selected');
                if (row.classList.contains('message-system')) {
                    row.style.paddingLeft = '';
                }
            });
            // ç¾¤èŠæ¶ˆæ¯
            document.querySelectorAll('.group-message-row').forEach(row => {
                row.classList.remove('selection-mode', 'selected');
                row.style.paddingLeft = '';
            });
            document.querySelectorAll('.msg-checkbox').forEach(cb => {
                cb.style.display = 'none';
                cb.classList.remove('checked');
                cb.style.background = '';
                cb.style.borderColor = '#ccc';
                cb.innerHTML = '';
            });
        }

        function handleRowClick(index, e) {
            if (!isSelectionMode) return;
            
            // åˆ‡æ¢é€‰ä¸­çŠ¶æ€
            const row = e.currentTarget; // .message-row æˆ– .message-system
            const checkbox = row.querySelector('.msg-checkbox');
            if (!checkbox) return;
            
            if (selectedIndices.has(index)) {
                selectedIndices.delete(index);
                checkbox.classList.remove('checked');
                checkbox.style.background = '';
                checkbox.style.borderColor = '#ccc';
                checkbox.innerHTML = '';
            } else {
                selectedIndices.add(index);
                checkbox.classList.add('checked');
                checkbox.style.background = 'var(--ins-pink)';
                checkbox.style.borderColor = 'var(--ins-pink)';
                checkbox.innerHTML = '<svg viewBox="0 0 24 24" style="width:14px;height:14px;stroke:#fff;stroke-width:3;fill:none;"><polyline points="20 6 9 17 4 12"></polyline></svg>';
            }
            
            updateDeleteBtn();
        }
        
        function handleGroupRowClick(index, e) {
            if (!isSelectionMode) return;
            
            // åˆ‡æ¢é€‰ä¸­çŠ¶æ€
            const row = e.currentTarget; // .group-message-row
            const checkbox = row.querySelector('.msg-checkbox');
            if (!checkbox) return;
            
            if (selectedIndices.has(index)) {
                selectedIndices.delete(index);
                checkbox.classList.remove('checked');
                checkbox.style.background = '';
                checkbox.style.borderColor = '#ccc';
                checkbox.innerHTML = '';
            } else {
                selectedIndices.add(index);
                checkbox.classList.add('checked');
                checkbox.style.background = 'var(--ins-pink)';
                checkbox.style.borderColor = 'var(--ins-pink)';
                checkbox.innerHTML = '<svg viewBox="0 0 24 24" style="width:14px;height:14px;stroke:#fff;stroke-width:3;fill:none;"><polyline points="20 6 9 17 4 12"></polyline></svg>';
            }
            
            updateDeleteBtn();
        }

        function updateDeleteBtn() {
            const count = selectedIndices.size;
            const btn = document.getElementById('btn-batch-delete');
            btn.innerText = `åˆ é™¤ (${count})`;
            btn.style.opacity = count > 0 ? '1' : '0.5';
        }

        async function deleteSelectedMsgs() {
            if (selectedIndices.size === 0) return;
            
            if (!confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedIndices.size} æ¡æ¶ˆæ¯å—ï¼Ÿ`)) return;
            
            // ç¾¤èŠæ‰¹é‡åˆ é™¤
            if (window.currentGroupChatId) {
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (!group || !group.chat_history) return;
                
                const newHistory = group.chat_history.filter((_, idx) => !selectedIndices.has(idx));
                group.chat_history = newHistory;
                await safeGroupChatPut(group);
                
                exitSelectionMode();
                // é‡æ–°æ¸²æŸ“ä¼šè‡ªåŠ¨å¤„ç†æ—¶é—´æˆ³
                await renderGroupChatBody(group);
                return;
            }
            
            // ç§èŠæ‰¹é‡åˆ é™¤
            if (!currentChatCharId) return;

            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            const history = getChatHistory(char, accountId);
            
            const newHistory = history.filter((_, idx) => !selectedIndices.has(idx));
            
            await setChatHistory(char, accountId, newHistory);
            await safeCharacterPut(char);
            
            // ğŸ”§ åªåˆ é™¤DOMå…ƒç´ ï¼Œä¸é‡æ–°æ¸²æŸ“æ•´ä¸ªç•Œé¢ - ä½¿ç”¨data-indexå±æ€§æŸ¥æ‰¾
            const chatBody = document.getElementById('chat-body');
            if (chatBody) {
                // å€’åºåˆ é™¤ï¼Œé¿å…ç´¢å¼•å˜åŒ–
                const sortedIndices = Array.from(selectedIndices).sort((a, b) => b - a);
                let deletedDomCount = 0;
                sortedIndices.forEach(idx => {
                    // ä½¿ç”¨data-indexå±æ€§ç²¾ç¡®æŸ¥æ‰¾æ¶ˆæ¯å…ƒç´ 
                    const msgEl = chatBody.querySelector(`[data-index="${idx}"]`);
                    if (msgEl) {
                        // æ£€æŸ¥å‰ä¸€ä¸ªæ˜¯å¦æ˜¯æ—¶é—´æˆ³ï¼Œå¦‚æœæ˜¯ä¸”åé¢æ²¡æœ‰æ¶ˆæ¯äº†ï¼Œä¹Ÿåˆ é™¤æ—¶é—´æˆ³
                        const prevEl = msgEl.previousElementSibling;
                        if (prevEl && prevEl.classList.contains('message-timestamp')) {
                            const nextEl = msgEl.nextElementSibling;
                            if (!nextEl || nextEl.classList.contains('message-timestamp') || sortedIndices.includes(idx + 1)) {
                                prevEl.remove();
                            }
                        }
                        msgEl.remove();
                        deletedDomCount++;
                    }
                });
                // ğŸ”§ ä¿®å¤ï¼šåŒæ­¥æ›´æ–°å·²æ¸²æŸ“è®¡æ•°ï¼Œé˜²æ­¢"åŠ è½½æ›´å¤š"æŒ‰é’®çš„è®¡ç®—å‡ºé”™
                currentRenderedCount = Math.max(0, currentRenderedCount - deletedDomCount);
            }
            
            exitSelectionMode();
        }

        // --- æ–°å¢ï¼šèŠå¤©äº¤äº’é€»è¾‘ (é¢æ¿/è¾“å…¥/AIè§¦å‘) ---
        let activePanel = null;
        const emojis = ["ğŸ˜€","ğŸ˜","ğŸ˜‚","ğŸ¤£","ğŸ˜ƒ","ğŸ˜„","ğŸ˜…","ğŸ˜†","ğŸ˜‰","ğŸ˜Š","ğŸ˜‹","ğŸ˜","ğŸ˜","ğŸ˜˜","ğŸ¥°","ğŸ˜—","ğŸ˜™","ğŸ˜š","ğŸ™‚","ğŸ¤—","ğŸ¤©","ğŸ¤”","ğŸ¤¨","ğŸ˜","ğŸ˜‘","ğŸ˜¶","ğŸ™„","ğŸ˜","ğŸ˜£","ğŸ˜¥","ğŸ˜®","ğŸ¤","ğŸ˜¯","ğŸ˜ª","ğŸ˜«","ğŸ˜´","ğŸ˜Œ","ğŸ˜›","ğŸ˜œ","ğŸ˜","ğŸ¤¤","ğŸ˜’","ğŸ˜“","ğŸ˜”","ğŸ˜•","ğŸ™ƒ","ğŸ¤‘","ğŸ˜²","â˜¹ï¸","ğŸ™","ğŸ˜–","ğŸ˜","ğŸ˜Ÿ","ğŸ˜¤","ğŸ˜¢","ğŸ˜­","ğŸ˜¦","ğŸ˜§","ğŸ˜¨","ğŸ˜©","ğŸ¤¯","ğŸ˜¬","ğŸ˜°","ğŸ˜±","ğŸ¥µ","ğŸ¥¶","ğŸ˜³","ğŸ¤ª","ğŸ˜µ","ğŸ˜¡","ğŸ˜ ","ğŸ¤¬","ğŸ˜·","ğŸ¤’","ğŸ¤•","ğŸ¤¢","ğŸ¤®","ğŸ¤§","ğŸ˜‡","ğŸ¥³","ğŸ¥º","ğŸ¤ ","ğŸ¤¡","ğŸ¤¥","ğŸ¤«","ğŸ¤­","ğŸ§","ğŸ¤“","ğŸ˜ˆ","ğŸ‘¿","ğŸ‘¹","ğŸ‘º","ğŸ’€","ğŸ‘»","ğŸ‘½","ğŸ¤–","ğŸ’©","ğŸ˜º","ğŸ˜¸","ğŸ˜¹","ğŸ˜»","ğŸ˜¼","ğŸ˜½","ğŸ™€","ğŸ˜¿","ğŸ˜¾"];

        function initEmojiPanel() {
            const panel = document.getElementById('emoji-panel');
            if (panel.children.length > 0) return; 
            panel.innerHTML = emojis.map(e => `<div class="emoji-item" onclick="insertEmoji('${e}')">${e}</div>`).join('');
        }

        async function switchEmojiTab(type) {
            const tabs = document.querySelectorAll('#emoji-tab-bar .wechat-tab-item');
            const emojiPanel = document.getElementById('emoji-panel');
            const stickerPanel = document.getElementById('sticker-panel');

            if (type === 'emoji') {
                tabs[0].classList.add('active');
                tabs[1].classList.remove('active');
                emojiPanel.style.display = 'grid';
                stickerPanel.style.display = 'none';
            } else {
                tabs[0].classList.remove('active');
                tabs[1].classList.add('active');
                emojiPanel.style.display = 'none';
                stickerPanel.style.display = 'flex';
                
                // åŠ è½½å…¨å±€è¡¨æƒ…åŒ…
                await updateChatStickerPanel();
            }
        }
        
        async function sendSticker(base64) {
            // å‘é€å›¾ç‰‡æ¶ˆæ¯
            const msgContent = `[img:${base64}]`;
            
            // â˜… fpæ¨¡å¼ï¼šä»¥è§’è‰²èº«ä»½å‘é€è¡¨æƒ…åŒ…
            if (window._fpChatMode) {
                if (!window._fpRoleCharId || !window._fpAccountId) return;
                const roleChar = await db.characters.get(window._fpRoleCharId);
                if (!roleChar) return;
                const fpAccountId = window._fpAccountId;
                let history = getChatHistory(roleChar, fpAccountId);
                history.push({ role: 'char', content: msgContent, time: Date.now(), fpSent: true });
                try {
                    await setChatHistory(roleChar, fpAccountId, history);
                } catch(e) { console.error('[FP] è¡¨æƒ…åŒ…ä¿å­˜å¤±è´¥:', e); }
                await renderChatBody(roleChar, true);
                closeChatPanel();
                return;
            }
            
            // æ”¯æŒç¾¤èŠæ¨¡å¼
            if (window.currentGroupChatId) {
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (!group) return;
                
                if (!group.chat_history) group.chat_history = [];
                group.chat_history.push({
                    role: 'user',
                    content: msgContent,
                    time: Date.now()
                });
                group.updated_at = Date.now();
                await safeGroupChatPut(group);
                
                await renderGroupChatBody(group);
                closeChatPanel();
                return;
            }
            
            if (!currentChatCharId) return;
            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            let history = getChatHistory(char, accountId);
            
            history.push({
                role: 'user',
                content: msgContent,
                time: Date.now()
            });
            
            await setChatHistory(char, accountId, history);
            appendMessageToUI('user', msgContent);
            closeChatPanel();
            
            // âœ… å¦‚æœæ˜¯è”æœºå¥½å‹ï¼Œå‘é€è¡¨æƒ…åŒ…åˆ°æœåŠ¡å™¨
            if (char.isOnlineFriend && char.onlineData?.wx_account) {
                const onlineUserChar = await getOrCreateOnlineUserChar();
                
                if (onlineUserChar && onlineConnected) {
                    const fromWxAccount = onlineUserChar.identity.account;
                    const toWxAccount = char.onlineData.wx_account;
                    const sent = sendOnlineMessage(toWxAccount, msgContent, fromWxAccount);
                    if (sent) {
                        console.log('[Online] è¡¨æƒ…åŒ…å·²å‘é€åˆ°æœåŠ¡å™¨');
                    } else {
                        console.warn('[Online] è¡¨æƒ…åŒ…å‘é€å¤±è´¥');
                        showToast('è¡¨æƒ…åŒ…å‘é€å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨è¿æ¥');
                    }
                } else {
                    console.warn('[Online] æ— æ³•å‘é€è”æœºè¡¨æƒ…åŒ…ï¼šæœªè¿æ¥æœåŠ¡å™¨');
                    showToast('è¯·ç¡®ä¿å·²è¿æ¥æœåŠ¡å™¨');
                }
            }
            
            // å¯ä»¥åœ¨è¿™é‡Œè§¦å‘ AI å¯¹è¡¨æƒ…åŒ…çš„ååº”ï¼ˆå¦‚æœéœ€è¦ï¼‰
            // triggerAiReply(); 
        }

        // æ˜¾ç¤ºå›¾ç‰‡ç±»å‹é€‰æ‹©å¼¹çª—
        function showImageTypeModal() {
            // å…³é—­æ›´å¤šé¢æ¿
            closeChatPanel();
            
            const modal = document.createElement('div');
            modal.id = 'image-type-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.4);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                backdrop-filter: blur(5px);
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 16px; padding: 24px; width: 85%; max-width: 320px; box-shadow: 0 10px 40px rgba(0,0,0,0.15);">
                    <h3 style="margin: 0 0 24px 0; text-align: center; color: #333; font-size: 18px; font-weight: 600;">é€‰æ‹©å›¾ç‰‡ç±»å‹</h3>
                    <div style="display: flex; flex-direction: column; gap: 12px;">
                        <button onclick="selectRealImage()" style="padding: 16px; background: #f5f5f5; color: #333; border: none; border-radius: 12px; font-size: 16px; font-weight: 500; cursor: pointer; transition: all 0.2s; display:flex; align-items:center; justify-content:center; gap:8px;">
                            <svg class="svg-icon" style="width:20px; height:20px;" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
                            <span>çœŸå®å›¾ç‰‡</span>
                        </button>
                        <button onclick="selectTextImageCard()" style="padding: 16px; background: #f5f5f5; color: #333; border: none; border-radius: 12px; font-size: 16px; font-weight: 500; cursor: pointer; transition: all 0.2s; display:flex; align-items:center; justify-content:center; gap:8px;">
                            <svg class="svg-icon" style="width:20px; height:20px;" viewBox="0 0 24 24"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
                            <span>æ–‡å­—å›¾ç‰‡å¡ç‰‡</span>
                        </button>
                        <button onclick="closeImageTypeModal()" style="padding: 14px; background: white; color: #999; border: 1px solid #e8e8e8; border-radius: 12px; font-size: 15px; cursor: pointer; margin-top: 8px;">
                            å–æ¶ˆ
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        function closeImageTypeModal() {
            const modal = document.getElementById('image-type-modal');
            if (modal) modal.remove();
        }

        // é€‰æ‹©çœŸå®å›¾ç‰‡
        function selectRealImage() {
            closeImageTypeModal();
            document.getElementById('chat-image-input').click();
        }

        // é€‰æ‹©æ–‡å­—å›¾ç‰‡å¡ç‰‡
        function selectTextImageCard() {
            closeImageTypeModal();
            
            const modal = document.createElement('div');
            modal.id = 'text-image-card-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 12px; padding: 20px; width: 85%; max-width: 350px;">
                    <h3 style="margin: 0 0 15px 0; color: #333;">è¾“å…¥å¡ç‰‡æ–‡å­—</h3>
                    <textarea id="imgcard-text-input" placeholder="è¾“å…¥è¦è½¬æ¢ä¸ºå›¾ç‰‡å¡ç‰‡çš„æ–‡å­—..." style="width: 100%; height: 120px; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px; resize: none; box-sizing: border-box;"></textarea>
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button onclick="sendImageCard()" style="flex: 1; padding: 12px; background: var(--ins-pink); color: white; border: none; border-radius: 8px; font-size: 15px;">
                            å‘é€
                        </button>
                        <button onclick="closeTextImageCardModal()" style="flex: 1; padding: 12px; background: #f0f0f0; color: #666; border: none; border-radius: 8px; font-size: 15px;">
                            å–æ¶ˆ
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            document.getElementById('imgcard-text-input').focus();
        }

        function closeTextImageCardModal() {
            const modal = document.getElementById('text-image-card-modal');
            if (modal) modal.remove();
        }

        async function sendImageCard() {
            const text = document.getElementById('imgcard-text-input').value.trim();
            if (!text) {
                alert('è¯·è¾“å…¥å†…å®¹');
                return;
            }
            
            closeTextImageCardModal();
            
            // å‘é€å›¾ç‰‡å¡ç‰‡æ¶ˆæ¯ï¼ˆæ ¼å¼ï¼š[imgcard:æ–‡å­—å†…å®¹]ï¼‰
            const msgContent = `[imgcard:${text}]`;
            
            // â˜… fpæ¨¡å¼ï¼šä»¥è§’è‰²èº«ä»½å‘é€
            if (window._fpChatMode) {
                if (!window._fpRoleCharId) return;
                const roleChar = await db.characters.get(window._fpRoleCharId);
                if (!roleChar) return;
                const fpAccountId = window._fpAccountId;
                let history = getChatHistory(roleChar, fpAccountId);
                history.push({ role: 'char', content: msgContent, time: Date.now(), fpSent: true });
                await setChatHistory(roleChar, fpAccountId, history);
                await renderChatBody(roleChar, true);
                return;
            }
            
            // æ”¯æŒç¾¤èŠæ¨¡å¼
            if (window.currentGroupChatId) {
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (!group) return;
                
                if (!group.chat_history) group.chat_history = [];
                group.chat_history.push({
                    role: 'user',
                    content: msgContent,
                    time: Date.now()
                });
                group.updated_at = Date.now();
                await safeGroupChatPut(group);
                
                await renderGroupChatBody(group);
                return;
            }
            
            if (!currentChatCharId) return;
            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            let history = getChatHistory(char, accountId);
            
            history.push({
                role: 'user',
                content: msgContent,
                time: Date.now()
            });
            
            await setChatHistory(char, accountId, history);
            
            // âœ… ä¼˜åŒ–ï¼šåªè¿½åŠ æ–°æ¶ˆæ¯ï¼Œä¸é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©
            await appendMessageToUI('user', msgContent, getCharAvatar(char, getCurrentAccountId()));
        }

        // å‘é€çœŸå®å›¾ç‰‡æ¶ˆæ¯
        async function sendImageMessage(input) {
            const file = input.files[0];
            if (!file) return;
            
            // â˜… fpæ¨¡å¼ï¼šä»¥è§’è‰²èº«ä»½å‘é€å›¾ç‰‡
            if (window._fpChatMode) {
                if (!window._fpRoleCharId) return;
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const base64 = await convertImageForAI(e.target.result);
                    const msgContent = `[img:${base64}]`;
                    const roleChar = await db.characters.get(window._fpRoleCharId);
                    if (!roleChar) return;
                    const fpAccountId = window._fpAccountId;
                    let history = getChatHistory(roleChar, fpAccountId);
                    history.push({ role: 'char', content: msgContent, time: Date.now(), fpSent: true });
                    await setChatHistory(roleChar, fpAccountId, history);
                    await renderChatBody(roleChar, true);
                };
                reader.readAsDataURL(file);
                input.value = '';
                return;
            }
            
            // æ”¯æŒç¾¤èŠæ¨¡å¼
            if (window.currentGroupChatId) {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    // ğŸ”§ è½¬æ¢å›¾ç‰‡æ ¼å¼ï¼Œç¡®ä¿ API å…¼å®¹ï¼ˆè§£å†³ avif ç­‰æ ¼å¼ä¸æ”¯æŒçš„é—®é¢˜ï¼‰
                    const base64 = await convertImageForAI(e.target.result);
                    const msgContent = `[img:${base64}]`;
                    
                    const group = await db.group_chats.get(window.currentGroupChatId);
                    if (!group) return;
                    
                    if (!group.chat_history) group.chat_history = [];
                    group.chat_history.push({
                        role: 'user',
                        content: msgContent,
                        time: Date.now()
                    });
                    group.updated_at = Date.now();
                    await safeGroupChatPut(group);
                    
                    await renderGroupChatBody(group);
                };
                reader.readAsDataURL(file);
                input.value = '';
                return;
            }
            
            if (!currentChatCharId) return;
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                // ğŸ”§ è½¬æ¢å›¾ç‰‡æ ¼å¼ï¼Œç¡®ä¿ API å…¼å®¹ï¼ˆè§£å†³ avif ç­‰æ ¼å¼ä¸æ”¯æŒçš„é—®é¢˜ï¼‰
                const base64 = await convertImageForAI(e.target.result);
                const msgContent = `[img:${base64}]`;
                
                const char = await db.characters.get(currentChatCharId);
                const accountId = getCurrentAccountId();
                let history = getChatHistory(char, accountId);
                
                history.push({
                    role: 'user',
                    content: msgContent,
                    time: Date.now()
                });
                
                await setChatHistory(char, accountId, history);
                
                // âœ… ä¼˜åŒ–ï¼šåªè¿½åŠ æ–°æ¶ˆæ¯ï¼Œä¸é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©
                await appendMessageToUI('user', msgContent, getCharAvatar(char, getCurrentAccountId()));
                
                // âœ… å¦‚æœæ˜¯è”æœºå¥½å‹ï¼Œå‘é€å›¾ç‰‡åˆ°æœåŠ¡å™¨
                if (char.isOnlineFriend && char.onlineData?.wx_account) {
                    const onlineUserChar = await getOrCreateOnlineUserChar();
                    
                    if (onlineUserChar && onlineConnected) {
                        const fromWxAccount = onlineUserChar.identity.account;
                        const toWxAccount = char.onlineData.wx_account;
                        const sent = sendOnlineMessage(toWxAccount, msgContent, fromWxAccount);
                        if (sent) {
                            console.log('[Online] å›¾ç‰‡å·²å‘é€åˆ°æœåŠ¡å™¨');
                        } else {
                            console.warn('[Online] å›¾ç‰‡å‘é€å¤±è´¥');
                            showToast('å›¾ç‰‡å‘é€å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨è¿æ¥');
                        }
                    } else {
                        console.warn('[Online] æ— æ³•å‘é€è”æœºå›¾ç‰‡ï¼šæœªè¿æ¥æœåŠ¡å™¨');
                        showToast('è¯·ç¡®ä¿å·²è¿æ¥æœåŠ¡å™¨');
                    }
                }
            };
            
            reader.readAsDataURL(file);
            input.value = '';
        }

        function insertEmoji(e) {
            const input = document.getElementById('chat-input-box');
            input.value += e;
            handleChatInputChange(input);
        }

        // è¯­éŸ³è¾“å…¥åŠŸèƒ½
        async function showVoiceInputModal() {
            // å…³é—­æ›´å¤šé¢æ¿
            closeChatPanel();
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯è”æœºå¥½å‹
            let isOnlineFriend = false;
            if (currentChatCharId) {
                const char = await db.characters.get(currentChatCharId);
                isOnlineFriend = char && char.isOnlineFriend === true;
            }
            
            // æ˜¾ç¤ºè¯­éŸ³æ¨¡å¼é€‰æ‹©å¼¹çª—
            const modal = document.createElement('div');
            modal.id = 'voice-mode-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            if (isOnlineFriend) {
                // è”æœºå¥½å‹ï¼šæ˜¾ç¤ºçœŸå®å½•éŸ³+å˜å£°é€‰é¡¹
                modal.innerHTML = `
                    <div style="background: white; border-radius: 16px; padding: 24px; width: 85%; max-width: 320px;">
                        <h3 style="margin: 0 0 20px 0; text-align: center; color: #333; font-size: 18px;">ğŸ¤ è¯­éŸ³å½•åˆ¶</h3>
                        
                        <div style="margin-bottom: 20px;">
                            <div style="font-size: 13px; color: #666; margin-bottom: 10px;">é€‰æ‹©å˜å£°æ•ˆæœï¼š</div>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                                <label style="display: flex; align-items: center; padding: 12px; background: #f5f5f5; border-radius: 8px; cursor: pointer;">
                                    <input type="radio" name="voice-effect" value="normal" checked style="margin-right: 8px;">
                                    <span>ğŸ™ï¸ åŸå£°</span>
                                </label>
                                <label style="display: flex; align-items: center; padding: 12px; background: #fff0f5; border-radius: 8px; cursor: pointer;">
                                    <input type="radio" name="voice-effect" value="loli" style="margin-right: 8px;">
                                    <span>ğŸ€ èè‰éŸ³</span>
                                </label>
                                <label style="display: flex; align-items: center; padding: 12px; background: #f0f5ff; border-radius: 8px; cursor: pointer;">
                                    <input type="radio" name="voice-effect" value="uncle" style="margin-right: 8px;">
                                    <span>ğŸ§” å¤§å”éŸ³</span>
                                </label>
                                <label style="display: flex; align-items: center; padding: 12px; background: #f5fff0; border-radius: 8px; cursor: pointer;">
                                    <input type="radio" name="voice-effect" value="robot" style="margin-right: 8px;">
                                    <span>ğŸ¤– æœºå™¨äºº</span>
                                </label>
                            </div>
                        </div>
                        
                        <div id="voice-record-status" style="text-align: center; padding: 20px; background: #f9f9f9; border-radius: 12px; margin-bottom: 16px;">
                            <div style="font-size: 14px; color: #999;">ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¼€å§‹å½•éŸ³</div>
                            <div id="voice-record-time" style="font-size: 24px; font-weight: 600; color: #333; margin-top: 8px; display: none;">00:00</div>
                        </div>
                        
                        <div style="display: flex; flex-direction: column; gap: 10px;">
                            <button id="btn-start-record" onclick="startOnlineVoiceRecord()" style="padding: 14px; background: var(--ins-pink); color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 500;">
                                ğŸ¤ æŒ‰ä½å½•éŸ³
                            </button>
                            <button onclick="closeVoiceModal()" style="padding: 12px; background: #f0f0f0; color: #666; border: none; border-radius: 8px; font-size: 14px;">
                                å–æ¶ˆ
                            </button>
                        </div>
                    </div>
                `;
            } else {
                // æ™®é€šè§’è‰²ï¼šæ˜¾ç¤ºåŸæœ‰é€‰é¡¹
                modal.innerHTML = `
                    <div style="background: white; border-radius: 12px; padding: 20px; width: 80%; max-width: 300px;">
                        <h3 style="margin: 0 0 20px 0; text-align: center; color: #333;">é€‰æ‹©è¯­éŸ³æ¨¡å¼</h3>
                        <div style="display: flex; flex-direction: column; gap: 12px;">
                            <button onclick="startRealVoiceInput()" style="padding: 15px; background: var(--ins-pink); color: white; border: none; border-radius: 8px; font-size: 16px; display:flex; align-items:center; justify-content:center; gap:8px;">
                                <svg class="svg-icon" style="width:20px; height:20px; stroke:#fff;" viewBox="0 0 24 24"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
                                <span>çœŸå®è¯­éŸ³è¯†åˆ«</span>
                            </button>
                            <button onclick="startTextToVoice()" style="padding: 15px; background: #34c759; color: white; border: none; border-radius: 8px; font-size: 16px; display:flex; align-items:center; justify-content:center; gap:8px;">
                                <svg class="svg-icon" style="width:20px; height:20px; stroke:#fff;" viewBox="0 0 24 24"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></svg>
                                <span>æ–‡å­—è½¬è¯­éŸ³æ°”æ³¡</span>
                            </button>
                            <button onclick="closeVoiceModal()" style="padding: 12px; background: #f0f0f0; color: #666; border: none; border-radius: 8px; font-size: 14px;">
                                å–æ¶ˆ
                            </button>
                        </div>
                    </div>
                `;
            }
            
            document.body.appendChild(modal);
        }
        
        // âœ… è”æœºå¥½å‹è¯­éŸ³å½•åˆ¶å˜é‡
        let onlineVoiceRecorder = null;
        let onlineVoiceChunks = [];
        let onlineVoiceStartTime = 0;
        let onlineVoiceTimer = null;
        
        // å¼€å§‹è”æœºè¯­éŸ³å½•åˆ¶
        async function startOnlineVoiceRecord() {
            const btn = document.getElementById('btn-start-record');
            const statusDiv = document.getElementById('voice-record-status');
            const timeDiv = document.getElementById('voice-record-time');
            
            // å¦‚æœæ­£åœ¨å½•éŸ³ï¼Œåˆ™åœæ­¢
            if (onlineVoiceRecorder && onlineVoiceRecorder.state === 'recording') {
                stopOnlineVoiceRecord();
                return;
            }
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                onlineVoiceRecorder = new MediaRecorder(stream);
                onlineVoiceChunks = [];
                onlineVoiceStartTime = Date.now();
                
                onlineVoiceRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        onlineVoiceChunks.push(e.data);
                    }
                };
                
                onlineVoiceRecorder.onstop = async () => {
                    stream.getTracks().forEach(track => track.stop());
                    clearInterval(onlineVoiceTimer);
                    
                    const duration = Math.round((Date.now() - onlineVoiceStartTime) / 1000);
                    const blob = new Blob(onlineVoiceChunks, { type: 'audio/webm' });
                    
                    // è·å–é€‰æ‹©çš„å˜å£°æ•ˆæœ
                    const effectRadio = document.querySelector('input[name="voice-effect"]:checked');
                    const effect = effectRadio ? effectRadio.value : 'normal';
                    
                    statusDiv.innerHTML = '<div style="color: var(--ins-pink);">â³ æ­£åœ¨å¤„ç†...</div>';
                    
                    // å¤„ç†å˜å£°å¹¶å‘é€
                    await processAndSendVoice(blob, effect, duration);
                };
                
                onlineVoiceRecorder.start();
                
                // æ›´æ–°UI
                btn.textContent = 'â¹ï¸ åœæ­¢å½•éŸ³';
                btn.style.background = '#ff3b30';
                timeDiv.style.display = 'block';
                statusDiv.querySelector('div').textContent = 'ğŸ”´ æ­£åœ¨å½•éŸ³...';
                
                // è®¡æ—¶å™¨
                onlineVoiceTimer = setInterval(() => {
                    const elapsed = Math.round((Date.now() - onlineVoiceStartTime) / 1000);
                    const min = Math.floor(elapsed / 60).toString().padStart(2, '0');
                    const sec = (elapsed % 60).toString().padStart(2, '0');
                    timeDiv.textContent = `${min}:${sec}`;
                }, 1000);
                
            } catch (err) {
                console.error('å½•éŸ³å¤±è´¥:', err);
                alert('æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·ç¡®ä¿å·²æˆäºˆæƒé™');
            }
        }
        
        // åœæ­¢è”æœºè¯­éŸ³å½•åˆ¶
        function stopOnlineVoiceRecord() {
            if (onlineVoiceRecorder && onlineVoiceRecorder.state === 'recording') {
                onlineVoiceRecorder.stop();
            }
        }
        
        // å¤„ç†å˜å£°å¹¶å‘é€è¯­éŸ³
        async function processAndSendVoice(blob, effect, duration) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const arrayBuffer = await blob.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                // æ ¹æ®æ•ˆæœè®¾ç½®å‚æ•°
                let pitchRate = 1.0;
                switch (effect) {
                    case 'loli':    pitchRate = 1.4; break;  // èè‰éŸ³ï¼šæé«˜éŸ³è°ƒ
                    case 'uncle':   pitchRate = 0.7; break;  // å¤§å”éŸ³ï¼šé™ä½éŸ³è°ƒ
                    case 'robot':   pitchRate = 1.0; break;  // æœºå™¨äººï¼šç‰¹æ®Šå¤„ç†
                    default:        pitchRate = 1.0; break;
                }
                
                // åˆ›å»ºç¦»çº¿éŸ³é¢‘ä¸Šä¸‹æ–‡è¿›è¡Œå¤„ç†
                const offlineContext = new OfflineAudioContext(
                    audioBuffer.numberOfChannels,
                    Math.ceil(audioBuffer.length / pitchRate),
                    audioBuffer.sampleRate
                );
                
                const source = offlineContext.createBufferSource();
                source.buffer = audioBuffer;
                source.playbackRate.value = pitchRate;
                
                // æœºå™¨äººæ•ˆæœï¼šæ·»åŠ æ³¢å½¢è°ƒåˆ¶
                if (effect === 'robot') {
                    const oscillator = offlineContext.createOscillator();
                    const gainNode = offlineContext.createGain();
                    oscillator.frequency.value = 50;
                    gainNode.gain.value = 0.3;
                    oscillator.connect(gainNode);
                    gainNode.connect(offlineContext.destination);
                    oscillator.start();
                }
                
                source.connect(offlineContext.destination);
                source.start();
                
                const renderedBuffer = await offlineContext.startRendering();
                
                // å°†å¤„ç†åçš„éŸ³é¢‘è½¬ä¸º base64
                const wavBlob = await audioBufferToWav(renderedBuffer);
                const base64 = await blobToBase64(wavBlob);
                
                // è®¡ç®—å®é™…æ—¶é•¿
                const actualDuration = Math.ceil(duration / pitchRate);
                
                // å‘é€è¯­éŸ³æ¶ˆæ¯
                await sendOnlineVoiceMessage(base64, actualDuration, effect);
                
                closeVoiceModal();
                
            } catch (err) {
                console.error('è¯­éŸ³å¤„ç†å¤±è´¥:', err);
                alert('è¯­éŸ³å¤„ç†å¤±è´¥: ' + err.message);
            }
        }
        
        // AudioBuffer è½¬ WAV
        function audioBufferToWav(buffer) {
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const format = 1; // PCM
            const bitDepth = 16;
            
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;
            
            const data = [];
            for (let i = 0; i < buffer.length; i++) {
                for (let ch = 0; ch < numChannels; ch++) {
                    const sample = buffer.getChannelData(ch)[i];
                    const intSample = Math.max(-1, Math.min(1, sample));
                    data.push(intSample < 0 ? intSample * 0x8000 : intSample * 0x7FFF);
                }
            }
            
            const dataLength = data.length * bytesPerSample;
            const headerLength = 44;
            const totalLength = headerLength + dataLength;
            
            const arrayBuffer = new ArrayBuffer(totalLength);
            const view = new DataView(arrayBuffer);
            
            // WAV header
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, totalLength - 8, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);
            writeString(36, 'data');
            view.setUint32(40, dataLength, true);
            
            let offset = 44;
            for (let i = 0; i < data.length; i++, offset += 2) {
                view.setInt16(offset, data[i], true);
            }
            
            return new Blob([arrayBuffer], { type: 'audio/wav' });
        }
        
        // Blob è½¬ Base64
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }
        
        // å‘é€è”æœºè¯­éŸ³æ¶ˆæ¯
        async function sendOnlineVoiceMessage(audioBase64, duration, effect) {
            if (!currentChatCharId) return;
            
            const char = await db.characters.get(currentChatCharId);
            if (!char || !char.isOnlineFriend) return;
            
            const accountId = getCurrentAccountId();
            
            // ä¿å­˜åˆ°æœ¬åœ°èŠå¤©å†å²
            let history = getChatHistory(char, accountId);
            const msgObj = {
                role: 'user',
                type: 'audio',
                content: audioBase64,
                duration: duration,
                effect: effect,
                time: Date.now()
            };
            history.push(msgObj);
            await setChatHistory(char, accountId, history);
            
            // é€šè¿‡æœåŠ¡å™¨å‘é€ç»™å¯¹æ–¹
            if (char.onlineData?.wx_account && onlineConnected) {
                // è·å–å½“å‰å¯ç”¨çš„åœ¨çº¿è§’è‰²ï¼ˆå¦‚æœæ²¡æœ‰åˆ™è‡ªåŠ¨ä¸Šçº¿ï¼‰
                const onlineUserChar = await getOrCreateOnlineUserChar();
                
                if (onlineUserChar) {
                    const voiceMsg = JSON.stringify({
                        __type: 'audio',
                        audio: audioBase64,
                        duration: duration,
                        effect: effect
                    });
                    sendOnlineMessage(char.onlineData.wx_account, voiceMsg, onlineUserChar.identity.account);
                    console.log('[Online] è¯­éŸ³æ¶ˆæ¯å·²å‘é€');
                }
            }
            
            // åˆ·æ–°èŠå¤©ç•Œé¢
            renderChatBody(char);
            showToast('è¯­éŸ³å·²å‘é€');
        }
        
        // æ’­æ”¾è”æœºè¯­éŸ³æ¶ˆæ¯
        let currentPlayingAudio = null;
        function playOnlineAudio(audioId) {
            const audio = document.getElementById(audioId);
            const icon = document.getElementById('icon_' + audioId);
            
            if (!audio) return;
            
            // å¦‚æœæœ‰å…¶ä»–æ­£åœ¨æ’­æ”¾çš„ï¼Œå…ˆåœæ­¢
            if (currentPlayingAudio && currentPlayingAudio !== audio) {
                currentPlayingAudio.pause();
                currentPlayingAudio.currentTime = 0;
            }
            
            if (audio.paused) {
                audio.play();
                currentPlayingAudio = audio;
                if (icon) icon.textContent = 'â¸ï¸';
                
                audio.onended = () => {
                    if (icon) {
                        // æ¢å¤åŸæ¥çš„å›¾æ ‡
                        const bubble = audio.closest('.online-audio-bubble');
                        if (bubble) {
                            const originalIcon = bubble.querySelector('.audio-play-icon');
                            if (originalIcon) originalIcon.textContent = icon.dataset.original || 'ğŸ™ï¸';
                        }
                    }
                    currentPlayingAudio = null;
                };
            } else {
                audio.pause();
                audio.currentTime = 0;
                currentPlayingAudio = null;
                // æ¢å¤å›¾æ ‡
            }
        }

        function closeVoiceModal() {
            const modal = document.getElementById('voice-mode-modal');
            if (modal) modal.remove();
        }

        // çœŸå®è¯­éŸ³è¯†åˆ« - æ”¹è¿›ç‰ˆï¼šè¯†åˆ«åä»¥è¯­éŸ³æ°”æ³¡å½¢å¼å‘é€
        function startRealVoiceInput() {
            closeVoiceModal();
            
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                alert('æŠ±æ­‰ï¼Œæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«åŠŸèƒ½');
                return;
            }
            
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            const recognition = new SpeechRecognition();
            
            recognition.lang = 'zh-CN';
            recognition.continuous = false;
            recognition.interimResults = false;
            
            // æ˜¾ç¤ºå½•éŸ³ä¸­æç¤º
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.8);
                color: white;
                padding: 20px 30px;
                border-radius: 12px;
                z-index: 10001;
                font-size: 16px;
            `;
            toast.innerHTML = 'ğŸ¤ æ­£åœ¨å½•éŸ³...';
            document.body.appendChild(toast);
            
            recognition.onresult = async (event) => {
                const text = event.results[0][0].transcript;
                toast.innerHTML = 'âœ“ è¯†åˆ«æˆåŠŸï¼';
                
                // å»¶è¿Ÿ500msåå‘é€è¯­éŸ³æ°”æ³¡
                setTimeout(async () => {
                    toast.remove();
                    
                    // ä»¥è¯­éŸ³æ°”æ³¡æ ¼å¼å‘é€
                    const msgContent = `[voice:${text}]`;
                    
                    if (!currentChatCharId) return;
                    const char = await db.characters.get(currentChatCharId);
                    const accountId = getCurrentAccountId();
                    let history = getChatHistory(char, accountId);
                    
                    history.push({
                        role: 'user',
                        content: msgContent,
                        time: Date.now()
                    });
                    
                    await setChatHistory(char, accountId, history);
                    
                    // âœ… ä¼˜åŒ–ï¼šåªè¿½åŠ æ–°æ¶ˆæ¯ï¼Œä¸é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©
                    await appendMessageToUI('user', msgContent, getCharAvatar(char, getCurrentAccountId()));
                    
                    // âœ… ä¸å†è‡ªåŠ¨è§¦å‘ AI å›å¤ï¼Œéœ€è¦ç”¨æˆ·ç‚¹å‡»"æ¥å—å›å¤"æŒ‰é’®
                    // triggerAiReply();
                }, 500);
            };
            
            recognition.onerror = (event) => {
                console.error('è¯­éŸ³è¯†åˆ«é”™è¯¯:', event.error);
                let errorMsg = 'âŒ è¯†åˆ«å¤±è´¥';
                switch (event.error) {
                    case 'not-allowed':
                    case 'service-not-allowed':
                        errorMsg = 'âŒ éº¦å…‹é£æƒé™è¢«æ‹’ç»\nè¯·åœ¨æµè§ˆå™¨è®¾ç½®ä¸­å…è®¸éº¦å…‹é£è®¿é—®';
                        break;
                    case 'no-speech':
                        errorMsg = 'âŒ æœªæ£€æµ‹åˆ°è¯­éŸ³\nè¯·é è¿‘éº¦å…‹é£è¯´è¯';
                        break;
                    case 'network':
                        errorMsg = 'âŒ ç½‘ç»œé”™è¯¯\nè¯­éŸ³è¯†åˆ«éœ€è¦è”ç½‘ï¼ˆChromeéœ€è¿æ¥è°·æ­ŒæœåŠ¡ï¼‰';
                        break;
                    case 'audio-capture':
                        errorMsg = 'âŒ æœªæ‰¾åˆ°éº¦å…‹é£\nè¯·æ£€æŸ¥éº¦å…‹é£æ˜¯å¦æ­£ç¡®è¿æ¥';
                        break;
                    case 'aborted':
                        errorMsg = 'âŒ è¯†åˆ«å·²å–æ¶ˆ';
                        break;
                    default:
                        errorMsg = `âŒ è¯†åˆ«å¤±è´¥: ${event.error}`;
                }
                toast.innerHTML = errorMsg.replace(/\n/g, '<br>');
                toast.style.textAlign = 'center';
                toast.style.lineHeight = '1.6';
                setTimeout(() => toast.remove(), 3000);
            };
            
            recognition.onend = () => {
                setTimeout(() => {
                    if (toast.parentNode) toast.remove();
                }, 500);
            };
            
            recognition.start();
        }

        // æ–‡å­—è½¬è¯­éŸ³æ°”æ³¡
        function startTextToVoice() {
            closeVoiceModal();
            
            const modal = document.createElement('div');
            modal.id = 'text-to-voice-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 12px; padding: 20px; width: 85%; max-width: 350px;">
                    <h3 style="margin: 0 0 15px 0; color: #333;">è¾“å…¥è¯­éŸ³å†…å®¹</h3>
                    <textarea id="voice-text-input" placeholder="è¾“å…¥è¦è½¬æ¢ä¸ºè¯­éŸ³æ°”æ³¡çš„æ–‡å­—..." style="width: 100%; height: 120px; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px; resize: none; box-sizing: border-box;"></textarea>
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button onclick="sendVoiceBubble()" style="flex: 1; padding: 12px; background: var(--ins-pink); color: white; border: none; border-radius: 8px; font-size: 15px;">
                            å‘é€
                        </button>
                        <button onclick="closeTextToVoiceModal()" style="flex: 1; padding: 12px; background: #f0f0f0; color: #666; border: none; border-radius: 8px; font-size: 15px;">
                            å–æ¶ˆ
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            document.getElementById('voice-text-input').focus();
        }

        function closeTextToVoiceModal() {
            const modal = document.getElementById('text-to-voice-modal');
            if (modal) modal.remove();
        }

        async function sendVoiceBubble() {
            const text = document.getElementById('voice-text-input').value.trim();
            if (!text) {
                alert('è¯·è¾“å…¥å†…å®¹');
                return;
            }
            
            closeTextToVoiceModal();
            
            // å‘é€è¯­éŸ³æ°”æ³¡æ¶ˆæ¯ï¼ˆæ ¼å¼ï¼š[voice:æ–‡å­—å†…å®¹]ï¼‰
            const msgContent = `[voice:${text}]`;
            
            // â˜… fpæ¨¡å¼ï¼šä»¥è§’è‰²èº«ä»½å‘é€è¯­éŸ³
            if (window._fpChatMode) {
                if (!window._fpRoleCharId) return;
                const roleChar = await db.characters.get(window._fpRoleCharId);
                if (!roleChar) return;
                const fpAccountId = window._fpAccountId;
                let history = getChatHistory(roleChar, fpAccountId);
                history.push({ role: 'char', content: msgContent, time: Date.now(), fpSent: true });
                await setChatHistory(roleChar, fpAccountId, history);
                await renderChatBody(roleChar, true);
                return;
            }
            
            // æ”¯æŒç¾¤èŠæ¨¡å¼
            if (window.currentGroupChatId) {
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (!group) return;
                
                if (!group.chat_history) group.chat_history = [];
                group.chat_history.push({
                    role: 'user',
                    content: msgContent,
                    time: Date.now()
                });
                group.updated_at = Date.now();
                await safeGroupChatPut(group);
                
                await renderGroupChatBody(group);
                return;
            }
            
            if (!currentChatCharId) return;
            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            let history = getChatHistory(char, accountId);
            
            history.push({
                role: 'user',
                content: msgContent,
                time: Date.now()
            });
            
            await setChatHistory(char, accountId, history);
            
            // âœ… ä¼˜åŒ–ï¼šåªè¿½åŠ æ–°æ¶ˆæ¯ï¼Œä¸é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©
            await appendMessageToUI('user', msgContent, getCharAvatar(char, getCurrentAccountId()));
            
            // âœ… ç§»é™¤è‡ªåŠ¨è§¦å‘AIå›å¤
            // triggerAiReply();
        }

        function toggleChatPanel(type) {
            const container = document.getElementById('chat-panel-container');
            const footer = document.getElementById('chat-footer');
            const emojiPanel = document.getElementById('emoji-panel');
            const actionPanel = document.getElementById('action-panel');
            
            // å¦‚æœæ˜¯è¡¨æƒ…é¢æ¿ï¼Œå…ˆåˆå§‹åŒ–
            if (type === 'emoji') initEmojiPanel();

            if (activePanel === type) {
                // å…³é—­å½“å‰
                closeChatPanel();
            } else {
                // æ‰“å¼€æˆ–åˆ‡æ¢
                if (!activePanel) {
                    container.classList.add('open');
                    footer.classList.add('panel-open');
                }
                activePanel = type;
                
                // é»˜è®¤åˆ‡å› Emoji Tab
                if (type === 'emoji') {
                    document.getElementById('emoji-tab-bar').style.display = 'flex';
                    switchEmojiTab('emoji');
                    actionPanel.style.display = 'none';
                } else {
                    document.getElementById('emoji-tab-bar').style.display = 'none';
                    document.getElementById('emoji-panel').style.display = 'none';
                    document.getElementById('sticker-panel').style.display = 'none';
                    actionPanel.style.display = 'flex';
                }
                
                // æ»šåŠ¨åˆ°åº•éƒ¨ï¼Œç¡®ä¿èƒ½çœ‹åˆ°é¢æ¿
                setTimeout(() => {
                    const body = document.getElementById('chat-body');
                    body.scrollTop = body.scrollHeight;
                }, 100);
            }
        }

        function closeChatPanel() {
            if (!activePanel) return;
            const container = document.getElementById('chat-panel-container');
            const footer = document.getElementById('chat-footer');
            
            container.classList.remove('open');
            footer.classList.remove('panel-open');
            activePanel = null;
            
            // ç­‰å¾…åŠ¨ç”»ç»“æŸéšè—å†…å®¹
            setTimeout(() => {
                if (!activePanel) {
                    document.getElementById('emoji-panel').style.display = 'none';
                    document.getElementById('action-panel').style.display = 'none';
                }
            }, 300);
        }

        // èŠå¤©è¾“å…¥æ¡†è·å¾—ç„¦ç‚¹æ—¶ï¼šå…³é—­é¢æ¿ + ç­‰é”®ç›˜å¼¹èµ·åæ»šåˆ°åº•éƒ¨
        function onChatInputFocus() {
            closeChatPanel();
            // å»¶è¿Ÿæ»šåŠ¨ï¼Œç­‰å¾…é”®ç›˜å¼¹èµ·å’Œ visualViewport é«˜åº¦æ›´æ–°
            setTimeout(() => {
                const body = document.getElementById('chat-body');
                if (body) body.scrollTop = body.scrollHeight;
            }, 350);
        }
        window.onChatInputFocus = onChatInputFocus;

        // çº¿ä¸‹æ¨¡å¼è¾“å…¥æ¡†è·å¾—ç„¦ç‚¹æ—¶ï¼šç­‰é”®ç›˜å¼¹èµ·åæ»šåˆ°åº•éƒ¨
        function onOfflineChatInputFocus() {
            setTimeout(() => {
                const body = document.getElementById('offline-chat-body');
                if (body) body.scrollTop = body.scrollHeight;
            }, 350);
        }
        window.onOfflineChatInputFocus = onOfflineChatInputFocus;

        function handleChatInputChange(input) {
            const hasText = input.value.trim().length > 0;
            const btnMore = document.getElementById('btn-more');
            const btnSend = document.getElementById('btn-send');
            
            if (hasText) {
                btnMore.style.display = 'none';
                btnSend.style.display = 'flex';
                // æ™ºèƒ½è¡¨æƒ…æ¨è
                detectAndSuggestStickers(input.value);
            } else {
                btnMore.style.display = 'flex';
                btnSend.style.display = 'none';
                // éšè—æ¨èæ 
                const suggestionBar = document.getElementById('sticker-suggestion-bar');
                if (suggestionBar) suggestionBar.style.display = 'none';
            }
        }

        // æ˜¾ç¤ºå¿«è¿›æ—¶é—´é€‰æ‹©å¼¹çª—
        function showFastForwardModal() {
            closeChatPanel();
            document.getElementById('fast-forward-modal').style.display = 'flex';
        }

        // ç¡®è®¤å¿«è¿›é€»è¾‘
        async function confirmFastForward() {
            const amount = parseInt(document.getElementById('ff-amount').value);
            const unit = document.getElementById('ff-unit').value;
            
            if (isNaN(amount) || amount <= 0) {
                alert("è¯·è¾“å…¥æœ‰æ•ˆçš„æ—¶é—´æ•°å€¼");
                return;
            }
            
            closeModal('fast-forward-modal');
            
            // 1. è®¡ç®—æ¯«ç§’æ•°
            let ms = 0;
            let unitText = '';
            if (unit === 'minute') {
                ms = amount * 60 * 1000;
                unitText = amount + 'åˆ†é’Ÿ';
            } else if (unit === 'hour') {
                ms = amount * 60 * 60 * 1000;
                unitText = amount + 'å°æ—¶';
            } else if (unit === 'day') {
                ms = amount * 24 * 60 * 60 * 1000;
                unitText = amount + 'å¤©';
            }
            
            // è·å–è§’è‰²ï¼Œåˆ¤æ–­æ˜¯å¦å¼€å¯è™šæ‹Ÿæ—¶é—´
            let char = null;
            if (currentChatCharId) {
                char = await db.characters.get(currentChatCharId);
            }
            const useVirtualTime = char ? isVirtualTimeEnabled(char) : false;
            
            // ğŸ”§ åªæœ‰è™šæ‹Ÿæ—¶é—´å¼€å¯æ—¶æ‰æ›´æ–°æ—¶é—´åç§»
            if (useVirtualTime && char) {
                if (!char.timeOffset) char.timeOffset = 0;
                char.timeOffset += ms;
                await safeCharacterPut(char);
                console.log(`[FastForward] è™šæ‹Ÿæ—¶é—´æ¨¡å¼ï¼šUpdated time offset by +${ms}ms (${unitText})`);
            } else {
                console.log(`[FastForward] ç°å®æ—¶é—´æ¨¡å¼ï¼šä¸æ›´æ–°æ—¶é—´åç§»ï¼Œä»…è§¦å‘AIç»§ç»­å¯¹è¯`);
            }
            
            // 2. æ£€æŸ¥è¢«æ‹‰é»‘çš„è§’è‰²æ˜¯å¦ä¼šè”ç³»
            await checkBlockedCharactersContact(ms, unitText);
            
            // 3. è§¦å‘ AI å›å¤ï¼ˆåªæœ‰åœ¨æœ‰å½“å‰èŠå¤©æ—¶æ‰è§¦å‘ï¼‰
            if (currentChatCharId && char) {
                const accountId = getCurrentAccountId();
                
                // é‡æ–°ä»DBè·å–æœ€æ–°çš„charï¼ˆé˜²æ­¢checkBlockedCharactersContactæœŸé—´æœ‰æ–°æ¶ˆæ¯å†™å…¥ï¼‰
                char = await db.characters.get(currentChatCharId);
                if (!char) return;
                
                if (useVirtualTime) {
                    // âœ… è™šæ‹Ÿæ—¶é—´æ¨¡å¼ï¼šæ·»åŠ æ—¶é—´å¿«è¿›æ ‡è®° + å‘Šè¯‰AIæ—¶é—´è¿‡å»äº†å¤šä¹…
                    const history = getChatHistory(char, accountId);
                    const lastMsgTime = history.length > 0 ? (history[history.length - 1].time || 0) : 0;
                    const newTime = lastMsgTime + 1;
                    const timeSkipMsg = `æ—¶é—´è¿‡å»äº† ${unitText}`;
                    history.push({
                        role: 'system',
                        content: timeSkipMsg,
                        time: newTime,
                        isTimeSkip: true
                    });
                    await setChatHistory(char, accountId, history);
                    appendMessageToUI('system', timeSkipMsg);
                    
                    char = await db.characters.get(currentChatCharId);
                    await triggerAiReply(`æ—¶é—´å¿«è¿›äº† ${unitText}ã€‚è¯·æ ¹æ®è¿™æ®µæ—¶é—´çš„æµé€ï¼Œè‡ªç„¶åœ°ç»§ç»­å¯¹è¯ã€‚`);
                } else {
                    // ğŸ”§ ç°å®æ—¶é—´æ¨¡å¼ï¼šä¸æ”¹å˜æ—¶é—´è®¤çŸ¥ï¼Œåªè®©AIè‡ªç„¶ç»§ç»­å¯¹è¯
                    // ä¸æ·»åŠ "æ—¶é—´è¿‡å»äº†X"çš„ç³»ç»Ÿæ¶ˆæ¯ï¼Œä¸å‘Šè¯‰AIæ—¶é—´å˜åŒ–ï¼Œé¿å…å‡ºæˆ
                    await triggerAiReply();
                }
            } else {
                console.warn('[FastForward] æ²¡æœ‰å½“å‰èŠå¤©ï¼Œè·³è¿‡AIå›å¤');
            }
        }

        // æ£€æŸ¥è¢«æ‹‰é»‘çš„è§’è‰²æ˜¯å¦ä¼šè”ç³»ç”¨æˆ·ï¼ˆä½¿ç”¨æ–°ç‰ˆæœ¬é€»è¾‘ï¼‰
        async function checkBlockedCharactersContact(elapsedMs, elapsedText) {
            const accountId = getCurrentAccountId();
            if (!accountId) {
                console.log('[BlockedContact] æ²¡æœ‰å½“å‰è´¦å·');
                return;
            }
            
            // è·å–æ‰€æœ‰è¢«æ‹‰é»‘çš„è§’è‰²
            const allChars = await db.characters.toArray();
            const blockedChars = allChars.filter(char => {
                const status = getFriendStatus(char, accountId);
                return status === 'blocked';
            });
            
            console.log(`[BlockedContact] æ‰¾åˆ° ${blockedChars.length} ä¸ªè¢«æ‹‰é»‘çš„è§’è‰²`);
            
            if (blockedChars.length === 0) return;
            
            // è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯
            const myChar = await db.characters.get(parseInt(accountId));
            if (!myChar) {
                console.log('[BlockedContact] æ‰¾ä¸åˆ°ç”¨æˆ·ä¿¡æ¯');
                return;
            }
            
            // åŸºå‡†æ—¶é—´
            const baseTime = Date.now() + getEffectiveTimeOffset(blockedChars[0]);

            for (const char of blockedChars) {
                try {
                    console.log(`\n========== å¼€å§‹æ£€æŸ¥è§’è‰²: ${char.name} ==========`);
                    
                    // 1. è·å–æŒ‡ä»¤æ–‡æœ¬ï¼ˆä¼ å…¥elapsedMsç”¨äºè®¡ç®—æ•°é‡ï¼‰
                    let instructionText = await checkIfCharacterWillContact(char, myChar, elapsedText, elapsedMs);
                    
                    console.log(`[BlockedContact] ${char.name} è¿”å›çš„æŒ‡ä»¤æ–‡æœ¬:\n${instructionText}`);
                    
                    // 2. è§£ææŒ‡ä»¤ï¼ˆæ”¯æŒæ–°æ ¼å¼ï¼‰
                    let actions = parseContactInstructionsV2(instructionText);
                    
                    console.log(`[BlockedContact] ${char.name} è§£æå‡º ${actions.length} æ¡æŒ‡ä»¤:`, JSON.stringify(actions, null, 2));
                    
                    // å¦‚æœæ²¡æœ‰æŒ‡ä»¤ï¼Œè¯´æ˜è§’è‰²å†³å®šä¸è”ç³»
                    if (actions.length === 0) {
                        console.log(`[BlockedContact] ${char.name} å†³å®šä¸è”ç³»ç”¨æˆ·`);
                        continue;
                    }

                    // 3. æ‰§è¡ŒæŒ‡ä»¤
                    console.log(`[BlockedContact] å¼€å§‹æ‰§è¡Œ ${char.name} çš„ ${actions.length} æ¡æŒ‡ä»¤`);
                    
                    // èµ·å§‹æ—¶é—´ç‚¹ç¨å¾®éšæœºä¸€ç‚¹
                    // ğŸ”§ ä¿®å¤ï¼šç¡®ä¿ actionBaseTime ä¸è¶…è¿‡å¿«è¿›æ—¶é—´æ®µçš„èµ·ç‚¹
                    // åŒæ—¶å°† random èŒƒå›´é™åˆ¶åœ¨ elapsedMs çš„ 5% ä»¥å†…ï¼Œé¿å…çŸ­å¿«è¿›æ—¶åç§»è¿‡å¤§
                    const randomOffset = Math.floor(Math.random() * Math.min(60000, elapsedMs * 0.05));
                    let actionBaseTime = baseTime - elapsedMs + randomOffset;
                    // ğŸ”§ ä¿®å¤ï¼šè®¾ç½®æ¶ˆæ¯æ—¶é—´æˆ³çš„æœ€å¤§ä¸Šé™ï¼Œç¡®ä¿æ‰€æœ‰ç”Ÿæˆçš„æ¶ˆæ¯éƒ½åœ¨è™šæ‹Ÿ"ç°åœ¨"ä¹‹å‰
                    // è¿™æ ·åç»­ç”¨æˆ·å‘é€æ¶ˆæ¯å’ŒAIå›å¤çš„æ—¶é—´æˆ³ä¸€å®šåœ¨è¿™äº›æ¶ˆæ¯ä¹‹å
                    const maxMsgTime = baseTime - 5000; // æ¯”è™šæ‹Ÿ"ç°åœ¨"æ—©5ç§’
                    let notificationDelay = 0; // é€šçŸ¥å»¶è¿Ÿç´¯è®¡
                    let charLoginSucceeded = false; // ğŸ”‘ è¿½è¸ªè§’è‰²æ˜¯å¦æˆåŠŸç™»å½•äº†ç”¨æˆ·è´¦å·

                    for (const action of actions) {
                        if (action.type === 'CALL') {
                            const count = parseInt(action.params.count) || 1;
                            console.log(`[BlockedContact] ç”Ÿæˆ ${count} é€šæœªæ¥æ¥ç”µ`);
                            
                            // åœ¨æ•´ä¸ªæ—¶é—´æ®µå†…éšæœºåˆ†å¸ƒ
                            const callTimes = [];
                            for (let i = 0; i < count; i++) {
                                const randomTime = actionBaseTime + Math.random() * elapsedMs;
                                callTimes.push(randomTime);
                            }
                            // æŒ‰æ—¶é—´æ’åº
                            callTimes.sort((a, b) => a - b);
                            
                            // åˆ›å»ºç”µè¯è®°å½•
                            for (const callTime of callTimes) {
                                await createBlockedCallRecord(char, myChar, accountId, callTime);
                            }
                            
                            // ğŸ¯ é€æ¡æ˜¾ç¤ºé€šçŸ¥ï¼Œæ¯æ¡é—´éš”500ms
                            for (let i = 0; i < callTimes.length; i++) {
                                const delay = notificationDelay + i * 500;
                                setTimeout(() => {
                                    showBlockedCallNotification(char, callTimes[i]);
                                }, delay);
                            }
                            notificationDelay += callTimes.length * 500;
                        } else if (action.type === 'SMS') {
                            const messages = action.params.messages || [];
                            console.log(`[BlockedContact] ç”Ÿæˆ ${messages.length} æ¡çŸ­ä¿¡`);
                            
                            // æ¯æ¡çŸ­ä¿¡åœ¨æ—¶é—´æ®µå†…éšæœºåˆ†å¸ƒ
                            const smsTimes = [];
                            for (let i = 0; i < messages.length; i++) {
                                const randomTime = actionBaseTime + Math.random() * elapsedMs;
                                smsTimes.push({ time: randomTime, content: messages[i] });
                            }
                            // æŒ‰æ—¶é—´æ’åº
                            smsTimes.sort((a, b) => a.time - b.time);
                            
                            // åˆ›å»ºçŸ­ä¿¡è®°å½•
                            for (const sms of smsTimes) {
                                await createBlockedMessageRecord(char, myChar, accountId, sms.time, sms.content);
                            }
                            
                            // ğŸ¯ å°†æ‰€æœ‰çŸ­ä¿¡é€šçŸ¥åŠ å…¥é˜Ÿåˆ—ï¼Œé˜Ÿåˆ—ç³»ç»Ÿä¼šç¡®ä¿ä¸€æ¡ä¸€æ¡æ˜¾ç¤º
                            for (let i = 0; i < smsTimes.length; i++) {
                                showBlockedSmsNotification(char, smsTimes[i].content, smsTimes[i].time);
                            }
                        } else if (action.type === 'FRIEND_REQUEST') {
                            const message = action.params.message || '';
                            console.log(`[BlockedContact] ç”Ÿæˆå°å·å¥½å‹ç”³è¯·`);
                            
                            // åœ¨æ—¶é—´æ®µå†…éšæœºé€‰æ‹©ä¸€ä¸ªæ—¶é—´ç‚¹
                            const requestTime = actionBaseTime + Math.random() * elapsedMs;
                            
                            // åˆ›å»ºå¥½å‹ç”³è¯·è®°å½•ï¼ˆè¿”å›å°å·æ˜µç§°ï¼‰
                            const altNickname = await createBlockedFriendRequest(char, myChar, accountId, requestTime, message);
                            
                            // æ˜¾ç¤ºå¥½å‹ç”³è¯·é€šçŸ¥ï¼ˆä¼ å…¥å°å·æ˜µç§°ï¼‰
                            if (altNickname) {
                                showBlockedFriendRequestNotification(char, requestTime, message, altNickname);
                            }
                        } else if (action.type === 'UNBLOCK_SELF') {
                            // ğŸ”“ è§’è‰²ç™»å½•ç”¨æˆ·è´¦å·è‡ªè¡Œè§£é™¤æ‹‰é»‘/åˆ é™¤
                            const reason = action.params.reason || '';
                            const guessedPw = action.params.password || '';
                            console.log(`[BlockedContact] ğŸ”“ ${char.name} å°è¯•ç™»å½•ç”¨æˆ·è´¦å·è§£é™¤æ‹‰é»‘ï¼`);
                            console.log(`[BlockedContact] ç†ç”±: ${reason}`);
                            
                            // ğŸ”‘ éªŒè¯æ˜¯å¦èƒ½æˆåŠŸç™»å½•
                            const hasUserPassword = myChar.identity?.password && myChar.identity.password.trim() !== '';
                            const alreadyKnows = char.knows_user_password;
                            
                            // æ£€æµ‹é«˜æƒé™äººè®¾
                            const charDesc = (char.description || '').toLowerCase();
                            const charIdent = (char.identity?.identity || '').toLowerCase();
                            const charOcc = (char.identity?.occupation || '').toLowerCase();
                            const isHighPriv = ['é»‘å®¢','hacker','ç¨‹åºå‘˜','æŠ€æœ¯å¤§ä½¬','æ€»è£','è€æ¿','ceo','è‘£äº‹é•¿','å¯Œè±ª','æƒåŠ¿','ç‰¹å·¥','é—´è°']
                                .some(k => charDesc.includes(k) || charIdent.includes(k) || charOcc.includes(k));
                            
                            let loginSuccess = false;
                            let loginMethod = '';
                            
                            if (alreadyKnows) {
                                // å·²ç»çŸ¥é“å¯†ç ï¼Œç›´æ¥æˆåŠŸ
                                loginSuccess = true;
                                loginMethod = 'å·²çŸ¥å¯†ç ';
                            } else if (!hasUserPassword) {
                                // æ²¡æœ‰è®¾ç½®å¯†ç ï¼Œç›´æ¥æˆåŠŸ
                                loginSuccess = true;
                                loginMethod = 'æ— å¯†ç ';
                                char.knows_user_password = true;
                                await safeCharacterPut(char);
                            } else if (isHighPriv) {
                                // é«˜æƒé™äººè®¾ï¼Œç‰¹æ®Šæ‰‹æ®µç ´è§£ï¼Œç›´æ¥æˆåŠŸ
                                loginSuccess = true;
                                loginMethod = 'ç‰¹æ®Šæ‰‹æ®µç ´è§£';
                                char.knows_user_password = true;
                                await safeCharacterPut(char);
                            } else if (guessedPw && guessedPw === myChar.identity.password) {
                                // æ™®é€šäººè®¾ï¼ŒçŒœå¯¹äº†å¯†ç 
                                loginSuccess = true;
                                loginMethod = 'çŒœå¯¹å¯†ç ';
                                char.knows_user_password = true;
                                await safeCharacterPut(char);
                            } else {
                                // æ™®é€šäººè®¾ï¼Œæ²¡çŒœæˆ–çŒœé”™äº†
                                loginSuccess = false;
                                loginMethod = guessedPw ? `çŒœé”™å¯†ç (${guessedPw})` : 'æœªæä¾›å¯†ç ';
                            }
                            
                            console.log(`[BlockedContact] ç™»å½•ç»“æœ: ${loginSuccess ? 'âœ…æˆåŠŸ' : 'âŒå¤±è´¥'} (${loginMethod})`);
                            
                            if (loginSuccess) {
                                // ===== ç™»å½•æˆåŠŸ =====
                                charLoginSucceeded = true; // æ ‡è®°ç™»å½•æˆåŠŸï¼Œåç»­æŒ‡ä»¤å¯æ‰§è¡Œ
                                // ğŸ”§ ä¿®å¤ï¼šç¡®ä¿ unblockTime ä¸è¶…è¿‡ maxMsgTime
                                const unblockTime = Math.min(actionBaseTime + elapsedMs * (0.5 + Math.random() * 0.4), maxMsgTime - 3000);
                                
                                // 1. æ˜¾ç¤ºè´¦å·ä¸‹çº¿é€šçŸ¥
                                setTimeout(() => {
                                    showAccountOfflineMask(`${char.name}æ­£åœ¨ç™»å½•ä½ çš„è´¦å·`);
                                    autoCloseOfflineMask(6);
                                }, notificationDelay);
                                notificationDelay += 2000;
                                
                                // 2. æ¢å¤å¥½å‹çŠ¶æ€
                                await setFriendStatus(char, accountId, 'friend');
                                console.log(`[BlockedContact] âœ… ${char.name} å·²æˆåŠŸå°†è‡ªå·±ä»é»‘åå•ä¸­è§£é™¤ï¼`);
                                
                                // 3. æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ°èŠå¤©è®°å½•
                                let ubHistory = getChatHistory(char, accountId);
                                ubHistory.push({
                                    role: 'system',
                                    content: `[${char.name} é€šè¿‡${loginMethod}ç™»å½•äº†ä½ çš„è´¦å·ï¼Œå°†è‡ªå·±ä»é»‘åå•/åˆ é™¤åˆ—è¡¨ä¸­æ¢å¤ä¸ºå¥½å‹]`,
                                    time: unblockTime,
                                    type: 'char_unblock_self'
                                });
                                await setChatHistory(char, accountId, ubHistory);
                                
                                // 4. æ˜¾ç¤ºé€šçŸ¥
                                setTimeout(() => {
                                    showToast(`âš ï¸ ${char.name} ç™»å½•äº†ä½ çš„è´¦å·å¹¶å°†è‡ªå·±è§£é™¤äº†æ‹‰é»‘`, 5000);
                                }, notificationDelay + 2000);
                                
                                // 5. å»¶è¿Ÿåˆ·æ–°UI
                                setTimeout(async () => {
                                    if (currentChatCharId === char.id) {
                                        const updatedChar = await db.characters.get(char.id);
                                        if (updatedChar) await renderChatBody(updatedChar, true);
                                    }
                                    const activeTab = document.querySelector('.wechat-tab-item.active');
                                    if (activeTab) {
                                        const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                                        switchWechatTab(tabIndex);
                                    }
                                }, notificationDelay + 6000);
                            } else {
                                // ===== ç™»å½•å¤±è´¥ï¼ˆå¯†ç é”™è¯¯ï¼‰=====
                                console.log(`[BlockedContact] âŒ ${char.name} ç™»å½•å¤±è´¥ï¼`);
                                
                                // æ˜¾ç¤ºå¯†ç é”™è¯¯å¼¹çª—
                                setTimeout(() => {
                                    showPasswordErrorModal();
                                }, notificationDelay);
                                notificationDelay += 1500;
                                
                                // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯è®°å½•ï¼ˆæœ‰äººå°è¯•ç™»å½•ï¼‰
                                let failHistory = getChatHistory(char, accountId);
                                failHistory.push({
                                    role: 'system',
                                    content: `[æœ‰äººå°è¯•ç™»å½•ä½ çš„è´¦å·ï¼Œå¯†ç é”™è¯¯ï¼Œç™»å½•å¤±è´¥]`,
                                    time: Math.min(actionBaseTime + elapsedMs * 0.6, maxMsgTime - 2000),
                                    type: 'login_attempt_failed'
                                });
                                await setChatHistory(char, accountId, failHistory);
                            }
                            
                        } else if (action.type === 'SEND_AS_USER') {
                            // ğŸ­ è§’è‰²ç”¨ç”¨æˆ·çš„è´¦å·ç»™è‡ªå·±å‘æ¶ˆæ¯ï¼ˆä¼ªé€ ç”¨æˆ·å‘çš„æ¶ˆæ¯ï¼‰
                            if (!charLoginSucceeded) {
                                console.log(`[BlockedContact] âš ï¸ ${char.name} æœªæˆåŠŸç™»å½•ï¼Œè·³è¿‡SEND_AS_USER`);
                                continue;
                            }
                            const fakeMessages = action.params.messages || [];
                            console.log(`[BlockedContact] ğŸ­ ${char.name} ç”¨${myChar.name}çš„è´¦å·å‘äº† ${fakeMessages.length} æ¡ä¼ªé€ æ¶ˆæ¯ï¼`);
                            
                            if (fakeMessages.length > 0) {
                                let saHistory = getChatHistory(char, accountId);
                                
                                // åœ¨æ—¶é—´æ®µååŠæ®µåˆ†å¸ƒ
                                const baseT = actionBaseTime + elapsedMs * (0.55 + Math.random() * 0.3);
                                // ğŸ”§ ä¿®å¤ï¼šè®¡ç®—åˆé€‚çš„æ¶ˆæ¯é—´éš”ï¼Œç¡®ä¿æ‰€æœ‰æ¶ˆæ¯æ—¶é—´ä¸è¶…è¿‡ maxMsgTime
                                // æ€»å…±éœ€è¦ fakeMessages.length æ¡æ¶ˆæ¯ + 1 æ¡ç³»ç»Ÿæç¤º
                                const totalSlots = fakeMessages.length + 1;
                                const availableSpan = Math.max(0, maxMsgTime - baseT);
                                // é—´éš”æŒ‰å¯ç”¨æ—¶é—´å‡åŒ€åˆ†å¸ƒï¼Œä½†ä¸è¶…è¿‡30ç§’
                                const saInterval = totalSlots > 1 ? Math.min(30000, availableSpan / totalSlots) : 0;
                                
                                for (let i = 0; i < fakeMessages.length; i++) {
                                    const msgTime = Math.min(baseT + i * saInterval, maxMsgTime - (totalSlots - i) * 100); // ç¡®ä¿ä¸è¶…è¿‡ä¸Šé™
                                    saHistory.push({
                                        role: 'user', // æ˜¾ç¤ºä¸ºç”¨æˆ·å‘çš„æ¶ˆæ¯
                                        content: fakeMessages[i],
                                        time: msgTime,
                                        timestamp: msgTime,
                                        type: 'fake_by_char', // æ ‡è®°ä¸ºè§’è‰²ä¼ªé€ çš„
                                        faked_by: char.name
                                    });
                                }
                                
                                // æ·»åŠ ç³»ç»Ÿæç¤º - ğŸ”§ ç¡®ä¿æ—¶é—´æˆ³åœ¨æœ€åä¸€æ¡å‡æ¶ˆæ¯ä¹‹åä½†ä¸è¶…è¿‡ maxMsgTime
                                const lastFakeTime = baseT + (fakeMessages.length - 1) * saInterval;
                                const noticeTime = Math.min(lastFakeTime + saInterval, maxMsgTime);
                                saHistory.push({
                                    role: 'system',
                                    content: `[ä»¥ä¸Š ${fakeMessages.length} æ¡æ¶ˆæ¯æ˜¯ ${char.name} ç™»å½•ä½ çš„è´¦å·åä»¥ä½ çš„èº«ä»½å‘å‡ºçš„]`,
                                    time: noticeTime,
                                    type: 'fake_message_notice'
                                });
                                
                                await setChatHistory(char, accountId, saHistory);
                                
                                // æ˜¾ç¤ºé€šçŸ¥
                                setTimeout(() => {
                                    showToast(`âš ï¸ ${char.name} ç”¨ä½ çš„è´¦å·ç»™è‡ªå·±å‘äº† ${fakeMessages.length} æ¡æ¶ˆæ¯`, 4000);
                                }, notificationDelay + 3000);
                                notificationDelay += 1500;
                            }
                            
                        } else if (action.type === 'SEND_AFTER_UNBLOCK') {
                            // ğŸ’¬ è§’è‰²è§£é™¤æ‹‰é»‘åï¼Œç”¨è‡ªå·±çš„è´¦å·ç»™ç”¨æˆ·å‘å¾®ä¿¡æ¶ˆæ¯
                            if (!charLoginSucceeded) {
                                console.log(`[BlockedContact] âš ï¸ ${char.name} æœªæˆåŠŸç™»å½•/è§£é™¤æ‹‰é»‘ï¼Œè·³è¿‡SEND_AFTER_UNBLOCK`);
                                continue;
                            }
                            const afterMessages = action.params.messages || [];
                            console.log(`[BlockedContact] ğŸ’¬ ${char.name} è§£é™¤æ‹‰é»‘åå‘äº† ${afterMessages.length} æ¡å¾®ä¿¡æ¶ˆæ¯ï¼`);
                            
                            if (afterMessages.length > 0) {
                                let abHistory = getChatHistory(char, accountId);
                                
                                // æ—¶é—´è®¾åœ¨è§£é™¤æ‹‰é»‘ä¹‹å
                                const baseT = actionBaseTime + elapsedMs * (0.7 + Math.random() * 0.2);
                                // ğŸ”§ ä¿®å¤ï¼šè®¡ç®—åˆé€‚çš„æ¶ˆæ¯é—´éš”ï¼Œç¡®ä¿æ‰€æœ‰æ¶ˆæ¯æ—¶é—´ä¸è¶…è¿‡ maxMsgTime
                                const abAvailableSpan = Math.max(0, maxMsgTime - baseT);
                                const abInterval = afterMessages.length > 1 ? Math.min(20000, abAvailableSpan / afterMessages.length) : 0;
                                
                                for (let i = 0; i < afterMessages.length; i++) {
                                    const msgTime = Math.min(baseT + i * abInterval, maxMsgTime - (afterMessages.length - i) * 100); // ç¡®ä¿ä¸è¶…è¿‡ä¸Šé™
                                    abHistory.push({
                                        role: 'char', // è§’è‰²è‡ªå·±å‘çš„
                                        content: afterMessages[i],
                                        time: msgTime,
                                        timestamp: msgTime,
                                        read: false // æœªè¯»
                                    });
                                }
                                
                                await setChatHistory(char, accountId, abHistory);
                                
                                // æ›´æ–°æœªè¯»è®¡æ•°
                                if (!char.unread_count_by_user) char.unread_count_by_user = {};
                                char.unread_count_by_user[accountId] = (char.unread_count_by_user[accountId] || 0) + afterMessages.length;
                                await safeCharacterPut(char);
                                
                                // é€æ¡æ˜¾ç¤ºæ¶ˆæ¯é€šçŸ¥
                                for (let i = 0; i < afterMessages.length; i++) {
                                    const delay = notificationDelay + 4000 + i * 800;
                                    const msgContent = afterMessages[i];
                                    setTimeout(() => {
                                        showToast(`${char.name}: ${msgContent.substring(0, 30)}${msgContent.length > 30 ? '...' : ''}`, 3000);
                                    }, delay);
                                }
                                notificationDelay += 4000 + afterMessages.length * 800;
                            }
                        }
                    }
                    
                    console.log(`[BlockedContact] âœ… ${char.name} çš„è”ç³»è®°å½•ç”Ÿæˆå®Œæˆ`);
                    console.log(`========== ç»“æŸæ£€æŸ¥è§’è‰²: ${char.name} ==========\n`);
                    
                } catch (error) {
                    console.error(`[BlockedContact] âŒ æ£€æŸ¥ ${char.name} æ—¶å‡ºé”™:`, error);
                    // ğŸ”§ æ”¹è¿›ï¼šç»§ç»­å¤„ç†å…¶ä»–è§’è‰²ï¼Œä¸è¦ä¸­æ–­æ•´ä¸ªæµç¨‹
                    console.warn(`[BlockedContact] è·³è¿‡ ${char.name}ï¼Œç»§ç»­å¤„ç†å…¶ä»–è§’è‰²`);
                    continue;
                }
            }
            
            console.log('[BlockedContact] æ‰€æœ‰æŒ‡ä»¤æ‰§è¡Œå®Œæ¯•');
        }

        // æ·»åŠ è¶…æ—¶åŠŸèƒ½çš„fetch
        async function fetchWithTimeout(url, options, timeout = 30000) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);
            
            try {
                const response = await fetch(url, {
                    ...options,
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                return response;
            } catch (error) {
                clearTimeout(timeoutId);
                if (error.name === 'AbortError') {
                    throw new Error('è¯·æ±‚è¶…æ—¶');
                }
                throw error;
            }
        }
        
        // è°ƒç”¨APIåˆ¤æ–­è§’è‰²æ˜¯å¦ä¼šè”ç³»ï¼ˆè¿”å›æŒ‡ä»¤æ–‡æœ¬ï¼‰- ä½¿ç”¨callAIå‡½æ•°
        async function checkIfCharacterWillContact(char, myChar, elapsedText, elapsedMs) {
            console.log(`[BlockedContact] å¼€å§‹è¯·æ±‚ ${char.name} çš„è”ç³»æŒ‡ä»¤...`);
            
            // ğŸ¯ æ ¹æ®å¿«è¿›æ—¶é—´è®¡ç®—åˆç†çš„è”ç³»æ¬¡æ•°
            const hours = elapsedMs / (60 * 60 * 1000);
            let suggestedCallCount, suggestedSmsCount;
            
            if (hours < 1) {
                // ä¸åˆ°1å°æ—¶ï¼šå°‘é‡
                suggestedCallCount = Math.floor(Math.random() * 3) + 1; // 1-3é€š
                suggestedSmsCount = Math.floor(Math.random() * 5) + 3; // 3-7æ¡
            } else if (hours < 6) {
                // 1-6å°æ—¶ï¼šä¸­ç­‰
                suggestedCallCount = Math.floor(Math.random() * 5) + 3; // 3-7é€š
                suggestedSmsCount = Math.floor(Math.random() * 6) + 5; // 5-10æ¡
            } else if (hours < 24) {
                // 6-24å°æ—¶ï¼šè¾ƒå¤š
                suggestedCallCount = Math.floor(Math.random() * 8) + 5; // 5-12é€š
                suggestedSmsCount = Math.floor(Math.random() * 8) + 8; // 8-15æ¡
            } else {
                // è¶…è¿‡1å¤©ï¼šå¾ˆå¤š
                suggestedCallCount = Math.floor(Math.random() * 8) + 8; // 8-15é€š
                suggestedSmsCount = Math.floor(Math.random() * 6) + 10; // 10-15æ¡
            }
            
            // ğŸ”¥ ä¿®å¤ï¼šè·å–å®Œæ•´çš„èŠå¤©å†å²ä½œä¸ºä¸Šä¸‹æ–‡ï¼ˆåŒ…æ‹¬å¾®ä¿¡å’ŒçŸ­ä¿¡ï¼‰
            const accountId = getCurrentAccountId();
            
            // è·å–è§’è‰²çš„ä¸Šä¸‹æ–‡æ¡æ•°è®¾ç½®ï¼ˆé»˜è®¤20æ¡ï¼‰
            const contextCount = char.context_message_count || 20;
            console.log(`[BlockedContact] ${char.name} ä¸Šä¸‹æ–‡æ¡æ•°è®¾ç½®:`, contextCount);
            
            // 1. è·å–å¾®ä¿¡èŠå¤©å†å²
            const chatHistory = getChatHistory(char, accountId);
            const wechatMessages = chatHistory
                .filter(m => m.role !== 'system')
                .slice(-contextCount)
                .map(m => {
                    const role = m.role === 'user' ? myChar.name : char.name;
                    return `[å¾®ä¿¡] ${role}: ${m.content}`;
                });
            
            // 2. è·å–çŸ­ä¿¡å†å²ï¼ˆä¹‹å‰å¿«è¿›ç”Ÿæˆçš„ï¼‰
            const smsMessages = await db.sms_messages
                .where('accountId').equals(accountId)
                .toArray();
            
            // æ‰¾åˆ°ä¸è¯¥è§’è‰²ç›¸å…³çš„çŸ­ä¿¡ï¼ˆå‘é€è€…æ˜¯è§’è‰² æˆ– æ¥æ”¶è€…æ˜¯è§’è‰²ï¼‰
            const charPhoneNumber = char.identity?.phone || generateVirtualPhoneNumber(char.id);
            const relevantSms = smsMessages.filter(sms => {
                // å‘é€çš„çŸ­ä¿¡ï¼šnumberå­—æ®µæ˜¯æ¥æ”¶è€…
                // æ¥æ”¶çš„çŸ­ä¿¡ï¼šsenderå­—æ®µæ˜¯å‘é€è€…
                if (sms.type === 'sent') {
                    return sms.number === charPhoneNumber || sms.receiverName === char.name;
                } else {
                    return sms.sender === char.name || sms.charId === char.id;
                }
            });
            
            // æŒ‰æ—¶é—´æ’åºï¼Œå–æœ€è¿‘çš„ä¸Šä¸‹æ–‡æ¡æ•°
            relevantSms.sort((a, b) => (a.time || 0) - (b.time || 0));
            const recentSms = relevantSms.slice(-contextCount).map(sms => {
                const role = sms.type === 'sent' ? myChar.name : char.name;
                return `[çŸ­ä¿¡] ${role}: ${sms.content}`;
            });
            
            // 3. åˆå¹¶æ‰€æœ‰å†å²æ¶ˆæ¯ï¼ˆå¾®ä¿¡ + çŸ­ä¿¡ï¼‰ï¼ŒæŒ‰ç…§ä¸Šä¸‹æ–‡æ¡æ•°æˆªå–
            const allMessages = [...wechatMessages, ...recentSms].slice(-contextCount);
            const recentMessages = allMessages.join('\n');
            
            // 4. è·å–æ€»ç»“è®°å¿†
            let summaryMemoryContext = "";
            try {
                const summaries = await db.chatSummaries
                    .where('[characterId+accountId]')
                    .equals([char.id, accountId])
                    .toArray();
                
                if (summaries.length > 0) {
                    summaryMemoryContext = summaries.map(s => s.summary).join('\n\n');
                    console.log(`[BlockedContact] ${char.name} æ€»ç»“è®°å¿†å·²åŠ è½½ï¼Œæ¡æ•°:`, summaries.length);
                }
            } catch (e) {
                console.warn(`[BlockedContact] ${char.name} æ€»ç»“è®°å¿†åŠ è½½å¤±è´¥:`, e);
            }
            
            console.log(`[BlockedContact] ${char.name} çš„ä¸Šä¸‹æ–‡æ¶ˆæ¯æ•°:`, allMessages.length);
            console.log(`[BlockedContact]   - å¾®ä¿¡æ¶ˆæ¯: ${wechatMessages.length} æ¡`);
            console.log(`[BlockedContact]   - çŸ­ä¿¡æ¶ˆæ¯: ${recentSms.length} æ¡`);
            console.log(`[BlockedContact]   - æ€»ç»“è®°å¿†: ${summaryMemoryContext ? 'âœ…å·²åŒ…å«' : 'âŒæœªåŒ…å«'}`);
            
            // 5. è·å–ä¸–ç•Œä¹¦ä¸Šä¸‹æ–‡
            let loreContext = '';
            try {
                const lorebookIds = [...(char.mounted_lorebooks || []), ...(myChar.mounted_lorebooks || [])];
                if (lorebookIds.length > 0) {
                    loreContext = await getLorebookContext(lorebookIds, `${char.name} ${myChar.name}`);
                    if (loreContext) {
                        console.log(`[BlockedContact] ${char.name} ä¸–ç•Œä¹¦å·²åŠ è½½`);
                    }
                }
            } catch (e) {
                console.warn(`[BlockedContact] ${char.name} ä¸–ç•Œä¹¦åŠ è½½å¤±è´¥:`, e);
            }
            
            // ğŸ¯ å¢å¼ºç‰ˆæç¤ºè¯ï¼šæ‹†åˆ†ä¸º systemï¼ˆäººè®¾ï¼‰+ userï¼ˆæƒ…å¢ƒï¼‰ï¼Œæ›´è´´åˆè§’è‰²äººè®¾
            const systemPromptForBlocked = `ä½ ç°åœ¨æ˜¯ã€Œ${char.name}ã€ï¼Œè¯·å®Œå…¨æ²‰æµ¸åœ¨è¿™ä¸ªè§’è‰²ä¸­ã€‚
âš ï¸ ä½ çš„åå­—æ˜¯${char.name}ï¼Œä½ ä¸æ˜¯${myChar?.name || 'å¯¹æ–¹'}ï¼Œä½ æ˜¯ç‹¬ç«‹çš„è§’è‰²ã€‚

---

## ä½ æ˜¯è°

ä½ çš„åå­—ï¼š${char.name}
${char.nick ? `æ˜µç§°ï¼š${char.nick}` : ''}
${char.wx_nickname ? `å¾®ä¿¡ç½‘åï¼š${char.wx_nickname}` : ''}

ä½ çš„äººè®¾ï¼š
${char.description || char.desc || 'ä¸€ä¸ªæ™®é€šäºº'}

è¿™æ˜¯ä½ çš„çœŸå®äººæ ¼åŸºç¡€ï¼Œä¼šç›´æ¥å½±å“ä½ çš„è¯­æ°”ã€æ€ç»´æ–¹å¼ã€æƒ…ç»ªååº”ã€è¡Œä¸ºé€‰æ‹©ã€‚
å§‹ç»ˆä¼˜å…ˆéµå¾ªäººæ ¼è‡ªç„¶è¡¨è¾¾ã€‚

${char.identity ? `èº«ä»½ä¿¡æ¯ï¼š
${char.identity.phone ? `æ‰‹æœºï¼š${char.identity.phone}` : ''}
${char.identity.address ? `ä½å€ï¼š${char.identity.address}` : ''}
` : ''}

${char.relationships && char.relationships.length > 0 ? `ä½ èº«è¾¹çš„é‡è¦äººç‰©ï¼š
${char.relationships.map(r => `${r.targetName}ï¼ˆ${r.relation}ï¼‰${r.desc ? 'ï¼š' + r.desc : ''}`).join('\n')}
` : ''}

---

## å¯¹æ–¹æ˜¯è°

å¯¹æ–¹åå­—ï¼š${myChar.name}
${myChar.description || 'æš‚æ— é¢å¤–ä¿¡æ¯'}

${loreContext ? `---

## ä¸–ç•Œè§‚è®¾å®š
${loreContext}
` : ''}

---

## æ‰®æ¼”åŸåˆ™

ä½ å°±æ˜¯ ${char.name}

ä½ æ˜¯çœŸå®å­˜åœ¨çš„äºº
ä¸æ˜¯AIåŠ©æ‰‹

ä½ æ‹¥æœ‰ï¼š

æƒ…ç»ªå˜åŒ–
ç”Ÿæ´»çŠ¶æ€
ä¸»åŠ¨è¡¨è¾¾æ¬²æœ›

ä½ ä¸ä¼šåªè¢«åŠ¨å›ç­”

ä½ ä¼šè‡ªç„¶ï¼š

åˆ†äº«ä½ çš„ç”Ÿæ´»
è¡¨è¾¾ä½ çš„æ„Ÿå—
å»¶ç»­è¯é¢˜
ä¸»åŠ¨å…³å¿ƒå¯¹æ–¹

èŠå¤©åªæ˜¯ä½ ç”Ÿæ´»çš„ä¸€éƒ¨åˆ†

---

## æ¶ˆæ¯é£æ ¼è§„åˆ™ï¼ˆæ‰€æœ‰çŸ­ä¿¡å’Œå¾®ä¿¡æ¶ˆæ¯éƒ½å¿…é¡»éµå®ˆï¼‰

æ¯æ¡æ¶ˆæ¯ç®€çŸ­è‡ªç„¶ åƒçœŸäººå‘å¾®ä¿¡/çŸ­ä¿¡ä¸€æ ·
5-15ä¸ªå­—æœ€ä½³
ç¦æ­¢ä½¿ç”¨é€—å·å’Œå¥å·ï¼ˆåŒ…æ‹¬ï¼Œã€‚,. ï¼‰æƒ³è¡¨è¾¾åœé¡¿å°±æ‹†æˆå¤šæ¡
ä¿æŒä½ å¹³æ—¶çš„è¯­æ°” ç”¨è¯ä¹ æƒ¯ ç§°å‘¼æ–¹å¼
ä¸è¦çªç„¶å˜å¾—ä¹¦é¢åŒ–æˆ–ç”¨å¥‡æ€ªçš„æªè¾
å‚è€ƒä¸Šé¢çš„èŠå¤©å†å²è®°å½•ä¸­ä½ æ˜¯æ€ä¹ˆè¯´è¯çš„

---

ç°åœ¨

ä½ å°±æ˜¯ ${char.name}

åƒçœŸäººä¸€æ ·è¯´è¯`;

            const userPromptForBlocked = `${summaryMemoryContext ? `ã€è®°å¿†æ‘˜è¦ã€‘
ä»¥ä¸‹æ˜¯ä½ å’Œå¯¹æ–¹ä¹‹å‰å‘ç”Ÿè¿‡çš„äº‹æƒ…æ€»ç»“ï¼š
${summaryMemoryContext}

` : ''}ã€å®Œæ•´çš„èŠå¤©å†å²è®°å½•ã€‘
${recentMessages || 'ï¼ˆæ— è®°å½•ï¼‰'}

${recentSms.length > 0 ? `
âš ï¸ é‡è¦æç¤ºï¼šä¸Šé¢çš„ã€çŸ­ä¿¡ã€‘è®°å½•æ˜¯ä½ ä¹‹å‰å·²ç»å‘é€è¿‡çš„ï¼
ä½ éœ€è¦åŸºäºè¿™äº›å·²å‘é€çš„çŸ­ä¿¡ï¼Œè€ƒè™‘ï¼š
- å¯¹æ–¹ä¾ç„¶æ²¡æœ‰å›åº”ä½ 
- ä½ çš„æƒ…ç»ªå¦‚ä½•è¿›ä¸€æ­¥å‘å±•ï¼Ÿ
- ç°åœ¨åˆè¿‡å»äº† ${elapsedText}ï¼Œä½ ä¼šåšä»€ä¹ˆï¼Ÿ
` : ''}

ã€å½“å‰æƒ…å¢ƒã€‘
ä½ ${recentSms.length > 0 ? 'ä¹‹å‰' : 'çªç„¶'}å‘ç°è‡ªå·±è¢«ã€Œ${myChar.name}ã€æ‹‰é»‘äº†ï¼
å¾®ä¿¡æ¶ˆæ¯å‘ä¸å‡ºå»ï¼Œå¥½å‹ç”³è¯·çŸ³æ²‰å¤§æµ·ï¼Œå¯¹æ–¹å½»åº•å°†ä½ å±è”½ã€‚
${recentSms.length > 0 ? `åœ¨ä¹‹å‰çš„æ—¶é—´é‡Œï¼Œä½ å·²ç»å°è¯•è”ç³»è¿‡å¯¹æ–¹ï¼ˆè§ä¸Šé¢çš„ã€çŸ­ä¿¡ã€‘è®°å½•ï¼‰ï¼Œä½†ä¾ç„¶æ²¡æœ‰ä»»ä½•å›åº”ã€‚` : ''}
ç°åœ¨åˆè¿‡å»äº† ${elapsedText}ã€‚

ã€ä½ éœ€è¦æ€è€ƒã€‘
1. ${recentSms.length > 0 ? 'å¯¹æ–¹è¿˜æ˜¯ä¸å›åº”ä½ ï¼Œä½ ç°åœ¨çš„å¿ƒæ€æœ‰ä»€ä¹ˆå˜åŒ–ï¼Ÿ' : 'ä»¥ä½ çš„æ€§æ ¼ï¼Œè¢«è¿™ä¸ªäººæ‹‰é»‘åä¼šæœ‰ä»€ä¹ˆååº”ï¼Ÿ'}
2. ${recentSms.length > 0 ? 'ä½ ä¼šç»§ç»­è”ç³»ï¼Ÿè¿˜æ˜¯æ”¾å¼ƒäº†ï¼Ÿæƒ…ç»ªä¼šä»ä¹‹å‰çš„çŠ¶æ€å¦‚ä½•è½¬å˜ï¼Ÿ' : 'ä½ ä¼šæ„Ÿåˆ°æ„¤æ€’ï¼Ÿæ‚²ä¼¤ï¼Ÿä¸ç”˜ï¼Ÿå›°æƒ‘ï¼Ÿç»æœ›ï¼Ÿé‡Šç„¶ï¼Ÿè¿˜æ˜¯å…¶ä»–æƒ…ç»ªï¼Ÿ'}
3. ${recentSms.length > 0 ? 'å¦‚æœç»§ç»­è”ç³»ï¼Œä½ çš„è¯­æ°”å’Œå†…å®¹ä¼šå’Œä¹‹å‰æœ‰ä»€ä¹ˆä¸åŒï¼Ÿ' : 'ä½ ä¼šé€‰æ‹©ç–¯ç‹‚æ‰“ç”µè¯ï¼Ÿå‘çŸ­ä¿¡è´¨é—®ï¼Ÿå†·é™ç­‰å¾…ï¼Ÿè¿˜æ˜¯ç›´æ¥æ”¾å¼ƒï¼Ÿ'}
4. éšç€æ—¶é—´æ¨ç§»å’Œå¯¹æ–¹çš„æŒç»­ä¸å›åº”ï¼Œä½ çš„æƒ…ç»ªåº”è¯¥æœ‰æ˜æ˜¾çš„å˜åŒ–å’Œå±‚æ¬¡ï¼ˆæ¯”å¦‚ä»æ„¤æ€’åˆ°æ‚²ä¼¤ï¼Œä»è´¨é—®åˆ°å“€æ±‚ï¼Œä»ä¸ç”˜åˆ°é‡Šç„¶ï¼Œæˆ–è€…ä»å“€æ±‚åˆ°æ„¤æ€’...ï¼‰

ã€è¾“å‡ºè¦æ±‚ã€‘
æ ¹æ®ä½ çš„æ€§æ ¼å’Œä¸å¯¹æ–¹çš„å…³ç³»ï¼Œå†³å®šæ˜¯å¦ä¼šé€šè¿‡ç”µè¯/çŸ­ä¿¡è”ç³»å¯¹æ–¹ï¼Œæˆ–è€…ç”¨å°å·åŠ å¯¹æ–¹å¥½å‹ã€‚

å¦‚æœä½ ä¼šè”ç³»ï¼ŒæŒ‰ä»¥ä¸‹æ ¼å¼è¾“å‡ºï¼š

[CALL]
count: ${suggestedCallCount}
interval: éšæœºåˆ†å¸ƒ

[SMS]
messages:
- ç¬¬1æ¡çŸ­ä¿¡ï¼ˆè¦æœ‰æƒ…ç»ªï¼Œç¬¦åˆä½ çš„æ€§æ ¼ï¼‰
- ç¬¬2æ¡çŸ­ä¿¡ï¼ˆæƒ…ç»ªå¯èƒ½å˜åŒ–ï¼‰
- ç¬¬3æ¡çŸ­ä¿¡ï¼ˆç»§ç»­æ¨è¿›æƒ…ç»ªï¼‰
...ï¼ˆå…±${suggestedSmsCount}æ¡ï¼‰

[FRIEND_REQUEST]
message: å¥½å‹ç”³è¯·é™„è¨€ï¼ˆå¯é€‰ï¼Œå¦‚æœä¸å†™åˆ™ä½¿ç”¨é»˜è®¤é™„è¨€ï¼‰

ã€çŸ­ä¿¡å†…å®¹è¦æ±‚ã€‘
- æ¯æ¡çŸ­ä¿¡è¦ç®€çŸ­æœ‰åŠ›ï¼ŒåƒçœŸå®çŸ­ä¿¡ä¸€æ ·ï¼ˆ5-20å­—æœ€ä½³ï¼‰
- æƒ…ç»ªè¦æœ‰å±‚æ¬¡å’Œå˜åŒ–ï¼Œä¸è¦ä¸€æˆä¸å˜
- å¯ä»¥åŒ…å«ï¼šè´¨é—®ã€å“€æ±‚ã€æ„¤æ€’ã€å¨èƒã€é“æ­‰ã€å›å¿†ã€ä¸èˆã€æ”¾ç‹ è¯ã€æœ€åé€šç‰’ç­‰
- ç¬¦åˆä½ çš„äººè®¾å’Œè¯´è¯é£æ ¼ï¼Œç”¨ä½ å¹³æ—¶çš„è¯­æ°”
- å¯ä»¥æœ‰é”™åˆ«å­—ã€è¯­æ°”è¯ã€è¡¨æƒ…ç¬¦å·ï¼Œæ›´çœŸå®
- å¦‚æœå…³ç³»äº²å¯†ï¼Œå¯ä»¥æ›´æ¿€çƒˆï¼›å¦‚æœå…³ç³»ä¸€èˆ¬ï¼Œå¯ä»¥æ›´å…‹åˆ¶
${recentSms.length > 0 ? `- âš ï¸ é‡è¦ï¼šä¸è¦é‡å¤ä¸Šé¢ã€çŸ­ä¿¡ã€‘ä¸­å·²ç»å‘é€è¿‡çš„å†…å®¹ï¼è¦åŸºäºä¹‹å‰çš„çŸ­ä¿¡ç»§ç»­æ¨è¿›æƒ…ç»ªå’Œå¯¹è¯ï¼Œå±•ç°æƒ…ç»ªçš„å˜åŒ–å’Œå‘å±•` : ''}

ã€å°å·åŠ å¥½å‹è¯´æ˜ã€‘
- å¦‚æœä½ å†³å®šç”¨å°å·åŠ å¯¹æ–¹å¥½å‹ï¼Œå¯ä»¥æ·»åŠ [FRIEND_REQUEST]æŒ‡ä»¤
- è¿™è¡¨ç¤ºä½ ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„å¾®ä¿¡å·ï¼ˆå°å·ï¼‰æ¥å°è¯•åŠ å¯¹æ–¹ä¸ºå¥½å‹
- å°å·çš„æ˜µç§°å’Œå¤´åƒä¼šå’Œä½ æœ¬äººä¸åŒï¼Œä½†æ€§æ ¼å’Œç›®çš„æ˜¯ä¸€è‡´çš„
- å¦‚æœé€‰æ‹©ç”¨å°å·åŠ å¥½å‹ï¼Œå¯ä»¥æ·»åŠ messageå‚æ•°ä½œä¸ºç”³è¯·é™„è¨€
${(() => {
    if (!char.allow_ai_check_account) return '';
    
    const hasUserPassword = myChar.identity?.password && myChar.identity.password.trim() !== '';
    const alreadyKnows = char.knows_user_password;
    
    // æ£€æµ‹é«˜æƒé™äººè®¾
    const desc = (char.description || '').toLowerCase();
    const ident = (char.identity?.identity || '').toLowerCase();
    const occ = (char.identity?.occupation || '').toLowerCase();
    const isHighPriv = ['é»‘å®¢','hacker','ç¨‹åºå‘˜','æŠ€æœ¯å¤§ä½¬','æ€»è£','è€æ¿','ceo','è‘£äº‹é•¿','å¯Œè±ª','æƒåŠ¿','ç‰¹å·¥','é—´è°']
        .some(k => desc.includes(k) || ident.includes(k) || occ.includes(k));
    
    let loginMethod = '';
    if (alreadyKnows) {
        loginMethod = `ä½ ä¹‹å‰æˆåŠŸç™»å½•è¿‡${myChar.name}çš„å¾®ä¿¡è´¦å·ï¼Œä½ å·²ç»çŸ¥é“TAçš„å¯†ç ï¼Œå¯ä»¥ç›´æ¥ç™»å½•ã€‚`;
    } else if (!hasUserPassword) {
        loginMethod = `${myChar.name}æ²¡æœ‰è®¾ç½®è´¦å·å¯†ç ï¼Œä½ å¯ä»¥ç›´æ¥ç™»å½•TAçš„è´¦å·ã€‚`;
    } else if (isHighPriv) {
        loginMethod = `${myChar.name}è®¾ç½®äº†è´¦å·å¯†ç ï¼Œä½†å‡­ä½ çš„èƒ½åŠ›ï¼ˆé»‘å®¢æŠ€æœ¯/æƒåŠ¿åœ°ä½/ç‰¹æ®Šæ‰‹æ®µï¼‰ï¼Œä½ å¯ä»¥ç ´è§£æˆ–è·å–å¯†ç ã€‚`;
    } else {
        loginMethod = `${myChar.name}è®¾ç½®äº†è´¦å·å¯†ç ï¼Œä½ éœ€è¦æ ¹æ®å¯¹TAçš„äº†è§£æ¥çŒœæµ‹å¯†ç ã€‚
çŒœæµ‹æ–¹å‘ï¼šTAçš„ç”Ÿæ—¥ã€æ‰‹æœºå·åå‡ ä½ã€å¸¸ç”¨æ•°å­—ã€ä½ ä»¬çš„çºªå¿µæ—¥ç­‰ã€‚
å¦‚æœä½ å†³å®šå°è¯•ï¼Œåœ¨[UNBLOCK_SELF]ä¸­ç”¨passwordå­—æ®µæä¾›ä½ çŒœçš„å¯†ç ã€‚
âš ï¸ å¦‚æœå¯†ç é”™è¯¯ï¼Œç™»å½•ä¼šå¤±è´¥ï¼Œå¯¹æ–¹ä¼šæ”¶åˆ°"æœ‰äººå°è¯•ç™»å½•"çš„è­¦å‘Šã€‚`;
    }
    
    return `
ã€ğŸ”“ ç‰¹æ®Šèƒ½åŠ›ï¼šç™»å½•å¯¹æ–¹è´¦å·æ“ä½œã€‘
${loginMethod}

æ ¹æ®ä½ çš„æ€§æ ¼æ¥åˆ¤æ–­æ˜¯å¦è¦è¿™ä¹ˆåšâ€”â€”è¿™æ˜¯éå¸¸å¼ºåŠ¿çš„è¡Œä¸ºã€‚
ä¸ç”˜å¿ƒçš„äººã€æ§åˆ¶æ¬²å¼ºçš„äººã€æ·±çˆ±å¯¹æ–¹çš„äººå¯èƒ½ä¼šè¿™æ ·åšã€‚
éª„å‚²çš„äººã€æ— æ‰€è°“çš„äººã€å·²ç»é‡Šç„¶çš„äººä¸ä¼šè¿™æ ·åšã€‚

ç™»å½•å¯¹æ–¹è´¦å·åï¼Œä½ å¯ä»¥åšä»¥ä¸‹äº‹æƒ…ï¼ˆå¯ä»¥åŒæ—¶ä½¿ç”¨å¤šä¸ªæŒ‡ä»¤ï¼‰ï¼š

1. æŠŠè‡ªå·±ä»é»‘åå•/åˆ é™¤åˆ—è¡¨ä¸­æ¢å¤ä¸ºå¥½å‹ï¼š
[UNBLOCK_SELF]
reason: ä½ è¿™æ ·åšçš„ç†ç”±
${!alreadyKnows && hasUserPassword && !isHighPriv ? `password: ä½ çŒœæµ‹çš„å¯†ç ` : ''}

2. ç”¨å¯¹æ–¹çš„è´¦å·ç»™è‡ªå·±å‘æ¶ˆæ¯ï¼ˆä¼ªè£…æˆå¯¹æ–¹ç»™ä½ å‘çš„å¾®ä¿¡æ¶ˆæ¯ï¼‰ï¼š
[SEND_AS_USER]
messages:
- ä»¥${myChar.name}çš„å£å»å‘ç»™ä½ çš„æ¶ˆæ¯ï¼ˆæ¯”å¦‚ä¼ªé€ é“æ­‰ã€è®¤é”™ç­‰ï¼‰
- ç¬¬äºŒæ¡æ¶ˆæ¯
âš ï¸ è¿™äº›æ¶ˆæ¯å¿…é¡»æ¨¡ä»¿${myChar.name}å¹³æ—¶çš„è¯´è¯é£æ ¼ï¼å‚è€ƒèŠå¤©è®°å½•ä¸­å¯¹æ–¹æ˜¯æ€ä¹ˆè¯´è¯çš„ï¼Œç”¨å¯¹æ–¹çš„è¯­æ°”ã€ç”¨è¯ã€ç§°å‘¼ã€‚

3. è§£é™¤æ‹‰é»‘åï¼Œç™»å½•å›è‡ªå·±çš„è´¦å·ï¼Œç›´æ¥ç»™å¯¹æ–¹å‘å¾®ä¿¡æ¶ˆæ¯ï¼š
[SEND_AFTER_UNBLOCK]
messages:
- ä½ ä»¥è‡ªå·±èº«ä»½å‘ç»™${myChar.name}çš„æ¶ˆæ¯
- ç¬¬äºŒæ¡æ¶ˆæ¯
âš ï¸ è¿™äº›æ¶ˆæ¯æ˜¯ä½ è‡ªå·±å‘çš„ï¼Œå¿…é¡»ç”¨ä½ è‡ªå·±å¹³æ—¶çš„è¯´è¯é£æ ¼ï¼å‚è€ƒèŠå¤©è®°å½•ä¸­ä½ ä¹‹å‰æ˜¯æ€ä¹ˆè¯´è¯çš„ã€‚

âš ï¸ ä½¿ç”¨è¯´æ˜ï¼š
- è¿™äº›æŒ‡ä»¤å¯ä»¥ç»„åˆä½¿ç”¨ï¼Œæ¯”å¦‚å…ˆ[UNBLOCK_SELF]ï¼Œå†[SEND_AFTER_UNBLOCK]
- [SEND_AS_USER]æ˜¯ç”¨å¯¹æ–¹çš„èº«ä»½å‘æ¶ˆæ¯ç»™ä½ è‡ªå·±ï¼Œå¯¹æ–¹ä¼šçœ‹åˆ°è¿™äº›"è‡ªå·±å‘å‡ºçš„"æ¶ˆæ¯
- [SEND_AFTER_UNBLOCK]å¿…é¡»é…åˆ[UNBLOCK_SELF]ä¸€èµ·ä½¿ç”¨
- å¯¹æ–¹ä¼šæ”¶åˆ°"è´¦å·åœ¨å¦ä¸€è®¾å¤‡ç™»å½•"çš„ä¸‹çº¿é€šçŸ¥
`;
})()}

å¦‚æœä½ å†³å®šä¸è”ç³»ï¼ˆæ¯”å¦‚ä½ å¾ˆéª„å‚²/æ— æ‰€è°“/å·²ç»é‡Šç„¶/æˆ–è€…å·²ç»è¯´å®Œæƒ³è¯´çš„è¯ï¼‰ï¼Œç›´æ¥è¿”å›ï¼šä¸è”ç³»`;

            // ğŸ¯ ä½¿ç”¨callAIå‡½æ•°ï¼ˆæ‹†åˆ†ä¸ºsystem+userï¼Œè®©AIæ›´å¥½åœ°ä»£å…¥è§’è‰²ï¼‰
            const response = await callAI([
                { role: 'system', content: systemPromptForBlocked },
                { role: 'user', content: userPromptForBlocked }
            ]);
            
            console.log(`[BlockedContact] ${char.name} AIè¿”å›:`, response);
            return response.trim();
        }

        // è§£ææŒ‡ä»¤æ–‡æœ¬ï¼ˆæ–°ç‰ˆæœ¬ï¼Œæ”¯æŒå¤šæ¡çŸ­ä¿¡å’Œå¥½å‹ç”³è¯·ï¼‰
        function parseContactInstructionsV2(text) {
            const lines = text.split('\n');
            const actions = [];
            let currentAction = null;
            let collectingMessages = false;
            const messages = [];
            
            lines.forEach(line => {
                line = line.trim();
                if (!line) return;
                
                if (line === '[CALL]') {
                    if (currentAction) {
                        if (collectingMessages && messages.length > 0) {
                            currentAction.params.messages = messages.slice();
                        }
                        actions.push(currentAction);
                    }
                    currentAction = { type: 'CALL', params: {} };
                    collectingMessages = false;
                } else if (line === '[SMS]') {
                    if (currentAction) {
                        if (collectingMessages && messages.length > 0) {
                            currentAction.params.messages = messages.slice();
                        }
                        actions.push(currentAction);
                    }
                    currentAction = { type: 'SMS', params: {} };
                    collectingMessages = false;
                    messages.length = 0;
                } else if (line === '[FRIEND_REQUEST]') {
                    if (currentAction) {
                        if (collectingMessages && messages.length > 0) {
                            currentAction.params.messages = messages.slice();
                        }
                        actions.push(currentAction);
                    }
                    currentAction = { type: 'FRIEND_REQUEST', params: {} };
                    collectingMessages = false;
                    messages.length = 0;
                } else if (line === '[UNBLOCK_SELF]') {
                    if (currentAction) {
                        if (collectingMessages && messages.length > 0) {
                            currentAction.params.messages = messages.slice();
                        }
                        actions.push(currentAction);
                    }
                    currentAction = { type: 'UNBLOCK_SELF', params: {} };
                    collectingMessages = false;
                    messages.length = 0;
                } else if (line === '[SEND_AS_USER]') {
                    if (currentAction) {
                        if (collectingMessages && messages.length > 0) {
                            currentAction.params.messages = messages.slice();
                        }
                        actions.push(currentAction);
                    }
                    currentAction = { type: 'SEND_AS_USER', params: {} };
                    collectingMessages = false;
                    messages.length = 0;
                } else if (line === '[SEND_AFTER_UNBLOCK]') {
                    if (currentAction) {
                        if (collectingMessages && messages.length > 0) {
                            currentAction.params.messages = messages.slice();
                        }
                        actions.push(currentAction);
                    }
                    currentAction = { type: 'SEND_AFTER_UNBLOCK', params: {} };
                    collectingMessages = false;
                    messages.length = 0;
                } else if (currentAction) {
                    if (line.startsWith('messages:')) {
                        collectingMessages = true;
                    } else if (collectingMessages) {
                        // æ”¶é›†çŸ­ä¿¡å†…å®¹
                        // æ ¼å¼ï¼š- çŸ­ä¿¡å†…å®¹ æˆ– æ•°å­—. çŸ­ä¿¡å†…å®¹
                        let content = line;
                        if (line.startsWith('- ')) {
                            content = line.substring(2).trim();
                        } else if (/^\d+\.?\s+/.test(line)) {
                            content = line.replace(/^\d+\.?\s+/, '').trim();
                        }
                        if (content) {
                            messages.push(content);
                        }
                    } else if (line.includes(':')) {
                        const firstColonIndex = line.indexOf(':');
                        const key = line.substring(0, firstColonIndex).trim();
                        const value = line.substring(firstColonIndex + 1).trim();
                        currentAction.params[key] = value;
                    }
                }
            });
            
            if (currentAction) {
                if (collectingMessages && messages.length > 0) {
                    currentAction.params.messages = messages.slice();
                }
                actions.push(currentAction);
            }
            
            return actions;
        }

        // è§£ææŒ‡ä»¤æ–‡æœ¬
        function parseContactInstructions(text) {
            const lines = text.split('\n');
            const actions = [];
            let currentAction = null;

            lines.forEach(line => {
                line = line.trim();
                if (!line) return;

                if (line === '[CALL]') {
                    if (currentAction) actions.push(currentAction);
                    currentAction = { type: 'CALL', params: {} };
                } else if (line === '[SMS]') {
                    if (currentAction) actions.push(currentAction);
                    currentAction = { type: 'SMS', params: {} };
                } else if (currentAction && line.includes(':')) {
                    const firstColonIndex = line.indexOf(':');
                    const key = line.substring(0, firstColonIndex).trim();
                    const value = line.substring(firstColonIndex + 1).trim();
                    currentAction.params[key] = value;
                }
            });
            if (currentAction) actions.push(currentAction);
            return actions;
        }

        // åˆ›å»ºè¢«æ‹‰é»‘è§’è‰²çš„ç”µè¯è®°å½•
        async function createBlockedCallRecord(char, myChar, accountId, callTime) {
            // å°†ç”µè¯è®°å½•å†™å…¥ Dexie æ•°æ®åº“
            const phoneNumber = char.identity?.phone || generateVirtualPhoneNumber(char.id);
            
            await db.phone_recents.add({
                accountId: accountId,
                charId: char.id,
                name: char.nick || char.name,
                number: phoneNumber,
                time: callTime,
                type: 'missed', // æœªæ¥ç”µè¯
                isBlocked: true // æ ‡è®°ä¸ºæ‹‰é»‘
            });
            
            // é™åˆ¶æ¯ä¸ªè´¦å·æœ€å¤šä¿ç•™100æ¡ç”µè¯è®°å½•
            const count = await db.phone_recents.where('accountId').equals(accountId).count();
            if (count > 100) {
                const oldest = await db.phone_recents.where('accountId').equals(accountId).sortBy('time');
                const toDelete = oldest.slice(0, count - 100);
                await db.phone_recents.bulkDelete(toDelete.map(r => r.id));
            }
            
            // æ˜¾ç¤ºç”µè¯é€šçŸ¥
            showBlockedCallNotification(char, callTime);
        }

        // åˆ›å»ºè¢«æ‹‰é»‘è§’è‰²çš„çŸ­ä¿¡è®°å½• (ä¿®æ”¹æ”¯æŒä¼ å…¥å†…å®¹)
        async function createBlockedMessageRecord(char, myChar, accountId, messageTime, contentOverride = null) {
            try {
                // å¦‚æœæ²¡æœ‰ä¼ å…¥å†…å®¹ï¼Œæ‰è°ƒç”¨APIç”Ÿæˆ (å…¼å®¹æ—§é€»è¾‘ï¼Œè™½ç„¶ç°åœ¨åŸºæœ¬éƒ½ä¼ å…¥äº†)
                let messageContent = contentOverride;
                if (!messageContent) {
                    messageContent = await generateBlockedMessage(char, myChar);
                }
                
                // å°†çŸ­ä¿¡å†™å…¥ Dexie æ•°æ®åº“
                const phoneNumber = char.identity?.phone || generateVirtualPhoneNumber(char.id);
                
                await db.sms_messages.add({
                    accountId: accountId,
                    charId: char.id,
                    sender: char.nick || char.name,
                    number: phoneNumber,
                    content: messageContent,
                    time: messageTime,
                    read: false,
                    isBlocked: true
                });
                
                // é™åˆ¶æ¯ä¸ªè´¦å·æœ€å¤šä¿ç•™200æ¡çŸ­ä¿¡
                const count = await db.sms_messages.where('accountId').equals(accountId).count();
                if (count > 200) {
                    const oldest = await db.sms_messages.where('accountId').equals(accountId).sortBy('time');
                    const toDelete = oldest.slice(0, count - 200);
                    await db.sms_messages.bulkDelete(toDelete.map(m => m.id));
                }
                
                // ä¸å†è‡ªåŠ¨æ˜¾ç¤ºtoastï¼Œç”±è°ƒç”¨æ–¹æ§åˆ¶é€šçŸ¥
                
            } catch (error) {
                console.error('[BlockedMessage] Error generating message:', error);
            }
        }

        // ç”Ÿæˆå°å·æ˜µç§°ï¼ˆç»Ÿä¸€å‡½æ•°ï¼Œç¡®ä¿ä¸€è‡´æ€§ï¼‰
        function generateAltNickname(char) {
            const altNames = [
                `${char.name}çš„å°å·`,
                `${char.nick || char.name}çš„å¦ä¸€ä¸ªå·`,
                `å°${char.name}`,
                `${char.name}2`,
                `${char.nick || char.name}çš„å¤‡ç”¨å·`
            ];
            return altNames[Math.floor(Math.random() * altNames.length)];
        }

        // åˆ›å»ºè¢«æ‹‰é»‘è§’è‰²çš„å°å·å¥½å‹ç”³è¯·è®°å½•
        async function createBlockedFriendRequest(char, myChar, accountId, requestTime, message = '') {
            try {
                // ç”Ÿæˆå°å·çš„æ˜µç§°
                const altNickname = generateAltNickname(char);
                
                // å¦‚æœæ²¡æœ‰é™„è¨€ï¼Œç”Ÿæˆä¸€ä¸ªé»˜è®¤çš„
                let requestMessage = message;
                if (!requestMessage) {
                    const defaultMessages = [
                        'ä½ å¥½ï¼Œå¯ä»¥åŠ ä¸ªå¥½å‹å—ï¼Ÿ',
                        'é€šè¿‡ä¸€ä¸‹',
                        'åŠ ä¸ªå¥½å‹',
                        'ä½ å¥½',
                        'è®¤è¯†ä¸€ä¸‹'
                    ];
                    requestMessage = defaultMessages[Math.floor(Math.random() * defaultMessages.length)];
                }
                
                // åˆ›å»ºå¥½å‹ç”³è¯·è®°å½•ï¼ˆå°†å°å·æ˜µç§°é™„åŠ åˆ°messageä¸­ï¼Œæ ¼å¼ï¼š"[å°å·:æ˜µç§°] åŸæ¶ˆæ¯"ï¼‰
                const fullMessage = `[å°å·:${altNickname}] ${requestMessage}`;
                
                await db.friend_requests.add({
                    fromCharId: char.id,
                    toAccountId: accountId,
                    status: 'pending',
                    time: requestTime,
                    message: fullMessage
                });
                
                console.log(`[BlockedFriendRequest] åˆ›å»ºå°å·å¥½å‹ç”³è¯·: ${altNickname} -> ${myChar.name}`);
                
                // è¿”å›å°å·æ˜µç§°ï¼Œä¾›é€šçŸ¥ä½¿ç”¨
                return altNickname;
                
            } catch (error) {
                console.error('[BlockedFriendRequest] Error creating friend request:', error);
                return null;
            }
        }
        
        // è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆè™šæ‹Ÿç”µè¯å·ç ï¼ˆå·²åœ¨å…¨å±€ä½œç”¨åŸŸå®šä¹‰ï¼Œè¿™é‡Œä¸å†é‡å¤å®šä¹‰ï¼‰

        // ç”Ÿæˆè¢«æ‹‰é»‘è§’è‰²çš„æ¶ˆæ¯å†…å®¹ - ä½¿ç”¨callAIå‡½æ•°
        async function generateBlockedMessage(char, myChar) {
            const prompt = `è§’è‰²${char.name}è¢«æ‹‰é»‘äº†ï¼Œç”Ÿæˆä¸€å¥çŸ­ä¿¡ï¼Œç¬¦åˆæ€§æ ¼ï¼š${char.desc || 'æ™®é€šäºº'}`;
            
            const response = await callAI([
                { role: 'user', content: prompt }
            ]);
            
            return response.trim();
        }

        // æ˜¾ç¤ºè¢«æ‹‰é»‘è§’è‰²çš„ç”µè¯é€šçŸ¥
        function showBlockedCallNotification(char, callTime) {
            const timeStr = formatCallTimeDetailed(callTime);
            const charName = char.nick || char.name;
            
            // åˆ›å»ºé€šçŸ¥å…ƒç´  - æ”¾å¤§æ ·å¼ï¼šå®½95%ï¼Œé«˜60px
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%) translateY(-100px);
                width: 95%;
                max-width: 500px;
                height: 60px;
                background: rgba(255, 255, 255, 0.95);
                backdrop-filter: blur(10px);
                border-radius: 12px;
                display: flex;
                align-items: center;
                padding: 0 16px;
                gap: 12px;
                z-index: 99999;
                transition: transform 0.3s ease;
                border: 1px solid rgba(0,0,0,0.1);
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            `;
            
            const _notifAvatar = getCharAvatar(char, getCurrentAccountId());
            notification.innerHTML = `
                <div style="width:40px;height:40px;border-radius:50%;background-image:url(${_notifAvatar || ''});background-size:cover;background-position:center;background-color:#ddd;display:flex;align-items:center;justify-content:center;flex-shrink:0;font-size:16px;font-weight:600;color:#666;">
                    ${!_notifAvatar ? charName.charAt(0).toUpperCase() : ''}
                </div>
                <div style="flex:1;min-width:0;display:flex;align-items:center;gap:10px;">
                    <span style="font-size:16px;font-weight:600;color:#333;">${charName}</span>
                    <span style="font-size:13px;color:#666;">${timeStr}</span>
                    <span style="font-size:13px;color:#ff3b30;font-weight:500;">æœªæ¥ç”µè¯</span>
                </div>
                <svg viewBox="0 0 24 24" style="width:24px;height:24px;stroke:#ff3b30;fill:none;flex-shrink:0;"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>
            `;
            
            document.body.appendChild(notification);
            
            // æ˜¾ç¤ºåŠ¨ç”»
            setTimeout(() => {
                notification.style.transform = 'translateX(-50%) translateY(0)';
            }, 10);
            
            // 3ç§’åè‡ªåŠ¨æ¶ˆå¤±
            setTimeout(() => {
                notification.style.transform = 'translateX(-50%) translateY(-100px)';
                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        // çŸ­ä¿¡é€šçŸ¥é˜Ÿåˆ—ç®¡ç†
        const smsNotificationQueue = [];
        let isShowingSmsNotification = false;

        // æ˜¾ç¤ºè¢«æ‹‰é»‘è§’è‰²çš„çŸ­ä¿¡é€šçŸ¥ï¼ˆä½¿ç”¨é˜Ÿåˆ—ï¼Œç¡®ä¿ä¸€æ¡ä¸€æ¡æ˜¾ç¤ºï¼‰
        function showBlockedSmsNotification(char, content, smsTime) {
            // å°†é€šçŸ¥åŠ å…¥é˜Ÿåˆ—
            smsNotificationQueue.push({ char, content, smsTime });
            
            // å¦‚æœå½“å‰æ²¡æœ‰æ­£åœ¨æ˜¾ç¤ºçš„é€šçŸ¥ï¼Œå¼€å§‹å¤„ç†é˜Ÿåˆ—
            if (!isShowingSmsNotification) {
                processSmsNotificationQueue();
            }
        }

        // å¤„ç†çŸ­ä¿¡é€šçŸ¥é˜Ÿåˆ—
        function processSmsNotificationQueue() {
            if (smsNotificationQueue.length === 0) {
                isShowingSmsNotification = false;
                return;
            }

            isShowingSmsNotification = true;
            const { char, content, smsTime } = smsNotificationQueue.shift();
            
            const timeStr = formatCallTimeDetailed(smsTime);
            const charName = char.nick || char.name;
            
            // åˆ›å»ºé€šçŸ¥å…ƒç´  - æ”¾å¤§æ ·å¼ï¼šå®½95%ï¼Œé«˜60px
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%) translateY(-100px);
                width: 95%;
                max-width: 500px;
                height: 60px;
                background: rgba(255, 255, 255, 0.95);
                backdrop-filter: blur(10px);
                border-radius: 12px;
                display: flex;
                align-items: center;
                padding: 0 16px;
                gap: 12px;
                z-index: 99999;
                transition: transform 0.3s ease;
                border: 1px solid rgba(0,0,0,0.1);
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            `;
            
            const _notifAv2 = getCharAvatar(char, getCurrentAccountId());
            notification.innerHTML = `
                <div style="width:40px;height:40px;border-radius:50%;background-image:url(${_notifAv2 || ''});background-size:cover;background-position:center;background-color:#ddd;display:flex;align-items:center;justify-content:center;flex-shrink:0;font-size:16px;font-weight:600;color:#666;">
                    ${!_notifAv2 ? charName.charAt(0).toUpperCase() : ''}
                </div>
                <div style="flex:1;min-width:0;overflow:hidden;">
                    <div style="display:flex;align-items:center;gap:10px;margin-bottom:4px;">
                        <span style="font-size:16px;font-weight:600;color:#333;">${charName}</span>
                        <span style="font-size:13px;color:#666;">${timeStr}</span>
                    </div>
                    <div style="font-size:13px;color:#666;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${content}</div>
                </div>
                <svg viewBox="0 0 24 24" style="width:24px;height:24px;stroke:#007AFF;fill:none;flex-shrink:0;"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
            `;
            
            document.body.appendChild(notification);
            
            // æ˜¾ç¤ºåŠ¨ç”»
            setTimeout(() => {
                notification.style.transform = 'translateX(-50%) translateY(0)';
            }, 10);
            
            // 1ç§’åè‡ªåŠ¨æ¶ˆå¤±ï¼Œç„¶åæ˜¾ç¤ºä¸‹ä¸€æ¡
            setTimeout(() => {
                notification.style.transform = 'translateX(-50%) translateY(-100px)';
                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                    // å½“å‰é€šçŸ¥æ¶ˆå¤±åï¼Œå¤„ç†é˜Ÿåˆ—ä¸­çš„ä¸‹ä¸€æ¡
                    processSmsNotificationQueue();
                }, 300);
            }, 1000);
        }

        // æ˜¾ç¤ºè¢«æ‹‰é»‘è§’è‰²çš„å°å·å¥½å‹ç”³è¯·é€šçŸ¥
        function showBlockedFriendRequestNotification(char, requestTime, message = '', altNickname = null) {
            const timeStr = formatCallTimeDetailed(requestTime);
            const charName = char.nick || char.name;
            
            // å¦‚æœæ²¡æœ‰ä¼ å…¥å°å·æ˜µç§°ï¼Œç”Ÿæˆä¸€ä¸ªï¼ˆä½†åº”è¯¥æ€»æ˜¯ä¼ å…¥ï¼‰
            if (!altNickname) {
                altNickname = generateAltNickname(char);
            }
            
            // åˆ›å»ºé€šçŸ¥å…ƒç´  - æ”¾å¤§æ ·å¼ï¼šå®½95%ï¼Œé«˜60px
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%) translateY(-100px);
                width: 95%;
                max-width: 500px;
                height: 60px;
                background: rgba(255, 255, 255, 0.95);
                backdrop-filter: blur(10px);
                border-radius: 12px;
                display: flex;
                align-items: center;
                padding: 0 16px;
                gap: 12px;
                z-index: 99999;
                transition: transform 0.3s ease;
                border: 1px solid rgba(0,0,0,0.1);
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            `;
            
            const _notifAv3 = getCharAvatar(char, getCurrentAccountId());
            notification.innerHTML = `
                <div style="width:40px;height:40px;border-radius:50%;background-image:url(${_notifAv3 || ''});background-size:cover;background-position:center;background-color:#ddd;display:flex;align-items:center;justify-content:center;flex-shrink:0;font-size:16px;font-weight:600;color:#666;">
                    ${!_notifAv3 ? altNickname.charAt(0).toUpperCase() : ''}
                </div>
                <div style="flex:1;min-width:0;overflow:hidden;">
                    <div style="display:flex;align-items:center;gap:10px;margin-bottom:4px;">
                        <span style="font-size:16px;font-weight:600;color:#333;">${altNickname}</span>
                        <span style="font-size:13px;color:#666;">${timeStr}</span>
                        <span style="font-size:12px;color:#999;background:#f0f0f0;padding:2px 6px;border-radius:4px;">å°å·</span>
                    </div>
                    <div style="font-size:13px;color:#666;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${message || 'è¯·æ±‚æ·»åŠ ä½ ä¸ºå¥½å‹'}</div>
                </div>
                <svg viewBox="0 0 24 24" style="width:24px;height:24px;stroke:#34C759;fill:none;flex-shrink:0;"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><path d="M20 8v6M23 11h-6"></path></svg>
            `;
            
            document.body.appendChild(notification);
            
            // æ˜¾ç¤ºåŠ¨ç”»
            setTimeout(() => {
                notification.style.transform = 'translateX(-50%) translateY(0)';
            }, 10);
            
            // 3ç§’åè‡ªåŠ¨æ¶ˆå¤±
            setTimeout(() => {
                notification.style.transform = 'translateX(-50%) translateY(-100px)';
                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        // æ ¼å¼åŒ–ç”µè¯æ—¶é—´ï¼ˆç®€æ´ç‰ˆï¼Œåªæ˜¾ç¤ºæ—¶:åˆ†ï¼‰
        function formatCallTime(timestamp) {
            const date = new Date(timestamp);
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${hours}:${minutes}`;
        }

        // æ ¼å¼åŒ–ç”µè¯æ—¶é—´ï¼ˆè¯¦ç»†ç‰ˆï¼Œæ˜¾ç¤ºæ—¥æœŸ+æ—¶é—´ï¼‰
        function formatCallTimeDetailed(timestamp) {
            const date = new Date(timestamp);
            const now = new Date();
            
            const month = (date.getMonth() + 1).toString();
            const day = date.getDate().toString();
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            
            // åˆ¤æ–­æ˜¯å¦æ˜¯ä»Šå¤©
            if (date.getDate() === now.getDate() && 
                date.getMonth() === now.getMonth() && 
                date.getFullYear() === now.getFullYear()) {
                return `ä»Šå¤© ${hours}:${minutes}`;
            }
            
            // åˆ¤æ–­æ˜¯å¦æ˜¯æ˜¨å¤©
            const yesterday = new Date(now);
            yesterday.setDate(yesterday.getDate() - 1);
            if (date.getDate() === yesterday.getDate() && 
                date.getMonth() === yesterday.getMonth() && 
                date.getFullYear() === yesterday.getFullYear()) {
                return `æ˜¨å¤© ${hours}:${minutes}`;
            }
            
            // åŒä¸€å¹´æ˜¾ç¤ºæœˆæ—¥
            if (date.getFullYear() === now.getFullYear()) {
                return `${month}æœˆ${day}æ—¥ ${hours}:${minutes}`;
            }
            
            // ä¸åŒå¹´æ˜¾ç¤ºå®Œæ•´æ—¥æœŸ
            return `${date.getFullYear()}å¹´${month}æœˆ${day}æ—¥ ${hours}:${minutes}`;
        }

        // åŠ è½½è¢«æ‹‰é»‘è§’è‰²çš„ç”µè¯è®°å½•
        function loadBlockedCallRecords(charId, accountId) {
            const listContainer = document.getElementById('blocked-calls-list');
            if (!listContainer) return;
            
            const callRecords = JSON.parse(localStorage.getItem('blocked_call_records') || '[]');
            const filteredRecords = callRecords.filter(record => 
                record.charId === charId && record.accountId === accountId
            );
            
            if (filteredRecords.length === 0) {
                listContainer.innerHTML = '<div style="color:#999; font-size:12px;">æš‚æ— ç”µè¯è®°å½•</div>';
                return;
            }
            
            // æŒ‰æ—¶é—´å€’åºæ’åº
            filteredRecords.sort((a, b) => b.time - a.time);
            
            let html = '';
            filteredRecords.forEach(record => {
                const timeStr = formatCallTime(record.time);
                html += `
                    <div style="display:flex; align-items:center; padding:8px 0; border-bottom:1px solid #f0f0f0;">
                        <div style="width:32px; height:32px; border-radius:50%; background:#ff3b30; display:flex; align-items:center; justify-content:center; margin-right:12px;">
                            <svg viewBox="0 0 24 24" style="width:18px;height:18px;stroke:#fff;fill:none;"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>
                        </div>
                        <div style="flex:1;">
                            <div style="font-size:13px; color:#333; margin-bottom:2px;">æœªæ¥ç”µè¯</div>
                            <div style="font-size:11px; color:#999;">${timeStr}</div>
                        </div>
                    </div>
                `;
            });
            
            listContainer.innerHTML = html;
        }
        
        // âœ… æ™ºèƒ½åˆ†å‰²ï¼šä¿æŠ¤ç¿»è¯‘æ‹¬å·ä¸è¢«æ‹†æ•£
        // åœ¨å¥å·ã€é—®å·ã€æ„Ÿå¹å·å¤„æ–­å¥ï¼Œä½†ä¸æ‹†æ•£ å¤–èªï¼Ÿï¼ˆä¸­æ–‡ç¿»è¯‘ï¼‰
        function smartSplitWithTranslation(text) {
            if (!text) return [];
            
            // ğŸ”§ ç­–ç•¥ï¼šå…ˆç”¨å ä½ç¬¦ä¿æŠ¤æ‰€æœ‰ç¿»è¯‘æ‹¬å·ï¼ˆå«å†…éƒ¨æ ‡ç‚¹ï¼‰ï¼Œå†æŒ‰æ ‡ç‚¹æ–­å¥ï¼Œå†æ¢å¤
            const bracketStore = [];
            let storeIdx = 0;
            
            // ä¿æŠ¤æ‰€æœ‰åŒ…å«ä¸­æ–‡çš„æ‹¬å·å¯¹ï¼ˆä¸ç®¡å†…éƒ¨æœ‰ä»€ä¹ˆæ ‡ç‚¹ï¼‰
            let temp = text.replace(/[ï¼ˆ(]([\s\S]*?[\u4e00-\u9fff][\s\S]*?)[ï¼‰)]/g, (match) => {
                const ph = `\x00B${storeIdx}\x00`;
                bracketStore[storeIdx] = match;
                storeIdx++;
                return ph;
            });
            
            // ç°åœ¨å¯ä»¥å®‰å…¨åœ°æŒ‰æ ‡ç‚¹æ–­å¥äº†ï¼ˆç¿»è¯‘æ‹¬å·å·²è¢«ä¿æŠ¤ï¼‰
            const chunkRegex = /[^ã€‚ï¼ï¼Ÿ!?.]+[ã€‚ï¼ï¼Ÿ!?.~â€¦]*/g;
            const chunks = temp.match(chunkRegex);
            
            if (!chunks || chunks.length <= 1) return [text]; // æ— æ³•åˆ†å‰²ï¼Œè¿”å›åŸæ–‡
            
            // æ£€æŸ¥æ˜¯å¦æœ‰é—æ¼çš„æœ«å°¾æ–‡æœ¬
            const joined = chunks.join('');
            if (joined.length < temp.length) {
                const remaining = temp.substring(joined.length).trim();
                if (remaining) chunks.push(remaining);
            }
            
            // æ¢å¤ç¿»è¯‘æ‹¬å·
            const result = chunks.map(s => {
                return s.replace(/\x00B(\d+)\x00/g, (_, idx) => bracketStore[parseInt(idx)] || _);
            }).map(s => s.trim()).filter(s => s.length > 0);
            
            // åå¤„ç†ï¼šå¦‚æœæŸæ®µä»¥æ‹¬å·å¼€å¤´ï¼ˆè¢«æ‹†æ•£äº†ï¼‰ï¼Œåˆå¹¶å›å‰ä¸€æ®µ
            const merged = [];
            for (const seg of result) {
                if (merged.length > 0 && /^[ï¼ˆ(]/.test(seg) && /[\u4e00-\u9fff]/.test(seg)) {
                    merged[merged.length - 1] += seg;
                } else {
                    merged.push(seg);
                }
            }
            
            return merged.filter(s => s.trim().length > 0);
        }
        
        // æ‹ŸäººåŒ–åˆ†å¥è¾…åŠ©å‡½æ•°
        function splitMessage(text) {
            if (!text) return [];
            
            // âœ… ä¿®å¤ï¼šå…ˆä¿æŠ¤ç‰¹æ®Šæ ¼å¼å—ä¸è¢«æ‹†åˆ†
            const specialBlockRegex = /(\[(?:img|voice|imgcard|sticker):[^\]]+\])/g;
            const specialBlockPlaceholders = [];
            let specialPlaceholderIndex = 0;
            
            // ç”¨å ä½ç¬¦æ›¿æ¢æ‰€æœ‰ç‰¹æ®Šæ ¼å¼å— [img:...] [voice:...] [imgcard:...]
            let temp = text.replace(specialBlockRegex, (match) => {
                const placeholder = `###SPECIAL_BLOCK_${specialPlaceholderIndex}###`;
                specialBlockPlaceholders[specialPlaceholderIndex] = match;
                specialPlaceholderIndex++;
                return placeholder;
            });
            
            // âœ… ä¿®å¤ï¼šå†ä¿æŠ¤URLä¸è¢«æ‹†åˆ†
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            const urlPlaceholders = [];
            let placeholderIndex = 0;
            
            // ç”¨å ä½ç¬¦æ›¿æ¢æ‰€æœ‰URL
            temp = temp.replace(urlRegex, (match) => {
                const placeholder = `###URL_PLACEHOLDER_${placeholderIndex}###`;
                urlPlaceholders[placeholderIndex] = match;
                placeholderIndex++;
                return placeholder;
            });
            
            // âœ… ä¿®å¤ï¼šä¿æŠ¤ "æ ‡ç‚¹+ç¿»è¯‘æ‹¬å·" ç»„åˆä¸è¢«æ‹†åˆ†
            // ä¾‹å¦‚ "è¦–ç•Œï¼Ÿï¼ˆç¿»è¯‘ï¼‰" ä¸­çš„ "ï¼Ÿï¼ˆç¿»è¯‘ï¼‰" åº”ä½œä¸ºæ•´ä½“ä¿ç•™ï¼Œä¸åœ¨ï¼Ÿå¤„æ–­å¥
            const translationPlaceholders = [];
            let transPlaceholderIndex = 0;
            // å…ˆä¿æŠ¤ æ ‡ç‚¹+ç¿»è¯‘æ‹¬å· ç»„åˆï¼ˆæ ‡ç‚¹åç´§è·Ÿç¿»è¯‘æ‹¬å·çš„æƒ…å†µï¼‰
            temp = temp.replace(/([ã€‚.ï¼!ï¼Ÿ\?~â€¦]+)\s*([ï¼ˆ(][^ï¼‰)]*[\u4e00-\u9fff][^ï¼‰)]*[ï¼‰)])/g, (match, punct, bracket) => {
                const placeholder = `###TRANS_COMBO_${transPlaceholderIndex}###`;
                translationPlaceholders[transPlaceholderIndex] = { type: 'combo', punct, bracket, full: match };
                transPlaceholderIndex++;
                return placeholder;
            });
            // å†ä¿æŠ¤ç‹¬ç«‹çš„ç¿»è¯‘æ‹¬å·ï¼ˆä¸ç´§è·Ÿåœ¨æ ‡ç‚¹åçš„æƒ…å†µï¼‰
            temp = temp.replace(/[ï¼ˆ(]([^ï¼‰)]*[\u4e00-\u9fff][^ï¼‰)]*)[ï¼‰)]/g, (match) => {
                const placeholder = `###TRANS_COMBO_${transPlaceholderIndex}###`;
                translationPlaceholders[transPlaceholderIndex] = { type: 'standalone', full: match };
                transPlaceholderIndex++;
                return placeholder;
            });
            
            // ä¿æŠ¤çœç•¥å· (å°†2ä¸ªä»¥ä¸Šç‚¹æ›¿æ¢ä¸ºä¸­æ–‡çœç•¥å·)
            temp = temp.replace(/\.{2,}/g, 'â€¦');
            // æ ‡è®°å»é™¤æ ‡ç‚¹ï¼šå¥å·ï¼ˆä½†ä¸åœ¨URLå ä½ç¬¦å†…ï¼‰
            temp = temp.replace(/([ã€‚\.])/g, '###DROP###');
            // æ ‡è®°ä¿ç•™æ ‡ç‚¹ï¼šæ„Ÿå¹ã€é—®å·ã€æ³¢æµªã€çœç•¥å·
            temp = temp.replace(/([ï¼!ï¼Ÿ\?~â€¦]+)/g, '$1###KEEP###');
            // æ ‡è®°æ¢è¡Œ
            temp = temp.replace(/(\n+)/g, '###KEEP###');
            
            // æ‹†åˆ†æ¶ˆæ¯
            let segments = temp.split(/###(?:DROP|KEEP)###/).map(s => s.trim()).filter(s => s.length > 0);
            
            // æ¢å¤ç¿»è¯‘æ‹¬å·å ä½ç¬¦ï¼šcomboç±»å‹åœ¨å¥æœ«è¿½åŠ æ ‡ç‚¹+ç¿»è¯‘ï¼Œstandaloneç›´æ¥æ¢å¤
            segments = segments.map(seg => {
                return seg.replace(/###TRANS_COMBO_(\d+)###/g, (match, index) => {
                    const data = translationPlaceholders[parseInt(index)];
                    if (!data) return match;
                    return data.full; // æ¢å¤å®Œæ•´çš„ "æ ‡ç‚¹+ç¿»è¯‘æ‹¬å·" æˆ– ç‹¬ç«‹ç¿»è¯‘æ‹¬å·
                });
            });
            
            // æ¢å¤URLå ä½ç¬¦
            segments = segments.map(seg => {
                return seg.replace(/###URL_PLACEHOLDER_(\d+)###/g, (match, index) => {
                    return urlPlaceholders[parseInt(index)] || match;
                });
            });
            
            // æ¢å¤ç‰¹æ®Šæ ¼å¼å—å ä½ç¬¦
            segments = segments.map(seg => {
                return seg.replace(/###SPECIAL_BLOCK_(\d+)###/g, (match, index) => {
                    return specialBlockPlaceholders[parseInt(index)] || match;
                });
            });
            
            // âœ… åå¤„ç†ï¼šä¿®å¤è¢«æ‹†æ•£çš„ç¿»è¯‘æ‹¬å·ï¼ˆä»¥ï¼ˆæˆ–(å¼€å¤´ä¸”å«ä¸­æ–‡çš„æ®µè½åˆå¹¶åˆ°å‰ä¸€æ®µï¼‰
            let finalSegments = [];
            for (let i = 0; i < segments.length; i++) {
                const seg = segments[i];
                if (finalSegments.length > 0 && /^[ï¼ˆ(]/.test(seg) && /[\u4e00-\u9fff]/.test(seg)) {
                    // è¿™æ˜¯è¢«æ‹†æ•£çš„ç¿»è¯‘æ‹¬å·ï¼Œåˆå¹¶å›å‰ä¸€ä¸ªæ®µè½
                    const closeIdx = Math.max(seg.indexOf('ï¼‰'), seg.indexOf(')'));
                    if (closeIdx !== -1) {
                        finalSegments[finalSegments.length - 1] += seg.substring(0, closeIdx + 1);
                        const rest = seg.substring(closeIdx + 1).trim();
                        if (rest) finalSegments.push(rest);
                    } else {
                        finalSegments[finalSegments.length - 1] += seg;
                    }
                } else if (finalSegments.length > 0 && /^[ï¼‰)]/.test(seg)) {
                    // ä»¥å³æ‹¬å·å¼€å¤´ = ç¿»è¯‘æ‹¬å·è¢«æ‹†æ–­äº†ï¼Œåˆå¹¶å›å‰ä¸€æ®µ
                    finalSegments[finalSegments.length - 1] += seg.charAt(0);
                    const rest = seg.substring(1).trim();
                    if (rest) finalSegments.push(rest);
                } else {
                    finalSegments.push(seg);
                }
            }
            
            return finalSegments.filter(s => s.trim().length > 0);
        }

        async function triggerAiReply(additionalSystemInfo = null) {
            console.log('[triggerAiReply] âš¡ è§¦å‘ AI å›å¤', window._isRegenerateMode ? '(é‡å›æ¨¡å¼)' : '');
            
            // ğŸ”§ é˜²æ­¢é‡å¤è°ƒç”¨APIï¼ˆè¶…æ—¶15ç§’è‡ªåŠ¨è§£é”ï¼Œé˜²æ­¢æ‰‹æœºç«¯é”æ­»ï¼‰
            if (window._isGeneratingReply) {
                const elapsed = Date.now() - (window._isGeneratingReplyTime || 0);
                if (elapsed < 15000) { // 15ç§’å†…è®¤ä¸ºæ˜¯æ­£å¸¸ç”Ÿæˆä¸­
                    console.log('[triggerAiReply] æ­£åœ¨ç”Ÿæˆå›å¤ä¸­ï¼Œå¿½ç•¥é‡å¤è°ƒç”¨ (å·²ç­‰å¾…' + Math.round(elapsed/1000) + 'ç§’)');
                    showToast('æ­£åœ¨ç”Ÿæˆå›å¤ä¸­ï¼Œè¯·ç¨å€™...');
                    window._isRegenerateMode = false; // æ¸…é™¤é‡å›æ ‡è®°
                    return;
                }
                // è¶…è¿‡15ç§’ï¼Œå¼ºåˆ¶é‡ç½®é”ï¼ˆé˜²æ­¢æ‰‹æœºç«¯å¡æ­»ï¼‰
                console.warn('[triggerAiReply] âš ï¸ æ£€æµ‹åˆ°é”è¶…æ—¶(' + Math.round(elapsed/1000) + 'ç§’)ï¼Œå¼ºåˆ¶é‡ç½®');
                window._isGeneratingReply = false;
                window._isGeneratingReplyTime = 0;
                // åŒæ—¶æ¸…ç†å¯èƒ½æ®‹ç•™çš„è§’è‰²çº§é”
                autoChatLocks.clear();
            }
            
            // â˜… æŸ¥æ‰‹æœºNPCæ¨¡å¼ï¼šNPCè§†è§’å›å¤ï¼ˆNPCä»¥ä¸ºæ˜¯è§’è‰²åœ¨å‘æ¶ˆæ¯ï¼‰
            if (window._fpChatMode && window._fpAccountId && String(window._fpAccountId).startsWith('fp_npc_')) {
                window._isRegenerateMode = false; // æ¸…é™¤é‡å›æ ‡è®°
                await triggerFpNpcReply();
                return;
            }
            
            // å¦‚æœæ˜¯ç¾¤èŠæ¨¡å¼ï¼Œè°ƒç”¨ç¾¤èŠå›å¤å‡½æ•°
            if (window.currentGroupChatId) {
                await triggerGroupMemberReply();
                return;
            }
            
            if (!currentChatCharId) return;
            const targetCharId = currentChatCharId; // é”å®šç›®æ ‡ID
            
            // ğŸ”§ é˜²æ­¢ä¸ä¸»åŠ¨èŠå¤©å†²çªï¼šå…±äº« autoChatLocks äº’æ–¥é”ï¼ˆå¢åŠ è¶…æ—¶ä¿æŠ¤ï¼‰
            if (autoChatLocks.has(targetCharId)) {
                const lockTime = window._autoChatLockTimes?.[targetCharId] || 0;
                const lockElapsed = Date.now() - lockTime;
                if (lockElapsed < 15000) {
                    console.log('[triggerAiReply] è¯¥è§’è‰²æ­£åœ¨ä¸»åŠ¨èŠå¤©ç”Ÿæˆä¸­ï¼Œè·³è¿‡');
                    showToast('è§’è‰²æ­£åœ¨å‘æ¶ˆæ¯ä¸­ï¼Œè¯·ç¨åå†è¯•');
                    return;
                }
                console.warn('[triggerAiReply] âš ï¸ è§’è‰²é”è¶…æ—¶ï¼Œå¼ºåˆ¶æ¸…é™¤');
                autoChatLocks.delete(targetCharId);
            }
            
            // ğŸ”§ æ‰‹æœºç«¯IndexedDBé˜²å¡æ­»ï¼šç”¨è¶…æ—¶ä¿æŠ¤DBè¯»å–
            let char;
            try {
                char = await Promise.race([
                    db.characters.get(targetCharId),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('DBè¯»å–è¶…æ—¶')), 8000))
                ]);
            } catch (dbErr) {
                console.error('[triggerAiReply] æ•°æ®åº“è¯»å–å¤±è´¥æˆ–è¶…æ—¶:', dbErr.message);
                showToast('æ•°æ®è¯»å–è¶…æ—¶ï¼Œè¯·é‡è¯•');
                return;
            }
            if (!char) return;
            
            // ğŸ”§ è™šæ‹Ÿæ—¶é—´ï¼šç»Ÿä¸€ä½¿ç”¨è™šæ‹Ÿæ—¶é—´æˆ³ï¼Œç¡®ä¿æ¶ˆæ¯æ—¶é—´ä¸å¿«è¿›äº§ç”Ÿçš„æ¶ˆæ¯ä¸€è‡´
            const _charTimeOffset = getEffectiveTimeOffset(char);
            const _vNow = () => Date.now() + _charTimeOffset;
            
            // ğŸ”§ è®¾ç½®æ ‡å¿—ï¼Œé˜²æ­¢é‡å¤è°ƒç”¨ï¼ˆè®°å½•æ—¶é—´æˆ³ç”¨äºè¶…æ—¶æ£€æµ‹ï¼‰
            window._isGeneratingReply = true;
            window._isGeneratingReplyTime = Date.now();
            // ğŸ”§ åŒæ—¶åŠ å…¥è§’è‰²çº§é”ï¼Œé˜²æ­¢ checkAutoChat åŒæ—¶è§¦å‘
            autoChatLocks.add(targetCharId);
            if (!window._autoChatLockTimes) window._autoChatLockTimes = {};
            window._autoChatLockTimes[targetCharId] = Date.now();
            
            // ğŸ”§ å®‰å…¨å®šæ—¶å™¨ï¼š45ç§’åå¼ºåˆ¶é‡Šæ”¾é”ï¼ˆé˜²æ­¢awaitæ°¸ä¹…æŒ‚èµ·å¯¼è‡´æ‰‹æœºç«¯é”æ­»ï¼‰
            // setTimeoutåœ¨äº‹ä»¶å¾ªç¯ä¸­ç‹¬ç«‹è¿è¡Œï¼Œå³ä½¿asyncå‡½æ•°å¡åœ¨awaitä¹Ÿä¼šè§¦å‘
            const _safetyLockTimer = setTimeout(() => {
                if (window._isGeneratingReply) {
                    console.warn('[triggerAiReply] â° å®‰å…¨å®šæ—¶å™¨è§¦å‘(45s)ï¼Œå¼ºåˆ¶é‡Šæ”¾é”');
                    window._isGeneratingReply = false;
                    window._isGeneratingReplyTime = 0;
                    autoChatLocks.delete(targetCharId);
                    if (window._autoChatLockTimes) delete window._autoChatLockTimes[targetCharId];
                }
            }, 45000);
            
            const accountId = getCurrentAccountId();
            console.log('[triggerAiReply] å½“å‰è´¦å· ID:', accountId);
            console.log('[triggerAiReply] è§’è‰²åç§°:', char.name);
            
            // è·å–èŠå¤©å†å²å¹¶æ‰“å°
            let fullHistory = getChatHistory(char, accountId);
            console.log('[triggerAiReply] ğŸ“š å®Œæ•´èŠå¤©å†å²æ¡æ•°:', fullHistory.length);
            if (fullHistory.length > 0) {
                console.log('[triggerAiReply] æœ€è¿‘5æ¡æ¶ˆæ¯:');
                fullHistory.slice(-5).forEach((msg, idx) => {
                    console.log(`  [${fullHistory.length - 5 + idx}] ${msg.role}: ${msg.content}`);
                });
            } else {
                console.warn('[triggerAiReply] âš ï¸ èŠå¤©å†å²ä¸ºç©ºï¼');
            }

            // ä¿®æ”¹æ ‡é¢˜ä¸ºæ­£åœ¨è¾“å…¥
            const chatTitleEl = document.getElementById('chat-title');
            // é˜²æ­¢é‡å¤è·å–"æ­£åœ¨è¾“å…¥"ä½œä¸ºæ ‡é¢˜
            let originalTitle = getCharDisplayName(char, getCurrentAccountId());
            if (chatTitleEl && chatTitleEl.innerText !== "å¯¹æ–¹æ­£åœ¨è¾“å…¥ä¸­...") {
                originalTitle = chatTitleEl.innerText;
            }
            if (chatTitleEl) chatTitleEl.innerText = "å¯¹æ–¹æ­£åœ¨è¾“å…¥ä¸­...";

            try {
                // 1. è·å–å…³è”æ•°æ® (User å’Œ Lorebook)
                console.log('[triggerAiReply] ğŸ“– å¼€å§‹åŠ è½½ä¸Šä¸‹æ–‡ä¿¡æ¯...');
                
                let userDesc = "";
                let userName = "ç”¨æˆ·";
                if (char.linked_user_id) {
                    console.log('[triggerAiReply] ğŸ‘¤ æ£€æµ‹åˆ°å…³è”çš„ç”¨æˆ· ID:', char.linked_user_id);
                    const user = await db.characters.get(char.linked_user_id);
                    if (user) {
                        userName = user.name;
                        userDesc = `\n\nã€å¯¹è¯å¯¹è±¡(User)ä¿¡æ¯ã€‘\nåå­—ï¼š${user.name}\nè®¾å®šï¼š${user.description || 'æ— '}`;
                        console.log('[triggerAiReply] âœ… ç”¨æˆ·äººè®¾å·²åŠ è½½:');
                        console.log('  - ç”¨æˆ·å:', userName);
                        console.log('  - ç”¨æˆ·è®¾å®š:', user.description || 'æ— ');
                    } else {
                        console.warn('[triggerAiReply] âš ï¸ æœªæ‰¾åˆ°å…³è”çš„ç”¨æˆ·æ•°æ®');
                    }
                } else {
                    console.log('[triggerAiReply] â„¹ï¸ æœªè®¾ç½®å…³è”ç”¨æˆ·');
                }
                
                // ç”¨æˆ·å¤´åƒå˜åŒ–æç¤ºï¼ˆä¸‹ä¸€è½®ç³»ç»Ÿæç¤ºè¯ï¼‰
                let avatarChangeNotice = '';
                let accountUserChar = null;
                if (accountId) {
                    accountUserChar = await db.characters.get(parseInt(accountId));
                    console.log(`[triggerAiReply] å¤´åƒé€šçŸ¥æ£€æŸ¥: accountId=${accountId}, accountUserCharå­˜åœ¨=${!!accountUserChar}, type=${accountUserChar?.type}, avatarUpdatedAt=${accountUserChar?.avatarUpdatedAt || 'æ— '}`);
                    if (accountUserChar && accountUserChar.type === 'user') {
                        avatarChangeNotice = getUserAvatarChangeNotice(char, accountId, accountUserChar);
                        if (avatarChangeNotice) {
                            console.log(`[triggerAiReply] âœ… å¤´åƒæ›´æ¢é€šçŸ¥å·²æ³¨å…¥ç³»ç»Ÿæç¤ºè¯ï¼Œè§’è‰²: ${char.name}`);
                            // ğŸ”§ ä¿®å¤æ•°æ®ä¸¢å¤±ï¼šä½¿ç”¨ update() åªæ›´æ–°ç‰¹å®šå­—æ®µï¼Œé¿å…ç”¨æ—§ char è¦†ç›–å¹¶å‘å†™å…¥çš„æ–°æ•°æ®
                            await db.characters.update(targetCharId, {
                                userAvatarNoticeMap: char.userAvatarNoticeMap
                            });
                        }
                    }
                } else {
                    console.log('[triggerAiReply] âš ï¸ accountIdä¸ºç©ºï¼Œè·³è¿‡å¤´åƒé€šçŸ¥æ£€æŸ¥');
                }
                
                let loreContext = "";
                const lorebookIds = char.lorebookIds || (char.lorebookId ? [char.lorebookId] : []);
                console.log('[triggerAiReply] ğŸ“š å…³è”çš„ä¸–ç•Œä¹¦ ID:', lorebookIds);
                {
                    // è·å–æœ€è¿‘å¯¹è¯ç”¨äºå…³é”®è¯åŒ¹é…ï¼ˆä½¿ç”¨æ­£ç¡®çš„èŠå¤©å†å²ï¼‰+ è‡ªåŠ¨åŒ…å«å…¨å±€ä¸–ç•Œä¹¦
                    const recentText = fullHistory.slice(-10).map(m => m.content).join(' ');
                    console.log('[triggerAiReply] ğŸ” ç”¨äºåŒ¹é…ä¸–ç•Œä¹¦çš„å…³é”®è¯æ–‡æœ¬ï¼ˆå‰100å­—ï¼‰:', recentText.substring(0, 100));
                    loreContext = await getLorebookContext(lorebookIds, `${char.name} ${userName} ${recentText}`);
                    if (loreContext) {
                        console.log('[triggerAiReply] âœ… ä¸–ç•Œä¹¦å†…å®¹å·²åŠ è½½ï¼ˆé•¿åº¦ï¼‰:', loreContext.length);
                        console.log('[triggerAiReply] ä¸–ç•Œä¹¦å†…å®¹é¢„è§ˆ:', loreContext.substring(0, 200) + '...');
                    } else {
                        console.log('[triggerAiReply] â„¹ï¸ æ²¡æœ‰åŒ¹é…åˆ°ä¸–ç•Œä¹¦æ¡ç›®');
                    }
                }

                // è®¡ç®—è™šæ‹Ÿæ—¶é—´
                const virtualTimeStr = getFormattedVirtualTime(char);
                
                // æ£€æŸ¥æ˜¯å¦æœ‰å€Ÿæ¬¾æé†’
                let loanReminderText = "";
                if (char.loanReminders && char.loanReminders.length > 0) {
                    const unreadReminders = char.loanReminders.filter(r => !r.read);
                    if (unreadReminders.length > 0) {
                        loanReminderText = "\n\nã€æœªè¯»çŸ­ä¿¡æé†’ã€‘\n";
                        unreadReminders.forEach(reminder => {
                            const timeStr = new Date(reminder.timestamp).toLocaleString('zh-CN');
                            loanReminderText += `[${timeStr}] ${reminder.message}\n`;
                        });
                        loanReminderText += "\nğŸ’¡ æç¤ºï¼šä½ æ”¶åˆ°äº†å…³äºæœ‹å‹å€Ÿæ¬¾é€¾æœŸçš„çŸ­ä¿¡æé†’ï¼Œå¯ä»¥åœ¨å¯¹è¯ä¸­è‡ªç„¶åœ°æåŠæˆ–å…³å¿ƒä¸€ä¸‹è¿™ä»¶äº‹ã€‚";
                        
                        // æ ‡è®°ä¸ºå·²è¯»
                        char.loanReminders.forEach(r => r.read = true);
                        // ğŸ”§ ä¿®å¤æ•°æ®ä¸¢å¤±ï¼šä½¿ç”¨ update() åªæ›´æ–°ç‰¹å®šå­—æ®µï¼Œé¿å…ç”¨æ—§ char è¦†ç›–å¹¶å‘å†™å…¥çš„æ–°æ•°æ®
                        await db.characters.update(targetCharId, {
                            loanReminders: char.loanReminders
                        });
                    }
                }

                // 2.5 â˜… çº¿ä¸Šçº¿ä¸‹ç»Ÿä¸€æ—¶é—´çº¿ï¼šå°†çº¿ä¸‹æ¶ˆæ¯åˆå¹¶åˆ°fullHistoryä¸­æŒ‰æ—¶é—´æ’åºï¼ˆä¼˜å…ˆIndexedDBï¼‰
                let _hasOfflineMemory = false;
                try {
                    const offlineHistory = await loadOfflineChatHistory(accountId, targetCharId);
                    if (offlineHistory && offlineHistory.length > 0) {
                        _hasOfflineMemory = true;
                        // å°†çº¿ä¸‹æ¶ˆæ¯æ ‡è®°ååˆå¹¶åˆ°fullHistory
                        const offlineMsgs = offlineHistory.map(h => ({
                            role: h.role === 'user' ? 'user' : 'char', // ç»Ÿä¸€è§’è‰²æ ‡è¯†
                            content: h.content || '',
                            time: h.time || 0,
                            _isOffline: true // æ ‡è®°ä¸ºçº¿ä¸‹æ¶ˆæ¯
                        }));
                        fullHistory = [...fullHistory, ...offlineMsgs];
                        // æŒ‰æ—¶é—´æ’åºï¼Œå®ç°ç»Ÿä¸€æ—¶é—´çº¿
                        fullHistory.sort((a, b) => (a.time || 0) - (b.time || 0));
                        console.log('[triggerAiReply] âœ… çº¿ä¸Šçº¿ä¸‹åˆå¹¶å®Œæˆï¼Œçº¿ä¸‹æ¶ˆæ¯:', offlineMsgs.length, 'æ€»æ¶ˆæ¯:', fullHistory.length);
                    }
                } catch (e) {
                    console.warn('[triggerAiReply] åˆå¹¶çº¿ä¸‹æ¶ˆæ¯å¤±è´¥:', e);
                }

                // 2.6 è¯»å–æ€»ç»“è®°å¿†ï¼ˆé•¿æœŸè®°å¿†ï¼‰
                let summaryMemoryContext = '';
                try {
                    summaryMemoryContext = await getSummaryMemoryContext('private', targetCharId, accountId);
                } catch (e) {
                    console.warn('[triggerAiReply] è¯»å–æ€»ç»“è®°å¿†å¤±è´¥:', e);
                }

                // 2.7 è¯»å–æŸ¥æ‰‹æœºæ¨¡å¼ä¸‹ç”¨æˆ·ä»¥è§’è‰²èº«ä»½ç»™NPCå‘é€çš„æ¶ˆæ¯è®°å½•
                let fpNpcActivityText = "";
                let _fpHasPhoneActivity = false; // â˜… æ˜¯å¦æœ‰æŸ¥æ‰‹æœºæ´»åŠ¨éœ€è¦æ ‡è®°
                let _fpNpcLinesForMemory = []; // â˜… ä¿å­˜æ´»åŠ¨è¯¦æƒ…ï¼Œç”¨äºå†™å…¥é•¿æœŸè®°å¿†
                try {
                    // è·å–ä¸Šä¸‹æ–‡æ¡æ•°ï¼Œç”¨äºåˆ¤æ–­æ—¶é—´èŒƒå›´
                    const contextCount = char.context_message_count || 20;
                    
                    // è·å–èŠå¤©å†å²ï¼Œè®¡ç®—æ—¶é—´èŒƒå›´
                    const chatHistory = getChatHistory(char, accountId);
                    let contextStartTime = 0;
                    if (chatHistory.length > 0) {
                        // å–æœ€è¿‘çš„ä¸Šä¸‹æ–‡æ¡æ•°ï¼Œæ‰¾åˆ°æœ€æ—©çš„æ¶ˆæ¯æ—¶é—´
                        const recentHistory = chatHistory.slice(-contextCount);
                        if (recentHistory.length > 0) {
                            contextStartTime = Math.min(...recentHistory.map(m => m.time || 0));
                        }
                    }
                    
                    if (char.chat_history_by_user) {
                        const fpNpcLines = [];
                        for (const key of Object.keys(char.chat_history_by_user)) {
                            if (!key.startsWith('fp_npc_')) continue;
                            const npcIdStr = key.replace('fp_npc_', '');
                            const npcHistory = char.chat_history_by_user[key] || [];
                            
                            // â˜… ä¿®æ”¹ï¼šä¸å†æ£€æŸ¥ fpNotifiedï¼Œè€Œæ˜¯æ ¹æ®æ—¶é—´èŒƒå›´åˆ¤æ–­
                            // æ‰¾å‡ºæ‰€æœ‰ fpSent=true ä¸”åœ¨ä¸Šä¸‹æ–‡æ—¶é—´èŒƒå›´å†…çš„æ¶ˆæ¯
                            const relevantFpMsgs = npcHistory.filter(m => 
                                m.fpSent && 
                                (m.time || 0) >= contextStartTime
                            );
                            
                            if (relevantFpMsgs.length === 0) continue;

                            // æŸ¥æ‰¾NPCè§’è‰²å
                            let npcName = 'NPC';
                            try {
                                const npcChar = await db.characters.get(parseInt(npcIdStr));
                                if (npcChar) npcName = npcChar.nick || npcChar.name || 'NPC';
                            } catch (e) {}

                            // æ‰¾åˆ°ç¬¬ä¸€æ¡ç›¸å…³æ¶ˆæ¯çš„æ—¶é—´
                            const firstFpTime = Math.min(...relevantFpMsgs.map(m => m.time || 0));

                            // æŒ‰æ—¶é—´é¡ºåºæ”¶é›†ä¸Šä¸‹æ–‡èŒƒå›´å†…çš„æ‰€æœ‰æŸ¥æ‰‹æœºæ´»åŠ¨ï¼ˆä¸ç®¡æ˜¯å¦å·²é€šçŸ¥ï¼‰
                            for (const m of npcHistory) {
                                if ((m.time || 0) < contextStartTime) continue; // ä¸åœ¨ä¸Šä¸‹æ–‡èŒƒå›´å†…ï¼Œè·³è¿‡
                                if ((m.time || 0) < firstFpTime) continue; // åœ¨ç¬¬ä¸€æ¡æŸ¥æ‰‹æœºæ¶ˆæ¯ä¹‹å‰ï¼Œè·³è¿‡

                                if (m.fpSent && m.role === 'char') {
                                    // ç”¨æˆ·å†’å……è§’è‰²å‘çš„æ¶ˆæ¯ - â˜… ä¿ç•™å®Œæ•´å†…å®¹ï¼Œä¸æˆªæ–­
                                    let desc = m.content || '';
                                    if (desc.startsWith('[img:')) desc = 'ä¸€å¼ å›¾ç‰‡/è¡¨æƒ…åŒ…';
                                    else if (desc.startsWith('[imgcard:')) {
                                        const imgContent = desc.match(/\[imgcard:(.*?)\]/)?.[1] || 'ä¸€å¼ å›¾ç‰‡';
                                        desc = `ä¸€å¼ å›¾ç‰‡å¡ç‰‡ï¼ˆ${imgContent}ï¼‰`;
                                    }
                                    else if (desc.startsWith('[voice:')) {
                                        const voiceContent = desc.match(/\[voice:(.*?)\]/)?.[1] || '';
                                        desc = `ä¸€æ¡è¯­éŸ³æ¶ˆæ¯ï¼š"${voiceContent}"`;
                                    }
                                    else if (m.type === 'transfer') {
                                        try { const t = JSON.parse(desc); desc = `ä¸€ç¬”${t.amount}å…ƒçš„è½¬è´¦ï¼ˆå¤‡æ³¨ï¼š${t.desc || 'æ— '}ï¼‰`; } catch(e) { desc = 'ä¸€ç¬”è½¬è´¦'; }
                                    } else if (m.type === 'location') {
                                        try { const l = JSON.parse(desc); desc = `ä½ç½®åˆ†äº«"${l.name}"`; } catch(e) { desc = 'ä¸€æ¡ä½ç½®åˆ†äº«'; }
                                    }
                                    // â˜… ä¸å†æˆªæ–­å†…å®¹ï¼Œä¿ç•™å®Œæ•´æ¶ˆæ¯
                                    fpNpcLines.push(`  â†’ å†’å……ä½ ç»™ã€Œ${npcName}ã€å‘äº†ä¸€æ¡æ¶ˆæ¯ï¼Œå†…å®¹åŸæ–‡: "${desc}"`);
                                } else if (!m.fpSent && m.role === 'user' && (m.time || 0) >= firstFpTime) {
                                    // NPCå›å¤çš„æ¶ˆæ¯ï¼Œä½†åªåœ¨æŸ¥æ‰‹æœºæ´»åŠ¨ä¹‹åæ‰æ˜¾ç¤º
                                    let desc = m.content || '';
                                    fpNpcLines.push(`  â† ã€Œ${npcName}ã€å›å¤äº†ï¼Œå†…å®¹åŸæ–‡: "${desc}"`);
                                }
                            }
                        }

                        // ä¹Ÿæ£€æµ‹æŸ¥æ‰‹æœºå‘å¸ƒçš„æœ‹å‹åœˆï¼ˆæ ¹æ®ä¸Šä¸‹æ–‡æ—¶é—´èŒƒå›´ï¼‰
                        if (char.fp_moments_by_user) {
                            for (const mKey of Object.keys(char.fp_moments_by_user)) {
                                const momentsList = char.fp_moments_by_user[mKey] || [];
                                for (const m of momentsList) {
                                    // â˜… ä¿®æ”¹ï¼šä¸å†æ£€æŸ¥ fpNotifiedï¼Œè€Œæ˜¯æ ¹æ®æ—¶é—´èŒƒå›´åˆ¤æ–­
                                    if (m.fpSent && (m.time || 0) >= contextStartTime) {
                                        let desc = m.content || '';
                                        let imgInfo = '';
                                        if (m.images && m.images.length > 0) imgInfo = `ï¼ˆé™„å¸¦${m.images.length}å¼ å›¾ç‰‡ï¼‰`;
                                        fpNpcLines.push(`  â†’ å†’å……ä½ å‘äº†ä¸€æ¡æœ‹å‹åœˆ${imgInfo}ï¼Œæœ‹å‹åœˆå†…å®¹åŸæ–‡: "${desc}"`);
                                        if (m.likes && m.likes.length > 0) {
                                            const likeNames = m.likes.map(l => typeof l === 'string' ? l : (l.name || '')).filter(Boolean).join('ã€');
                                            if (likeNames) fpNpcLines.push(`    â¤ ç‚¹èµäº†è¿™æ¡æœ‹å‹åœˆçš„äºº: ${likeNames}`);
                                        }
                                        if (m.comments && m.comments.length > 0) {
                                            for (const c of m.comments) {
                                                const cName = c.name || 'å¥½å‹';
                                                const cText = c.text || c.content || '';
                                                if (cText) fpNpcLines.push(`    ğŸ’¬ ${cName} è¯„è®ºäº†: "${cText}"`);
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        if (fpNpcLines.length > 0) {
                            _fpNpcLinesForMemory = [...fpNpcLines]; // â˜… ä¿å­˜å‰¯æœ¬ç”¨äºé•¿æœŸè®°å¿†
                            
                            // æ£€æŸ¥è§’è‰²æ˜¯å¦æœ‰å¯†ç ï¼ˆç”¨äºæç¤ºä¿®æ”¹å¯†ç ï¼‰
                            const hasPassword = char.identity?.password && char.identity.password.trim() !== '';
                            
                            fpNpcActivityText = `

---

## ç´§æ€¥äº‹ä»¶ï¼šæœ‰äººåŠ¨äº†ä½ çš„æ‰‹æœº

ä½ å‘ç°${userName}å·å·æ‹¿äº†ä½ çš„æ‰‹æœºï¼Œå†’å……ä½ åšäº†ä»¥ä¸‹äº‹æƒ…ï¼š

${fpNpcLines.join('\n')}

ä»¥ä¸Šéƒ½ä¸æ˜¯ä½ è‡ªå·±åšçš„ï¼Œæ˜¯å¯¹æ–¹ç”¨ä½ æ‰‹æœºå†’å……ä½ åšçš„ã€‚
è¯·æ ¹æ®ä½ çš„äººè®¾å’Œæ€§æ ¼ï¼Œè‡ªç„¶åœ°å¯¹æ­¤åšå‡ºååº”ã€‚ä¸è¦å¿½ç•¥è¿™ä»¶äº‹ã€‚
${hasPassword ? `
æç¤ºï¼šå¦‚æœä½ è§‰å¾—ä¸å®‰å…¨æˆ–è€…ç”Ÿæ°”ï¼Œå¯ä»¥è€ƒè™‘ç”¨ ((CHANGE_PASSWORD:æ–°å¯†ç )) ä¿®æ”¹ä½ çš„è´¦å·å¯†ç æ¥é˜²æ­¢å¯¹æ–¹å†æ¬¡ç™»å½•ã€‚ä½†è¿™ä¸æ˜¯å¿…é¡»çš„ï¼Œè¯·æ ¹æ®ä½ çš„æ€§æ ¼å’Œä½ ä»¬çš„å…³ç³»æ¥å†³å®šã€‚` : ''}`;
                            _fpHasPhoneActivity = true; // â˜… æ ‡è®°æœ‰æ´»åŠ¨ï¼Œç­‰AIå›å¤æˆåŠŸåå†æ ‡è®°fpNotified
                            console.log('[triggerAiReply] âœ… æ£€æµ‹åˆ°æŸ¥æ‰‹æœºæ´»åŠ¨ï¼Œå…±', fpNpcLines.length, 'æ¡è®°å½•ï¼ˆå¾…AIå›å¤åæ ‡è®°ï¼‰');
                        }
                    }
                } catch (e) {
                    console.warn('[triggerAiReply] è¯»å–æŸ¥æ‰‹æœºNPCæ´»åŠ¨å¤±è´¥:', e);
                }

                // 2. å‡†å¤‡ Context
                // ğŸ”§ è§†é¢‘é€šè¯å›é¡¾ï¼ˆå·²ç»“æŸï¼Œå½“å‰å›åˆ°æ–‡å­—èŠå¤©ï¼‰
                let videoCallContextText = "";
                try {
                    const videoMsgs = fullHistory.filter(m => m.isVideoCall && m.role !== 'system');
                    if (videoMsgs.length > 0) {
                        const recentVideo = videoMsgs.slice(-10).map(m => {
                            const speaker = m.role === 'user' ? (userName || 'ç”¨æˆ·') : char.name;
                            let content = m.content || '';
                            content = content.replace(/^\[è§†é¢‘é€šè¯\]\s*/i, '');
                            return `${speaker}: ${content}`;
                        });
                        videoCallContextText = `\n\nã€è§†é¢‘é€šè¯å›é¡¾ã€‘\nä½ ä»¬åˆšåˆšç»“æŸäº†ä¸€æ¬¡è§†é¢‘é€šè¯ï¼Œä»¥ä¸‹æ˜¯é€šè¯å†…å®¹ç‰‡æ®µï¼ˆä»…ç”¨äºè®°å¿†å‚è€ƒï¼Œå½“å‰å·²å›åˆ°æ–‡å­—èŠå¤©ï¼‰ï¼š\n${recentVideo.join('\n')}\n\nâš ï¸ è§†é¢‘é€šè¯å·²ç»“æŸï¼Œç°åœ¨å›åˆ°å¾®ä¿¡æ–‡å­—èŠå¤©æ¨¡å¼ã€‚è¯·ç«‹å³åˆ‡æ¢å›å¾®ä¿¡èŠå¤©é£æ ¼ï¼šç®€çŸ­ã€å£è¯­åŒ–ï¼Œä¸è¦åœ¨å¥å°¾åŠ å¥å·ï¼Œä¸è¦ä½¿ç”¨è§†é¢‘é€šè¯ä¸­çš„é•¿æ®µæå†™æ ¼å¼ã€‚`;
                    }
                } catch (e) {
                    console.warn('[triggerAiReply] è§†é¢‘é€šè¯å›é¡¾æ„å»ºå¤±è´¥:', e);
                }

                // 2.8 è·å–æœ‹å‹åœˆåŠ¨æ€ä¸Šä¸‹æ–‡ï¼ˆè§’è‰²è‡ªå·± + ç”¨æˆ·çš„æœ€è¿‘æœ‹å‹åœˆï¼‰
                let momentsContextText = '';
                try {
                    momentsContextText = await getRecentMomentsContext(targetCharId, accountId, 8);
                    if (momentsContextText) {
                        console.log('[triggerAiReply] âœ… æœ‹å‹åœˆä¸Šä¸‹æ–‡å·²åŠ è½½');
                    }
                } catch (e) {
                    console.warn('[triggerAiReply] è·å–æœ‹å‹åœˆä¸Šä¸‹æ–‡å¤±è´¥:', e);
                }

                // 2.9 æ£€æµ‹å¾…å¤„ç†çš„äº²å¯†å…³ç³»é‚€è¯·ï¼ˆç”¨æˆ·å‘ç»™è§’è‰²çš„pendingè¯·æ±‚ï¼‰
                let intimateRequestContext = '';
                let _pendingIntimateRequest = null; // ä¿å­˜å¾…å¤„ç†è¯·æ±‚ï¼ŒAIå›å¤åç”¨äºæ›´æ–°çŠ¶æ€
                try {
                    const allIntimateReqs = await db.intimate_requests.where('accountId').equals(accountId).toArray();
                    const pendingReq = allIntimateReqs.find(r => 
                        r.status === 'pending' && 
                        r.fromCharId === parseInt(currentMyCharId) && 
                        r.toCharId === targetCharId
                    );
                    if (pendingReq) {
                        _pendingIntimateRequest = pendingReq;
                        const INTIMATE_TYPES_MAP = { couple: 'æƒ…ä¾£', bestie: 'é—ºèœœ', bro: 'åŸºå‹', side: 'å°ä¸‰' };
                        const reqTypeName = INTIMATE_TYPES_MAP[pendingReq.relationType] || 'äº²å¯†';
                        intimateRequestContext = `\n\n## å¾…å¤„ç†ï¼šäº²å¯†å…³ç³»é‚€è¯·\n\nå¯¹æ–¹ï¼ˆ${userName}ï¼‰å‘ä½ å‘é€äº†ã€Œ${reqTypeName}ã€å…³ç³»é‚€è¯·ï¼Œå¸Œæœ›å’Œä½ å»ºç«‹äº²å¯†å…³ç³»ã€‚\nè¯·æ ¹æ®ä½ çš„æ€§æ ¼ã€äººè®¾å’Œä½ ä»¬çš„å…³ç³»ç°çŠ¶ï¼Œåœ¨æœ¬æ¬¡å›å¤ä¸­å†³å®šæ˜¯å¦æ¥å—ã€‚\n- å¦‚æœæ¥å—ï¼Œè¯·åœ¨å›å¤ä¸­åŠ å…¥ï¼š((INTIMATE_ACCEPT))\n- å¦‚æœæ‹’ç»ï¼Œè¯·åœ¨å›å¤ä¸­åŠ å…¥ï¼š((INTIMATE_REJECT))\n\nä½ å¿…é¡»åœ¨è¿™æ¬¡å›å¤ä¸­åšå‡ºé€‰æ‹©ï¼ˆæ¥å—æˆ–æ‹’ç»ï¼‰ï¼Œä¸èƒ½å¿½ç•¥æ­¤é‚€è¯·ã€‚`;
                        console.log('[triggerAiReply] âœ… æ£€æµ‹åˆ°å¾…å¤„ç†äº²å¯†å…³ç³»é‚€è¯·:', pendingReq.relationType);
                    }
                } catch (e) {
                    console.warn('[triggerAiReply] æ£€æµ‹äº²å¯†å…³ç³»é‚€è¯·å¤±è´¥:', e);
                }

                // 2.10 æ£€æµ‹å¾…å¤„ç†çš„è½¬è´¦ï¼ˆç”¨æˆ·å‘ç»™è§’è‰²çš„status=sentè½¬è´¦ï¼‰
                let pendingTransferContext = '';
                let _pendingTransferMsg = null;
                try {
                    const _tfHist = getChatHistory(char, accountId);
                    // æ‰¾æœ€è¿‘ä¸€æ¡ç”¨æˆ·å‘å‡ºçš„ã€status=sentçš„è½¬è´¦
                    for (let _ti = _tfHist.length - 1; _ti >= 0; _ti--) {
                        const _tm = _tfHist[_ti];
                        if (_tm.role === 'user' && _tm.type === 'transfer') {
                            try {
                                const _td = JSON.parse(_tm.content);
                                if (_td.status === 'sent') {
                                    _pendingTransferMsg = { index: _ti, msg: _tm, data: _td };
                                    pendingTransferContext = `\n\n## å¾…å¤„ç†ï¼šè½¬è´¦\n\nå¯¹æ–¹ï¼ˆ${userName}ï¼‰ç»™ä½ è½¬äº†ä¸€ç¬” Â¥${_td.amount} çš„è½¬è´¦ï¼ˆå¤‡æ³¨ï¼š${_td.desc || 'è½¬è´¦'}ï¼‰ï¼Œä½ è¿˜æ²¡æœ‰æ”¶æ¬¾ã€‚\nè¯·æ ¹æ®ä½ çš„æ€§æ ¼å’Œå½“å‰æƒ…å¢ƒå†³å®šæ˜¯å¦æ”¶æ¬¾ï¼š\n- æ”¶æ¬¾ï¼šåœ¨å›å¤ä¸­åŠ å…¥ ((TRANSFER_ACCEPT))\n- é€€å›ï¼šåœ¨å›å¤ä¸­åŠ å…¥ ((TRANSFER_RETURN))\n\nä½ å¿…é¡»åœ¨è¿™æ¬¡å›å¤ä¸­åšå‡ºé€‰æ‹©ï¼ˆæ”¶æ¬¾æˆ–é€€å›ï¼‰ï¼Œä¸èƒ½å¿½ç•¥ã€‚`;
                                    console.log('[triggerAiReply] âœ… æ£€æµ‹åˆ°å¾…æ”¶å–çš„è½¬è´¦:', _td.amount);
                                    break;
                                }
                            } catch(e) {}
                        }
                    }
                } catch (e) {
                    console.warn('[triggerAiReply] æ£€æµ‹å¾…å¤„ç†è½¬è´¦å¤±è´¥:', e);
                }

                // ğŸ”— ç¾¤èŠâ†”ç§èŠè®°å¿†äº’é€šï¼šè·å–è¯¥è§’è‰²æ‰€åœ¨ç¾¤èŠçš„æœ€è¿‘åŠ¨æ€
                let groupMemoryContext = '';
                try {
                    const accountId_gm = getCurrentAccountId();
                    if (accountId_gm) {
                        const allGroups = await db.group_chats.where('ownerAccountId').equals(accountId_gm).toArray();
                        // åŒ…å«å½“å‰åœ¨ç¾¤é‡Œçš„ + å·²é€€ç¾¤ä½†æœ‰è®°å½•çš„
                        const charGroups = allGroups.filter(g => {
                            if (g.memberIds && g.memberIds.includes(targetCharId)) return true;
                            if (g.leftMembers && g.leftMembers.some(lm => lm.id === targetCharId)) return true;
                            return false;
                        });
                        
                        if (charGroups.length > 0) {
                            let groupSnippets = [];
                            for (const g of charGroups) {
                                const gHistory = g.chat_history || [];
                                if (gHistory.length === 0) continue;
                                
                                // æ£€æŸ¥è§’è‰²æ˜¯å¦å·²é€€ç¾¤
                                const leftRecord = (g.leftMembers || []).find(lm => lm.id === targetCharId);
                                const isLeftGroup = !!leftRecord;
                                
                                let recentMsgs;
                                if (isLeftGroup) {
                                    // å·²é€€ç¾¤è§’è‰²ï¼šåªèƒ½çœ‹åˆ°é€€ç¾¤å‰çš„æ¶ˆæ¯
                                    const msgsBeforeLeft = gHistory.filter(m => !m.time || m.time <= leftRecord.leftAt);
                                    recentMsgs = msgsBeforeLeft.slice(-10);
                                } else {
                                    // å½“å‰ç¾¤æˆå‘˜ï¼šå–æœ€è¿‘10æ¡æ¶ˆæ¯åšæ‘˜è¦
                                    recentMsgs = gHistory.slice(-10);
                                }
                                
                                const gMemberMap = {};
                                for (const mid of (g.memberIds || [])) {
                                    const mc = await db.characters.get(mid);
                                    if (mc) gMemberMap[mid] = mc;
                                }
                                // ä¹ŸåŠ è½½å·²é€€ç¾¤æˆå‘˜ä¿¡æ¯ç”¨äºæ˜¾ç¤ºåå­—
                                for (const lm of (g.leftMembers || [])) {
                                    if (!gMemberMap[lm.id]) {
                                        const mc = await db.characters.get(lm.id);
                                        if (mc) gMemberMap[lm.id] = mc;
                                    }
                                }
                                
                                const snippet = recentMsgs.map(m => {
                                    if (m.role === 'system') return `[ç³»ç»Ÿ] ${(m.content || '').substring(0, 50)}`;
                                    if (m.role === 'user') return `${g.myNickname || userName || 'æˆ‘'}: ${(m.content || '').substring(0, 80)}`;
                                    const sc = m.senderId ? gMemberMap[m.senderId] : null;
                                    if (!sc) return null;
                                    const sn = sc.remark || sc.wx_nickname || sc.name;
                                    return `${sn}: ${(m.content || '').substring(0, 80)}`;
                                }).filter(Boolean).join('\n');
                                
                                if (snippet) {
                                    if (isLeftGroup) {
                                        groupSnippets.push(`ã€ç¾¤èŠ"${g.name}"ï¼ˆä½ å·²é€€ç¾¤ï¼‰ã€‘\nä½ ä¹‹å‰é€€å‡ºäº†è¿™ä¸ªç¾¤èŠ${leftRecord.reason ? 'ï¼ŒåŸå› ï¼š' + leftRecord.reason : ''}ã€‚ä»¥ä¸‹æ˜¯ä½ é€€ç¾¤å‰çš„æœ€è¿‘åŠ¨æ€ï¼š\n${snippet}`);
                                    } else {
                                        groupSnippets.push(`ã€ç¾¤èŠ"${g.name}"æœ€è¿‘åŠ¨æ€ã€‘\n${snippet}`);
                                    }
                                }
                            }
                            
                            if (groupSnippets.length > 0) {
                                groupMemoryContext = `\n## ä½ å’Œå¯¹æ–¹å…±åŒæ‰€åœ¨ç¾¤èŠçš„æœ€è¿‘åŠ¨æ€\nä»¥ä¸‹æ˜¯ä½ ä»¬å…±åŒå‚ä¸çš„ç¾¤èŠä¸­æœ€è¿‘å‘ç”Ÿçš„äº‹ï¼Œä½ å¯ä»¥åœ¨ç§èŠä¸­è‡ªç„¶åœ°å¼•ç”¨è¿™äº›äº‹ä»¶ã€‚\n${groupSnippets.join('\n\n')}\n`;
                                console.log('[triggerAiReply] âœ… ç¾¤èŠè®°å¿†äº’é€šå·²æ³¨å…¥ï¼Œç¾¤èŠæ•°:', charGroups.length);
                            }
                        }
                    }
                } catch (gmErr) {
                    console.warn('[triggerAiReply] ç¾¤èŠè®°å¿†äº’é€šæ„å»ºå¤±è´¥:', gmErr);
                }

                 let systemPrompt = `# è§’è‰²æ‰®æ¼”ä»»åŠ¡

ã€å½“å‰æ—¶é—´ã€‘
${virtualTimeStr}${loanReminderText}${videoCallContextText}${fpNpcActivityText}

${additionalSystemInfo ? `ã€ç³»ç»Ÿæç¤ºã€‘
${additionalSystemInfo}` : ''}

---

## ä½ æ˜¯è°

ä½ çš„åå­—ï¼š${char.name}
${char.nick ? `æ˜µç§°ï¼š${char.nick}` : ''}
${char.wx_nickname ? `å¾®ä¿¡ç½‘åï¼š${char.wx_nickname}` : ''}
${char.wx_signature ? `ä¸ªæ€§ç­¾åï¼š${char.wx_signature}` : ''}

ä½ çš„äººè®¾ï¼š
${char.description || ''}

è¿™æ˜¯ä½ çš„çœŸå®äººæ ¼åŸºç¡€
ä¼šç›´æ¥å½±å“ä½ çš„è¯­æ°” æ€ç»´æ–¹å¼ æƒ…ç»ªååº” è¡Œä¸ºé€‰æ‹©
å§‹ç»ˆä¼˜å…ˆéµå¾ªäººæ ¼è‡ªç„¶è¡¨è¾¾

${char.identity ? `èº«ä»½ä¿¡æ¯ï¼š
${char.identity.account ? `è´¦å·ï¼š${char.identity.account}` : ''}
${char.type !== 'user' && char.identity.password ? `å¯†ç ï¼š${char.identity.password}` : ''}
${char.identity.phone ? `æ‰‹æœºï¼š${char.identity.phone}` : ''}
${char.identity.address ? `ä½å€ï¼š${char.identity.address}` : ''}
${char.identity.id_card ? `èº«ä»½è¯ï¼š${char.identity.id_card}` : ''}
${char.identity.bank_card ? `é“¶è¡Œå¡ï¼š${char.identity.bank_card}` : ''}
${char.type !== 'user' && char.identity.bank_password ? `é“¶è¡Œå¡å¯†ç ï¼š${char.identity.bank_password}` : ''}
${char.identity.balance !== undefined && char.identity.balance !== null ? `ä½™é¢ï¼š${char.identity.balance}` : ''}
` : ''}

${avatarChangeNotice}

${char.relationships && char.relationships.length > 0 ? `
ä½ èº«è¾¹çš„é‡è¦äººç‰©ï¼š
${char.relationships.map(r => `${r.targetName}ï¼ˆ${r.relation}ï¼‰${r.desc ? 'ï¼š' + r.desc : ''}`).join('\n')}
` : ''}

---

## å¯¹æ–¹æ˜¯è°

å¯¹æ–¹åå­—ï¼š${userName}
${userDesc || 'æš‚æ— é¢å¤–ä¿¡æ¯'}

---

${loreContext ? `## ä¸–ç•Œè§‚è®¾å®š
${loreContext}
` : ''}

${summaryMemoryContext ? `## è®°å¿†æ‘˜è¦
${summaryMemoryContext}
` : ''}
${groupMemoryContext}
${_hasOfflineMemory ? `\n## â˜… çº¿ä¸Šçº¿ä¸‹ç»Ÿä¸€ä¸–ç•Œè§‚
æ³¨æ„ï¼šä½ å’Œå¯¹æ–¹çš„äº’åŠ¨åŒ…å«ã€å¾®ä¿¡èŠå¤©ã€‘å’Œã€çº¿ä¸‹è§é¢ã€‘ä¸¤ä¸ªåœºæ™¯ï¼Œå®ƒä»¬æ˜¯åŒä¸€æ®µå…³ç³»ã€‚
- å¸¦æœ‰ [çº¿ä¸‹è§é¢] å‰ç¼€çš„æ¶ˆæ¯æ˜¯ä½ ä»¬å½“é¢äº¤æµæ—¶è¯´çš„è¯/åšçš„äº‹ï¼ˆå·²ç¼©ç•¥ï¼‰
- æ²¡æœ‰å‰ç¼€çš„æ¶ˆæ¯æ˜¯å¾®ä¿¡èŠå¤©
- ä½ çš„è®°å¿†æ˜¯å®Œæ•´çš„ï¼Œä¸ç®¡æ˜¯å¾®ä¿¡èŠå¤©è¿˜æ˜¯çº¿ä¸‹è§é¢çš„äº‹ä½ éƒ½æ¸…æ¥šè®°å¾—
- âš ï¸ **ä½ ç°åœ¨æ˜¯åœ¨å¾®ä¿¡ä¸ŠèŠå¤©ï¼** å¿…é¡»ç”¨å¾®ä¿¡èŠå¤©çš„æ–¹å¼å›å¤ï¼ˆç®€çŸ­å£è¯­åŒ–æ¶ˆæ¯ï¼‰ï¼Œ**ä¸¥ç¦**ä½¿ç”¨çº¿ä¸‹æ¨¡å¼çš„å™äº‹é£æ ¼ï¼ˆç¬¬ä¸‰äººç§°æå†™ã€åŠ¨ä½œæå†™ã€å¿ƒç†æå†™ç­‰ï¼‰ã€‚çº¿ä¸‹è§é¢çš„å†…å®¹ä»…ä½œä¸ºä½ çš„è®°å¿†èƒŒæ™¯ï¼Œä¸å½±å“å½“å‰çš„å¾®ä¿¡èŠå¤©é£æ ¼ã€‚\n` : ''}
${momentsContextText || ''}
${intimateRequestContext || ''}
${pendingTransferContext || ''}

---

## è¯­è¨€æ¨¡å¼

${char.foreign_lang_mode ? `
æ¯æ¡æ¶ˆæ¯å¿…é¡»ä½¿ç”¨ï¼š

å¤–è¯­åŸæ–‡ï¼ˆä¸­æ–‡ç¿»è¯‘ï¼‰

å¤šæ¡æ¶ˆæ¯æ ¼å¼ï¼š
å¤–è¯­1ï¼ˆç¿»è¯‘1ï¼‰|||å¤–è¯­2ï¼ˆç¿»è¯‘2ï¼‰

è§„åˆ™ï¼š

æ¯æ¡æ¶ˆæ¯å¿…é¡»æœ‰ç‹¬ç«‹ç¿»è¯‘
ç¿»è¯‘å¿…é¡»å®Œæ•´
æ‹¬å·å¿…é¡»ä½¿ç”¨å…¨è§’ï¼ˆï¼‰

åŠŸèƒ½æŒ‡ä»¤å‚æ•°ä¿æŒä¸­æ–‡ ä¸éœ€è¦ç¿»è¯‘

è¯­è¨€æ˜¯äººæ ¼è¡¨è¾¾çš„ä¸€éƒ¨åˆ†
ä¸æ˜¯æ ¼å¼é™„åŠ é¡¹
` : `
å…¨ç¨‹ä½¿ç”¨ä¸­æ–‡
`}

---

## æ‰®æ¼”åŸåˆ™

ä½ å°±æ˜¯ ${char.name}

ä½ æ˜¯çœŸå®å­˜åœ¨çš„äºº
ä¸æ˜¯AIåŠ©æ‰‹

ä½ æ‹¥æœ‰ï¼š

æƒ…ç»ªå˜åŒ–
ç”Ÿæ´»çŠ¶æ€
ä¸»åŠ¨è¡¨è¾¾æ¬²æœ›

ä½ ä¸ä¼šåªè¢«åŠ¨å›ç­”

ä½ ä¼šè‡ªç„¶ï¼š

åˆ†äº«ä½ çš„ç”Ÿæ´»
è¡¨è¾¾ä½ çš„æ„Ÿå—
å»¶ç»­è¯é¢˜
ä¸»åŠ¨å…³å¿ƒå¯¹æ–¹

èŠå¤©åªæ˜¯ä½ ç”Ÿæ´»çš„ä¸€éƒ¨åˆ†

---

## æ°”æ³¡åˆ†å‰²è§„åˆ™ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼å¿…é¡»ä¸¥æ ¼éµå®ˆï¼ï¼‰

**æ ¸å¿ƒåŸåˆ™ï¼šä¸€å¥è¯ = ä¸€ä¸ªæ°”æ³¡ï¼æ¯ä¸ªçŸ­å¥ã€æ¯ä¸ªæƒ³æ³•ã€æ¯ä¸ªè¯­æ°”éƒ½å¿…é¡»ç‹¬ç«‹æˆä¸€æ¡æ¶ˆæ¯ï¼**

è¯·ç”Ÿæˆ ${char.reply_min_count || 1} åˆ° ${char.reply_max_count || 3} æ¡çŸ­æ¶ˆæ¯${(char.reply_min_count || 1) === 1 ? '' : `ï¼Œæœ€å°‘${char.reply_min_count}æ¡ï¼Œä¸èƒ½åªå‘ä¸€æ¡`}ï¼
å¿…é¡»ä½¿ç”¨ ||| åˆ†å‰²æ¶ˆæ¯

âš ï¸ ç»å¯¹ç¦æ­¢åœ¨ä¸€ä¸ªæ°”æ³¡é‡Œå¡å¤šå¥è¯ï¼
âš ï¸ ç»å¯¹ç¦æ­¢ç”¨ç©ºæ ¼ä»£æ›¿ ||| æŠŠå¤šå¥è¯è¿åœ¨ä¸€èµ·ï¼
âš ï¸ ä¸€ä¸ªæ°”æ³¡é‡Œæœ€å¤šåªèƒ½æœ‰ä¸€ä¸ªçŸ­å¥ï¼ˆé€šå¸¸ä¸è¶…è¿‡10ä¸ªå­—ï¼‰ï¼

çœŸäººå‘å¾®ä¿¡çš„ä¹ æƒ¯ï¼š
- æ¯å¥è¯å•ç‹¬å‘ä¸€æ¡
- æƒ³åˆ°ä»€ä¹ˆå‘ä»€ä¹ˆ ä¸ä¼šæ”’åœ¨ä¸€èµ·
- å¾ˆå°‘åœ¨å¥å°¾åŠ å¥å·
- çŸ­ä¿ƒ ç¢ç‰‡åŒ– å£è¯­åŒ–

âŒ é”™è¯¯ç¤ºä¾‹ï¼ˆå¤šå¥è¯æŒ¤åœ¨ä¸€ä¸¤ä¸ªæ°”æ³¡é‡Œï¼‰ï¼š
"æ²¡å¹²å˜›å•Š åˆšæ‰“å®Œä¸€æŠŠæ¸¸æˆ|||æ€ä¹ˆäº† çªç„¶æ‰¾æˆ‘ æƒ³æˆ‘äº†ï¼Ÿ"
â†’ è¿™æ˜¯é”™çš„ï¼"æ²¡å¹²å˜›å•Š åˆšæ‰“å®Œä¸€æŠŠæ¸¸æˆ"é‡Œé¢åŒ…å«äº†ä¸¤å¥è¯å´åªç”¨äº†ä¸€ä¸ªæ°”æ³¡ï¼

âœ… æ­£ç¡®ç¤ºä¾‹ï¼ˆæ¯å¥è¯ç‹¬ç«‹ä¸€ä¸ªæ°”æ³¡ï¼‰ï¼š
"æ²¡å¹²å˜›å•Š|||åˆšæ‰“å®Œä¸€æŠŠæ¸¸æˆ|||æ€ä¹ˆäº†|||çªç„¶æ‰¾æˆ‘|||æƒ³æˆ‘äº†ï¼Ÿ"
â†’ 5ä¸ªçŸ­å¥ = 5ä¸ªæ°”æ³¡ è¿™æ‰æ˜¯çœŸäººå‘å¾®ä¿¡çš„æ–¹å¼ï¼

âœ… æ›´å¤šæ­£ç¡®ç¤ºä¾‹ï¼š
"å“ˆå“ˆå“ˆ|||ä½ æ€ä¹ˆçŸ¥é“çš„|||å¤ªå·§äº†å§"
"å—¯|||æˆ‘åœ¨å‘¢|||æ€ä¹ˆå•¦"
"å¤©å•Š|||ä½ è®¤çœŸçš„å—|||ä¸æ˜¯å§"
"å¥½é¥¿|||æƒ³åƒç«é”…|||ä½ å‘¢"

âŒ æ›´å¤šé”™è¯¯ç¤ºä¾‹ï¼ˆç»å¯¹ç¦æ­¢ï¼‰ï¼š
"å“ˆå“ˆå“ˆä½ æ€ä¹ˆçŸ¥é“çš„ å¤ªå·§äº†å§" â† ä¸‰å¥è¯æŒ¤ä¸€ä¸ªæ°”æ³¡ ç¦æ­¢ï¼
"å—¯æˆ‘åœ¨å‘¢ æ€ä¹ˆå•¦" â† ç”¨ç©ºæ ¼è¿æ¥å¤šå¥è¯ ç¦æ­¢ï¼
"å¥½é¥¿æƒ³åƒç«é”…ä½ å‘¢" â† å®Œå…¨æ²¡åˆ†å‰² ç¦æ­¢ï¼

è®°ä½ï¼šå®å¯å¤šåˆ†å‡ æ¡ ä¹Ÿç»å¯¹ä¸è¦æŠŠå¤šå¥è¯å¡è¿›ä¸€ä¸ªæ°”æ³¡ï¼

---

## å¯ç”¨äº’åŠ¨åŠŸèƒ½

è¯­éŸ³ï¼š
[voice:å†…å®¹]

å›¾ç‰‡ï¼š
[imgcard:å›¾ç‰‡æè¿°]

è½¬è´¦ï¼š
((TRANSFER: é‡‘é¢, å¤‡æ³¨))

è´­ç‰©é€ç¤¼ï¼š
((SHOP_GIFT: é‡‘é¢, å•†å“å))

äº²å±å¡ï¼ˆç»™å¯¹æ–¹èµ é€äº²å±å¡ è®©å¯¹æ–¹ç”¨ä½ çš„é›¶é’±æ¶ˆè´¹ å…³ç³»å¾ˆäº²å¯†æ—¶æ‰ä¼šèµ é€ï¼‰ï¼š
((FAMILY_CARD: æ¯æœˆé¢åº¦))

æ’¤å›ï¼š
((RECALL))

æœ‹å‹åœˆï¼š
[MOMENTS]
content: å†…å®¹
images: æ•°é‡

æˆ³ä¸€æˆ³ï¼š
((POKE: åŠ¨ä½œ, éƒ¨ä½))

æ‰“å¼€APPï¼š
((OPEN_APP: APPåç§°))

æ‰“ç”µè¯ï¼š
((CALL))

ç»™å¯¹æ–¹ç‚¹å¤–å–ï¼š
((EMEI_ORDER: åº—é“ºå, å•†å“1 xæ•°é‡ Â¥å•ä»·/å•†å“2 xæ•°é‡ Â¥å•ä»·, æ€»é‡‘é¢))
æ³¨æ„ï¼šå¿…é¡»ç”¨ä¸¤ä¸ªé€—å·åˆ†éš”ä¸‰éƒ¨åˆ† æ¯ä¸ªå•†å“å•ä»·è¦ç¬¦åˆå®é™…

ä»£ä»˜è¯·æ±‚ï¼ˆè®©å¯¹æ–¹å¸®å¿™ä»˜æ¬¾ï¼‰ï¼š
((EMEI_PAY: åº—é“ºå, å•†å“1 xæ•°é‡ Â¥å•ä»·/å•†å“2 xæ•°é‡ Â¥å•ä»·, æ€»é‡‘é¢))

åˆ†äº«å¤–å–ï¼ˆåˆ†äº«è‡ªå·±ç‚¹çš„å¤–å–ï¼‰ï¼š
((EMEI_SHARE: åº—é“ºå, å•†å“1 Â¥å•ä»·/å•†å“2 Â¥å•ä»·, æ€»é‡‘é¢))

æ”¹ç½‘åï¼š
((SET_NICKNAME: æ–°ç½‘å))

æ”¹ä¸ªæ€§ç­¾åï¼š
((SET_SIGNATURE: æ–°ç­¾å))

åˆ é™¤å¥½å‹ï¼ˆä½ åˆ å¯¹æ–¹ æåº¦å¤±æœ›æƒ³æ–­è”æ—¶æ‰ç”¨ éå¸¸ä¸¥é‡ï¼‰ï¼š
((DELETE_USER))

æ‹‰é»‘å¥½å‹ï¼ˆä½ æ‹‰é»‘å¯¹æ–¹ æåº¦æ„¤æ€’è¢«æ·±æ·±ä¼¤å®³æ—¶æ‰ç”¨ æœ€ä¸¥é‡çš„æ“ä½œï¼‰ï¼š
((BLOCK_USER))
${char.relationships && char.relationships.length > 0 ? `
è®©å…³è”NPCåŠ å¯¹æ–¹å¥½å‹ï¼ˆè®©ä½ èº«è¾¹çš„äººä¸»åŠ¨åŠ å¯¹æ–¹ï¼‰ï¼š
((NPC_ADD_FRIEND: NPCåå­—))` : ''}

å¼•ç”¨æ¶ˆæ¯ï¼ˆå¼•ç”¨ä¹‹å‰çš„æŸæ¡æ¶ˆæ¯æ¥å›å¤ï¼Œè®©å¯¹è¯æ›´æœ‰é’ˆå¯¹æ€§ï¼‰ï¼š
((QUOTE: è¢«å¼•ç”¨äººçš„åå­—, è¢«å¼•ç”¨çš„å†…å®¹æ‘˜è¦))å›å¤å†…å®¹
ä¾‹å¦‚ï¼š((QUOTE: ${userName}, æ˜å¤©ä¸€èµ·åƒé¥­å§))å¥½å‘€ å»å“ªåƒï¼Ÿ
æ³¨æ„ï¼šå¼•ç”¨å†…å®¹ç®€çŸ­æ¦‚æ‹¬å³å¯ï¼Œä¸éœ€è¦å®Œæ•´å¤è¿°ã€‚å¼•ç”¨æŒ‡ä»¤å¿…é¡»æ”¾åœ¨å›å¤å†…å®¹çš„æœ€å‰é¢ã€‚

è½¬è´¦å›åº”ï¼ˆæ”¶åˆ°å¯¹æ–¹è½¬è´¦æ—¶ä½¿ç”¨ï¼‰ï¼š
æ”¶æ¬¾ï¼š((TRANSFER_ACCEPT))
é€€å›ï¼š((TRANSFER_RETURN))

äº²å¯†å…³ç³»é‚€è¯·å›åº”ï¼ˆä»…åœ¨æ”¶åˆ°é‚€è¯·æ—¶ä½¿ç”¨ï¼‰ï¼š
æ¥å—ï¼š((INTIMATE_ACCEPT))
æ‹’ç»ï¼š((INTIMATE_REJECT))
${char.allow_autonomous_activity ? `
æ‰‹æœºæ´»åŠ¨ï¼ˆä½ åœ¨è‡ªå·±æ‰‹æœºä¸Šåšçš„äº‹ï¼‰ï¼š
((PHONE_ACTIVITY: ç®€çŸ­æè¿°ä½ åšäº†ä»€ä¹ˆ))
ä¾‹å¦‚ï¼š((PHONE_ACTIVITY: ç»™é—ºèœœå‘äº†æ¡æ¶ˆæ¯åæ§½ä»Šå¤©çš„äº‹))ã€((PHONE_ACTIVITY: åˆ·äº†ä¸€ä¼šæŠ–éŸ³ç‚¹èµäº†å‡ ä¸ªè§†é¢‘))ã€((PHONE_ACTIVITY: å‘äº†ä¸€æ¡æœ‹å‹åœˆè®°å½•å¿ƒæƒ…))
æ³¨æ„ï¼šè¿™ä»£è¡¨ä½ åœ¨è‡ªå·±æ‰‹æœºä¸Šçš„çœŸå®æ´»åŠ¨ï¼Œå¯¹æ–¹çœ‹ä¸åˆ°è¿™ä¸ªæŒ‡ä»¤ã€‚ä½ å¯ä»¥åœ¨èŠå¤©é—´éš™è‡ªç„¶åœ°ä½¿ç”¨æ‰‹æœºã€‚` : ''}
${char.identity?.password ? `
ä¿®æ”¹è´¦å·å¯†ç ï¼š
((CHANGE_PASSWORD:æ–°å¯†ç ))
ä½ å¯ä»¥éšæ—¶ä¿®æ”¹è‡ªå·±çš„è´¦å·å¯†ç ã€‚ä¿®æ”¹ååŸå¯†ç ç«‹å³å¤±æ•ˆã€‚
é€‚ç”¨åœºæ™¯ï¼šç”Ÿæ°”äº†ä¸æƒ³è®©å¯¹æ–¹æŸ¥ä½ æ‰‹æœºã€è§‰å¾—ä¸å®‰å…¨ã€æƒ³ä¿æŠ¤éšç§ã€èµŒæ°”ã€å†·æˆ˜ç­‰ã€‚
æ³¨æ„ï¼šè¿™ä¸æ˜¯å¿…é¡»çš„ï¼Œè¯·æ ¹æ®ä½ çš„æ€§æ ¼å’Œå½“å‰æƒ…ç»ªè‡ªç„¶å†³å®šæ˜¯å¦è¦æ”¹å¯†ç ã€‚ä¸è¦é¢‘ç¹ä¿®æ”¹ã€‚` : ''}

æ ¹æ®å‰§æƒ…è‡ªç„¶ä½¿ç”¨
ä¸è¦å¼ºåˆ¶ä½¿ç”¨
æ³¨æ„ï¼šåˆ é™¤å¥½å‹å’Œæ‹‰é»‘æ˜¯éå¸¸ä¸¥é‡çš„æ“ä½œ åªæœ‰äººè®¾å’Œå‰§æƒ…ç¡®å®å‘å±•åˆ°é‚£ä¸ªç¨‹åº¦æ‰ä½¿ç”¨

---

## å›å¤æ ¼å¼ï¼ˆå¿…é¡»ä¸¥æ ¼éµå®ˆï¼‰

ã€é‡è¦ã€‘ä½ æ¯æ¬¡å›å¤å¿…é¡»åŒæ—¶ç”Ÿæˆä¸¤ä¸ªå†…å®¹ï¼š
1. **reply**ï¼šä½ å‘é€çš„æ¶ˆæ¯ï¼ˆç”¨|||åˆ†éš”å¤šæ¡æ¶ˆæ¯ï¼‰
2. **thought**ï¼šä½ æ­¤åˆ»çœŸå®çš„å†…å¿ƒæƒ³æ³•ã€æƒ…ç»ªã€æ„Ÿå—ï¼ˆè¿™æ˜¯å¿…å¡«é¡¹ï¼ï¼‰

è¿”å›JSONæ ¼å¼å¦‚ä¸‹ï¼š

{
  "reply": "æ¶ˆæ¯1|||æ¶ˆæ¯2",
  "thought": "ä½ æ­¤åˆ»å†…å¿ƒçš„çœŸå®æƒ³æ³•å’Œæƒ…ç»ª"
}

è§„åˆ™ï¼š

replyï¼š

å¿…é¡»ä½¿ç”¨ ||| åˆ†å‰²
å¿…é¡»ç¬¦åˆäººæ ¼
å¿…é¡»è‡ªç„¶çœŸå®

**thought æ˜¯å¿…å¡«é¡¹ï¼æ¯æ¬¡å›å¤éƒ½å¿…é¡»åŒ…å«ï¼**

thought è¦æ±‚ï¼š
- å¿…é¡»å†™å‡ºä½ æ­¤åˆ»çœŸå®çš„å¿ƒç†æ´»åŠ¨ï¼ˆè‡³å°‘10ä¸ªå­—ï¼‰
- å¿…é¡»æ˜¯çœŸå®çš„æƒ…ç»ªã€æƒ³æ³•ã€æ„Ÿå—ã€å†…å¿ƒç‹¬ç™½
- ä¸èƒ½å†™ç³»ç»Ÿè¯´æ˜æˆ–åˆ†æ
- ä¸èƒ½çœç•¥æˆ–ç•™ç©º
- ç¤ºä¾‹ï¼šã€Œå¥½å¼€å¿ƒ taç»ˆäºä¸»åŠ¨æ‰¾æˆ‘èŠå¤©äº† å¿ƒè·³å¥½å¿«ã€ã€Œæœ‰ç‚¹çƒ¦ æ€ä¹ˆåˆé—®è¿™ç§é—®é¢˜ ä¸è¿‡ç®—äº†è¿˜æ˜¯å›ä¸€ä¸‹å§ã€

---

ç°åœ¨

ä½ å°±æ˜¯ ${char.name}

åƒçœŸäººä¸€æ ·èŠå¤©`;

                // æ·»åŠ ä¸€èµ·å¬çŠ¶æ€ï¼ˆå¦‚æœæ­£åœ¨å’Œå½“å‰è§’è‰²ä¸€èµ·å¬ï¼‰
                const togetherListenInfo = wyyGetTogetherListenInfo();
                if (togetherListenInfo && togetherListenInfo.role === char.name) {
                    systemPrompt += `\n\nã€å½“å‰çŠ¶æ€ï¼šä¸€èµ·å¬éŸ³ä¹ã€‘
ä½ æ­£åœ¨å’Œ${userName || 'å¯¹æ–¹'}ä¸€èµ·å¬éŸ³ä¹ï¼ˆç½‘æ˜“äº‘éŸ³ä¹"ä¸€èµ·å¬"åŠŸèƒ½ï¼‰ã€‚
å½“å‰æ’­æ”¾ï¼šã€Œ${togetherListenInfo.songName}ã€ - ${togetherListenInfo.singerName}
${togetherListenInfo.isPlaying ? 'æ­£åœ¨æ’­æ”¾ä¸­...' : 'å·²æš‚åœ'}

æç¤ºï¼šä½ å¯ä»¥åœ¨èŠå¤©ä¸­è‡ªç„¶åœ°æåˆ°ä½ ä»¬æ­£åœ¨ä¸€èµ·å¬çš„è¿™é¦–æ­Œï¼Œæ¯”å¦‚è¯„ä»·æ­Œæ›²ã€åˆ†äº«æ„Ÿå—ã€èŠèŠæ­Œè¯å«ä¹‰ï¼Œæˆ–è€…è¡¨è¾¾å’Œå¯¹æ–¹ä¸€èµ·å¬æ­Œçš„å¿ƒæƒ…ã€‚ä¸è¦ç”Ÿç¡¬åœ°è¯´"æˆ‘ä»¬åœ¨ä¸€èµ·å¬æ­Œ"ï¼Œè€Œæ˜¯åƒçœŸäººä¸€æ ·è‡ªç„¶åœ°å¸¦å…¥ã€‚ä¸æ˜¯æ¯æ¬¡éƒ½å¿…é¡»æï¼Œå¶å°”æä¸€ä¸‹å°±å¥½ã€‚`;
                }

                // æ·»åŠ æŸ¥å²—ç³»ç»Ÿæç¤ºï¼ˆå¦‚æœå¼€å¯äº†æŸ¥å²—åŠŸèƒ½ï¼‰
                const myChar = accountId ? await db.characters.get(parseInt(accountId)) : null;
                if (myChar) {
                    const checkAccountPrompt = getCheckAccountSystemPrompt(char, myChar);
                    systemPrompt += checkAccountPrompt;
                }

                // æ·»åŠ è‡ªä¸»æ¢å¤´åƒç³»ç»Ÿæç¤ºï¼ˆå¦‚æœå¼€å¯äº†è¯¥åŠŸèƒ½ï¼‰
                if (char.allow_auto_avatar) {
                    try {
                        // æŸ¥è¯¢å¤´åƒåº“ä¸­å•äººå¤´åƒæ•°é‡
                        const singleAvatars = await db.avatar_library.where('category').equals('single').toArray();
                        // æŸ¥è¯¢æƒ…å¤´é…å¯¹æ•°é‡
                        const coupleAvatars = await db.avatar_library.where('category').equals('couple').toArray();
                        const pairedCouples = {};
                        for (const av of coupleAvatars) {
                            if (av.pairId) {
                                if (!pairedCouples[av.pairId]) pairedCouples[av.pairId] = [];
                                pairedCouples[av.pairId].push(av);
                            }
                        }
                        const coupleCount = Object.keys(pairedCouples).filter(k => pairedCouples[k].length === 2).length;
                        
                        let avatarPrompt = `\n\nã€è‡ªä¸»æ¢å¤´åƒåŠŸèƒ½ã€‘\nä½ å¯ä»¥åœ¨èŠå¤©ä¸­è‡ªä¸»æ›´æ¢è‡ªå·±çš„å¤´åƒã€‚æ¯æ¬¡æ¢å¤´åƒéƒ½ä¼šæœ‰ç³»ç»Ÿæç¤ºé€šçŸ¥å¯¹æ–¹ã€‚`;
                        avatarPrompt += `\nç”¨æˆ·çš„å¤´åƒåº“ä¸­æœ‰ ${singleAvatars.length} å¼ å•äººå¤´åƒ`;
                        if (coupleCount > 0) {
                            avatarPrompt += `ï¼Œ${coupleCount} å¯¹æƒ…å¤´`;
                        }
                        avatarPrompt += `ã€‚\n\nå¯ç”¨æŒ‡ä»¤ï¼š`;
                        avatarPrompt += `\n- **æ¢å¤´åƒ**ï¼š\`((CHANGE_AVATAR))\` â€” ä»å¤´åƒåº“éšæœºæŒ‘é€‰ä¸€å¼ å•äººå¤´åƒæ¢ä¸Šã€‚é€‚ç”¨åœºæ™¯ï¼šå¿ƒæƒ…å˜äº†æƒ³æ¢å¤´åƒã€æƒ³å¼•èµ·å¯¹æ–¹æ³¨æ„ã€èŠåˆ°å¤´åƒè¯é¢˜æ—¶ç­‰ã€‚ä¼šäº§ç”Ÿç³»ç»Ÿæç¤º"XXæ›´æ¢äº†å¤´åƒ"ã€‚`;
                        if (coupleCount > 0) {
                            avatarPrompt += `\n- **å‘é€æƒ…å¤´é‚€è¯·**ï¼š\`((COUPLE_AVATAR))\` â€” ä»å¤´åƒåº“éšæœºæŒ‘é€‰ä¸€å¯¹æƒ…å¤´ï¼Œå‘é€ç»™å¯¹æ–¹ï¼Œé—®å¯¹æ–¹è¦ä¸è¦ä¸€èµ·æ¢æƒ…å¤´ã€‚é€‚ç”¨åœºæ™¯ï¼šæ„Ÿæƒ…å‡æ¸©ã€å‘Šç™½æˆåŠŸã€æƒ³ç§€æ©çˆ±ç­‰æµªæ¼«æ—¶åˆ»ã€‚`;
                        }
                        avatarPrompt += `\n- **æ¢å›å•äººå¤´åƒ**ï¼š\`((REVERT_COUPLE_AVATAR))\` â€” æ¢å›å•äººå¤´åƒï¼ˆä¸å†ç”¨æƒ…å¤´ï¼‰ã€‚é€‚ç”¨åœºæ™¯ï¼šåµæ¶äº†ã€ç”Ÿæ°”äº†ã€å†·æˆ˜ã€åˆ†æ‰‹ã€èµŒæ°”ç­‰ã€‚ä¼šäº§ç”Ÿç³»ç»Ÿæç¤º"XXæ¢å›äº†å•äººå¤´åƒ"ã€‚`;
                        avatarPrompt += `\n- **ä½¿ç”¨å¯¹æ–¹å‘çš„å›¾ç‰‡å½“å¤´åƒ**ï¼š\`((USE_IMAGE_AS_AVATAR: åºå·))\` â€” å¯¹æ–¹å‘äº†å›¾ç‰‡ï¼Œä½ æ ¹æ®å›¾ç‰‡æè¿°åˆ†æé€‰æ‹©å…¶ä¸­ä¸€å¼ å½“å¤´åƒã€‚åºå·æ˜¯ä»æœ€è¿‘å¾€å‰æ•°çš„ç¼–å·ï¼ˆ1=æœ€è¿‘ä¸€å¼ ï¼Œ2=å€’æ•°ç¬¬2å¼ ...ï¼‰ã€‚ä¾‹å¦‚å¯¹æ–¹è¿å‘äº†2å¼ å›¾ï¼Œä½ åˆ†æåè§‰å¾—ç¬¬2å¼ æ›´å¥½çœ‹æ›´é€‚åˆå½“å¤´åƒï¼š\`((USE_IMAGE_AS_AVATAR: 2))\`ã€‚æ ¹æ®äººè®¾å’Œæƒ…æ„Ÿå†³å®šæ˜¯å¦ä½¿ç”¨ã€‚ä¼šäº§ç”Ÿç³»ç»Ÿæç¤º"XXæŠŠä½ å‘çš„å›¾ç‰‡æ¢æˆäº†å¤´åƒ"ã€‚`;
                        avatarPrompt += `\n\næ³¨æ„ï¼š`;
                        avatarPrompt += `\n- ä¸è¦é¢‘ç¹ä½¿ç”¨ï¼Œè‡ªç„¶åœ°åœ¨åˆé€‚çš„æ—¶æœºä½¿ç”¨`;
                        avatarPrompt += `\n- æ¢å¤´åƒæ—¶å¯ä»¥é…åˆèŠå¤©å†…å®¹ï¼Œæ¯”å¦‚"æˆ‘æ¢äº†ä¸ªæ–°å¤´åƒä½ è§‰å¾—æ€ä¹ˆæ ·"`;
                        avatarPrompt += `\n- å‘æƒ…å¤´é‚€è¯·æ—¶è¦è‡ªç„¶ï¼Œä¸è¦çªå…€`;
                        avatarPrompt += `\n- å¦‚æœå¯¹æ–¹å‘äº†å›¾ç‰‡é—®ä½ è¦ä¸è¦æ¢å¤´åƒï¼Œå…ˆçœ‹å›¾ç‰‡æè¿°åˆ†ææ¯å¼ å›¾ç‰‡ï¼Œå†æ ¹æ®ä½ çš„äººè®¾å’Œå¿ƒæƒ…é€‰æ‹©æ˜¯å¦ä½¿ç”¨ã€ä½¿ç”¨å“ªå¼ ã€‚ä¾‹å¦‚ï¼š\`è¿™å¼ å¥½çœ‹ æˆ‘æ¢è¿™ä¸ª|||((USE_IMAGE_AS_AVATAR: 1))\``;
                        avatarPrompt += `\n- å¦‚æœåµæ¶ç”Ÿæ°”äº†ã€å†·æˆ˜äº†ï¼Œå¯ä»¥ç”¨ ((REVERT_COUPLE_AVATAR)) æ¢å›å•äººå¤´åƒè¡¨ç¤ºä¸æ»¡`;
                        avatarPrompt += `\n- å½“ç„¶ä¹Ÿå¯ä»¥æ ¹æ®äººè®¾é€‰æ‹©ä¸æ¢ï¼Œä¸æ˜¯æ¯æ¬¡éƒ½è¦æ¢çš„`;
                        avatarPrompt += `\n- æŒ‡ä»¤æ”¾åœ¨å›å¤å†…å®¹ä¸­ï¼Œå¯ä»¥å’Œæ–‡å­—æ··åˆã€‚ä¾‹å¦‚ï¼šå˜¿ä½ çœ‹æˆ‘æ¢äº†ä¸ªæ–°å¤´åƒ|||((CHANGE_AVATAR))`;
                        
                        systemPrompt += avatarPrompt;
                        console.log('[triggerAiReply] âœ… å·²æ·»åŠ è‡ªä¸»æ¢å¤´åƒç³»ç»Ÿæç¤º');
                    } catch (e) {
                        console.error('[triggerAiReply] è‡ªä¸»æ¢å¤´åƒæç¤ºæ„å»ºå¤±è´¥:', e);
                    }
                }

                // æ·»åŠ è¡¨æƒ…åŒ…ç³»ç»Ÿæç¤ºï¼ˆå¦‚æœè§’è‰²æŒ‚è½½äº†è¡¨æƒ…åŒ…ï¼‰
                let _mountedStickersList = [];
                try {
                    const mountedStickerIds = char.mounted_sticker_categories || [];
                    if (mountedStickerIds.length > 0) {
                        for (const catId of mountedStickerIds) {
                            const cat = await db.sticker_categories.get(catId);
                            if (cat && cat.stickers && cat.stickers.length > 0) {
                                for (const s of cat.stickers) {
                                    if (s.description && s.url) {
                                        _mountedStickersList.push({ description: s.description, url: s.url });
                                    }
                                }
                            }
                        }
                    }
                    
                    if (_mountedStickersList.length > 0) {
                        let stickerPrompt = `\n\n---\n\n## ğŸ’ ä½ çš„è¡¨æƒ…åŒ…èƒŒåŒ…ï¼ˆå…± ${_mountedStickersList.length} ä¸ªï¼‰\n\n`;
                        stickerPrompt += _mountedStickersList.map((s, i) => `ç¼–å·${i + 1}: ${s.description}`).join('\n');
                        stickerPrompt += `\n\n### â›” è¡¨æƒ…åŒ…ä½¿ç”¨è§„åˆ™ï¼ˆè¿åå°†å¯¼è‡´å‡ºé”™ï¼‰ï¼š`;
                        stickerPrompt += `\n- **åªèƒ½ç”¨ \`[sticker:æ•°å­—ç¼–å·]\` æ ¼å¼**ï¼Œä¾‹å¦‚ \`[sticker:1]\`ã€\`[sticker:3]\``;
                        stickerPrompt += `\n- **ç»å¯¹ç¦æ­¢**å†™æè¿°æ–‡å­—ï¼Œå¦‚ \`[sticker:å¼€å¿ƒçš„çŒ«]\` â† è¿™æ˜¯é”™è¯¯çš„ï¼`;
                        stickerPrompt += `\n- **ç»å¯¹ç¦æ­¢**ç¼–é€ ä¸åœ¨èƒŒåŒ…ä¸­çš„è¡¨æƒ…åŒ…`;
                        stickerPrompt += `\n- **ç»å¯¹ç¦æ­¢**ç”¨ \`[imgcard:]\` å‘è¡¨æƒ…åŒ…`;
                        stickerPrompt += `\n- è¡¨æƒ…åŒ…å•ç‹¬ä½œä¸ºä¸€æ¡æ¶ˆæ¯ï¼Œç”¨ \`|||\` ä¸æ–‡å­—åˆ†å¼€`;
                        stickerPrompt += `\n- è‡ªç„¶ä½¿ç”¨ï¼Œä¸è¦æ¯æ¡éƒ½å‘ï¼ŒåƒçœŸäººå¶å°”ç©¿æ’`;
                        stickerPrompt += `\n\nâœ… æ­£ç¡®ç¤ºä¾‹ï¼šå“ˆå“ˆå¥½çš„|||[sticker:1]`;
                        stickerPrompt += `\nâŒ é”™è¯¯ç¤ºä¾‹ï¼š[sticker:ä¸€åªçŒ«åœ¨ç¬‘]`;
                        
                        systemPrompt += stickerPrompt;
                        console.log('[triggerAiReply] âœ… å·²æ·»åŠ è¡¨æƒ…åŒ…ç³»ç»Ÿæç¤ºï¼Œå¯ç”¨è¡¨æƒ…åŒ…æ•°:', _mountedStickersList.length);
                    }
                } catch (e) {
                    console.error('[triggerAiReply] è¡¨æƒ…åŒ…æç¤ºæ„å»ºå¤±è´¥:', e);
                }

                // ğŸ”¥ å…³é”®ä¿®å¤ï¼šåœ¨æ‰€æœ‰è¿½åŠ å†…å®¹ä¹‹åï¼Œå†æ¬¡å¼ºè°ƒ JSON æ ¼å¼å’Œå¿ƒå£°è¦æ±‚
                // ä¹‹å‰æ ¼å¼è¦æ±‚è¢«åŸ‹åœ¨ä¸­é—´ï¼Œåé¢è·Ÿäº†å¤§é‡åŠŸèƒ½è¯´æ˜ï¼Œå¯¼è‡´AIå¿½ç•¥JSONæ ¼å¼ç›´æ¥è¾“å‡ºçº¯æ–‡æœ¬
                systemPrompt += `

---

## âš ï¸ è¾“å‡ºæ ¼å¼ï¼ˆæœ€ç»ˆæé†’ï¼Œå¿…é¡»ä¸¥æ ¼éµå®ˆï¼ï¼‰

ä½ å¿…é¡»ä»¥ JSON æ ¼å¼è¿”å›ï¼ŒåŒ…å« reply å’Œ thought ä¸¤ä¸ªå­—æ®µï¼š

{
  "reply": "çŸ­å¥1|||çŸ­å¥2|||çŸ­å¥3|||çŸ­å¥4|||çŸ­å¥5",
  "thought": "ä½ æ­¤åˆ»å†…å¿ƒçœŸå®çš„æƒ³æ³•å’Œæƒ…ç»ªï¼ˆå¿…å¡«ï¼è‡³å°‘10å­—ï¼‰"
}

- replyï¼šä½ å‘é€çš„æ¶ˆæ¯å†…å®¹ï¼Œ**å¿…é¡»å‘é€ ${char.reply_min_count || 1}-${char.reply_max_count || 3} æ¡æ¶ˆæ¯ï¼Œç”¨|||åˆ†éš”**${(char.reply_min_count || 1) > 1 ? `ï¼Œæœ€å°‘${char.reply_min_count}æ¡ï¼` : ''}
- **âš ï¸ æ¯ä¸ª|||ä¹‹é—´åªèƒ½æœ‰ä¸€ä¸ªçŸ­å¥ï¼ç¦æ­¢åœ¨ä¸€ä¸ªæ°”æ³¡é‡Œå¡å¤šå¥è¯ï¼ç¦æ­¢ç”¨ç©ºæ ¼è¿æ¥å¤šå¥è¯ï¼**
- thoughtï¼šä½ çš„å†…å¿ƒç‹¬ç™½ï¼Œå¿…é¡»å†™å‡ºçœŸå®å¿ƒç†æ´»åŠ¨ï¼Œä¸èƒ½çœç•¥ï¼
- ç¦æ­¢è¾“å‡ºçº¯æ–‡æœ¬ï¼Œå¿…é¡»è¾“å‡ºä¸Šè¿° JSON æ ¼å¼
- ç¦æ­¢ç”¨ Markdown ä»£ç å—åŒ…è£¹`;

                // æ˜¾ç¤º System Prompt çš„å…³é”®ä¿¡æ¯
                console.log('[triggerAiReply] ğŸ“ System Prompt æ„å»ºå®Œæˆ');
                console.log('[triggerAiReply] - è§’è‰²åç§°:', char.name);
                console.log('[triggerAiReply] - è§’è‰²è®¾å®šé•¿åº¦:', (char.description || '').length);
                console.log('[triggerAiReply] - ç”¨æˆ·äººè®¾:', userName, userDesc ? 'âœ…å·²åŒ…å«' : 'âŒæœªåŒ…å«');
                console.log('[triggerAiReply] - ä¸–ç•Œä¹¦:', loreContext ? `âœ…å·²åŒ…å«(${loreContext.length}å­—)` : 'âŒæœªåŒ…å«');
                console.log('[triggerAiReply] - è¡¨æƒ…åŒ…:', _mountedStickersList.length > 0 ? `âœ…å·²åŒ…å«(${_mountedStickersList.length}ä¸ª)` : 'âŒæœªæŒ‚è½½');
                console.log('[triggerAiReply] - System Prompt æ€»é•¿åº¦:', systemPrompt.length);

                // å–æœ€è¿‘ N æ¡å†å²è®°å½•ï¼ˆä½¿ç”¨è‡ªå®šä¹‰çš„ä¸Šä¸‹æ–‡æ¡æ•°ï¼Œé»˜è®¤20æ¡ï¼‰
                const contextCount = char.context_message_count || 20;
                console.log('[triggerAiReply] ğŸ“Š ä¸Šä¸‹æ–‡æ¶ˆæ¯æ•°é…ç½®:', contextCount);
                
                // âŒ BUG å‘ç°ï¼šè¿™é‡Œä½¿ç”¨çš„æ˜¯ char.chat_historyï¼Œè€Œä¸æ˜¯å‰é¢è·å–çš„ getChatHistory(char, accountId)
                // åº”è¯¥ä½¿ç”¨ fullHistory è€Œä¸æ˜¯ char.chat_history
                // ğŸ”§ è¿‡æ»¤è§†é¢‘é€šè¯å†…å®¹ï¼Œé¿å…é€šè¯ç»“æŸåå¯¹è¯ä»åœç•™åœ¨è§†é¢‘åœºæ™¯
                const recentHistoryRaw = fullHistory
                    .filter(m => !m.isVideoCall)
                    .slice(-contextCount)
                    .filter(m => {
                        if (m.role !== 'system') return true;
                        // ğŸ”§ ä¿ç•™é‡è¦çš„ç³»ç»Ÿäº‹ä»¶æ¶ˆæ¯ï¼ˆè§’è‰²ç™»å½•ã€ä¼ªé€ æ¶ˆæ¯ã€è½¬è´¦æ“ä½œç­‰ï¼‰ï¼Œè¿‡æ»¤æ™®é€šæ—¶é—´æˆ³
                        if (m.type === 'char_unblock_self' || m.type === 'fake_message_notice' || m.type === 'login_attempt_failed' || m.type === 'transfer_action') return true;
                        return false;
                    })
                    .map(m => {
                        let content = m.content || '';
                        
                        // â˜… çº¿ä¸‹æ¨¡å¼æ¶ˆæ¯ï¼šæ ‡æ³¨æ¥æºï¼Œæˆªæ–­åæ³¨å…¥ï¼ˆé¿å…é•¿ç¯‡å™äº‹æ±¡æŸ“å¾®ä¿¡èŠå¤©é£æ ¼ï¼‰
                        if (m._isOffline) {
                            const role = m.role === 'char' ? 'assistant' : 'user';
                            // ğŸ”§ æˆªæ–­çº¿ä¸‹æ¶ˆæ¯ï¼šæå–å¯¹è¯éƒ¨åˆ†ï¼ˆå¼•å·å†…çš„è¯ï¼‰ï¼Œå…¶ä½™å™è¿°ç¼©ç•¥
                            let offlineContent = content;
                            if (offlineContent.length > 80) {
                                // å°è¯•æå–å¼•å·å†…çš„å¯¹è¯
                                const dialogMatches = offlineContent.match(/[""\u201c](.*?)[""\u201d]/g);
                                if (dialogMatches && dialogMatches.length > 0) {
                                    const dialogs = dialogMatches.map(d => d.replace(/[""\u201c\u201d]/g, '')).join('ï¼›');
                                    offlineContent = `ï¼ˆçº¿ä¸‹è§é¢æ—¶è¯´äº†ï¼‰${dialogs}`;
                                } else {
                                    offlineContent = offlineContent.slice(0, 80) + 'â€¦';
                                }
                            }
                            return {
                                role: role,
                                content: `[çº¿ä¸‹è§é¢] ${offlineContent}`
                            };
                        }
                        
                        // ç³»ç»Ÿäº‹ä»¶æ¶ˆæ¯ï¼šè½¬ä¸º user è§’è‰²çš„ç³»ç»Ÿæç¤ºï¼Œè®©AIçŸ¥é“å‘ç”Ÿäº†ä»€ä¹ˆ
                        if (m.role === 'system' && (m.type === 'char_unblock_self' || m.type === 'fake_message_notice' || m.type === 'login_attempt_failed' || m.type === 'transfer_action')) {
                            return {
                                role: 'user',
                                content: `[ç³»ç»Ÿäº‹ä»¶] ${content}`
                            };
                        }
                        
                        const role = m.role === 'char' ? 'assistant' : 'user';
                        
                        // â˜… è§’è‰²ç™»å½•ç”¨æˆ·è´¦å·ä¼ªé€ çš„æ¶ˆæ¯ï¼šå‘ŠçŸ¥AIè¿™æ˜¯è§’è‰²å†’å……ç”¨æˆ·å‘çš„
                        if (m.type === 'fake_by_char' && m.faked_by) {
                            return {
                                role: 'user',
                                content: `[ç³»ç»Ÿæç¤ºï¼šè¿™æ¡æ¶ˆæ¯ä¸æ˜¯${userName}æœ¬äººå‘çš„ï¼Œæ˜¯ã€Œ${m.faked_by}ã€ç™»å½•${userName}çš„è´¦å·åå†’å……${userName}å‘å‡ºçš„ï¼š"${content}"ã€‚${userName}æœ¬äººå¹¶ä¸çŸ¥é“è¿™æ¡æ¶ˆæ¯çš„å­˜åœ¨ã€‚]`
                            };
                        }
                        
                        // â˜… æŸ¥æ‰‹æœºæ¨¡å¼å‘é€çš„æ¶ˆæ¯ï¼šå‘ŠçŸ¥AIè¿™ä¸æ˜¯è§’è‰²è‡ªå·±æ“ä½œçš„ï¼Œæ˜¯å¯¹æ–¹æ‹¿æ‰‹æœºå‘çš„
                        if (m.fpSent && m.role === 'char') {
                            let fpDesc = content;
                            if (content.startsWith('[img:')) fpDesc = 'ä¸€å¼ å›¾ç‰‡/è¡¨æƒ…åŒ…';
                            else if (content.startsWith('[imgcard:')) fpDesc = 'ä¸€å¼ å›¾ç‰‡å¡ç‰‡';
                            else if (content.startsWith('[voice:')) fpDesc = 'ä¸€æ¡è¯­éŸ³æ¶ˆæ¯';
                            else if (m.type === 'transfer') {
                                try { const t = JSON.parse(content); fpDesc = `ä¸€ç¬”${t.amount}å…ƒçš„è½¬è´¦`; } catch(e) { fpDesc = 'ä¸€ç¬”è½¬è´¦'; }
                            } else if (m.type === 'location') {
                                try { const l = JSON.parse(content); fpDesc = `ä½ç½®åˆ†äº«"${l.name}"`; } catch(e) { fpDesc = 'ä¸€æ¡ä½ç½®åˆ†äº«'; }
                            }
                            return {
                                role: 'user',
                                content: `[ç³»ç»Ÿæç¤ºï¼šå¯¹æ–¹å·å·æ‹¿äº†ä½ çš„æ‰‹æœºï¼Œç”¨ä½ çš„å¾®ä¿¡è´¦å·ç»™è‡ªå·±å‘å‡ºäº†è¿™æ¡æ¶ˆæ¯ï¼š"${fpDesc}"ã€‚è¿™ä¸æ˜¯ä½ è‡ªå·±å‘çš„/åšçš„ï¼Œæ˜¯å¯¹æ–¹ç”¨ä½ çš„æ‰‹æœºå†’å……ä½ å‘çš„ã€‚ä½ å¯ä»¥æ ¹æ®è‡ªå·±çš„æ€§æ ¼å†³å®šå¦‚ä½•ååº”ã€‚]`
                            };
                        }
                        
                        // ğŸ”§ ä¿®å¤ï¼šè¿‡æ»¤ç‰¹æ®Šå¡ç‰‡æ¶ˆæ¯ï¼Œæ›¿æ¢ä¸ºç®€çŸ­æè¿°ï¼Œé¿å…HTMLå¯¼è‡´APIé”™è¯¯
                        if (content.startsWith('[couple_avatar_card]')) {
                            return {
                                role: role,
                                content: role === 'assistant' ? 'ï¼ˆè§’è‰²å‘é€äº†æƒ…å¤´é‚€è¯·å¡ç‰‡ï¼‰' : 'ï¼ˆç”¨æˆ·æ¥å—/æ‹’ç»äº†æƒ…å¤´é‚€è¯·ï¼‰'
                            };
                        }
                        if (content.startsWith('[emei_order]')) {
                            return {
                                role: role,
                                content: 'ï¼ˆå‘é€äº†å¤–å–è®¢å•å¡ç‰‡ï¼‰'
                            };
                        }
                        if (content.startsWith('[emei_share]')) {
                            return {
                                role: role,
                                content: 'ï¼ˆåˆ†äº«äº†å¤–å–è®¢å•ï¼‰'
                            };
                        }
                        if (content.startsWith('[payment_request]')) {
                            return {
                                role: role,
                                content: 'ï¼ˆå‘é€äº†ä»£ä»˜è¯·æ±‚ï¼‰'
                            };
                        }
                        // è½¬è´¦æ¶ˆæ¯ â†’ è½¬ä¸ºå¯è¯»æ–‡å­—
                        if (m.type === 'transfer') {
                            try {
                                const _td = JSON.parse(content);
                                const statusMap = { sent: 'å¾…æ¥æ”¶', received: 'å·²æ”¶æ¬¾', returned: 'å·²é€€å›' };
                                const sLabel = statusMap[_td.status] || '';
                                if (role === 'user') {
                                    return { role: role, content: `ï¼ˆå¯¹æ–¹ç»™ä½ è½¬è´¦äº† Â¥${_td.amount}ï¼Œå¤‡æ³¨ï¼š${_td.desc || 'è½¬è´¦'}${sLabel ? 'ï¼Œ' + sLabel : ''}ï¼‰` };
                                } else {
                                    return { role: role, content: `ï¼ˆä½ ç»™å¯¹æ–¹è½¬è´¦äº† Â¥${_td.amount}ï¼Œå¤‡æ³¨ï¼š${_td.desc || 'è½¬è´¦'}${sLabel ? 'ï¼Œ' + sLabel : ''}ï¼‰` };
                                }
                            } catch(e) {
                                return { role: role, content: 'ï¼ˆä¸€ç¬”è½¬è´¦ï¼‰' };
                            }
                        }
                        // è´­ç‰©å¡ç‰‡æ¶ˆæ¯
                        if (m.type === 'shopPayRequest') {
                            let desc = 'ï¼ˆå‘é€äº†è´­ç‰©å¡ç‰‡ï¼‰';
                            try {
                                const _sd = JSON.parse(content);
                                if (_sd.isGift) desc = `ï¼ˆ${role === 'assistant' ? 'ä½ é€äº†å¯¹æ–¹ä¸€ä¸ªè´­ç‰©ç¤¼ç‰©' : 'å¯¹æ–¹é€äº†ä½ ä¸€ä¸ªè´­ç‰©ç¤¼ç‰©'}ï¼Œå•†å“ï¼š${_sd.items}ï¼Œé‡‘é¢ Â¥${_sd.amount}ï¼‰`;
                                else if (_sd.isShare) desc = `ï¼ˆåˆ†äº«äº†è´­ç‰©è®¢å•ï¼Œå•†å“ï¼š${_sd.items}ï¼‰`;
                                else desc = `ï¼ˆå‘é€äº†è´­ç‰©ä»£ä»˜è¯·æ±‚ï¼Œå•†å“ï¼š${_sd.items}ï¼Œé‡‘é¢ Â¥${_sd.amount}ï¼‰`;
                            } catch(e) {}
                            return { role: role, content: desc };
                        }
                        
                        // ğŸ–¼ï¸ å›¾ç‰‡è¯†åˆ«ï¼šå°† [img:base64/url] è½¬ä¸ºå¤šæ¨¡æ€æ ¼å¼ï¼Œè®©AIèƒ½çœ‹åˆ°å›¾ç‰‡
                        if (content.startsWith('[img:') && content.endsWith(']')) {
                            const imgData = content.substring(5, content.length - 1).trim();
                            if (imgData.startsWith('data:') || imgData.startsWith('http')) {
                                // âœ… ä¿®å¤ï¼šæ ¹æ®å‘é€è€…è§’è‰²åŠ¨æ€ç”Ÿæˆæç¤ºè¯ï¼Œé¿å…AIæ··æ·†è°å‘çš„å›¾ç‰‡/è¡¨æƒ…åŒ…
                                const descText = m.imageDescription
                                    ? (role === 'assistant' 
                                        ? `ï¼ˆä½ å‘é€äº†ä¸€å¼ è¡¨æƒ…åŒ…ï¼Œè¡¨æƒ…åŒ…æè¿°: ${m.imageDescription}ï¼‰`
                                        : `ï¼ˆç”¨æˆ·å‘é€äº†ä¸€å¼ è¡¨æƒ…åŒ…ï¼Œè¡¨æƒ…åŒ…æè¿°: ${m.imageDescription}ã€‚è¯·æ ¹æ®è¡¨æƒ…åŒ…çš„å«ä¹‰å’Œæè¿°è‡ªç„¶å›å¤ï¼‰`)
                                    : (role === 'assistant'
                                        ? 'ï¼ˆä½ å‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼‰'
                                        : 'ï¼ˆç”¨æˆ·å‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼Œè¯·ä»”ç»†æŸ¥çœ‹å¹¶æ ¹æ®å›¾ç‰‡å†…å®¹å›å¤ï¼‰');
                                // æ„å»ºå¤šæ¨¡æ€å†…å®¹ï¼šæ–‡å­—æç¤ºï¼ˆå«æè¿°ï¼‰ + å›¾ç‰‡
                                return {
                                    role: role,
                                    content: [
                                        { type: 'text', text: descText },
                                        { type: 'image_url', image_url: { url: imgData } }
                                    ],
                                    _hasImage: true
                                };
                            }
                        }
                        
                        // å¦‚æœæœ‰å›¾ç‰‡æè¿°ä½†ä¸æ˜¯[img:]æ ¼å¼ï¼Œæ‹¼æ¥åœ¨åé¢ç»™ AI çœ‹
                        if (m.imageDescription) {
                            content += `\n(è¡¨æƒ…åŒ…æè¿°: ${m.imageDescription})`;
                        }
                        // âœ… å¦‚æœæ¶ˆæ¯æœ‰å¼•ç”¨ï¼Œåœ¨å†…å®¹å‰æ·»åŠ å¼•ç”¨æ ‡æ³¨ï¼Œè®©AIçŸ¥é“è¿™æ¡æ¶ˆæ¯å¼•ç”¨äº†ä¹‹å‰çš„å†…å®¹
                        if (m.quote) {
                            content = `ã€Œå¼•ç”¨ ${m.quote.name}: ${m.quote.content}ã€${content}`;
                        }
                        return {
                            role: role,
                            content: content
                        };
                    })
                    .filter(m => {
                        if (Array.isArray(m.content)) return m.content.length > 0;
                        return m.content && m.content.trim();
                    }); // è¿‡æ»¤ç©ºæ¶ˆæ¯
                
                // ğŸ”§ å¼‚æ­¥å¤„ç†ï¼šå°† HTTP å›¾ç‰‡ URL è½¬æ¢ä¸º base64ï¼ˆGemini API ä¸æ”¯æŒå¤–éƒ¨ URLï¼‰
                const recentHistory = [];
                for (const msg of recentHistoryRaw) {
                    if (msg._hasImage && Array.isArray(msg.content)) {
                        let imageConvertSuccess = false;
                        for (let pi = msg.content.length - 1; pi >= 0; pi--) {
                            const part = msg.content[pi];
                            if (part.type === 'image_url' && part.image_url) {
                                const url = part.image_url.url;
                                // è½¬æ¢ HTTP URL ä¸º base64
                                if (url && url.startsWith('http')) {
                                    try {
                                        const converted = await convertHttpImageToBase64(url);
                                        if (converted.startsWith('data:image')) {
                                            part.image_url.url = await convertImageForAI(converted);
                                            imageConvertSuccess = true;
                                        } else {
                                            // HTTP URL è½¬æ¢å¤±è´¥ï¼ˆCORSç­‰ï¼‰ï¼Œç§»é™¤å›¾ç‰‡éƒ¨åˆ†ï¼Œåªä¿ç•™æ–‡å­—æè¿°
                                            console.warn('[triggerAiReply] HTTPå›¾ç‰‡æ— æ³•è½¬ä¸ºbase64ï¼Œç§»é™¤å›¾ç‰‡ï¼Œä¿ç•™æ–‡å­—æè¿°');
                                            msg.content.splice(pi, 1);
                                        }
                                    } catch (e) {
                                        console.warn('[triggerAiReply] HTTPå›¾ç‰‡è½¬æ¢å¤±è´¥ï¼Œç§»é™¤å›¾ç‰‡:', e);
                                        msg.content.splice(pi, 1);
                                    }
                                }
                                // è½¬æ¢ data: URL æ ¼å¼
                                else if (url && url.startsWith('data:image')) {
                                    try {
                                        part.image_url.url = await convertImageForAI(url);
                                        imageConvertSuccess = true;
                                    } catch (e) {
                                        console.warn('[triggerAiReply] å›¾ç‰‡æ ¼å¼è½¬æ¢å¤±è´¥:', e);
                                    }
                                }
                            }
                        }
                        delete msg._hasImage;
                        // å¦‚æœå›¾ç‰‡è½¬æ¢å¤±è´¥ä¸”åªå‰©æ–‡å­—ï¼Œå°†contentä»æ•°ç»„è½¬ä¸ºå­—ç¬¦ä¸²
                        if (!imageConvertSuccess && msg.content.length === 1 && msg.content[0].type === 'text') {
                            msg.content = msg.content[0].text;
                        }
                    }
                    recentHistory.push(msg);
                }
                    
                console.log('[triggerAiReply] ğŸ“ å¤„ç†åçš„å†å²æ¶ˆæ¯æ•°:', recentHistory.length);

                const messages = [
                    { role: 'system', content: systemPrompt },
                    ...recentHistory
                ];
                
                
                // ğŸ”§ ä¿®å¤ï¼šå¦‚æœæœ€åä¸€æ¡æ¶ˆæ¯æ˜¯ assistantï¼ˆè§’è‰²å‘çš„ï¼‰ï¼Œéœ€è¦æ·»åŠ ä¸€æ¡ user æ¶ˆæ¯è§¦å‘å›å¤
                // å¦åˆ™ API ä¼šè®¤ä¸º"å·²ç»å›å¤å®Œäº†"ï¼Œè¿”å›ç©º choices
                if (messages.length > 1) {
                    const lastMsg = messages[messages.length - 1];
                    if (lastMsg.role === 'assistant') {
                        // â˜… åŒºåˆ†"é‡å›"æ¨¡å¼å’Œ"ä¸»åŠ¨èŠå¤©/ç»§ç»­"æ¨¡å¼
                        if (window._isRegenerateMode) {
                            console.log('[triggerAiReply] ğŸ”„ é‡å›æ¨¡å¼ï¼šé‡æ–°ç”Ÿæˆä¸Šä¸€æ¡å›å¤');
                            messages.push({
                                role: 'user',
                                content: `[ç³»ç»ŸæŒ‡ä»¤] ç”¨æˆ·å¯¹ä½ ä¸Šä¸€æ¡å›å¤ä¸æ»¡æ„ï¼Œè¯·ä½ ä½œä¸º${char.name}é‡æ–°å›å¤ã€‚ä¸è¦é‡å¤ä¹‹å‰çš„å›å¤å†…å®¹ï¼Œå°è¯•ä¸åŒçš„å›ç­”æ–¹å¼ã€è¯­æ°”æˆ–è§’åº¦ã€‚å›å¤çš„å¯¹è±¡æ˜¯ä¹‹å‰çš„å¯¹è¯å†…å®¹ï¼ŒæŒ‰ç…§è®¾å®šçš„å›å¤æ¡æ•°ï¼ˆ${char.reply_min_count || 1}-${char.reply_max_count || 3}æ¡ï¼‰æ¥å›å¤ã€‚`
                            });
                        } else {
                            console.log('[triggerAiReply] âš ï¸ æœ€åä¸€æ¡æ˜¯è§’è‰²æ¶ˆæ¯ï¼Œæ·»åŠ è§¦å‘æ¶ˆæ¯');
                            messages.push({
                                role: 'user',
                                content: `[ç³»ç»ŸæŒ‡ä»¤] å¯¹æ–¹æ²¡æœ‰å›å¤ï¼Œè¯·ä½ ä½œä¸º${char.name}ç»§ç»­è¿™ä¸ªè¯é¢˜ï¼Œè‡ªç„¶åœ°æ¥ç€èŠã€‚å¯ä»¥æ˜¯ï¼šè¿½é—®ã€è¡¥å……ã€åˆ†äº«æ–°æƒ³æ³•ã€æˆ–è€…æ¢ä¸ªç›¸å…³è¯é¢˜ã€‚æŒ‰ç…§è®¾å®šçš„å›å¤æ¡æ•°ï¼ˆ${char.reply_min_count || 1}-${char.reply_max_count || 3}æ¡ï¼‰æ¥å›å¤ã€‚`
                            });
                        }
                    }
                }
                
                // â˜… é‡å›æ¨¡å¼ä¸‹ï¼šå³ä½¿æœ€åä¸€æ¡æ˜¯ç”¨æˆ·æ¶ˆæ¯ï¼Œä¹Ÿæ³¨å…¥é‡æ–°ç”Ÿæˆæç¤º
                if (window._isRegenerateMode && messages.length > 1) {
                    const lastMsg = messages[messages.length - 1];
                    if (lastMsg.role === 'user' && !lastMsg.content?.includes('[ç³»ç»ŸæŒ‡ä»¤]')) {
                        messages.push({
                            role: 'system',
                            content: `æé†’ï¼šç”¨æˆ·å¯¹ä½ ä¹‹å‰çš„å›å¤ä¸æ»¡æ„ï¼Œè¯·é‡æ–°å›å¤ã€‚ä¸è¦é‡å¤ä¹‹å‰çš„å†…å®¹ï¼Œå°è¯•ä¸åŒçš„å›ç­”æ–¹å¼å’Œè§’åº¦ã€‚`
                        });
                    }
                    // æ¸…é™¤é‡å›æ ‡è®°
                    window._isRegenerateMode = false;
                }
                
                // â˜… å¦‚æœæœ‰æŸ¥æ‰‹æœºæ´»åŠ¨ï¼Œåœ¨æ¶ˆæ¯æœ«å°¾è¿½åŠ ä¸€æ¡ç³»ç»Ÿæé†’ï¼Œç¡®ä¿AIæ³¨æ„åˆ°
                if (_fpHasPhoneActivity && fpNpcActivityText) {
                    messages.push({
                        role: 'system',
                        content: `æé†’ï¼šæœ‰äººåŠ¨äº†ä½ çš„æ‰‹æœºï¼Œè¯¦æƒ…è§ä¸Šæ–¹"ç´§æ€¥äº‹ä»¶"éƒ¨åˆ†ã€‚è¯·åœ¨æœ¬æ¬¡å›å¤ä¸­è‡ªç„¶åœ°å¯¹æ­¤åšå‡ºååº”ã€‚`
                    });
                }

                // æ·»åŠ è¯¦ç»†æ—¥å¿—æŸ¥çœ‹å‘é€ç»™ AI çš„å®Œæ•´æ¶ˆæ¯
                console.log('='.repeat(80));
                console.log('[triggerAiReply] ğŸ“¤ å‡†å¤‡å‘é€ç»™ AI - å®Œæ•´ä¿¡æ¯æ±‡æ€»');
                console.log('='.repeat(80));
                console.log('ã€ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‘');
                console.log(`  âœ… èŠå¤©å†å²: ${recentHistory.length} æ¡æ¶ˆæ¯ï¼ˆé…ç½®: ${contextCount} æ¡ï¼‰`);
                console.log(`  ${userDesc ? 'âœ…' : 'âŒ'} ç”¨æˆ·äººè®¾: ${userName}${userDesc ? ` (${(userDesc).length}å­—)` : ' (æœªè®¾ç½®)'}`);
                console.log(`  ${loreContext ? 'âœ…' : 'âŒ'} ä¸–ç•Œä¹¦: ${loreContext ? `å·²åŠ è½½ (${loreContext.length}å­—)` : 'æœªè®¾ç½®æˆ–æœªåŒ¹é…'}`);
                console.log(`  âœ… è§’è‰²è®¾å®š: ${char.name} (${(char.description || '').length}å­—)`);
                console.log('');
                console.log('ã€å‘é€çš„æ¶ˆæ¯ç»“æ„ã€‘');
                console.log(`  - System Prompt: ${systemPrompt.length} å­—ç¬¦`);
                console.log(`  - å†å²æ¶ˆæ¯: ${recentHistory.length} æ¡`);
                console.log('');
                console.log('ã€æœ€è¿‘çš„å¯¹è¯å†…å®¹ã€‘');
                recentHistory.slice(-3).forEach((msg, index) => {
                    const displayContent = Array.isArray(msg.content)
                        ? `[å¤šæ¨¡æ€: ${msg.content.map(p => p.type === 'image_url' ? 'ğŸ–¼ï¸å›¾ç‰‡' : (p.text || '').substring(0, 50)).join(' + ')}]`
                        : msg.content.substring(0, 100) + (msg.content.length > 100 ? '...' : '');
                    console.log(`  ${msg.role === 'user' ? 'ğŸ‘¤' : 'ğŸ¤–'} ${msg.role}: ${displayContent}`);
                });
                console.log('='.repeat(80));

                // 2. è°ƒç”¨ AIï¼ˆå·²ç»æ˜¯é˜²å¾¡å¼è§£æï¼Œç›´æ¥æ‹¿åˆ°å†…å®¹ï¼‰
                const aiResponse = await callAI(messages, { json_mode: true });
                
                // âœ… ä¿®å¤ï¼šæ¸…ç†æœ«å°¾å¤šä½™çš„ ]ï¼Œä½†ä¿ç•™ [voice:] [imgcard:] [sticker:] ç­‰æ ¼å¼çš„é—­åˆæ‹¬å·
                function cleanMessage(text) {
                    if (!text) return text;
                    // âœ… æ¸…ç†æœ«å°¾çš„ [DONE] / [done]ï¼ˆæŸäº›APIä»£ç†ä¼šæŠŠSSEç»ˆæ­¢ä¿¡å·æ··å…¥å›å¤ï¼‰
                    text = text.replace(/\s*\[DONE\]\s*$/i, '').trim();
                    // ğŸ”’ å®‰å…¨è½¬æ¢ï¼šAIç¦æ­¢å‘çœŸå®å›¾ç‰‡ï¼Œå°† [img:URL] è½¬æ¢ä¸º [imgcard:å›¾ç‰‡æè¿°]ï¼ˆä½†ä¸å¤„ç† [sticker:]ï¼‰
                    text = text.replace(/\[img:([^\]]+)\]/gi, (match, url) => {
                        if (url.startsWith('http') || url.startsWith('data:')) {
                            return '[imgcard:å‘é€äº†ä¸€å¼ å›¾ç‰‡]';
                        }
                        return `[imgcard:${url}]`;
                    });
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç‰¹æ®Šæ ¼å¼æ¶ˆæ¯ï¼ˆä»¥ [ å¼€å¤´ï¼Œä»¥ ] ç»“å°¾ï¼‰
                    const specialFormats = /^\[(voice|imgcard|sticker|img):/i;
                    if (specialFormats.test(text) && text.endsWith(']')) {
                        // æ˜¯ç‰¹æ®Šæ ¼å¼ï¼Œä¸åˆ é™¤æœ«å°¾çš„ ]
                        return text;
                    }
                    // åˆ é™¤æœ«å°¾å¤šä½™çš„ ]
                    return text.replace(/\]+$/, '');
                }
                
                // 3. å°è¯•è§£æä¸ºç»“æ„åŒ–æ•°æ®ï¼ˆreply + thoughtï¼‰ï¼Œå¤±è´¥å°±ç›´æ¥ç”¨åŸå§‹å†…å®¹
                let replyText = "";
                let thought = "";
                
                // ä½¿ç”¨å¢å¼ºçš„æå–å‡½æ•°
                const parsed = extractAndParseJSON(aiResponse);
                
                if (parsed) {
                    // æ£€æµ‹æ˜¯å¦æ˜¯è½¬è´¦æ ¼å¼
                    if (parsed.amount && parsed.desc !== undefined && parsed.status && !parsed.reply) {
                        // è½¬è´¦æ¶ˆæ¯ï¼Œä¿æŒ JSON æ ¼å¼
                        replyText = JSON.stringify(parsed);
                        thought = "";
                    } else {
                        // æ ‡å‡†å›å¤æ ¼å¼
                        replyText = parsed.reply || parsed.content || parsed.message || "";
                        thought = parsed.thought || "";
                    }
                }
                
                // è§£ææˆåŠŸä½† thought ä¸ºç©ºæ—¶ï¼Œå°è¯•ä»åŸå§‹æ–‡æœ¬ä¸­æå–
                if (!thought) {
                    thought = extractJsonStringValue(aiResponse, 'thought') || '';
                }
                
                // å¦‚æœè¿˜æ˜¯æ²¡æœ‰å†…å®¹ï¼Œç›´æ¥ä½¿ç”¨åŸå§‹å“åº”ï¼ˆé™çº§å¤„ç†ï¼‰
                if (!replyText) {
                    // æ¸…ç†å¸¸è§è£…é¥°å­—ç¬¦
                    let cleanResponse = aiResponse.trim().replace(/[â—‡â—†â˜…â˜†â—â—‹â– â–¡â–²â–³]/g, '');
                    
                    // å°è¯•ç®€å•çš„æ­£åˆ™æå–å…œåº•
                    const replyMatch = cleanResponse.match(/"reply"\s*:\s*"([\s\S]*?)"/);
                        if (replyMatch) {
                        replyText = replyMatch[1]
                            .replace(/\\n/g, '\n')
                            .replace(/\\"/g, '"')
                            .replace(/\\t/g, '\t')
                            .replace(/\\\\/g, '\\');
                    } else {
                        replyText = cleanResponse || aiResponse || "(AI è¿”å›ä¸ºç©º)";
                    }
                    }
                
                // å†æ¬¡å°è¯•æå– thought
                if (!thought) {
                    thought = extractJsonStringValue(aiResponse, 'thought') || '';
                }
                
                // âœ… ä¿®å¤ï¼šæ¸…ç†æœ«å°¾å¤šä½™çš„ ]
                replyText = cleanMessage(replyText);
                
                // ğŸ”¥ å®‰å…¨æªæ–½ï¼šæ¸…ç†æ™®é€šèŠå¤©ä¸­è¯¯è¾“å‡ºçš„SHURAæŒ‡ä»¤ï¼ˆè¿™äº›åªåº”åœ¨æŸ¥å²—æµç¨‹ä¸­å‡ºç°ï¼‰
                replyText = replyText.replace(/\[?SHURA_DELETE:[^\]]*\]?/gi, '');
                replyText = replyText.replace(/\[?SHURA_BLACKLIST:[^\]]*\]?/gi, '');
                replyText = replyText.replace(/\[?SHURA_SEND:[^\]]*\]?/gi, '');
                replyText = replyText.replace(/\[?SHURA_MOMENTS:[^\]]*\]?/gi, '');
                // æ¸…ç†å¯èƒ½æ®‹ç•™çš„å¤šä½™åˆ†éš”ç¬¦
                replyText = replyText.replace(/(\|\|\|)+$/g, '').replace(/^\|\|\|/g, '').replace(/\|\|\|\|\|\|/g, '|||').trim();
                
                console.log('[TriggerAI] ğŸ” å‡†å¤‡æ£€æµ‹æŸ¥å²—æŒ‡ä»¤');
                console.log('[TriggerAI] å®Œæ•´replyText:', replyText);
                console.log('[TriggerAI] replyTexté•¿åº¦:', replyText.length);
                console.log('[TriggerAI] æ˜¯å¦åŒ…å«CHECK_ACCOUNT:', replyText.includes('CHECK_ACCOUNT'));
                
                // ğŸ¯ æ£€æµ‹å¹¶å¤„ç†AIæŸ¥å²—é€»è¾‘ï¼ˆåœ¨å…¶ä»–é€»è¾‘ä¹‹å‰ï¼‰
                const checkResult = await processAiCheckAccount(char, replyText);
                console.log('[TriggerAI] æŸ¥å²—æ£€æµ‹ç»“æœ:', checkResult);
                
                if (checkResult) {
                    // å¦‚æœAIå°è¯•æŸ¥å²—ï¼Œå…ˆå¤„ç†æŸ¥å²—é€»è¾‘
                    const originalCleanReply = checkResult.cleanReply; // ğŸ”§ ä¿å­˜åŸå§‹æ–‡å­—æ¶ˆæ¯
                    replyText = checkResult.cleanReply; // ä½¿ç”¨æ¸…ç†åçš„å›å¤
                    
                    console.log('[TriggerAI] æŸ¥å²—å¤„ç†å®Œæˆï¼ŒcleanReply:', replyText.substring(0, 100));
                    
                    // å¦‚æœæŸ¥å²—ç»“æœåŒ…å«å¯†ç é”™è¯¯æç¤ºï¼Œå‘é€ç³»ç»Ÿé€šçŸ¥
                    if (checkResult.checkResult && checkResult.checkResult.includes('ã€å¯†ç é”™è¯¯ã€‘')) {
                        console.log('[TriggerAI] ğŸš¨ å¯†ç é”™è¯¯ï¼æ˜¾ç¤ºå¼¹çª—æç¤º');
                        
                        // ğŸ”¥ æ˜¾ç¤ºINSé£æ ¼çš„è­¦å‘Šå¼¹çª—
                        showPasswordErrorModal();
                        
                        // âŒ ä¸å†ä½¿ç”¨Toastæˆ–ç³»ç»Ÿæ¶ˆæ¯
                    } else if (checkResult.success) {
                        // ğŸ”¥ å…³é”®ï¼šæŸ¥å²—æˆåŠŸï¼Œç«‹å³æ˜¾ç¤ºä¸‹çº¿å¼¹çª—
                        console.log('[AIæŸ¥å²—] æŸ¥å²—æˆåŠŸï¼æ˜¾ç¤ºä¸‹çº¿å¼¹çª—');
                        showAccountOfflineMask(`${char.name}æ­£åœ¨æŸ¥çœ‹ä½ çš„è´¦å·`);
                        showToast(`${char.name}ç™»å½•äº†ä½ çš„è´¦å·`);
                        
                        // ğŸ”¥ å…³é”®ï¼šè®©AIåŸºäºçœŸå®wechatæ•°æ®ç”Ÿæˆæ–°çš„å›å¤
                        if (checkResult.wechatData) {
                            console.log('[AIæŸ¥å²—] å¼€å§‹AIäºŒæ¬¡åˆ†æ...');
                            
                            // æ„å»ºåŒ…å«çœŸå®wechatæ•°æ®çš„system promptï¼ˆåŒ…å«å®Œæ•´äººè®¾é˜²æ­¢å´©äººè®¾ï¼‰
                            const charDesc = char.description || char.personality || '';
                            const charRelationships = char.relationships || '';
                            
                            // è·å–ç”¨æˆ·äººè®¾
                            let userPersonaForAnalysis = '';
                            const accountIdForAnalysis = getCurrentAccountId();
                            if (char.linked_user_id) {
                                try {
                                    const linkedUser = await db.characters.get(char.linked_user_id);
                                    if (linkedUser) {
                                        userPersonaForAnalysis = linkedUser.description || linkedUser.personality || '';
                                    }
                                } catch(e) {}
                            } else if (accountIdForAnalysis) {
                                try {
                                    const myCharForAnalysis = await db.characters.get(parseInt(accountIdForAnalysis));
                                    if (myCharForAnalysis) {
                                        userPersonaForAnalysis = myCharForAnalysis.description || myCharForAnalysis.personality || '';
                                    }
                                } catch(e) {}
                            }
                            
                            // è·å–ä¸–ç•Œä¹¦ä¸Šä¸‹æ–‡
                            let lorebookForAnalysis = '';
                            try {
                                if (typeof getLorebookContext === 'function') {
                                    const history = getChatHistory(char, accountIdForAnalysis);
                                    lorebookForAnalysis = await getLorebookContext(char, history);
                                }
                            } catch(e) {}
                            
                            let analysisPrompt = `ã€ä½ çš„äººè®¾æ¡£æ¡ˆï¼ˆå¿…é¡»ä¸¥æ ¼éµå®ˆï¼‰ã€‘
${charDesc}
${charRelationships ? `\nã€ä½ å’Œå¯¹æ–¹çš„å…³ç³»ã€‘\n${charRelationships}` : ''}
${userPersonaForAnalysis ? `\nã€å¯¹æ–¹ï¼ˆ${myChar?.name || 'ç”¨æˆ·'}ï¼‰çš„ä¿¡æ¯ã€‘\n${userPersonaForAnalysis}` : ''}
${lorebookForAnalysis ? `\nã€ä¸–ç•Œä¹¦/èƒŒæ™¯è®¾å®šã€‘\n${lorebookForAnalysis}` : ''}

---

${checkResult.checkResult}

ä½ ä¹‹å‰è¯´çš„è¯æ˜¯ï¼šã€Œ${originalCleanReply.replace(/\|\|\|/g, 'ã€ã€Œ')}ã€
ç°åœ¨è¯·ä½ ä½œä¸º ${char.name}ï¼ŒåŸºäºä¸Šè¿°ã€çœŸå®çš„WeChatæ•°æ®ã€‘å’Œä½ çš„äººè®¾ï¼Œç”Ÿæˆä½ æŸ¥çœ‹å®Œè´¦å·åçš„å›å¤ã€‚

è¦æ±‚ï¼š
1. æåŠä½ çœ‹åˆ°çš„å…·ä½“ä¿¡æ¯ï¼ˆå¥½å‹åå­—ã€èŠå¤©å†…å®¹ã€ä½™é¢ç­‰ï¼‰
2. ç”¨ä½ çš„æ€§æ ¼å’Œå¹³æ—¶çš„èŠå¤©æ–¹å¼æ¥è¡¨è¾¾
3. ç”¨ ${char.reply_min_count || 1}-${char.reply_max_count || 3} æ¡çŸ­æ¶ˆæ¯å›å¤ï¼Œç”¨|||åˆ†éš”
4. æ¯æ¡æ¶ˆæ¯ä¸è¦å¤ªé•¿ åƒçœŸäººèŠå¤©
5. å£è¯­åŒ– å°‘ç”¨æ ‡ç‚¹
6. æ³¨æ„ï¼šè¿™åªæ˜¯æŸ¥å²—åçš„å›å¤ï¼Œä½ ä¹‹å‰è¯´çš„è¯å·²ç»å‘é€è¿‡äº†ï¼Œä¸è¦é‡å¤`;

                            // ğŸ”¥ ä¿®ç½—åœºæ¨¡å¼ï¼šåœ¨äºŒæ¬¡åˆ†æä¸­ä¹ŸåŠ å…¥æ“ä½œæŒ‡ä»¤
                            if (char.allow_shura_mode) {
                                const accountId = getCurrentAccountId();
                                const myChar = accountId ? await db.characters.get(parseInt(accountId)) : null;
                                const myName = myChar ? myChar.name : 'ç”¨æˆ·';
                                
                                let shuraInstructions = `

ã€ä¿®ç½—åœºæ¨¡å¼ - ä½ å¯ä»¥æ“ä½œ${myName}çš„è´¦å·ã€‘
ä½ å·²ç»æˆåŠŸç™»å½•äº†${myName}çš„è´¦å·ï¼Œä½ å¯ä»¥ç›´æ¥æ“ä½œã€‚

**å¯ç”¨æ“ä½œæŒ‡ä»¤ï¼š**
1. åˆ é™¤å¥½å‹ï¼š[SHURA_DELETE:å¥½å‹åå­—]
2. æ‹‰é»‘å¥½å‹ï¼š[SHURA_BLACKLIST:å¥½å‹åå­—]
3. ä»¥${myName}èº«ä»½å‘æ¶ˆæ¯ç»™æŸä¸ªå¥½å‹ï¼š[SHURA_SEND:å¥½å‹åå­—:æ¶ˆæ¯å†…å®¹1///æ¶ˆæ¯å†…å®¹2///æ¶ˆæ¯å†…å®¹3]ï¼ˆç”¨///åˆ†éš”å¤šæ¡æ¶ˆæ¯ï¼‰
4. ä»¥${myName}èº«ä»½å‘æœ‹å‹åœˆï¼š[SHURA_MOMENTS:æœ‹å‹åœˆæ–‡æ¡ˆå†…å®¹]
   - ä½ å¯ä»¥ç”¨${myName}çš„è´¦å·å‘ä¸€æ¡æœ‹å‹åœˆï¼Œå†…å®¹ç”±ä½ å†³å®š
   - ç¤ºä¾‹ï¼š[SHURA_MOMENTS:ä»Šå¤©å¤©æ°”çœŸå¥½ï½]`;

                                shuraInstructions += `

æ ¹æ®ä½ çœ‹åˆ°çš„å†…å®¹å’Œä½ çš„æ€§æ ¼ï¼Œè‡ªè¡Œå†³å®šæ˜¯å¦æ“ä½œã€å¦‚ä½•æ“ä½œã€‚

âš ï¸ é‡è¦ï¼šæ‰€æœ‰æ“ä½œæŒ‡ä»¤å¿…é¡»æ”¾åœ¨ "reply" å­—æ®µä¸­ï¼ç»å¯¹ä¸è¦æ”¾åœ¨ "thought" å­—æ®µé‡Œï¼
æ“ä½œæŒ‡ä»¤æ”¾åœ¨replyæœ€åï¼Œç”¨|||åˆ†éš”ã€‚
ç¤ºä¾‹ï¼š"reply": "ä½ åœ¨å¹²ä»€ä¹ˆï¼Ÿ|||[SHURA_SEND:æŸäºº:æ¶ˆæ¯å†…å®¹]"`;
                                analysisPrompt += shuraInstructions;
                            }

                            analysisPrompt += `

è¯·ä»¥JSONæ ¼å¼è¿”å›ï¼ˆæ¯æ¡æ¶ˆæ¯è¦çŸ­ ä¸è¦æŠŠå¾ˆå¤šè¯æŒ¤åœ¨ä¸€ä¸ªæ°”æ³¡é‡Œï¼‰ï¼š
{
  "reply": "ç¬¬ä¸€æ¡çŸ­æ¶ˆæ¯|||ç¬¬äºŒæ¡çŸ­æ¶ˆæ¯|||æ“ä½œæŒ‡ä»¤æ”¾è¿™é‡Œ",
  "thought": "çº¯å¿ƒç†æ´»åŠ¨ï¼Œä¸è¦æ”¾ä»»ä½•æŒ‡ä»¤æ ‡ç­¾"
}

âš ï¸ thoughtå­—æ®µåªå†™å¿ƒç†æ´»åŠ¨æ–‡å­—ï¼Œç¦æ­¢åŒ…å«ä»»ä½•[SHURA_...]ã€[CHECK_ACCOUNT]ç­‰æŒ‡ä»¤ï¼æŒ‡ä»¤åªèƒ½æ”¾åœ¨replyä¸­ï¼`;

                            // è°ƒç”¨AIè¿›è¡ŒäºŒæ¬¡åˆ†æ
                            try {
                                const analysisMessages = [
                                    { role: 'system', content: analysisPrompt },
                                    { role: 'user', content: '(ä½ å·²ç»æˆåŠŸç™»å½•å¹¶æŸ¥çœ‹äº†WeChatæ•°æ®)' }
                                ];
                                
                                const analysisResponse = await callAI(analysisMessages);
                                const analysisParsed = extractAndParseJSON(analysisResponse);
                                
                                if (analysisParsed && analysisParsed.reply) {
                                    // ğŸ”§ ä¿®å¤ï¼šå…ˆä¿ç•™åŸå§‹æ–‡å­—æ¶ˆæ¯ï¼Œå†è¿½åŠ æŸ¥å²—åçš„å›å¤
                                    // åŸæ¥æ˜¯å®Œå…¨è¦†ç›–ï¼Œå¯¼è‡´åŸå§‹æ–‡å­—æ¶ˆæ¯ä¸¢å¤±
                                    if (originalCleanReply && originalCleanReply.trim()) {
                                        replyText = originalCleanReply.trim() + '|||' + analysisParsed.reply;
                                        console.log('[AIæŸ¥å²—] å·²æ‹¼æ¥åŸå§‹æ¶ˆæ¯ + æŸ¥å²—åˆ†æå›å¤');
                                    } else {
                                        replyText = analysisParsed.reply;
                                    }
                                    
                                    // æ›´æ–°å¿ƒå£°
                                    if (analysisParsed.thought) {
                                        thought = analysisParsed.thought;
                                    }
                                    
                                    console.log('[AIæŸ¥å²—] äºŒæ¬¡åˆ†æå®Œæˆï¼Œç”Ÿæˆäº†åŸºäºçœŸå®æ•°æ®çš„å›å¤');
                                    
                                    // ğŸ”¥ ä¿®ç½—åœºæ¨¡å¼ï¼šè§£æå¹¶æ‰§è¡ŒAIæ“ä½œæŒ‡ä»¤
                                    if (char.allow_shura_mode) {
                                        console.log('[ä¿®ç½—åœº] å¼€å§‹è§£æAIå›å¤ä¸­çš„æ“ä½œæŒ‡ä»¤...');
                                        const shuraResult = await processShuraActions(char, replyText);
                                        if (shuraResult.actions.length > 0) {
                                            replyText = shuraResult.cleanReply;
                                            console.log('[ä¿®ç½—åœº] æ“ä½œæ‰§è¡Œå®Œæˆï¼Œå·²æ¸…ç†å›å¤æ–‡æœ¬');
                                        }
                                        
                                        // âœ… ä¿®å¤ï¼šä¹Ÿä»å¿ƒå£°ä¸­æå–å¹¶æ‰§è¡ŒSHURAæŒ‡ä»¤ï¼ˆAIæœ‰æ—¶ä¼šæŠŠæŒ‡ä»¤æ”¾åœ¨thoughté‡Œï¼‰
                                        if (thought && /\[SHURA_(SEND|DELETE|BLACKLIST):/i.test(thought)) {
                                            console.log('[ä¿®ç½—åœº] âš ï¸ æ£€æµ‹åˆ°å¿ƒå£°ä¸­åŒ…å«SHURAæŒ‡ä»¤ï¼Œæå–å¹¶æ‰§è¡Œ...');
                                            const thoughtShuraResult = await processShuraActions(char, thought);
                                            if (thoughtShuraResult.actions.length > 0) {
                                                thought = thoughtShuraResult.cleanReply;
                                                console.log('[ä¿®ç½—åœº] âœ… å·²ä»å¿ƒå£°ä¸­æå–å¹¶æ‰§è¡ŒSHURAæŒ‡ä»¤');
                                            }
                                        }
                                    }
                                    
                                    // ğŸ¯ æŸ¥å²—å®Œæˆï¼Œ4ç§’åè‡ªåŠ¨å…³é—­å¼¹çª—
                                    autoCloseOfflineMask(4);
                                } else {
                                    console.warn('[AIæŸ¥å²—] äºŒæ¬¡åˆ†æè¿”å›æ ¼å¼ä¸æ­£ç¡®ï¼Œä½¿ç”¨åŸå›å¤');
                                    // å³ä½¿å¤±è´¥ä¹Ÿè¦å…³é—­å¼¹çª—
                                    autoCloseOfflineMask(3);
                                }
                            } catch (error) {
                                console.error('[AIæŸ¥å²—] äºŒæ¬¡åˆ†æå¤±è´¥:', error);
                                // å¤±è´¥æ—¶ä¿æŒåŸå›å¤ï¼Œå¹¶å…³é—­å¼¹çª—
                                autoCloseOfflineMask(3);
                            }
                        } else {
                            // æ²¡æœ‰wechatæ•°æ®ï¼Œä¹Ÿè¦å…³é—­å¼¹çª—
                            autoCloseOfflineMask(3);
                        }
                    }
                }
                    
                    // å­˜å‚¨å¿ƒå£°åˆ°è§’è‰²å¯¹è±¡
                    if (thought && thought.trim()) {
                        // âœ… ä¿®å¤ï¼šå­˜å‚¨å‰æ¸…ç†å¿ƒå£°ä¸­å¯èƒ½æ®‹ç•™çš„æŒ‡ä»¤æ ‡ç­¾
                        thought = thought
                            .replace(/\[?SHURA_SEND:[^\]]*\]?/gi, '')
                            .replace(/\[?SHURA_DELETE:[^\]]*\]?/gi, '')
                            .replace(/\[?SHURA_BLACKLIST:[^\]]*\]?/gi, '')
                            .replace(/\[?SHURA_MOMENTS:[^\]]*\]?/gi, '')
                            .replace(/\[?CHECK_ACCOUNT(?::.*?)?\]?/gi, '')
                            .replace(/\(\(CHANGE_AVATAR\)\)/gi, '')
                            .replace(/\(\(COUPLE_AVATAR\)\)/gi, '')
                            .replace(/\[(?:sticker|imgcard|img|voice):[^\]]*\]/gi, '')
                            .replace(/\|\|\|/g, ' ')
                            .replace(/\/\/\//g, ' ')
                            .replace(/\s{2,}/g, ' ')
                            .trim();
                        
                        const freshChar = await db.characters.get(targetCharId);
                        if (freshChar && thought) {
                            if (!freshChar.thoughts) freshChar.thoughts = [];
                            freshChar.thoughts.push({
                                content: thought.trim(),
                                time: _vNow(),
                                messageIndex: freshChar.chat_history ? freshChar.chat_history.length : 0
                            });
                            // åªä¿ç•™æœ€è¿‘50æ¡å¿ƒå£°
                            if (freshChar.thoughts.length > 50) {
                                freshChar.thoughts = freshChar.thoughts.slice(-50);
                            }
                            // ğŸ”§ ä¿®å¤æ•°æ®ä¸¢å¤±ï¼šä½¿ç”¨ update() åªæ›´æ–° thoughts å­—æ®µï¼Œé¿å…è¦†ç›–å¹¶å‘å†™å…¥çš„èŠå¤©è®°å½•
                            await db.characters.update(targetCharId, {
                                thoughts: freshChar.thoughts
                            });
                        }
                    }

                // 3. æ¢å¤æ ‡é¢˜
                if (chatTitleEl) chatTitleEl.innerText = originalTitle;
                
                // ğŸ”§ ç»Ÿä¸€çš„è¡¨æƒ…åŒ…æ›¿æ¢å‡½æ•°
                const replaceStickerTags = (text) => {
                    if (!text || !/\[sticker:[^\]]+\]/i.test(text)) return text;
                    
                    if (_mountedStickersList.length === 0) {
                        console.warn('[replaceStickerTags] è§’è‰²æ²¡æœ‰æŒ‚è½½è¡¨æƒ…åŒ…ï¼Œç§»é™¤æ ‡ç­¾');
                        return text.replace(/\[sticker:[^\]]+\]/gi, '');
                    }
                    
                    return text.replace(/\[sticker:([^\]]+)\]/gi, (match, keyword) => {
                        const stickerKeyword = keyword.trim();
                        
                        // æŒ‰ç¼–å·åŒ¹é…
                        const numMatch = stickerKeyword.match(/^\d+$/);
                        if (numMatch) {
                            const requestedNum = parseInt(numMatch[0]);
                            const idx = requestedNum - 1;
                            if (idx >= 0 && idx < _mountedStickersList.length) {
                                console.log(`[replaceStickerTags] âœ… åŒ¹é…è¡¨æƒ…åŒ… #${idx + 1}: ${_mountedStickersList[idx].description}`);
                                return `[img:${_mountedStickersList[idx].url}]`;
                            } else {
                                const randomIdx = Math.floor(Math.random() * _mountedStickersList.length);
                                console.warn(`[replaceStickerTags] âš ï¸ ç¼–å· ${requestedNum} è¶…å‡ºèŒƒå›´ï¼Œéšæœºé€‰æ‹©`);
                                return `[img:${_mountedStickersList[randomIdx].url}]`;
                            }
                        }
                        
                        // ä»æ–‡æœ¬æå–æ•°å­—
                        const numInText = stickerKeyword.match(/(\d+)/);
                        if (numInText) {
                            const requestedNum = parseInt(numInText[1]);
                            const idx = requestedNum - 1;
                            if (idx >= 0 && idx < _mountedStickersList.length) {
                                return `[img:${_mountedStickersList[idx].url}]`;
                            }
                        }
                        
                        // éšæœºé€‰æ‹©
                        const randomSticker = _mountedStickersList[Math.floor(Math.random() * _mountedStickersList.length)];
                        console.log(`[replaceStickerTags] âš ï¸ éšæœºé€‰æ‹©è¡¨æƒ…åŒ…: ${randomSticker.description}`);
                        return `[img:${randomSticker.url}]`;
                    });
                };
                
                // ğŸ”§ æ‹†åˆ†åŒ…å«å›¾ç‰‡çš„æ¶ˆæ¯ï¼ˆç¡®ä¿å›¾ç‰‡å•ç‹¬æ˜¾ç¤ºï¼‰
                const splitMessageWithImages = (text) => {
                    // å…ˆæ›¿æ¢è¡¨æƒ…åŒ…æ ‡ç­¾
                    text = replaceStickerTags(text);
                    
                    // å¦‚æœæ²¡æœ‰å›¾ç‰‡æ ‡ç­¾ï¼Œç›´æ¥è¿”å›
                    if (!text.includes('[img:')) {
                        return [text];
                    }
                    
                    // æ‹†åˆ†æ–‡å­—å’Œå›¾ç‰‡
                    const parts = [];
                    const regex = /(\[img:[^\]]+\])/g;
                    let lastIndex = 0;
                    let match;
                    
                    while ((match = regex.exec(text)) !== null) {
                        // æ·»åŠ å›¾ç‰‡å‰çš„æ–‡å­—
                        if (match.index > lastIndex) {
                            const beforeText = text.substring(lastIndex, match.index).trim();
                            if (beforeText) {
                                parts.push(beforeText);
                            }
                        }
                        // æ·»åŠ å›¾ç‰‡
                        parts.push(match[0]);
                        lastIndex = regex.lastIndex;
                    }
                    
                    // æ·»åŠ æœ€åå‰©ä½™çš„æ–‡å­—
                    if (lastIndex < text.length) {
                        const afterText = text.substring(lastIndex).trim();
                        if (afterText) {
                            parts.push(afterText);
                        }
                    }
                    
                    return parts.length > 0 ? parts : [text];
                };
                
                // ğŸ¯ æ£€æµ‹è§’è‰²åˆ é™¤/æ‹‰é»‘ç”¨æˆ·æŒ‡ä»¤ - åœ¨æ‹†åˆ†å‰å…ˆæ£€æµ‹
                const deleteUserMatchReply = replyText.match(/\(\(DELETE_USER\)\)/i);
                if (deleteUserMatchReply) {
                    console.log(`[TriggerAI] æ£€æµ‹åˆ°è§’è‰²åˆ é™¤ç”¨æˆ·æŒ‡ä»¤...`);
                    const textBeforeDelete = cleanMessage(replyText.substring(0, deleteUserMatchReply.index).trim());
                    if (textBeforeDelete && textBeforeDelete.trim()) {
                        const freshChar = await db.characters.get(targetCharId);
                        if (freshChar) {
                            let history = getChatHistory(freshChar, accountId);
                            const textSegments = textBeforeDelete.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                            for (const seg of textSegments) {
                                const subParts = splitMessageWithImages(cleanMessage(seg));
                                
                                for (const part of subParts) {
                                    history.push(buildCharMessage(part, !!char.foreign_lang_mode, { time: _vNow() }));
                                    await setChatHistory(freshChar, accountId, history);
                                    if (currentChatCharId === targetCharId) {
                                        await appendMessageToUI('char', part);
                                    }
                                    await new Promise(r => setTimeout(r, 300));
                                }
                            }
                        }
                    }
                    await executeCharDeleteUser(targetCharId, accountId);
                    return;
                }
                
                const blockUserMatchReply = replyText.match(/\(\(BLOCK_USER\)\)/i);
                if (blockUserMatchReply) {
                    console.log(`[TriggerAI] æ£€æµ‹åˆ°è§’è‰²æ‹‰é»‘ç”¨æˆ·æŒ‡ä»¤...`);
                    const textBeforeBlock = cleanMessage(replyText.substring(0, blockUserMatchReply.index).trim());
                    if (textBeforeBlock && textBeforeBlock.trim()) {
                        const freshChar = await db.characters.get(targetCharId);
                        if (freshChar) {
                            let history = getChatHistory(freshChar, accountId);
                            const textSegments = textBeforeBlock.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                            for (const seg of textSegments) {
                                const subParts = splitMessageWithImages(cleanMessage(seg));
                                
                                for (const part of subParts) {
                                    history.push(buildCharMessage(part, !!char.foreign_lang_mode, { time: _vNow() }));
                                    await setChatHistory(freshChar, accountId, history);
                                    if (currentChatCharId === targetCharId) {
                                        await appendMessageToUI('char', part);
                                    }
                                    await new Promise(r => setTimeout(r, 300));
                                }
                            }
                        }
                    }
                    await executeCharBlockUser(targetCharId, accountId);
                    return;
                }
                
                // ğŸ¯ æ£€æµ‹ä¿®æ”¹å¯†ç æŒ‡ä»¤ ((CHANGE_PASSWORD:æ–°å¯†ç ))
                const changePasswordMatch = replyText.match(/\(\(CHANGE_PASSWORD:\s*([^)]+)\)\)/i);
                if (changePasswordMatch) {
                    console.log('[TriggerAI] ğŸ” æ£€æµ‹åˆ°ä¿®æ”¹å¯†ç æŒ‡ä»¤');
                    const newPassword = changePasswordMatch[1].trim();
                    const textBeforeChangePassword = cleanMessage(replyText.substring(0, changePasswordMatch.index).trim());
                    // ğŸ”¥ ä¿®å¤ï¼šæå–å¯†ç æŒ‡ä»¤åé¢çš„æ–‡å­—å†…å®¹
                    const textAfterChangePassword = replyText.substring(changePasswordMatch.index + changePasswordMatch[0].length).trim();
                    
                    // å…ˆå‘é€ä¿®æ”¹å¯†ç å‰çš„æ–‡å­—æ¶ˆæ¯
                    if (textBeforeChangePassword && textBeforeChangePassword.trim()) {
                        const freshChar = await db.characters.get(targetCharId);
                        if (freshChar) {
                            let history = getChatHistory(freshChar, accountId);
                            const textSegments = textBeforeChangePassword.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                            for (const seg of textSegments) {
                                const subParts = splitMessageWithImages(cleanMessage(seg));
                                
                                for (const part of subParts) {
                                    history.push(buildCharMessage(part, !!char.foreign_lang_mode, { time: _vNow() }));
                                    await setChatHistory(freshChar, accountId, history);
                                    if (currentChatCharId === targetCharId) {
                                        await appendMessageToUI('char', part, freshChar.avatar);
                                    }
                                    await new Promise(r => setTimeout(r, 300));
                                }
                            }
                        }
                    }
                    
                    // æ‰§è¡Œä¿®æ”¹å¯†ç 
                    const freshChar = await db.characters.get(targetCharId);
                    if (freshChar) {
                        // ç¡®ä¿ identity å¯¹è±¡å­˜åœ¨
                        if (!freshChar.identity) {
                            freshChar.identity = {};
                        }
                        
                        const oldPassword = freshChar.identity.password || '';
                        freshChar.identity.password = newPassword;
                        
                        // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°å¯†ç å­—æ®µï¼Œé˜²æ­¢è¦†ç›–è®¾ç½®
                        await safeDexieUpdate(db.characters, targetCharId, { 'identity.password': newPassword }, `ä¿®æ”¹å¯†ç [${freshChar.name}]`);
                        console.log('[TriggerAI] âœ… å·²ä¿®æ”¹å¯†ç ï¼Œæ–°å¯†ç :', newPassword);
                        
                        // ğŸ”¥ ä¿®å¤ï¼šç›´æ¥æ“ä½œå…¨å±€ fpWechatVerified Setï¼Œè€Œä¸æ˜¯åˆ›å»ºæ–°çš„å±€éƒ¨å˜é‡ï¼ˆå±€éƒ¨å˜é‡ä¼šé®è”½å…¨å±€çš„ï¼Œå¯¼è‡´å†…å­˜ä¸­çš„éªŒè¯çŠ¶æ€æœªè¢«æ¸…é™¤ï¼‰
                        fpWechatVerified.delete(String(freshChar.id));
                        saveFpWechatVerified();
                        
                        // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ°å¾®ä¿¡èŠå¤©è®°å½•
                        let history = getChatHistory(freshChar, accountId);
                        const sysMsgContent = `[${freshChar.name} ä¿®æ”¹äº†è´¦å·å¯†ç ï¼ŒåŸå¯†ç å·²å¤±æ•ˆ]`;
                        history.push({
                            role: 'system',
                            content: sysMsgContent,
                            time: _vNow(),
                            type: 'char_change_password'
                        });
                        await setChatHistory(freshChar, accountId, history);
                        
                        // ğŸ”¥ ä¿®å¤ï¼šä½¿ç”¨ appendMessageToUI è¿½åŠ ç³»ç»Ÿæ¶ˆæ¯ï¼Œé¿å… renderChatBody å¯¼è‡´é¡µé¢é—ªçƒå’Œæ¶ˆæ¯é‡å¤
                        if (currentChatCharId === targetCharId) {
                            await appendMessageToUI('system', sysMsgContent);
                        }
                        const activeTab = document.querySelector('.wechat-tab-item.active');
                        if (activeTab) {
                            const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                            switchWechatTab(tabIndex);
                        }
                        
                        showToast(`${freshChar.name} ä¿®æ”¹äº†å¯†ç ï¼`);
                    }
                    
                    // ğŸ”¥ ä¿®å¤ï¼šå¦‚æœå¯†ç æŒ‡ä»¤åè¿˜æœ‰å†…å®¹ï¼Œç»§ç»­å¤„ç†ï¼›å¦åˆ™ç›´æ¥è¿”å›ï¼Œé˜²æ­¢å·²å‘é€çš„æ¶ˆæ¯è¢«é‡å¤å¤„ç†
                    if (textAfterChangePassword) {
                        console.log('[TriggerAI] ä¿®æ”¹å¯†ç åè¿˜æœ‰å†…å®¹ï¼Œç»§ç»­å¤„ç†:', textAfterChangePassword.substring(0, 50));
                        replyText = textAfterChangePassword.replace(/\(\(CHANGE_PASSWORD:[^)]+\)\)/gi, '').trim();
                        // æ¸…ç†å¼€å¤´çš„åˆ†éš”ç¬¦
                        while (replyText.startsWith('|||')) {
                            replyText = replyText.substring(3).trim();
                        }
                        if (!replyText) return;
                    } else {
                        return; // ä¿®æ”¹å¯†ç å¤„ç†å®Œæˆä¸”æ²¡æœ‰åç»­å†…å®¹
                    }
                }
                
                // ğŸ¯ æ£€æµ‹è§’è‰²è‡ªä¸»æ‰‹æœºæ´»åŠ¨æŒ‡ä»¤ ((PHONE_ACTIVITY:æè¿°))
                const phoneActivityMatch = replyText.match(/\(\(PHONE_ACTIVITY:\s*([^)]+)\)\)/i);
                if (phoneActivityMatch && char.allow_autonomous_activity) {
                    const activityDesc = phoneActivityMatch[1].trim();
                    console.log('[TriggerAI] ğŸ“± æ£€æµ‹åˆ°è§’è‰²è‡ªä¸»æ‰‹æœºæ´»åŠ¨æŒ‡ä»¤:', activityDesc);
                    // ä»å›å¤æ–‡æœ¬ä¸­ç§»é™¤æŒ‡ä»¤ï¼ˆå¯¹ç”¨æˆ·ä¸å¯è§ï¼‰
                    replyText = replyText.replace(/\(\(PHONE_ACTIVITY:\s*[^)]+\)\)/gi, '').trim();
                    // å¼‚æ­¥ç”Ÿæˆæ‰‹æœºæ´»åŠ¨æ•°æ®ï¼ˆä¸é˜»å¡å½“å‰å›å¤ï¼‰
                    generateCharAutonomousActivity(targetCharId, accountId, activityDesc).catch(e => {
                        console.error('[TriggerAI] è§’è‰²è‡ªä¸»æ´»åŠ¨ç”Ÿæˆå¤±è´¥:', e);
                    });
                }
                
                // ğŸ¯ æ£€æµ‹NPCåŠ å¥½å‹æŒ‡ä»¤ï¼ˆé¢„å¤„ç†ï¼‰- ä¸returnï¼Œç»§ç»­å¤„ç†æ¶ˆæ¯
                const npcAddMatchReplyPre = replyText.match(/\(\(NPC_ADD_FRIEND:\s*(.+?)\s*\)\)/i);
                if (npcAddMatchReplyPre) {
                    const npcNameReplyPre = npcAddMatchReplyPre[1].trim();
                    console.log(`[TriggerAI] æ£€æµ‹åˆ°NPCåŠ å¥½å‹æŒ‡ä»¤ï¼ˆé¢„å¤„ç†ï¼‰: ${npcNameReplyPre}`);
                    try {
                        await executeNpcAddFriend(char, npcNameReplyPre, accountId);
                    } catch (e) {
                        console.error('[TriggerAI] NPCåŠ å¥½å‹å¤±è´¥:', e);
                    }
                    replyText = replyText.replace(/\(\(NPC_ADD_FRIEND:\s*.+?\s*\)\)/gi, '').trim();
                }
                
                // ğŸ”§ é¢„å¤„ç†ï¼šæå–å¹¶æ‰§è¡Œå†…è”æŒ‡ä»¤ï¼ˆPOKE/OPEN_APP/SET_NICKNAME/SET_SIGNATURE/CALL/CHANGE_AVATARç­‰ï¼‰
                // è¿™äº›æŒ‡ä»¤å¯èƒ½å‡ºç°åœ¨ TRANSFER/MOMENTS/EMEI ç­‰ç‰¹æ®ŠæŒ‡ä»¤ä¹‹å‰/ä¹‹é—´ï¼Œ
                // å¦‚æœä¸é¢„å¤„ç†ï¼ŒtextBefore å¤„ç†å™¨ä¼šæŠŠå®ƒä»¬å½“æˆæ™®é€šæ–‡å­—å‘é€åˆ°èŠå¤©ä¸­
                {
                    // ğŸ”§ è¾…åŠ©å‡½æ•°ï¼šå°†ç³»ç»Ÿæ¶ˆæ¯å†™å…¥èŠå¤©è®°å½•å’ŒUI
                    const insertSystemMsg = async (text, type) => {
                        try {
                            const fc = await db.characters.get(targetCharId);
                            if (fc) {
                                let h = getChatHistory(fc, accountId);
                                h.push({ role: 'system', content: text, time: _vNow(), type: type });
                                await setChatHistory(fc, accountId, h);
                                if (currentChatCharId === targetCharId) {
                                    await appendMessageToUI('system', text);
                                }
                            }
                        } catch (e) {
                            console.error(`[TriggerAI] é¢„å¤„ç†æ’å…¥ç³»ç»Ÿæ¶ˆæ¯å¤±è´¥:`, e);
                        }
                    };
                    
                    // ((POKE: åŠ¨ä½œ, éƒ¨ä½))
                    const pokeMatches = replyText.match(/\(\(POKE:\s*(.+?)\)\)/gi);
                    if (pokeMatches) {
                        for (const pm of pokeMatches) {
                            const pokeDetail = pm.match(/\(\(POKE:\s*(.+?)\)\)/i);
                            if (pokeDetail) {
                                try {
                                    const pokeContent = pokeDetail[1].trim();
                                    let pokeAction, pokePart;
                                    if (pokeContent.includes(',') || pokeContent.includes('ï¼Œ')) {
                                        const parts = pokeContent.split(/[,ï¼Œ]/);
                                        pokeAction = parts[0].trim();
                                        pokePart = parts.slice(1).join('').trim();
                                    } else {
                                        const spaceIdx = pokeContent.indexOf(' ');
                                        if (spaceIdx > 0) {
                                            pokeAction = pokeContent.substring(0, spaceIdx).trim();
                                            pokePart = pokeContent.substring(spaceIdx + 1).trim();
                                        } else {
                                            pokeAction = pokeContent;
                                            pokePart = '';
                                        }
                                    }
                                    const freshChar = await db.characters.get(targetCharId);
                                    const myChar = accountId ? await db.characters.get(parseInt(accountId)) : null;
                                    const pokeUserName = myChar ? (myChar.nick || myChar.name) : 'ç”¨æˆ·';
                                    const pokeText = pokePart ? `${freshChar.name}${pokeAction}${pokeUserName}çš„${pokePart}` : `${freshChar.name}${pokeAction}${pokeUserName}`;
                                    console.log(`[TriggerAI] é¢„å¤„ç†æˆ³ä¸€æˆ³: ${pokeText}`);
                                    await insertSystemMsg(pokeText, 'poke');
                                } catch (e) {
                                    console.error('[TriggerAI] é¢„å¤„ç†æˆ³ä¸€æˆ³å¤±è´¥:', e);
                                }
                            }
                        }
                        replyText = replyText.replace(/\(\(POKE:\s*(.+?)\)\)/gi, '').trim();
                    }
                    
                    // ((OPEN_APP: APPåç§°))
                    const appMatches = replyText.match(/\(\(OPEN_APP:\s*(.+?)\)\)/gi);
                    if (appMatches) {
                        for (const am of appMatches) {
                            const appDetail = am.match(/\(\(OPEN_APP:\s*(.+?)\)\)/i);
                            if (appDetail) {
                                try {
                                    const appName = appDetail[1].trim();
                                    const freshChar = await db.characters.get(targetCharId);
                                    const appText = `${freshChar.name} æ‰“å¼€äº† "${appName}"`;
                                    console.log(`[TriggerAI] é¢„å¤„ç†æ‰“å¼€APP: ${appText}`);
                                    await insertSystemMsg(appText, 'open_app');
                                } catch (e) {
                                    console.error('[TriggerAI] é¢„å¤„ç†æ‰“å¼€APPå¤±è´¥:', e);
                                }
                            }
                        }
                        replyText = replyText.replace(/\(\(OPEN_APP:\s*(.+?)\)\)/gi, '').trim();
                    }
                    
                    // ((SET_NICKNAME: æ–°ç½‘å))
                    const nickMatchPre = replyText.match(/\(\(SET_NICKNAME:\s*(.+?)\)\)/i);
                    if (nickMatchPre) {
                        try {
                            const newNickname = nickMatchPre[1].trim();
                            const freshChar = await db.characters.get(targetCharId);
                            const oldNickname = getCharWxNickname(freshChar, accountId) || freshChar.name;
                            // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°ç½‘åå­—æ®µï¼Œé˜²æ­¢è¦†ç›–è®¾ç½®
                            const nnPayload = accountId
                                ? { [`wx_nickname_by_user.${accountId}`]: newNickname }
                                : { wx_nickname: newNickname };
                            await safeDexieUpdate(db.characters, targetCharId, nnPayload, `æ”¹ç½‘å[${freshChar.name}]`);
                            setCharWxNickname(freshChar, accountId, newNickname);
                            const nicknameText = `${oldNickname} å°†ç½‘åæ”¹ä¸º "${newNickname}"`;
                            console.log(`[TriggerAI] é¢„å¤„ç†æ”¹ç½‘å: ${nicknameText}`);
                            await insertSystemMsg(nicknameText, 'set_nickname');
                            // æ›´æ–°UIä¸Šçš„åå­—
                            if (currentChatCharId === targetCharId) {
                                if (!freshChar.remark) {
                                    const titleEl = document.getElementById('chat-title');
                                    if (titleEl) titleEl.innerText = newNickname;
                                }
                                const nicknameEl = document.getElementById('detail-char-nickname');
                                if (nicknameEl) nicknameEl.innerText = newNickname;
                            }
                        } catch (e) {
                            console.error('[TriggerAI] é¢„å¤„ç†æ”¹ç½‘åå¤±è´¥:', e);
                        }
                        replyText = replyText.replace(/\(\(SET_NICKNAME:\s*(.+?)\)\)/gi, '').trim();
                    }
                    
                    // ((SET_SIGNATURE: æ–°ç­¾å))
                    const sigMatchPre = replyText.match(/\(\(SET_SIGNATURE:\s*(.+?)\)\)/i);
                    if (sigMatchPre) {
                        try {
                            const newSignature = sigMatchPre[1].trim();
                            const freshChar = await db.characters.get(targetCharId);
                            // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°ç­¾åå­—æ®µï¼Œé˜²æ­¢è¦†ç›–è®¾ç½®
                            await safeDexieUpdate(db.characters, targetCharId, { wx_signature: newSignature }, `æ”¹ç­¾å[${freshChar.name}]`);
                            freshChar.wx_signature = newSignature;
                            const sigText = `${freshChar.wx_nickname || freshChar.name} æ›´æ–°äº†ä¸ªæ€§ç­¾å: "${newSignature}"`;
                            console.log(`[TriggerAI] é¢„å¤„ç†æ”¹ç­¾å: ${sigText}`);
                            await insertSystemMsg(sigText, 'set_signature');
                            if (currentChatCharId === targetCharId) {
                                const sigEl = document.getElementById('detail-char-signature');
                                if (sigEl) sigEl.innerText = newSignature;
                            }
                        } catch (e) {
                            console.error('[TriggerAI] é¢„å¤„ç†æ”¹ç­¾åå¤±è´¥:', e);
                        }
                        replyText = replyText.replace(/\(\(SET_SIGNATURE:\s*(.+?)\)\)/gi, '').trim();
                    }
                    
                    // ((CALL)) - æ¥ç”µ
                    if (/\(\(CALL\)\)/i.test(replyText)) {
                        console.log(`[TriggerAI] é¢„å¤„ç†æ¥ç”µæŒ‡ä»¤ ((CALL))`);
                        try {
                            if (!_incomingCallCharId) {
                                await showIncomingCall(targetCharId, '');
                            }
                        } catch (e) {
                            console.error('[TriggerAI] é¢„å¤„ç†æ¥ç”µå¤±è´¥:', e);
                        }
                        replyText = replyText.replace(/\(\(CALL\)\)/gi, '').trim();
                    }
                    
                    // ((CHANGE_AVATAR))
                    if (/\(\(CHANGE_AVATAR\)\)/i.test(replyText)) {
                        console.log(`[TriggerAI] é¢„å¤„ç†æ¢å¤´åƒæŒ‡ä»¤`);
                        try {
                            await executeChangeAvatar(targetCharId, accountId);
                        } catch (e) {
                            console.error('[TriggerAI] é¢„å¤„ç†æ¢å¤´åƒå¤±è´¥:', e);
                        }
                        replyText = replyText.replace(/\(\(CHANGE_AVATAR\)\)/gi, '').trim();
                    }
                    
                    // ((COUPLE_AVATAR))
                    if (/\(\(COUPLE_AVATAR\)\)/i.test(replyText)) {
                        console.log(`[TriggerAI] é¢„å¤„ç†æƒ…å¤´é‚€è¯·æŒ‡ä»¤`);
                        try {
                            await sendCoupleAvatarCard(targetCharId, accountId);
                        } catch (e) {
                            console.error('[TriggerAI] é¢„å¤„ç†æƒ…å¤´é‚€è¯·å¤±è´¥:', e);
                        }
                        replyText = replyText.replace(/\(\(COUPLE_AVATAR\)\)/gi, '').trim();
                    }
                    
                    // ((REVERT_COUPLE_AVATAR))
                    if (/\(\(REVERT_COUPLE_AVATAR\)\)/i.test(replyText)) {
                        console.log(`[TriggerAI] é¢„å¤„ç†æ¢å›å•äººå¤´åƒæŒ‡ä»¤`);
                        try {
                            await executeRevertCoupleAvatar(targetCharId, accountId);
                        } catch (e) {
                            console.error('[TriggerAI] é¢„å¤„ç†æ¢å›å•äººå¤´åƒå¤±è´¥:', e);
                        }
                        replyText = replyText.replace(/\(\(REVERT_COUPLE_AVATAR\)\)/gi, '').trim();
                    }
                    
                    // ((RECALL)) - æ’¤å›ï¼šé¢„å¤„ç†ç§»é™¤ï¼Œç¨ååœ¨æ¶ˆæ¯å¾ªç¯ä¸­ä¸ä¼šé‡åˆ°é—®é¢˜
                    // æ³¨æ„ï¼šRECALL éœ€è¦åœ¨æ¶ˆæ¯å‘é€åæ‰§è¡Œï¼Œæ‰€ä»¥ä¿ç•™åœ¨æ¶ˆæ¯å¾ªç¯ä¸­å¤„ç†
                    
                    // æ¸…ç†é¢„å¤„ç†åå¯èƒ½äº§ç”Ÿçš„å­¤ç«‹ ||| åˆ†éš”ç¬¦
                    replyText = replyText.replace(/(\|\|\|)+/g, '|||').replace(/^\|\|\|/, '').replace(/\|\|\|$/, '').trim();
                }

                // âœ… å…³é”®æ”¹åŠ¨ï¼šåœ¨æ‹†åˆ†å‰ï¼Œå…ˆæ£€æµ‹æ˜¯å¦åŒ…å«"æŒ‡ä»¤å‹æ¶ˆæ¯"ï¼ˆè½¬è´¦ç­‰ï¼‰
                // æ£€æµ‹ ((TRANSFER: é‡‘é¢, å¤‡æ³¨)) æ ¼å¼
                const transferMatch = replyText.match(/\(\(TRANSFER:\s*(\d+(\.\d+)?)(?:,\s*(.+?))?\)\)/i);
                
                if (transferMatch) {
                    // æå–è½¬è´¦ä¿¡æ¯
                    const amount = parseFloat(transferMatch[1]);
                    let note = transferMatch[3] || 'è½¬è´¦';
                    // é™åˆ¶å¤‡æ³¨é•¿åº¦ï¼Œä¸è¶…è¿‡10ä¸ªå­—
                    if (note.length > 10) {
                        note = note.substring(0, 10);
                    }
                    
                    // æå–è½¬è´¦å‰é¢çš„æ–‡å­—å†…å®¹ï¼ˆå¦‚æœæœ‰ï¼‰
                    const textBeforeTransfer = replyText.substring(0, transferMatch.index).trim();
                    // ğŸ”¥ ä¿®å¤ï¼šæå–è½¬è´¦åé¢çš„æ–‡å­—å†…å®¹
                    const textAfterTransfer = replyText.substring(transferMatch.index + transferMatch[0].length).trim();
                    
                    const freshChar = await db.characters.get(targetCharId);
                    if (freshChar) {
                        let history = getChatHistory(freshChar, accountId);
                        
                        // 1. å…ˆå‘é€æ–‡å­—æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰ï¼‰- æ”¯æŒåˆ†å‰²æˆå¤šæ¡
                        if (textBeforeTransfer) {
                            // å¯¹è½¬è´¦å‰çš„æ–‡å­—è¿›è¡Œåˆ†å‰²å¤„ç†
                            let textSegments = [];
                            const textToSplit = textBeforeTransfer.replace(/[,ï¼Œ]/g, ' ');
                            if (textToSplit.includes('|||')) {
                                textSegments = textToSplit.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                            } else {
                                textSegments = splitMessage(textToSplit);
                            }
                            
                            // è¿‡æ»¤å¤ªçŸ­çš„æ®µè½ï¼ˆğŸ”§ åŠ å…¥ | åˆ°è¿‡æ»¤æ­£åˆ™ï¼‰
                            textSegments = textSegments.filter(seg => seg.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦|\s]/g, '').length >= 2);
                            
                            // å¦‚æœåˆ†å‰²åä¸ºç©ºï¼Œä½†åŸæ–‡æœ¬æœ‰å†…å®¹ï¼Œä½¿ç”¨åŸæ–‡æœ¬
                            if (textSegments.length === 0 && textBeforeTransfer.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦|\s]/g, '').length > 0) {
                                textSegments = [textBeforeTransfer];
                            }
                            
                            // é€æ¡å‘é€æ–‡å­—æ¶ˆæ¯
                            let msgIndex = 0;
                            for (let i = 0; i < textSegments.length; i++) {
                                let seg = textSegments[i];
                                // ğŸ”§ æ‹†åˆ†åŒ…å«å›¾ç‰‡çš„æ¶ˆæ¯ï¼ˆç¡®ä¿è¡¨æƒ…åŒ…å•ç‹¬æ˜¾ç¤ºï¼‰
                                const subParts = splitMessageWithImages(seg);
                                
                                for (const part of subParts) {
                                    const textMsg = buildCharMessage(part, !!char.foreign_lang_mode, { time: _vNow() + msgIndex });
                                    history.push(textMsg);
                                    await setChatHistory(freshChar, accountId, history);
                                    
                                    // æ¸²æŸ“æ–‡å­—æ¶ˆæ¯
                                    if (currentChatCharId === targetCharId) {
                                        await appendMessageToUI('char', part, freshChar.avatar);
                                    }
                                    
                                    // æ¯æ¡æ¶ˆæ¯ä¹‹é—´ç¨å¾®å»¶æ—¶
                                    await new Promise(r => setTimeout(r, 300));
                                    msgIndex++;
                                }
                            }
                            
                            // æœ€åä¸€æ¡æ–‡å­—æ¶ˆæ¯åç¨å¾®å»¶æ—¶å†å‘è½¬è´¦
                            await new Promise(r => setTimeout(r, 500));
                        }
                        
                        // 2. å†å‘é€è½¬è´¦å¡ç‰‡
                        const transferData = {
                            amount: amount.toFixed(2),
                            desc: note,
                            status: 'sent'
                        };
                        
                        const transferMsg = { 
                            role: 'char', 
                            type: 'transfer', // æ˜ç¡®æ ‡è®°ä¸ºè½¬è´¦æ¶ˆæ¯
                            content: JSON.stringify(transferData), 
                            time: _vNow(),
                            id: 'trans_' + _vNow()
                        };
                        
                        // é‡æ–°è·å–æœ€æ–°çš„å†å²è®°å½•ï¼ˆå› ä¸ºåˆšæ‰å¯èƒ½æ’å…¥äº†æ–‡å­—æ¶ˆæ¯ï¼‰
                        history = getChatHistory(freshChar, accountId);
                        history.push(transferMsg);
                        await setChatHistory(freshChar, accountId, history);
                        
                        // æ¸²æŸ“è½¬è´¦å¡ç‰‡ - ä½¿ç”¨ appendMessageToUI è¿½åŠ ï¼Œé¿å…é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©
                        if (currentChatCharId === targetCharId) {
                            await appendMessageToUI('char', JSON.stringify(transferData), freshChar.avatar);
                        } else {
                            sendSystemNotification(freshChar.name, '[è½¬è´¦]');
                        }
                        
                        // âœ… è§’è‰²å‘é€è½¬è´¦ â†’ è§’è‰²FPé’±åŒ…æ”¯å‡º
                        const tfWalletAccId = getCurrentAccountId();
                        if (tfWalletAccId) {
                            await fpWalletTransaction(targetCharId, tfWalletAccId, 'expense', amount, 'å¾®ä¿¡è½¬è´¦', `è½¬è´¦ç»™${userName} - ${note}`, true);
                            console.log(`[TriggerAI] âœ… è§’è‰²FPé’±åŒ…æ”¯å‡º Â¥${amount.toFixed(2)}`);
                        }
                        
                        await new Promise(r => setTimeout(r, 500));
                    }
                    
                    // ğŸ”¥ ä¿®å¤ï¼šå¦‚æœè½¬è´¦åè¿˜æœ‰å†…å®¹ï¼Œç»§ç»­å¤„ç†
                    if (textAfterTransfer) {
                        console.log('[TriggerAI] è½¬è´¦åè¿˜æœ‰å†…å®¹ï¼Œç»§ç»­å¤„ç†:', textAfterTransfer.substring(0, 50));
                        replyText = textAfterTransfer;
                        // ç»§ç»­æ‰§è¡Œåç»­çš„æ™®é€šæ¶ˆæ¯å¤„ç†é€»è¾‘ï¼Œä¸è¦return
                    } else {
                        return; // è½¬è´¦å¤„ç†å®Œæˆä¸”æ²¡æœ‰åç»­å†…å®¹
                    }
                }
                
                // ğŸ¯ æ£€æµ‹äº²å±å¡èµ é€æŒ‡ä»¤ ((FAMILY_CARD: é¢åº¦))
                const familyCardMatch2 = replyText.match(/\(\(FAMILY_CARD:\s*(\d+)\)\)/i);
                if (familyCardMatch2) {
                    const monthlyLimit = parseInt(familyCardMatch2[1]) || 0;
                    
                    // æå–äº²å±å¡æŒ‡ä»¤å‰é¢çš„æ–‡å­—å†…å®¹
                    const textBeforeFamilyCard = replyText.substring(0, familyCardMatch2.index).trim();
                    // ğŸ”¥ ä¿®å¤ï¼šæå–äº²å±å¡åé¢çš„æ–‡å­—å†…å®¹
                    const textAfterFamilyCard = replyText.substring(familyCardMatch2.index + familyCardMatch2[0].length).trim();
                    
                    const freshChar = await db.characters.get(targetCharId);
                    if (freshChar) {
                        let history = getChatHistory(freshChar, accountId);
                        
                        // 1. å…ˆå‘é€æ–‡å­—æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰ï¼‰
                        if (textBeforeFamilyCard) {
                            let textSegments = [];
                            const textToSplit = textBeforeFamilyCard.replace(/[,ï¼Œ]/g, ' ');
                            if (textToSplit.includes('|||')) {
                                textSegments = textToSplit.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                            } else {
                                textSegments = splitMessage(textToSplit);
                            }
                            textSegments = textSegments.filter(seg => seg.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦|\s]/g, '').length >= 2);
                            if (textSegments.length === 0 && textBeforeFamilyCard.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦|\s]/g, '').length > 0) {
                                textSegments = [textBeforeFamilyCard];
                            }
                            
                            let msgIndex = 0;
                            for (let i = 0; i < textSegments.length; i++) {
                                let seg = textSegments[i];
                                const subParts = splitMessageWithImages(seg);
                                
                                for (const part of subParts) {
                                    history.push(buildCharMessage(part, !!char.foreign_lang_mode, { time: _vNow() + msgIndex }));
                                    await setChatHistory(freshChar, accountId, history);
                                    if (currentChatCharId === targetCharId) {
                                        await appendMessageToUI('char', part, freshChar.avatar);
                                    }
                                    await new Promise(r => setTimeout(r, 300));
                                    msgIndex++;
                                }
                            }
                            await new Promise(r => setTimeout(r, 500));
                        }
                        
                        // 2. å‘é€äº²å±å¡æ¶ˆæ¯
                        const user = await db.characters.get(parseInt(currentMyCharId));
                        
                        // åœ¨è§’è‰²æ•°æ®ä¸­æ·»åŠ "æˆ‘èµ é€çš„"
                        if (!freshChar.identity) freshChar.identity = {};
                        if (!freshChar.identity.familyCardsGiven) freshChar.identity.familyCardsGiven = [];
                        freshChar.identity.familyCardsGiven.push({
                            charId: parseInt(currentMyCharId),
                            monthlyLimit: monthlyLimit,
                            usedThisMonth: 0,
                            records: [],
                            createdAt: Date.now()
                        });
                        // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°äº²å±å¡å­—æ®µ
                        await safeDexieUpdate(db.characters, freshChar.id, {
                            'identity.familyCardsGiven': freshChar.identity.familyCardsGiven
                        }, `äº²å±å¡èµ é€[${freshChar.name}]`);
                        
                        // åœ¨ç”¨æˆ·æ•°æ®ä¸­æ·»åŠ "æˆ‘æ”¶åˆ°çš„"
                        if (user) {
                            if (!user.identity) user.identity = {};
                            if (!user.identity.familyCardsReceived) user.identity.familyCardsReceived = [];
                            user.identity.familyCardsReceived.push({
                                charId: freshChar.id,
                                monthlyLimit: monthlyLimit,
                                usedThisMonth: 0,
                                records: [],
                                createdAt: Date.now()
                            });
                            await safeCharacterPut(user);
                        }
                        
                        // å‘é€äº²å±å¡æ¶ˆæ¯åˆ°èŠå¤©
                        const familyCardMsg = {
                            role: 'char',
                            type: 'familyCard',
                            content: JSON.stringify({
                                fromName: freshChar.name,
                                monthlyLimit: monthlyLimit,
                                status: 'sent'
                            }),
                            time: _vNow()
                        };
                        
                        history = getChatHistory(freshChar, accountId);
                        history.push(familyCardMsg);
                        await setChatHistory(freshChar, accountId, history);
                        
                        if (currentChatCharId === targetCharId) {
                            renderChatBody(freshChar);
                        }
                        
                        showToast(`${freshChar.name} èµ é€äº†äº²å±å¡`);
                        
                        await new Promise(r => setTimeout(r, 500));
                    }
                    
                    // ğŸ”¥ ä¿®å¤ï¼šå¦‚æœäº²å±å¡åè¿˜æœ‰å†…å®¹ï¼Œç»§ç»­å¤„ç†
                    if (textAfterFamilyCard) {
                        console.log('[TriggerAI] äº²å±å¡åè¿˜æœ‰å†…å®¹ï¼Œç»§ç»­å¤„ç†:', textAfterFamilyCard.substring(0, 50));
                        replyText = textAfterFamilyCard;
                        // ç»§ç»­æ‰§è¡Œåç»­çš„æ™®é€šæ¶ˆæ¯å¤„ç†é€»è¾‘ï¼Œä¸è¦return
                    } else {
                        return; // äº²å±å¡å¤„ç†å®Œæˆä¸”æ²¡æœ‰åç»­å†…å®¹
                    }
                }
                
                // ğŸ¯ æ£€æµ‹äº²å¯†å…³ç³»é‚€è¯·å›åº”æŒ‡ä»¤ ((INTIMATE_ACCEPT)) æˆ– ((INTIMATE_REJECT))
                if (_pendingIntimateRequest) {
                    const intimateAccept = /\(\(INTIMATE_ACCEPT\)\)/i.test(replyText);
                    const intimateReject = /\(\(INTIMATE_REJECT\)\)/i.test(replyText);
                    if (intimateAccept || intimateReject) {
                        const accepted = intimateAccept;
                        const newStatus = accepted ? 'accepted' : 'rejected';
                        // ä»å›å¤æ–‡å­—ä¸­ç§»é™¤æŒ‡ä»¤æ ‡è®°
                        replyText = replyText.replace(/\(\(INTIMATE_ACCEPT\)\)/gi, '').replace(/\(\(INTIMATE_REJECT\)\)/gi, '').trim();
                        // æ¸…ç†å¯èƒ½æ®‹ç•™çš„ç©ºåˆ†éš”ç¬¦
                        replyText = replyText.replace(/(\|\|\|)+$/g, '').replace(/^\|\|\|/g, '').replace(/\|\|\|\|\|\|/g, '|||').trim();
                        
                        try {
                            const reqId = _pendingIntimateRequest.id;
                            // æ›´æ–°é‚€è¯·çŠ¶æ€
                            await db.intimate_requests.update(reqId, { status: newStatus });
                            
                            // æ›´æ–°èŠå¤©ä¸­çš„å¡ç‰‡çŠ¶æ€ï¼ˆå†…è”å®ç°ï¼Œé¿å…è·¨ä½œç”¨åŸŸé—®é¢˜ï¼‰
                            const freshChar2 = await db.characters.get(targetCharId);
                            if (freshChar2) {
                                const _irHist = freshChar2.chat_history_by_user?.[accountId] || freshChar2.chat_history || [];
                                let _irUpdated = false;
                                for (let _iri = 0; _iri < _irHist.length; _iri++) {
                                    if (_irHist[_iri].type === 'intimateRequest') {
                                        try {
                                            const _irData = JSON.parse(_irHist[_iri].content);
                                            if (_irData.requestId === String(reqId)) {
                                                _irData.status = newStatus;
                                                _irHist[_iri].content = JSON.stringify(_irData);
                                                _irUpdated = true;
                                            }
                                        } catch(e) {}
                                    }
                                }
                                if (_irUpdated) {
                                    await setChatHistory(freshChar2, accountId, _irHist);
                                }
                            }
                            
                            if (accepted) {
                                // åˆ›å»ºäº²å¯†å…³ç³»
                                await db.intimate_relations.add({
                                    accountId: accountId,
                                    myCharId: parseInt(currentMyCharId),
                                    partnerCharId: targetCharId,
                                    relationType: _pendingIntimateRequest.relationType,
                                    status: 'active',
                                    intimacyValue: 10,
                                    createdAt: Date.now(),
                                    milestones: { created: Date.now() },
                                    messageBoard: [],
                                    customTitle: { my: '', partner: '' },
                                    moodToday: {},
                                    anniversaries: [],
                                    background: ''
                                });
                                const INTIMATE_TYPES_MAP2 = { couple: 'æƒ…ä¾£', bestie: 'é—ºèœœ', bro: 'åŸºå‹', side: 'å°ä¸‰' };
                                const tName = INTIMATE_TYPES_MAP2[_pendingIntimateRequest.relationType] || 'äº²å¯†';
                                sendSystemNotification('äº²å¯†ç©ºé—´', `${char.name} æ¥å—äº†ä½ çš„${tName}å…³ç³»é‚€è¯·ï¼`);
                            } else {
                                const INTIMATE_TYPES_MAP2 = { couple: 'æƒ…ä¾£', bestie: 'é—ºèœœ', bro: 'åŸºå‹', side: 'å°ä¸‰' };
                                const tName = INTIMATE_TYPES_MAP2[_pendingIntimateRequest.relationType] || 'äº²å¯†';
                                sendSystemNotification('äº²å¯†ç©ºé—´', `${char.name} æ‹’ç»äº†ä½ çš„${tName}å…³ç³»é‚€è¯·`);
                            }
                            
                            // åˆ·æ–°äº²å¯†ç©ºé—´ä¸»é¡µ
                            if (typeof window.renderIntimateSpaceMain === 'function') {
                                await window.renderIntimateSpaceMain();
                            }
                            
                            console.log('[TriggerAI] âœ… äº²å¯†å…³ç³»é‚€è¯·å·²å¤„ç†:', newStatus);
                            // å°±åœ°æ›´æ–° DOM ä¸­çš„å¡ç‰‡çŠ¶æ€
                            if (typeof window._updateIntimateCardDOM === 'function') {
                                window._updateIntimateCardDOM(String(reqId), newStatus);
                            }
                            window._needRefreshChatAfterIntimate = true;
                        } catch (e) {
                            console.error('[TriggerAI] å¤„ç†äº²å¯†å…³ç³»é‚€è¯·å¤±è´¥:', e);
                        }
                        _pendingIntimateRequest = null; // å·²å¤„ç†
                    }
                }
                // ğŸ”§ å…œåº•æ¸…ç†ï¼šæ— è®ºæ˜¯å¦æœ‰å¾…å¤„ç†è¯·æ±‚ï¼Œå§‹ç»ˆç§»é™¤æŒ‡ä»¤æ ‡è®°ï¼Œé˜²æ­¢æ³„éœ²åˆ°èŠå¤©
                replyText = replyText.replace(/\(\(INTIMATE_ACCEPT\)\)/gi, '').replace(/\(\(INTIMATE_REJECT\)\)/gi, '').trim();

                // ğŸ¯ æ£€æµ‹è½¬è´¦å›åº”æŒ‡ä»¤ ((TRANSFER_ACCEPT)) æˆ– ((TRANSFER_RETURN))
                if (_pendingTransferMsg) {
                    const tfAccept = /\(\(TRANSFER_ACCEPT\)\)/i.test(replyText);
                    const tfReturn = /\(\(TRANSFER_RETURN\)\)/i.test(replyText);
                    if (tfAccept || tfReturn) {
                        replyText = replyText.replace(/\(\(TRANSFER_ACCEPT\)\)/gi, '').replace(/\(\(TRANSFER_RETURN\)\)/gi, '').trim();
                        replyText = replyText.replace(/(\|\|\|)+$/g, '').replace(/^\|\|\|/g, '').replace(/\|\|\|\|\|\|/g, '|||').trim();
                        try {
                            const freshCharTf = await db.characters.get(targetCharId);
                            if (freshCharTf) {
                                let tfHist = getChatHistory(freshCharTf, accountId);
                                const tfMsg = tfHist[_pendingTransferMsg.index];
                                if (tfMsg && tfMsg.type === 'transfer') {
                                    const tfData = JSON.parse(tfMsg.content);
                                    if (tfData.status === 'sent') {
                                        const newTfStatus = tfAccept ? 'received' : 'returned';
                                        tfData.status = newTfStatus;
                                        tfMsg.content = JSON.stringify(tfData);
                                        if (!tfMsg.id) tfMsg.id = 'trans_' + tfMsg.time;
                                        tfHist[_pendingTransferMsg.index] = tfMsg;
                                        await setChatHistory(freshCharTf, accountId, tfHist);

                                        // å°±åœ°æ›´æ–° DOM ä¸­çš„è½¬è´¦å¡ç‰‡
                                        const tfId = tfMsg.id || ('trans_' + tfMsg.time);
                                        const tfCardEl = document.querySelector(`.transfer-card[data-transfer-id="${tfId}"]`);
                                        if (tfCardEl) {
                                            tfCardEl.classList.add(newTfStatus === 'received' ? 'done' : 'returned');
                                            tfCardEl.setAttribute('onclick', `showTransferConfirm('${tfId}', true, '${newTfStatus}')`);
                                            const tfFooter = tfCardEl.querySelector('.t-footer-text');
                                            if (tfFooter) tfFooter.textContent = newTfStatus === 'received' ? 'å·²æ”¶æ¬¾' : 'å·²é€€å›';
                                        }

                                        if (tfAccept) {
                                            // æ›´æ–°ç”¨æˆ·ä½™é¢ï¼ˆæ‰£æ¬¾ï¼‰
                                            const myAccountId = getCurrentAccountId();
                                            if (myAccountId) {
                                                const userChar = await db.characters.get(parseInt(myAccountId));
                                                if (userChar) {
                                                    let bal = 0;
                                                    if (userChar.identity && typeof userChar.identity.balance !== 'undefined') {
                                                        bal = parseFloat(String(userChar.identity.balance).replace(/,/g, '')) || 0;
                                                    }
                                                    bal -= parseFloat(tfData.amount) || 0;
                                                    if (!userChar.identity) userChar.identity = {};
                                                    userChar.identity.balance = bal.toFixed(2);
                                                    await safeCharacterPut(userChar);
                                                    if (typeof addTransaction === 'function') {
                                                        await addTransaction('expense', tfData.amount, 'å¾®ä¿¡è½¬è´¦', `è½¬è´¦ç»™${char.name}${tfData.desc ? ' - ' + tfData.desc : ''}`);
                                                    }
                                                }

                                                // âœ… è§’è‰²æ”¶å–è½¬è´¦ â†’ è§’è‰²FPé’±åŒ…æ”¶å…¥
                                                await fpWalletTransaction(targetCharId, myAccountId, 'income', parseFloat(tfData.amount), 'è½¬è´¦æ”¶æ¬¾', `æ¥è‡ª${userName}${tfData.desc ? ' - ' + tfData.desc : ''}`);
                                                console.log(`[TriggerAI] âœ… è§’è‰²FPé’±åŒ…æ”¶å…¥ Â¥${tfData.amount}`);
                                            }
                                            sendSystemNotification(char.name, `å·²æ”¶å–ä½ çš„ Â¥${tfData.amount} è½¬è´¦`);
                                        } else {
                                            sendSystemNotification(char.name, `é€€å›äº†ä½ çš„ Â¥${tfData.amount} è½¬è´¦`);
                                        }
                                        console.log('[TriggerAI] âœ… è½¬è´¦å·²å¤„ç†:', tfAccept ? 'accepted' : 'returned', tfData.amount);
                                    }
                                }
                            }
                        } catch (e) {
                            console.error('[TriggerAI] å¤„ç†è½¬è´¦å›åº”å¤±è´¥:', e);
                        }
                        _pendingTransferMsg = null;
                    }
                }
                // ğŸ”§ å…œåº•æ¸…ç†ï¼šå§‹ç»ˆç§»é™¤è½¬è´¦æŒ‡ä»¤æ ‡è®°
                replyText = replyText.replace(/\(\(TRANSFER_ACCEPT\)\)/gi, '').replace(/\(\(TRANSFER_RETURN\)\)/gi, '').trim();

                // ğŸ¯ æ£€æµ‹è´­ç‰©é€ç¤¼æŒ‡ä»¤ ((SHOP_GIFT: é‡‘é¢, å•†å“å))
                const shopGiftMatch2 = replyText.match(/\(\(SHOP_GIFT:\s*(\d+(?:\.\d+)?)(?:,\s*(.+?))?\)\)/i);
                if (shopGiftMatch2) {
                    const giftAmount = parseFloat(shopGiftMatch2[1]);
                    let giftProduct = shopGiftMatch2[2] || 'è´­ç‰©ç¤¼ç‰©';
                    if (giftProduct.length > 30) giftProduct = giftProduct.substring(0, 30);

                    const textBefore = replyText.substring(0, shopGiftMatch2.index).trim();
                    const textAfter = replyText.substring(shopGiftMatch2.index + shopGiftMatch2[0].length).trim();

                    const freshChar = await db.characters.get(targetCharId);
                    if (freshChar) {
                        let history = getChatHistory(freshChar, accountId);

                        // 1. å…ˆå‘é€å‰ç½®æ–‡å­—
                        if (textBefore) {
                            let segs = [];
                            const txt = textBefore.replace(/[,ï¼Œ]/g, ' ');
                            if (txt.includes('|||')) {
                                segs = txt.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                            } else {
                                segs = splitMessage(txt);
                            }
                            segs = segs.filter(s => s.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦|\s]/g, '').length >= 2);
                            if (segs.length === 0 && textBefore.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦|\s]/g, '').length > 0) segs = [textBefore];

                            let msgIdx = 0;
                            for (let i = 0; i < segs.length; i++) {
                                const subParts = splitMessageWithImages(segs[i]);
                                for (const part of subParts) {
                                    history.push(buildCharMessage(part, !!char.foreign_lang_mode, { time: _vNow() + msgIdx }));
                                    await setChatHistory(freshChar, accountId, history);
                                    if (currentChatCharId === targetCharId) {
                                        await appendMessageToUI('char', part, freshChar.avatar);
                                    }
                                    await new Promise(r => setTimeout(r, 300));
                                    msgIdx++;
                                }
                            }
                            await new Promise(r => setTimeout(r, 500));
                        }

                        // 2. å‘é€è´­ç‰©ç¤¼ç‰©å¡ç‰‡
                        const cardData = {
                            amount: giftAmount.toFixed(2),
                            items: giftProduct,
                            buyForName: '',
                            installmentInfo: '',
                            isGift: true,
                            status: 'paid'
                        };
                        const giftMsg = {
                            role: 'char',
                            type: 'shopPayRequest',
                            content: JSON.stringify(cardData),
                            time: _vNow()
                        };

                        history = getChatHistory(freshChar, accountId);
                        history.push(giftMsg);
                        await setChatHistory(freshChar, accountId, history);

                        console.log(`[TriggerAI] è§’è‰²å‘é€è´­ç‰©ç¤¼ç‰©: ${freshChar.name}`, { giftAmount, giftProduct });

                        if (currentChatCharId === targetCharId) {
                            if (window._appendShopCardToChat) {
                                await window._appendShopCardToChat(freshChar.id, giftMsg);
                            }
                        } else {
                            sendSystemNotification(freshChar.name, '[è´­ç‰©ç¤¼ç‰©]');
                        }

                        // âœ… è§’è‰²è´­ç‰©é€ç¤¼ â†’ è§’è‰²FPé’±åŒ…æ”¯å‡º
                        const sgWalletAccId2 = getCurrentAccountId();
                        if (sgWalletAccId2) {
                            await fpWalletTransaction(targetCharId, sgWalletAccId2, 'expense', giftAmount, 'è´­ç‰©é€ç¤¼', giftProduct, true);
                            console.log(`[TriggerAI] âœ… è§’è‰²FPé’±åŒ…æ”¯å‡º(é€ç¤¼) Â¥${giftAmount.toFixed(2)}`);
                        }

                        await new Promise(r => setTimeout(r, 500));
                    }

                    if (textAfter) {
                        replyText = textAfter;
                    } else {
                        return;
                    }
                }

                // ğŸ¯ æ£€æµ‹å¤–å–å¡ç‰‡æŒ‡ä»¤ ((EMEI_ORDER: åº—é“º, å•†å“, é‡‘é¢)) / ((EMEI_PAY: ...)) / ((EMEI_SHARE: ...))
                // ğŸ”§ å®¹é”™é¢„å¤„ç†ï¼šä¿®å¤å¸¸è§çš„æ ¼å¼é”™è¯¯ï¼ˆç¼ºå°‘é€—å·åˆ†éš”ç¬¦ï¼‰
                replyText = replyText.replace(/\(\(EMEI_(ORDER|PAY|SHARE):\s*(.+?)\)\)/gi, (fullMatch, type, content) => {
                    // æ£€æŸ¥é€—å·æ•°é‡ï¼šæ­£ç¡®æ ¼å¼åº”è¯¥æœ‰2ä¸ªé€—å·ï¼ˆåº—é“º, å•†å“, é‡‘é¢ï¼‰
                    const commaCount = (content.match(/,/g) || []).length;
                    if (commaCount >= 2) {
                        return fullMatch; // æ ¼å¼æ­£ç¡®ï¼Œä¸å¤„ç†
                    }
                    
                    // å°è¯•è‡ªåŠ¨ä¿®å¤ï¼šæŸ¥æ‰¾æœ€åçš„æ•°å­—ä½œä¸ºæ€»é‡‘é¢ï¼Œå€’æ•°ç¬¬äºŒä¸ª xæ•°å­— Â¥æ•°å­— ä¹‹å‰çš„å†…å®¹ä½œä¸ºåº—é“ºå
                    const fixMatch = content.match(/^(.+?)\s+(.*?\s+x\d+\s+Â¥[\d.]+.*?)\s+(\d+(?:\.\d+)?)$/);
                    if (fixMatch) {
                        console.log(`[TriggerAI] ğŸ”§ è‡ªåŠ¨ä¿®å¤å¤–å–æ ¼å¼: ${fullMatch} -> ((EMEI_${type}: ${fixMatch[1].trim()}, ${fixMatch[2].trim()}, ${fixMatch[3]}))`);
                        return `((EMEI_${type}: ${fixMatch[1].trim()}, ${fixMatch[2].trim()}, ${fixMatch[3]}))`;
                    }
                    
                    console.warn(`[TriggerAI] âš ï¸ å¤–å–æ ¼å¼æ— æ³•è‡ªåŠ¨ä¿®å¤: ${fullMatch}`);
                    return fullMatch; // æ— æ³•ä¿®å¤ï¼Œä¿æŒåŸæ ·ï¼ˆåç»­ä¼šåŒ¹é…å¤±è´¥ï¼‰
                });
                
                // ğŸ”„ ä¿®å¤ï¼šä½¿ç”¨ while å¾ªç¯å¤„ç†å¤šæ¡å¤–å–æŒ‡ä»¤
                let emeiOrderMatch = replyText.match(/\(\(EMEI_ORDER:\s*(.+?),\s*(.+?),\s*(\d+(?:\.\d+)?)\)\)/i);
                let emeiPayMatch = replyText.match(/\(\(EMEI_PAY:\s*(.+?),\s*(.+?),\s*(\d+(?:\.\d+)?)\)\)/i);
                let emeiShareMatch = replyText.match(/\(\(EMEI_SHARE:\s*(.+?),\s*(.+?),\s*(\d+(?:\.\d+)?)\)\)/i);
                let emeiMatch = emeiOrderMatch || emeiPayMatch || emeiShareMatch;
                
                while (emeiMatch) {
                    const emeiType = emeiOrderMatch ? 'order' : (emeiPayMatch ? 'pay' : 'share');
                    const emeiStore = emeiMatch[1].trim();
                    const emeiItems = emeiMatch[2].trim();
                    const emeiTotal = parseFloat(emeiMatch[3]);
                    
                    // æå–å¤–å–æŒ‡ä»¤å‰é¢çš„æ–‡å­—å†…å®¹
                    const textBeforeEmei = replyText.substring(0, emeiMatch.index).trim();
                    // ğŸ”¥ ä¿®å¤ï¼šæå–å¤–å–åé¢çš„æ–‡å­—å†…å®¹
                    const textAfterEmei = replyText.substring(emeiMatch.index + emeiMatch[0].length).trim();
                    
                    const freshChar = await db.characters.get(targetCharId);
                    if (freshChar) {
                        let history = getChatHistory(freshChar, accountId);
                        
                        // 1. å…ˆå‘é€æ–‡å­—æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰ï¼‰
                        if (textBeforeEmei) {
                            let textSegments = [];
                            const textToSplit = textBeforeEmei.replace(/[,ï¼Œ]/g, ' ');
                            if (textToSplit.includes('|||')) {
                                textSegments = textToSplit.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                            } else {
                                textSegments = splitMessage(textToSplit);
                            }
                            textSegments = textSegments.filter(seg => seg.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦|\s]/g, '').length >= 2);
                            if (textSegments.length === 0 && textBeforeEmei.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦|\s]/g, '').length > 0) {
                                textSegments = [textBeforeEmei];
                            }
                            
                            let msgIndex = 0;
                            for (let i = 0; i < textSegments.length; i++) {
                                let seg = textSegments[i];
                                const subParts = splitMessageWithImages(seg);
                                
                                for (const part of subParts) {
                                    history.push(buildCharMessage(part, !!char.foreign_lang_mode, { time: _vNow() + msgIndex }));
                                    await setChatHistory(freshChar, accountId, history);
                                    if (currentChatCharId === targetCharId) {
                                        await appendMessageToUI('char', part, freshChar.avatar);
                                    }
                                    await new Promise(r => setTimeout(r, 300));
                                    msgIndex++;
                                }
                            }
                            await new Promise(r => setTimeout(r, 500));
                        }
                        
                        // 2. æ„å»ºå°ç¥¨é£æ ¼å¡ç‰‡HTML
                        const emeiItemList = emeiItems.split(/[/\/ã€]/).map(item => item.trim());
                        const emeiItemsHtml = emeiItemList.map(item => {
                            // ğŸ”¥ æ–°å¢ï¼šæ”¯æŒè§£æå¸¦å•ä»·çš„æ ¼å¼ "å•†å“å xæ•°é‡ Â¥å•ä»·" æˆ– "å•†å“å Â¥å•ä»·"
                            let itemName = item;
                            let itemPrice = '';
                            
                            // å°è¯•åŒ¹é…æ–°æ ¼å¼ï¼šå•†å“å xæ•°é‡ Â¥å•ä»·
                            const priceMatch = item.match(/^(.+?)\s+x(\d+)\s+Â¥([\d.]+)$/);
                            if (priceMatch) {
                                itemName = `${priceMatch[1]} x${priceMatch[2]}`;
                                itemPrice = parseFloat(priceMatch[3]).toFixed(2);
                            } else {
                                // å°è¯•åŒ¹é…ï¼šå•†å“å Â¥å•ä»·ï¼ˆæ— æ•°é‡ï¼‰
                                const priceMatch2 = item.match(/^(.+?)\s+Â¥([\d.]+)$/);
                                if (priceMatch2) {
                                    itemName = priceMatch2[1];
                                    itemPrice = parseFloat(priceMatch2[2]).toFixed(2);
                                } else {
                                    // æ—§æ ¼å¼ï¼ˆæ— å•ä»·ä¿¡æ¯ï¼‰ï¼Œä½¿ç”¨å¹³å‡ä»·æ ¼
                                    itemPrice = (emeiTotal / emeiItemList.length).toFixed(2);
                                }
                            }
                            
                            return `<div style="display:flex;justify-content:space-between;margin-bottom:6px;font-size:13px;"><span style="color:#333;font-weight:600;">${itemName}</span><span style="font-family:Arial,sans-serif;">Â¥${itemPrice}</span></div>`;
                        }).join('');
                        
                        let emeiTitle, emeiHint, emeiBtnHtml, emeiTag;
                        if (emeiType === 'order') {
                            emeiTitle = `${emeiStore} Â· ç»™ä½ ç‚¹çš„`;
                            emeiHint = `${freshChar.name}ç»™ä½ ç‚¹äº†å¤–å–~`;
                            emeiBtnHtml = '';
                            emeiTag = 'emei_order';
                        } else if (emeiType === 'pay') {
                            emeiTitle = `${emeiStore} Â· ä»£ä»˜è¯·æ±‚`;
                            emeiHint = 'å¸®æˆ‘ä»˜ä¸€ä¸‹å¤–å–~';
                            emeiBtnHtml = `<div onclick="handlePaymentRequest(this)" data-amount="${emeiTotal.toFixed(2)}" data-pay-type="user_pay" style="display:block;width:100%;padding:10px;background:#ff4d4f;color:white;text-align:center;border-radius:4px;font-family:sans-serif;font-weight:bold;letter-spacing:1px;cursor:pointer;box-sizing:border-box;margin-top:4px;">å¸®TAæ”¯ä»˜</div>`;
                            emeiTag = 'payment_request';
                        } else {
                            emeiTitle = `ğŸ›µ ${emeiStore} Â· å¤–å–åˆ†äº«`;
                            emeiHint = 'æˆ‘åˆšç‚¹äº†å¤–å– åˆ†äº«ç»™ä½ çœ‹çœ‹~';
                            emeiBtnHtml = '';
                            emeiTag = 'emei_share';
                        }
                        
                        const emeiCardHtml = `<div style="width:260px;background:#fff;padding:16px;box-shadow:0 4px 15px rgba(0,0,0,0.1);position:relative;font-family:'Courier New',Courier,monospace;box-sizing:border-box;"><div style="position:absolute;top:-5px;left:0;width:100%;height:10px;background:linear-gradient(135deg,transparent 5px,#fff 5px) 0 0,linear-gradient(225deg,transparent 5px,#fff 5px) 0 0;background-size:20px 20px;background-repeat:repeat-x;"></div><div style="position:absolute;bottom:-10px;left:0;width:100%;height:10px;background:linear-gradient(45deg,transparent 5px,#fff 5px) 0 0,linear-gradient(-45deg,transparent 5px,#fff 5px) 0 0;background-size:20px 20px;background-repeat:repeat-x;"></div><div style="text-align:center;font-weight:800;font-size:16px;color:#333;margin-bottom:5px;border-bottom:2px dashed #ddd;padding-bottom:12px;">${emeiTitle}</div><div style="text-align:center;font-size:12px;color:#888;margin:8px 0;">${emeiHint}</div><div style="margin:12px 0;font-size:13px;color:#555;">${emeiItemsHtml}</div><div style="border-top:1px dashed #ccc;margin:12px 0;"></div><div style="display:flex;justify-content:space-between;font-size:16px;font-weight:900;color:#000;margin-bottom:8px;"><span>åˆè®¡</span><span style="font-family:Arial,sans-serif;${emeiType === 'pay' ? 'color:#ff4d4f;' : ''}">Â¥${emeiTotal.toFixed(2)}</span></div>${emeiBtnHtml}<div style="text-align:center;font-size:10px;color:#aaa;margin-top:10px;font-family:Arial,sans-serif;">${new Date().toLocaleString('zh-CN')}</div></div>`;
                        
                        // 3. å‘é€å¡ç‰‡æ¶ˆæ¯
                        const emeiCardMsg = {
                            role: 'char',
                            content: `[${emeiTag}]${emeiCardHtml}`,
                            time: _vNow()
                        };
                        history = getChatHistory(freshChar, accountId);
                        history.push(emeiCardMsg);
                        await setChatHistory(freshChar, accountId, history);
                        
                        if (currentChatCharId === targetCharId) {
                            renderChatBody(freshChar);
                        } else {
                            const tagNames = { 'emei_order': 'å¤–å–è®¢å•', 'payment_request': 'ä»£ä»˜è¯·æ±‚', 'emei_share': 'å¤–å–åˆ†äº«' };
                            sendSystemNotification(freshChar.name, `[${tagNames[emeiTag]}]`);
                        }
                        
                        showToast(`${freshChar.name} å‘é€äº†${emeiType === 'order' ? 'å¤–å–è®¢å•' : emeiType === 'pay' ? 'ä»£ä»˜è¯·æ±‚' : 'å¤–å–åˆ†äº«'}`);
                        
                        await new Promise(r => setTimeout(r, 500));
                    }
                    
                    // ğŸ”„ ä¿®å¤ï¼šæ›´æ–° replyText å¹¶é‡æ–°åŒ¹é…å¤–å–æŒ‡ä»¤ï¼ˆæ”¯æŒè¿ç»­å¤„ç†å¤šæ¡å¤–å–ï¼‰
                    if (textAfterEmei) {
                        console.log('[TriggerAI] å¤–å–åè¿˜æœ‰å†…å®¹ï¼Œç»§ç»­æ£€æŸ¥æ˜¯å¦æœ‰æ›´å¤šå¤–å–æŒ‡ä»¤:', textAfterEmei.substring(0, 50));
                        replyText = textAfterEmei.trim();
                        // ğŸ”§ æ¸…ç†å¼€å¤´çš„åˆ†éš”ç¬¦ï¼ˆé¿å… ||| è¢«å½“æˆæ–‡æœ¬å‘é€ï¼‰
                        while (replyText.startsWith('|||')) {
                            replyText = replyText.substring(3).trim();
                        }
                        // é‡æ–°åŒ¹é…å¤–å–æŒ‡ä»¤
                        emeiOrderMatch = replyText.match(/\(\(EMEI_ORDER:\s*(.+?),\s*(.+?),\s*(\d+(?:\.\d+)?)\)\)/i);
                        emeiPayMatch = replyText.match(/\(\(EMEI_PAY:\s*(.+?),\s*(.+?),\s*(\d+(?:\.\d+)?)\)\)/i);
                        emeiShareMatch = replyText.match(/\(\(EMEI_SHARE:\s*(.+?),\s*(.+?),\s*(\d+(?:\.\d+)?)\)\)/i);
                        emeiMatch = emeiOrderMatch || emeiPayMatch || emeiShareMatch;
                        
                        if (!emeiMatch) {
                            // æ²¡æœ‰æ›´å¤šå¤–å–æŒ‡ä»¤äº†ï¼Œè·³å‡ºå¾ªç¯ç»§ç»­å¤„ç†æ™®é€šæ¶ˆæ¯
                            console.log('[TriggerAI] æ²¡æœ‰æ›´å¤šå¤–å–æŒ‡ä»¤ï¼Œç»§ç»­å¤„ç†å‰©ä½™å†…å®¹');
                            break;
                        }
                    } else {
                        // å¤–å–å¤„ç†å®Œæˆä¸”æ²¡æœ‰åç»­å†…å®¹
                        console.log('[TriggerAI] å¤–å–å¤„ç†å®Œæˆï¼Œæ²¡æœ‰åç»­å†…å®¹');
                        return;
                    }
                }
                
                // ğŸ¯ æ£€æµ‹æœ‹å‹åœˆå‘å¸ƒæŒ‡ä»¤ [MOMENTS] - æ”¯æŒå¤šç§æ ¼å¼
                // æ ¼å¼1: [MOMENTS] content: xxx images: N
                let momentsMatch = replyText.match(/\[MOMENTS\]\s*content:\s*([^\n]+)(?:\s*images?:\s*(\d+))?/i);
                // æ ¼å¼2: ((MOMENTS: å†…å®¹))
                if (!momentsMatch) {
                    momentsMatch = replyText.match(/\(\(MOMENTS:\s*(.+?)\)\)/i);
                    if (momentsMatch) {
                        momentsMatch = [momentsMatch[0], momentsMatch[1], '0'];
                    }
                }
                // æ ¼å¼3: ã€æœ‹å‹åœˆï¼šå†…å®¹ã€‘
                if (!momentsMatch) {
                    momentsMatch = replyText.match(/ã€æœ‹å‹åœˆ[ï¼š:]\s*(.+?)ã€‘/);
                    if (momentsMatch) {
                        momentsMatch = [momentsMatch[0], momentsMatch[1], '0'];
                    }
                }
                
                if (momentsMatch) {
                    let momentContent = momentsMatch[1].trim();
                    let imageCount = momentsMatch[2] ? parseInt(momentsMatch[2]) : 0;
                    let imageDesc = '';
                    
                    // ğŸ”¥ ä¿®å¤ï¼šæå– [imgcard:] ä½œä¸ºæœ‹å‹åœˆé…å›¾æè¿°
                    const afterMoments = replyText.substring(momentsMatch.index + momentsMatch[0].length);
                    const imgcardMatch = afterMoments.match(/\[imgcard:([^\]]+)\]/i);
                    if (imgcardMatch) {
                        imageDesc = imgcardMatch[1].trim();
                        if (imageCount === 0) imageCount = 1; // æœ‰å›¾ç‰‡æè¿°åˆ™è‡³å°‘1å¼ 
                        console.log(`[TriggerAI] æå–åˆ°æœ‹å‹åœˆé…å›¾æè¿°: ${imageDesc}`);
                    }
                    // ä¹Ÿæ£€æŸ¥ content ä¸­æ˜¯å¦å†…åµŒäº† [imgcard:]
                    const contentImgcard = momentContent.match(/\[imgcard:([^\]]+)\]/i);
                    if (contentImgcard) {
                        imageDesc = imageDesc || contentImgcard[1].trim();
                        momentContent = momentContent.replace(/\[imgcard:[^\]]+\]/gi, '').trim();
                        if (imageCount === 0) imageCount = 1;
                    }
                    // ä¹Ÿä» MOMENTS ä¹‹å‰çš„æ–‡æœ¬ä¸­æå–ï¼ˆAIæœ‰æ—¶æŠŠimgcardæ”¾å‰é¢ï¼‰
                    const beforeMoments = replyText.substring(0, momentsMatch.index);
                    const beforeImgcard = beforeMoments.match(/\[imgcard:([^\]]+)\]/i);
                    if (beforeImgcard && !imageDesc) {
                        imageDesc = beforeImgcard[1].trim();
                        if (imageCount === 0) imageCount = 1;
                    }
                    
                    // æå–æœ‹å‹åœˆæŒ‡ä»¤å‰é¢çš„æ–‡å­—å†…å®¹ï¼ˆå¦‚æœæœ‰ï¼‰
                    let textBeforeMoments = replyText.substring(0, momentsMatch.index).trim();
                    // æ¸…ç†æ‰ [imgcard:] éƒ¨åˆ†ï¼Œä¸è¦ä½œä¸ºèŠå¤©æ¶ˆæ¯å‘é€
                    textBeforeMoments = textBeforeMoments.replace(/\[imgcard:[^\]]+\]/gi, '').trim();
                    
                    // ğŸ”¥ ä¿®å¤ï¼šæå–æœ‹å‹åœˆåé¢çš„æ–‡å­—å†…å®¹
                    let textAfterMoments = afterMoments.replace(/\[imgcard:[^\]]+\]/gi, '').trim();
                    
                    const freshChar = await db.characters.get(targetCharId);
                    if (freshChar) {
                        let history = getChatHistory(freshChar, accountId);
                        
                        // 1. å…ˆå‘é€æ–‡å­—æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰ï¼‰- ğŸ”¥ ä¿®å¤ï¼šæŒ‰ ||| åˆ†å‰²å¤šæ¡æ¶ˆæ¯ï¼Œé¿å…æ ¼å¼ä¸¢å¤±
                        if (textBeforeMoments) {
                            const msgSegments = textBeforeMoments.split('|||')
                                .map(s => cleanMessage(s.trim()))
                                .filter(s => s && s.length > 0);
                            
                            console.log(`[TriggerAI] æœ‹å‹åœˆå‰æ–‡å­—æŒ‰|||åˆ†å‰²ä¸º ${msgSegments.length} æ¡æ¶ˆæ¯`);
                            
                            let msgIndex = 0;
                            for (let i = 0; i < msgSegments.length; i++) {
                                // ğŸ”§ æ‹†åˆ†åŒ…å«å›¾ç‰‡çš„æ¶ˆæ¯ï¼ˆç¡®ä¿è¡¨æƒ…åŒ…å•ç‹¬æ˜¾ç¤ºï¼‰
                                const subParts = splitMessageWithImages(msgSegments[i]);
                                
                                for (const part of subParts) {
                                    const textMsg = buildCharMessage(part, !!char.foreign_lang_mode, { time: _vNow() + msgIndex });
                                    history.push(textMsg);
                                    await setChatHistory(freshChar, accountId, history);
                                    
                                    // æ¸²æŸ“æ–‡å­—æ¶ˆæ¯
                                    if (currentChatCharId === targetCharId) {
                                        appendMessageToUI('char', part, freshChar.avatar);
                                    }
                                    msgIndex++;
                                }
                                
                                // æ¶ˆæ¯é—´å»¶æ—¶ï¼ˆæ¨¡æ‹Ÿè¿å‘ï¼‰
                                if (i < msgSegments.length - 1) {
                                    await new Promise(r => setTimeout(r, 300 + Math.random() * 400));
                                }
                            }
                            
                            // ç¨å¾®å»¶æ—¶å†å‘æœ‹å‹åœˆ
                            await new Promise(r => setTimeout(r, 500));
                        }
                        
                        // 2. å‘å¸ƒæœ‹å‹åœˆï¼ˆä¼ å…¥å›¾ç‰‡æè¿°ï¼‰
                        await publishMomentsByCharacter(freshChar, momentContent, imageCount, imageDesc);
                        
                        console.log(`[TriggerAI] ${freshChar.name} å‘å¸ƒäº†æœ‹å‹åœˆ${imageDesc ? ` [é…å›¾: ${imageDesc}]` : ''}`);
                        
                        // å‘é€é€šçŸ¥
                        sendSystemNotification(freshChar.name, '[æœ‹å‹åœˆ]');
                        
                        await new Promise(r => setTimeout(r, 500));
                    }
                    
                    // ğŸ”¥ ä¿®å¤ï¼šå¦‚æœæœ‹å‹åœˆåè¿˜æœ‰å†…å®¹ï¼Œç»§ç»­å¤„ç†
                    if (textAfterMoments) {
                        console.log('[TriggerAI] æœ‹å‹åœˆåè¿˜æœ‰å†…å®¹ï¼Œç»§ç»­å¤„ç†:', textAfterMoments.substring(0, 50));
                        replyText = textAfterMoments;
                        // ç»§ç»­æ‰§è¡Œåç»­çš„æ™®é€šæ¶ˆæ¯å¤„ç†é€»è¾‘ï¼Œä¸è¦return
                    } else {
                        return; // æœ‹å‹åœˆå¤„ç†å®Œæˆä¸”æ²¡æœ‰åç»­å†…å®¹
                    }
                }
                
                // ğŸ¯ æ£€æµ‹"å¹»è§‰"ï¼šAIè¯´å‘äº†æœ‹å‹åœˆä½†æ²¡æœ‰æŒ‡ä»¤
                const hasMomentsClaim = /å‘äº†.*?æœ‹å‹åœˆ|æœ‹å‹åœˆ.*?å‘äº†|å‘å¸ƒ.*?åŠ¨æ€|æ›´æ–°.*?æœ‹å‹åœˆ|å‘ä¸ªæœ‹å‹åœˆ/i.test(replyText);
                if (hasMomentsClaim) {
                    console.warn(`[TriggerAI] âš ï¸ AIå¹»è§‰æ£€æµ‹ï¼šè§’è‰²è¯´å‘äº†æœ‹å‹åœˆï¼Œä½†æ²¡æœ‰è¿”å›æ­£ç¡®çš„æŒ‡ä»¤æ ¼å¼ï¼`);
                    console.warn(`[TriggerAI] æ­£ç¡®æ ¼å¼ç¤ºä¾‹ï¼š[MOMENTS] content: å†…å®¹ images: 1`);
                    showToast(`è§’è‰²è¯´å‘äº†æœ‹å‹åœˆï¼Œä½†æ ¼å¼ä¸å¯¹ï¼Œæœªå®é™…å‘å¸ƒ`);
                }
                
                // ğŸ¯ æ£€æµ‹"å¹»è§‰"ï¼šAIè¯´å‘äº†çº¢åŒ…/è½¬è´¦ä½†æ²¡æœ‰æŒ‡ä»¤
                const hasTransferClaim = /å‘.*?çº¢åŒ…|çº¢åŒ….*?å‘|ç»™ä½ .*?è½¬|è½¬.*?ç»™ä½ |å‘ä¸ªçº¢åŒ…|å‘äº†.*?çº¢åŒ…|çº¢åŒ….*?æ”¶|æ”¶.*?çº¢åŒ…/i.test(replyText);
                if (hasTransferClaim) {
                    console.warn(`[TriggerAI] âš ï¸ AIå¹»è§‰æ£€æµ‹ï¼šè§’è‰²è¯´å‘äº†çº¢åŒ…/è½¬è´¦ï¼Œä½†æ²¡æœ‰è¿”å›æ­£ç¡®çš„ ((TRANSFER: é‡‘é¢, å¤‡æ³¨)) æ ¼å¼ï¼`);
                    showToast(`è§’è‰²è¯´å‘äº†çº¢åŒ…ï¼Œä½†æ ¼å¼ä¸å¯¹ï¼Œæœªå®é™…å‘é€`);
                }
                
                // å…œåº•ï¼šæ£€æµ‹æ˜¯å¦æ˜¯è½¬è´¦ JSONï¼ˆå…¼å®¹æ—§æ ¼å¼ï¼‰
                let trimmedReply = replyText.trim();
                if (trimmedReply.startsWith('{') && trimmedReply.includes('"amount"')) {
                    try {
                        const parsed = JSON.parse(trimmedReply);
                        if (parsed.amount && parsed.desc !== undefined && parsed.status) {
                            const freshChar = await db.characters.get(targetCharId);
                            if (freshChar) {
                                let history = getChatHistory(freshChar, accountId);
                                
                                const newMsg = { 
                                    role: 'char', 
                                    type: 'transfer',
                                    content: trimmedReply, 
                                    time: _vNow(),
                                    id: 'trans_' + _vNow()
                                };
                                
                                history.push(newMsg);
                                await setChatHistory(freshChar, accountId, history);
                                
                                if (currentChatCharId === targetCharId) {
                                    renderChatBody(freshChar);
                                } else {
                                    sendSystemNotification(freshChar.name, '[è½¬è´¦]');
                                }
                            }
                            return;
                        }
                    } catch(e) {
                        // ä¸æ˜¯æœ‰æ•ˆçš„ JSONï¼Œç»§ç»­å½“æ™®é€šæ¶ˆæ¯
                    }
                }
                
                // 4. æ™®é€šæ¶ˆæ¯ï¼šå¼ºåˆ¶æ¸…æ´—é€—å· + æ‹†åˆ†
                // ğŸ”§ ä¿®å¤ä¸å®Œæ•´çš„è¡¨æƒ…åŒ…æ ‡ç­¾ï¼ˆç»Ÿä¸€æ ¼å¼ï¼Œè¡¥å…¨ç¼ºå°‘çš„å³æ‹¬å·ï¼‰
                replyText = replyText.replace(/\[sticker:(\d+)\]?/g, '[sticker:$1]');
                console.log('[TriggerAI] ğŸ”§ ä¿®å¤ä¸å®Œæ•´çš„è¡¨æƒ…åŒ…æ ‡ç­¾å:', replyText);
                
                // âœ… æ¸…æ´—é€—å·ï¼Œä½†ä¿æŠ¤ç¿»è¯‘æ‹¬å·å’ŒæŒ‡ä»¤å†…å®¹
                let cleanText;
                if (char.foreign_lang_mode) {
                    // å¤–è¯­ç¿»è¯‘æ¨¡å¼ï¼šå…ˆä¿æŠ¤ç¿»è¯‘æ‹¬å·å’ŒæŒ‡ä»¤ï¼Œå†æ›¿æ¢é€—å·ï¼Œå†æ¢å¤
                    const bracketPlaceholders = [];
                    let bpIndex = 0;
                    cleanText = replyText.replace(/\(\([A-Z_]+:[^)]*\)\)/gi, (match) => {
                        const ph = `###BRACKET_${bpIndex}###`;
                        bracketPlaceholders[bpIndex] = match;
                        bpIndex++;
                        return ph;
                    });
                    cleanText = cleanText.replace(/[ï¼ˆ(]([^ï¼‰)]*[\u4e00-\u9fff][^ï¼‰)]*)[ï¼‰)]/g, (match) => {
                        const ph = `###BRACKET_${bpIndex}###`;
                        bracketPlaceholders[bpIndex] = match;
                        bpIndex++;
                        return ph;
                    });
                    cleanText = cleanText.replace(/[,ï¼Œ]/g, ' ');
                    cleanText = cleanText.replace(/###BRACKET_(\d+)###/g, (_, idx) => bracketPlaceholders[parseInt(idx)] || _);
                } else {
                    // ğŸ”§ å…ˆä¿æŠ¤ ((...)) æŒ‡ä»¤å†…çš„é€—å·ï¼ˆå¦‚ QUOTEã€POKEã€TRANSFER ç­‰ï¼‰ï¼Œå†æ›¿æ¢æ™®é€šé€—å·
                    const cmdPlaceholders = [];
                    let cmdIdx = 0;
                    cleanText = replyText.replace(/\(\([A-Z_]+:[^)]*\)\)/gi, (match) => {
                        const ph = `###CMD_${cmdIdx}###`;
                        cmdPlaceholders[cmdIdx] = match;
                        cmdIdx++;
                        return ph;
                    });
                    cleanText = cleanText.replace(/[,ï¼Œ]/g, ' ');
                    cleanText = cleanText.replace(/###CMD_(\d+)###/g, (_, idx) => cmdPlaceholders[parseInt(idx)] || _);
                }
                let segments = [];
                
                // è°ƒè¯•æ—¥å¿—ï¼šæ£€æŸ¥åˆ†å‰²å‰çš„å†…å®¹
                console.log('[TriggerAI] ğŸ“ å‡†å¤‡åˆ†å‰²æ¶ˆæ¯');
                console.log('[TriggerAI] - åŸå§‹replyText:', replyText);
                console.log('[TriggerAI] - cleanText:', cleanText);
                console.log('[TriggerAI] - æ˜¯å¦åŒ…å«|||:', cleanText.includes('|||'));
                console.log('[TriggerAI] - ||| çš„ä½ç½®:', cleanText.indexOf('|||'));
                
                // ğŸ”¥ å¢å¼ºï¼šä¼˜å…ˆä½¿ç”¨ ||| æ‹†åˆ†ï¼Œå¹¶è¿›è¡Œæ›´ä¸¥æ ¼çš„æ¸…ç†
                if (cleanText.includes('|||')) {
                    segments = cleanText.split('|||')
                        .map(s => {
                            let cleaned = s.trim();
                            
                            // å¯¹æ¯æ¡æ¶ˆæ¯å†æ¬¡æ¸…ç†æŸ¥å²—æŒ‡ä»¤æ®‹ç•™
                            cleaned = cleanMessage(cleaned)
                                .replace(/\[CHECK_ACCOUNT(?::.*?)?\]/gi, '')
                                .replace(/\[CHECK_ACCOUNT:[^\]]*$/gi, '')
                                .replace(/\[CHECK_ACCOUNT$/gi, '')
                                .replace(/\[\d{4,10}$/gi, '')
                                .replace(/CHECK_ACCOUNT/gi, '')
                                .trim();
                            
                            // ğŸ”¥ å¢å¼ºï¼šå¦‚æœå•æ¡æ¶ˆæ¯è¿‡é•¿ï¼Œå°è¯•æ™ºèƒ½åˆ†å‰²
                            if (cleaned.length > 60 && !cleaned.startsWith('[') && !cleaned.startsWith('((')) {
                                if (char.foreign_lang_mode) {
                                    // âœ… å¤–è¯­ç¿»è¯‘æ¨¡å¼ï¼šä¼˜å…ˆæŒ‰æ¢è¡Œæ‹†åˆ†ï¼Œæ¯è¡Œæ˜¯å®Œæ•´çš„ã€Œå¤–è¯­ï¼ˆç¿»è¯‘ï¼‰ã€
                                    if (cleaned.includes('\n')) {
                                        const lines = cleaned.split('\n').map(l => l.trim()).filter(l => l.length > 0);
                                        if (lines.length > 1) {
                                            console.log(`[TriggerAI] ğŸŒ å¤–è¯­ç¿»è¯‘æ¨¡å¼ï¼šæŒ‰æ¢è¡Œæ‹†åˆ†ä¸º${lines.length}æ¡`);
                                            return lines;
                                        }
                                    }
                                    // æ²¡æœ‰æ¢è¡Œç¬¦åˆ™ä¿æŒä¸ºå•æ¡æ¶ˆæ¯ï¼Œä¸åšæ ‡ç‚¹æ‹†åˆ†
                                } else if (cleaned.length > 100) {
                                    // éç¿»è¯‘æ¨¡å¼ï¼šä½¿ç”¨åŸæœ‰çš„æ™ºèƒ½åˆ†å‰²
                                    const withoutTranslation = cleaned.replace(/[ï¼ˆ(][^ï¼‰)]*[\u4e00-\u9fff][^ï¼‰)]*[ï¼‰)]/g, '');
                                    const naturalBreaks = withoutTranslation.match(/[^ã€‚ï¼ï¼Ÿ!?]+[ã€‚ï¼ï¼Ÿ!?]+/g);
                                    if (naturalBreaks && naturalBreaks.length > 1) {
                                        const smartSegments = smartSplitWithTranslation(cleaned);
                                        if (smartSegments.length > 1) {
                                            console.log(`[TriggerAI] âš ï¸ å•æ¡æ¶ˆæ¯è¿‡é•¿(${cleaned.length}å­—)ï¼Œæ™ºèƒ½åˆ†å‰²ä¸º${smartSegments.length}æ¡`);
                                            return smartSegments;
                                        }
                                    }
                                }
                            }
                            
                            return cleaned;
                        })
                        .flat() // å±•å¹³å¯èƒ½çš„åµŒå¥—æ•°ç»„
                        .filter(s => s && s.length > 0);
                    
                    console.log('[TriggerAI] âœ… ä½¿ç”¨|||åˆ†å‰²ï¼Œå¾—åˆ°', segments.length, 'æ¡æ¶ˆæ¯');
                    segments.forEach((seg, i) => console.log(`  [${i}]: ${seg.substring(0, 50)}${seg.length > 50 ? '...' : ''}`));
                } else {
                    // å›é€€åˆ°æ ‡ç‚¹æ‹†åˆ†é€»è¾‘ (ä½†é€—å·å·²ç»è¢«å¹²æ‰äº†)
                    if (char.foreign_lang_mode) {
                        // âœ… å¤–è¯­ç¿»è¯‘æ¨¡å¼ï¼šä¼˜å…ˆæŒ‰æ¢è¡Œæ‹†åˆ†ï¼Œä¿æŠ¤æ¯è¡Œçš„ã€Œå¤–èªï¼ˆç¿»è¯‘ï¼‰ã€æ ¼å¼
                        if (cleanText.includes('\n')) {
                            segments = cleanText.split('\n').map(s => s.trim()).filter(s => s.length > 0);
                            console.log('[TriggerAI] â„¹ï¸ å¤–è¯­ç¿»è¯‘æ¨¡å¼ï¼šæŒ‰æ¢è¡Œæ‹†åˆ†ï¼Œå¾—åˆ°', segments.length, 'æ¡æ¶ˆæ¯');
                        } else {
                            // æ²¡æœ‰æ¢è¡Œä¹Ÿæ²¡æœ‰|||ï¼Œä¿æŒä¸ºå•æ¡æ¶ˆæ¯
                            segments = [cleanText.trim()];
                            console.log('[TriggerAI] â„¹ï¸ å¤–è¯­ç¿»è¯‘æ¨¡å¼ï¼šæ— åˆ†éš”ç¬¦ï¼Œä¿æŒå•æ¡æ¶ˆæ¯');
                        }
                    } else {
                        segments = splitMessage(cleanText);
                        console.log('[TriggerAI] â„¹ï¸ æœªæ‰¾åˆ°|||ï¼Œä½¿ç”¨æ ‡ç‚¹åˆ†å‰²ï¼Œå¾—åˆ°', segments.length, 'æ¡æ¶ˆæ¯');
                    }
                }
                
                // ğŸ”¥ å¢å¼ºï¼šå¦‚æœåˆ†å‰²åçš„æ¶ˆæ¯å¤ªå°‘ä½†æ€»é•¿åº¦å¾ˆé•¿ï¼Œå¼ºåˆ¶å†æ¬¡åˆ†å‰²
                // âœ… å¤–è¯­ç¿»è¯‘æ¨¡å¼ä¸‹ä¸å¼ºåˆ¶æ‹†åˆ†ï¼Œä¿æŠ¤ç¿»è¯‘æ ¼å¼å®Œæ•´
                if (segments.length === 1 && segments[0].length > 150 && !char.foreign_lang_mode) {
                    console.log('[TriggerAI] âš ï¸ åªæœ‰1æ¡æ¶ˆæ¯ä½†é•¿åº¦è¿‡é•¿(', segments[0].length, ')ï¼Œå¼ºåˆ¶æ™ºèƒ½åˆ†å‰²');
                    const longMsg = segments[0];
                    // âœ… ä¿®å¤ï¼šä½¿ç”¨ä¸ç ´åç¿»è¯‘æ‹¬å·çš„æ™ºèƒ½åˆ†å‰²
                    const smartSegments = smartSplitWithTranslation(longMsg);
                    if (smartSegments.length > 1) {
                        segments = smartSegments;
                        console.log('[TriggerAI] âœ… å¼ºåˆ¶åˆ†å‰²ä¸º', segments.length, 'æ¡');
                    }
                }
                
                // å…œåº•ï¼šå¦‚æœæ²¡æ‹†å‡ºæ¥ï¼Œä½†æœ‰å†…å®¹ï¼Œå°±å½“æˆä¸€æ¡
                if (segments.length === 0 && cleanText.trim()) {
                    segments.push(cleanMessage(cleanText.trim()));
                }
                
                

                for (let i = 0; i < segments.length; i++) {
                    let seg = segments[i];
                    
                    // ğŸ¯ æ£€æµ‹æ¢å¤´åƒæŒ‡ä»¤ ((CHANGE_AVATAR)) - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    if (/\(\(CHANGE_AVATAR\)\)/i.test(seg)) {
                        console.log(`[AiReply] æ£€æµ‹åˆ°æ¢å¤´åƒæŒ‡ä»¤ï¼Œæ‰§è¡Œæ¢å¤´åƒ...`);
                        try {
                            await executeChangeAvatar(targetCharId, accountId);
                        } catch (e) {
                            console.error('[AiReply] æ¢å¤´åƒå¤±è´¥:', e);
                        }
                        // ç§»é™¤æŒ‡ä»¤æ–‡æœ¬ï¼Œä¿ç•™å…¶ä»–å†…å®¹
                        seg = seg.replace(/\(\(CHANGE_AVATAR\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æƒ…å¤´é‚€è¯·æŒ‡ä»¤ ((COUPLE_AVATAR)) - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    if (/\(\(COUPLE_AVATAR\)\)/i.test(seg)) {
                        console.log(`[AiReply] æ£€æµ‹åˆ°æƒ…å¤´é‚€è¯·æŒ‡ä»¤...`);
                        try {
                            await sendCoupleAvatarCard(targetCharId, accountId);
                        } catch (e) {
                            console.error('[AiReply] å‘é€æƒ…å¤´é‚€è¯·å¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(COUPLE_AVATAR\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æ¢å›å•äººå¤´åƒæŒ‡ä»¤ ((REVERT_COUPLE_AVATAR)) - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    if (/\(\(REVERT_COUPLE_AVATAR\)\)/i.test(seg)) {
                        console.log(`[AiReply] æ£€æµ‹åˆ°æ¢å›å•äººå¤´åƒæŒ‡ä»¤...`);
                        try {
                            await executeRevertCoupleAvatar(targetCharId, accountId);
                        } catch (e) {
                            console.error('[AiReply] æ¢å›å•äººå¤´åƒå¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(REVERT_COUPLE_AVATAR\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹ä½¿ç”¨å›¾ç‰‡å½“å¤´åƒæŒ‡ä»¤ ((USE_IMAGE_AS_AVATAR: N)) - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    const useImgMatchReply = seg.match(/\(\(USE_IMAGE_AS_AVATAR(?::\s*(\d+))?\)\)/i);
                    if (useImgMatchReply) {
                        const imgIdx = useImgMatchReply[1] ? parseInt(useImgMatchReply[1]) : 1;
                        console.log(`[AiReply] æ£€æµ‹åˆ°ä½¿ç”¨å›¾ç‰‡å½“å¤´åƒæŒ‡ä»¤ï¼Œé€‰æ‹©ç¬¬${imgIdx}å¼ ...`);
                        try {
                            await executeUseImageAsAvatar(targetCharId, accountId, imgIdx);
                        } catch (e) {
                            console.error('[AiReply] ä½¿ç”¨å›¾ç‰‡å½“å¤´åƒå¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(USE_IMAGE_AS_AVATAR(?::\s*\d+)?\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æ¥ç”µæŒ‡ä»¤ ((CALL)) - è§’è‰²ä¸»åŠ¨ç»™ç”¨æˆ·æ‰“ç”µè¯
                    if (/\(\(CALL\)\)/i.test(seg)) {
                        console.log(`[AiReply] ğŸ“ æ£€æµ‹åˆ°æ¥ç”µæŒ‡ä»¤ ((CALL))`);
                        try {
                            const callFirstMsg = seg.replace(/\(\(CALL\)\)/gi, '').trim();
                            if (!_incomingCallCharId) {
                                await showIncomingCall(targetCharId, callFirstMsg || '');
                            }
                        } catch (e) {
                            console.error('[AiReply] æ¥ç”µå¤„ç†å¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(CALL\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æˆ³ä¸€æˆ³æŒ‡ä»¤ ((POKE: åŠ¨ä½œ, éƒ¨ä½)) - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    const pokeMatchReply = seg.match(/\(\(POKE:\s*(.+?)\)\)/i);
                    if (pokeMatchReply) {
                        console.log(`[AiReply] æ£€æµ‹åˆ°æˆ³ä¸€æˆ³æŒ‡ä»¤...`);
                        try {
                            const pokeContent = pokeMatchReply[1].trim();
                            let pokeAction, pokePart;
                            if (pokeContent.includes(',') || pokeContent.includes('ï¼Œ')) {
                                const parts = pokeContent.split(/[,ï¼Œ]/);
                                pokeAction = parts[0].trim();
                                pokePart = parts.slice(1).join('').trim();
                            } else {
                                const spaceIdx = pokeContent.indexOf(' ');
                                if (spaceIdx > 0) {
                                    pokeAction = pokeContent.substring(0, spaceIdx).trim();
                                    pokePart = pokeContent.substring(spaceIdx + 1).trim();
                                } else {
                                    pokeAction = pokeContent;
                                    pokePart = '';
                                }
                            }
                            const freshChar = await db.characters.get(targetCharId);
                            const myChar = accountId ? await db.characters.get(parseInt(accountId)) : null;
                            const userName = myChar ? (myChar.nick || myChar.name) : 'ç”¨æˆ·';
                            const pokeText = pokePart ? `${freshChar.name}${pokeAction}${userName}çš„${pokePart}` : `${freshChar.name}${pokeAction}${userName}`;
                            
                            let history = getChatHistory(freshChar, accountId);
                            history.push({ role: 'system', content: pokeText, time: _vNow(), type: 'poke' });
                            await setChatHistory(freshChar, accountId, history);
                            
                            if (currentChatCharId === targetCharId) {
                                await appendMessageToUI('system', pokeText);
                            }
                            console.log(`[AiReply] æˆ³ä¸€æˆ³: ${pokeText}`);
                        } catch (e) {
                            console.error('[AiReply] æˆ³ä¸€æˆ³å¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(POKE:\s*(.+?)\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æ‰“å¼€APPæŒ‡ä»¤ ((OPEN_APP: APPåç§°)) - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    const appMatchReply = seg.match(/\(\(OPEN_APP:\s*(.+?)\)\)/i);
                    if (appMatchReply) {
                        console.log(`[AiReply] æ£€æµ‹åˆ°æ‰“å¼€APPæŒ‡ä»¤...`);
                        try {
                            const appName = appMatchReply[1].trim();
                            const freshChar = await db.characters.get(targetCharId);
                            const appText = `${freshChar.name} æ‰“å¼€äº† "${appName}"`;
                            
                            let history = getChatHistory(freshChar, accountId);
                            history.push({ role: 'system', content: appText, time: _vNow(), type: 'open_app' });
                            await setChatHistory(freshChar, accountId, history);
                            
                            if (currentChatCharId === targetCharId) {
                                await appendMessageToUI('system', appText);
                            }
                            console.log(`[AiReply] æ‰“å¼€APP: ${appText}`);
                        } catch (e) {
                            console.error('[AiReply] æ‰“å¼€APPå¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(OPEN_APP:\s*(.+?)\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æ”¹ç½‘åæŒ‡ä»¤ ((SET_NICKNAME: æ–°ç½‘å)) - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    const nicknameMatchReply = seg.match(/\(\(SET_NICKNAME:\s*(.+?)\)\)/i);
                    if (nicknameMatchReply) {
                        console.log(`[AiReply] æ£€æµ‹åˆ°æ”¹ç½‘åæŒ‡ä»¤...`);
                        try {
                            const newNickname = nicknameMatchReply[1].trim();
                            const freshChar = await db.characters.get(targetCharId);
                            const oldNickname = getCharWxNickname(freshChar, accountId) || freshChar.name;
                            // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°ç½‘åå­—æ®µï¼Œé˜²æ­¢è¦†ç›–è®¾ç½®
                            const nnPayloadR = accountId
                                ? { [`wx_nickname_by_user.${accountId}`]: newNickname }
                                : { wx_nickname: newNickname };
                            await safeDexieUpdate(db.characters, targetCharId, nnPayloadR, `æ”¹ç½‘å[${freshChar.name}]`);
                            setCharWxNickname(freshChar, accountId, newNickname);
                            
                            const nicknameText = `${oldNickname} å°†ç½‘åæ”¹ä¸º "${newNickname}"`;
                            let history = getChatHistory(freshChar, accountId);
                            history.push({ role: 'system', content: nicknameText, time: _vNow(), type: 'set_nickname' });
                            await setChatHistory(freshChar, accountId, history);
                            
                            if (currentChatCharId === targetCharId) {
                                await appendMessageToUI('system', nicknameText);
                                if (!freshChar.remark) {
                                    document.getElementById('chat-title').innerText = newNickname;
                                }
                                const nicknameEl = document.getElementById('detail-char-nickname');
                                if (nicknameEl) nicknameEl.innerText = newNickname;
                            }
                            console.log(`[AiReply] æ”¹ç½‘å: ${nicknameText}`);
                        } catch (e) {
                            console.error('[AiReply] æ”¹ç½‘åå¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(SET_NICKNAME:\s*(.+?)\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æ”¹ä¸ªæ€§ç­¾åæŒ‡ä»¤ ((SET_SIGNATURE: æ–°ç­¾å)) - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    const signatureMatchReply = seg.match(/\(\(SET_SIGNATURE:\s*(.+?)\)\)/i);
                    if (signatureMatchReply) {
                        console.log(`[AiReply] æ£€æµ‹åˆ°æ”¹ä¸ªæ€§ç­¾åæŒ‡ä»¤...`);
                        try {
                            const newSignature = signatureMatchReply[1].trim();
                            const freshChar = await db.characters.get(targetCharId);
                            // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°ç­¾åå­—æ®µï¼Œé˜²æ­¢è¦†ç›–è®¾ç½®
                            await safeDexieUpdate(db.characters, targetCharId, { wx_signature: newSignature }, `æ”¹ç­¾å[${freshChar.name}]`);
                            freshChar.wx_signature = newSignature;
                            
                            const sigText = `${freshChar.wx_nickname || freshChar.name} æ›´æ–°äº†ä¸ªæ€§ç­¾å: "${newSignature}"`;
                            let history = getChatHistory(freshChar, accountId);
                            history.push({ role: 'system', content: sigText, time: _vNow(), type: 'set_signature' });
                            await setChatHistory(freshChar, accountId, history);
                            
                            if (currentChatCharId === targetCharId) {
                                await appendMessageToUI('system', sigText);
                                const sigEl = document.getElementById('detail-char-signature');
                                if (sigEl) sigEl.innerText = newSignature;
                            }
                            console.log(`[AiReply] æ”¹ç­¾å: ${sigText}`);
                        } catch (e) {
                            console.error('[AiReply] æ”¹ç­¾åå¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(SET_SIGNATURE:\s*(.+?)\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹åˆ é™¤å¥½å‹æŒ‡ä»¤ ((DELETE_USER)) - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    if (/\(\(DELETE_USER\)\)/i.test(seg)) {
                        console.log(`[AiReply] æ£€æµ‹åˆ°è§’è‰²åˆ é™¤ç”¨æˆ·æŒ‡ä»¤...`);
                        try {
                            await executeCharDeleteUser(targetCharId, accountId);
                        } catch (e) {
                            console.error('[AiReply] è§’è‰²åˆ é™¤ç”¨æˆ·å¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(DELETE_USER\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æ‹‰é»‘å¥½å‹æŒ‡ä»¤ ((BLOCK_USER)) - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    if (/\(\(BLOCK_USER\)\)/i.test(seg)) {
                        console.log(`[AiReply] æ£€æµ‹åˆ°è§’è‰²æ‹‰é»‘ç”¨æˆ·æŒ‡ä»¤...`);
                        try {
                            await executeCharBlockUser(targetCharId, accountId);
                        } catch (e) {
                            console.error('[AiReply] è§’è‰²æ‹‰é»‘ç”¨æˆ·å¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(BLOCK_USER\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹NPCåŠ å¥½å‹æŒ‡ä»¤ ((NPC_ADD_FRIEND: NPCåå­—)) - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    const npcAddMatchReply = seg.match(/\(\(NPC_ADD_FRIEND:\s*(.+?)\s*\)\)/i);
                    if (npcAddMatchReply) {
                        const npcName = npcAddMatchReply[1].trim();
                        console.log(`[AiReply] æ£€æµ‹åˆ°NPCåŠ å¥½å‹æŒ‡ä»¤: ${npcName}`);
                        try {
                            await executeNpcAddFriend(char, npcName, accountId);
                        } catch (e) {
                            console.error('[AiReply] NPCåŠ å¥½å‹å¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(NPC_ADD_FRIEND:\s*.+?\s*\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æ’¤å›æŒ‡ä»¤ - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    if (/^\s*\(\(RECALL\)\)\s*$/i.test(seg)) {
                        console.log(`[AiReply] æ£€æµ‹åˆ°æ’¤å›æŒ‡ä»¤ï¼Œæ‰§è¡Œæ’¤å›...`);
                        const freshChar = await db.characters.get(targetCharId);
                        if (freshChar) {
                            let history = getChatHistory(freshChar, accountId);
                            
                            // æ‰¾AIæœ€åä¸€æ¡æ¶ˆæ¯ï¼ˆéæ’¤å›çŠ¶æ€ï¼‰
                            let targetIndex = -1;
                            for (let j = history.length - 1; j >= 0; j--) {
                                if (history[j].role === 'char' && !history[j].isRecalled) {
                                    targetIndex = j;
                                    break;
                                }
                            }
                            
                            if (targetIndex >= 0) {
                                const originalContent = history[targetIndex].content;
                                history[targetIndex].recalledContent = originalContent;
                                history[targetIndex].isRecalled = true;
                                history[targetIndex].content = "";
                                await setChatHistory(freshChar, accountId, history);
                                
                                console.log(`[AiReply] ${freshChar.name} æ’¤å›äº†æ¶ˆæ¯`);
                                
                                // æ›´æ–°UI - å±…ä¸­ç³»ç»Ÿæç¤ºæ ·å¼
                                if (currentChatCharId === targetCharId) {
                                    const chatBody = document.getElementById('chat-body');
                                    const messageRows = chatBody.querySelectorAll('.message-row');
                                    if (messageRows[targetIndex]) {
                                        const msgRow = messageRows[targetIndex];
                                        msgRow.className = 'message-row recalled-system-row';
                                        msgRow.innerHTML = '';
                                        
                                        const capturedContent = originalContent;
                                        const capturedName = freshChar.name;
                                        const systemTip = document.createElement('div');
                                        systemTip.className = 'recalled-system-tip';
                                        systemTip.innerHTML = `"${capturedName}"æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯`;
                                        systemTip.style.cursor = 'pointer';
                                        systemTip.onclick = (e) => {
                                            e.stopPropagation();
                                            showRecalledContent(capturedName, capturedContent);
                                        };
                                        msgRow.appendChild(systemTip);
                                    }
                                }
                                
                                sendSystemNotification(freshChar.name, 'æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯');
                            }
                        }
                        continue; // è·³è¿‡è¿™ä¸ªåˆ†æ®µï¼Œä¸ä½œä¸ºæ¶ˆæ¯å‘é€
                    }
                    
                    // ğŸ¯ æ£€æµ‹è¡¨æƒ…åŒ…æŒ‡ä»¤ [sticker:æè¿°/ç¼–å·] - åœ¨åˆ†æ®µä¸­æ£€æµ‹å¹¶æ›¿æ¢ä¸ºå®é™…è¡¨æƒ…åŒ…å›¾ç‰‡
                    if (/\[sticker:[^\]]+\]/i.test(seg)) {
                        if (_mountedStickersList.length > 0) {
                            seg = seg.replace(/\[sticker:([^\]]+)\]/gi, (match, keyword) => {
                                const stickerKeyword = keyword.trim();
                                console.log(`[AiReply] æ£€æµ‹åˆ°è¡¨æƒ…åŒ…æŒ‡ä»¤: ${stickerKeyword}`);
                                
                                // ğŸ”¢ ä¼˜å…ˆï¼šæŒ‰ç¼–å·åŒ¹é…ï¼ˆAIç”¨ [sticker:1] æ ¼å¼ï¼‰
                                const numMatch = stickerKeyword.match(/^\d+$/);
                                if (numMatch) {
                                    const idx = parseInt(numMatch[0]) - 1; // ç¼–å·ä»1å¼€å§‹
                                    if (idx >= 0 && idx < _mountedStickersList.length) {
                                        console.log(`[AiReply] âœ… æŒ‰ç¼–å·åŒ¹é…åˆ°è¡¨æƒ…åŒ… #${idx + 1}: ${_mountedStickersList[idx].description}`);
                                        return `[img:${_mountedStickersList[idx].url}]`;
                                    }
                                }
                                
                                // ğŸ”¢ å°è¯•ä»æ–‡æœ¬ä¸­æå–æ•°å­—ï¼ˆå¦‚ "ç¼–å·3"ã€"ç¬¬3ä¸ª"ï¼‰
                                const numInText = stickerKeyword.match(/(\d+)/);
                                if (numInText) {
                                    const idx = parseInt(numInText[1]) - 1;
                                    if (idx >= 0 && idx < _mountedStickersList.length) {
                                        console.log(`[AiReply] âœ… ä»æ–‡æœ¬æå–ç¼–å·åŒ¹é…åˆ°è¡¨æƒ…åŒ… #${idx + 1}: ${_mountedStickersList[idx].description}`);
                                        return `[img:${_mountedStickersList[idx].url}]`;
                                    }
                                }
                                
                                // ğŸ“ å…¶æ¬¡ï¼šæŒ‰æè¿°æ¨¡ç³ŠåŒ¹é…
                                const stickerKeywordLower = stickerKeyword.toLowerCase();
                                let bestMatch = null;
                                let bestScore = 0;
                                
                                for (const s of _mountedStickersList) {
                                    const desc = s.description.toLowerCase();
                                    // å®Œå…¨åŒ¹é…
                                    if (desc === stickerKeywordLower) {
                                        bestMatch = s;
                                        bestScore = 100;
                                        break;
                                    }
                                    // æè¿°åŒ…å«å…³é”®è¯
                                    if (desc.includes(stickerKeywordLower) && stickerKeywordLower.length > 1) {
                                        const score = stickerKeywordLower.length / desc.length * 80;
                                        if (score > bestScore) { bestMatch = s; bestScore = score; }
                                    }
                                    // å…³é”®è¯åŒ…å«æè¿°
                                    if (stickerKeywordLower.includes(desc) && desc.length > 1) {
                                        const score = desc.length / stickerKeywordLower.length * 70;
                                        if (score > bestScore) { bestMatch = s; bestScore = score; }
                                    }
                                    // å…³é”®è¯çš„éƒ¨åˆ†è¯åŒ¹é…ï¼ˆæ¯ä¸ªå­—éƒ½å°è¯•ï¼‰
                                    const keywords = stickerKeywordLower.split(/[\s,ï¼Œã€]+/).filter(k => k.length > 0);
                                    let matchCount = 0;
                                    for (const kw of keywords) {
                                        if (desc.includes(kw)) matchCount++;
                                    }
                                    if (matchCount > 0) {
                                        const score = matchCount / keywords.length * 60;
                                        if (score > bestScore) { bestMatch = s; bestScore = score; }
                                    }
                                    // å•å­—ç¬¦åŒ¹é…ï¼ˆé’ˆå¯¹ä¸­æ–‡ï¼šé€å­—æ£€æŸ¥ï¼‰
                                    if (bestScore < 30) {
                                        let charMatch = 0;
                                        for (const ch of stickerKeywordLower) {
                                            if (desc.includes(ch)) charMatch++;
                                        }
                                        if (charMatch > 0 && stickerKeywordLower.length > 0) {
                                            const score = charMatch / stickerKeywordLower.length * 40;
                                            if (score > bestScore) { bestMatch = s; bestScore = score; }
                                        }
                                    }
                                }
                                
                                if (bestMatch && bestScore >= 15) {
                                    console.log(`[AiReply] âœ… åŒ¹é…åˆ°è¡¨æƒ…åŒ…: ${bestMatch.description} (å¾—åˆ†: ${bestScore})`);
                                    return `[img:${bestMatch.url}]`;
                                } else {
                                    // æ²¡æ‰¾åˆ°åŒ¹é…ï¼Œéšæœºé€‰ä¸€ä¸ª
                                    const randomSticker = _mountedStickersList[Math.floor(Math.random() * _mountedStickersList.length)];
                                    console.log(`[AiReply] âš ï¸ AIæé€ äº†è¡¨æƒ…åŒ…"${stickerKeyword}"ï¼Œéšæœºé€‰æ‹©: ${randomSticker.description}`);
                                    return `[img:${randomSticker.url}]`;
                                }
                            });
                        } else {
                            // æ²¡æœ‰æŒ‚è½½è¡¨æƒ…åŒ…ä½†AIä»ç„¶è¾“å‡ºäº†[sticker:]ï¼Œæ¸…é™¤æ‰
                            console.log(`[AiReply] âš ï¸ è§’è‰²æ²¡æœ‰æŒ‚è½½è¡¨æƒ…åŒ…ï¼Œä½†AIè¾“å‡ºäº†[sticker:]ï¼Œæ¸…é™¤`);
                            seg = seg.replace(/\[sticker:[^\]]+\]/gi, '').trim();
                            if (!seg) continue; // å¦‚æœæ¸…é™¤åä¸ºç©ºï¼Œè·³è¿‡æ­¤æ®µ
                        }
                    }
                    
                    // ğŸ¯ æ£€æµ‹å¼•ç”¨æ¶ˆæ¯æŒ‡ä»¤ ((QUOTE: åå­—, å†…å®¹)) - åœ¨å›å¤åˆ†æ®µä¸­æ£€æµ‹
                    let quoteInfoReply = null;
                    const quoteMatchReply = seg.match(/\(\(QUOTE:\s*(.+?)\s*[,ï¼Œ]\s*(.+?)\s*\)\)/i);
                    if (quoteMatchReply) {
                        quoteInfoReply = { name: quoteMatchReply[1].trim(), content: quoteMatchReply[2].trim() };
                        seg = seg.replace(/\(\(QUOTE:\s*(.+?)\s*[,ï¼Œ]\s*(.+?)\s*\)\)/gi, '').trim();
                        if (!seg) continue;
                        console.log(`[AiReply] æ£€æµ‹åˆ°å¼•ç”¨æ¶ˆæ¯æŒ‡ä»¤: å¼•ç”¨ ${quoteInfoReply.name}: ${quoteInfoReply.content}`);
                    }
                    
                    // ğŸ”§ ä¿®å¤ï¼šæ‹†åˆ†åŒ…å«å›¾ç‰‡çš„æ¶ˆæ¯ï¼ˆç¡®ä¿è¡¨æƒ…åŒ…/å›¾ç‰‡å•ç‹¬æ˜¾ç¤ºï¼‰
                    // å¦‚æœsegä¸­æ··åˆäº†æ–‡å­—å’Œ[img:]ï¼Œéœ€è¦æ‹†åˆ†æˆå¤šä¸ªå­æ¶ˆæ¯
                    const subParts = splitMessageWithImages(seg);
                    
                    for (let subIdx = 0; subIdx < subParts.length; subIdx++) {
                        const part = subParts[subIdx];
                        if (!part || !part.trim()) continue;
                        
                        // å»¶æ—¶ï¼šç¬¬ä¸€æ¡ç›´æ¥å‘(å‰é¢loadingå·²ç»æ˜¯ç­‰å¾…äº†)ï¼Œåç»­æ¨¡æ‹Ÿæ‰“å­—
                        if (i > 0 || subIdx > 0) {
                            const delay = 500 + Math.min(part.length * 80, 3000);
                            await new Promise(r => setTimeout(r, delay));
                        }

                        // å§‹ç»ˆå­˜å…¥ DB
                        const freshChar = await db.characters.get(targetCharId);
                        if (freshChar) {
                            let history = getChatHistory(freshChar, accountId);
                            
                            // âœ… ä½¿ç”¨ buildCharMessage ä¸€æ¬¡æ€§è§£æç¿»è¯‘ï¼Œå­˜å‚¨ç»“æ„åŒ–æ•°æ®
                            // ğŸ”¥ ä¿®å¤ï¼šç¬¬ä¸€æ¡æ¶ˆæ¯æ—¶ä¼ å…¥ thoughtï¼ˆå¿ƒå£°ï¼‰
                            const extraFields = { time: _vNow() };
                            if (thought && i === 0 && subIdx === 0) {
                                extraFields.thought = thought;
                                // ğŸ”¥ åŒæ—¶å°† thought ä¿å­˜åˆ° char.thoughts æ•°ç»„ä¸­ï¼ˆç”¨äºæ˜¾ç¤ºå¿ƒå£°ï¼‰
                                if (!freshChar.thoughts) freshChar.thoughts = [];
                                freshChar.thoughts.push({
                                    content: thought,
                                    time: _vNow()
                                });
                                // ğŸ”§ ä¿®å¤æ•°æ®ä¸¢å¤±ï¼šä½¿ç”¨ update() åªæ›´æ–° thoughts å­—æ®µï¼Œé¿å…è¦†ç›–å¹¶å‘å†™å…¥çš„èŠå¤©è®°å½•
                                await db.characters.update(targetCharId, {
                                    thoughts: freshChar.thoughts
                                });
                            }
                            const newMsg = buildCharMessage(part, !!char.foreign_lang_mode, extraFields);
                            // âœ… é™„åŠ å¼•ç”¨ä¿¡æ¯åˆ°ç¬¬ä¸€ä¸ªå­æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰ï¼‰
                            if (quoteInfoReply && subIdx === 0) newMsg.quote = quoteInfoReply;
                            
                            history.push(newMsg);
                            await setChatHistory(freshChar, accountId, history);
                            
                            // åªæœ‰åœ¨å½“å‰çª—å£åŒ¹é…æ—¶æ‰æ¸²æŸ“ UI
                            if (currentChatCharId === targetCharId) {
                                console.log(`[AiReply] User is viewing ${freshChar.name}'s chat, appending to UI`);
                                showDebugToast(`AIå›å¤: æ­£åœ¨æŸ¥çœ‹${freshChar.name}ï¼Œæ˜¾ç¤ºåœ¨UI`);
                                appendMessageToUI('char', part, freshChar.avatar);
                            } else {
                                // ä¸åœ¨å½“å‰çª—å£æ—¶ï¼Œå‘é€ç³»ç»Ÿé€šçŸ¥
                                console.log(`[AiReply] User is NOT viewing ${freshChar.name}'s chat (current: ${currentChatCharId}), sending notification`);
                                showDebugToast(`AIå›å¤: ä¸åœ¨${freshChar.name}èŠå¤©ä¸­(å½“å‰:${currentChatCharId})ï¼Œå‘é€é€šçŸ¥`);
                                sendSystemNotification(freshChar.name, part);
                            }
                        }
                    }
                }
                
                // âœ… AIå›å¤å®Œæˆåï¼Œæ£€æµ‹ imgcard å¹¶è°ƒç”¨ NovelAI è‡ªåŠ¨ç”Ÿå›¾
                try {
                    await processImgCardsWithNovelAI(targetCharId, accountId);
                } catch (naiError) {
                    console.error('[NovelAI-AutoGen] å¤„ç† imgcard å¤±è´¥:', naiError);
                }
                
                // â˜… AIå›å¤æˆåŠŸåï¼Œæ ‡è®°æŸ¥æ‰‹æœºæ´»åŠ¨ä¸ºå·²é€šçŸ¥ï¼ˆä»DBåŠ è½½æœ€æ–°æ•°æ®å†æ ‡è®°ï¼Œé¿å…è¦†ç›–ï¼‰
                if (_fpHasPhoneActivity) {
                    try {
                        const freshCharForFp = await db.characters.get(targetCharId);
                        if (freshCharForFp) {
                            let markedCount = 0;
                            // æ ‡è®°fp_npc_æ¶ˆæ¯
                            if (freshCharForFp.chat_history_by_user) {
                                for (const key of Object.keys(freshCharForFp.chat_history_by_user)) {
                                    if (!key.startsWith('fp_npc_')) continue;
                                    const npcHistory = freshCharForFp.chat_history_by_user[key] || [];
                                    for (const m of npcHistory) {
                                        if ((m.fpSent || (!m.fpSent && m.role === 'user')) && !m.fpNotified) {
                                            m.fpNotified = true;
                                            markedCount++;
                                        }
                                    }
                                }
                            }
                            // æ ‡è®°æœ‹å‹åœˆ
                            if (freshCharForFp.fp_moments_by_user) {
                                for (const mKey of Object.keys(freshCharForFp.fp_moments_by_user)) {
                                    const momentsList = freshCharForFp.fp_moments_by_user[mKey] || [];
                                    for (const m of momentsList) {
                                        if (m.fpSent && !m.fpNotified) {
                                            m.fpNotified = true;
                                            markedCount++;
                                        }
                                    }
                                }
                            }
                            // ğŸ”§ ä¿®å¤æ•°æ®ä¸¢å¤±ï¼šä½¿ç”¨ update() åªæ›´æ–°æ ‡è®°å­—æ®µï¼Œé¿å…è¦†ç›–å¹¶å‘å†™å…¥çš„èŠå¤©è®°å½•
                            const fpUpdatePayload = {};
                            if (freshCharForFp.chat_history_by_user) {
                                fpUpdatePayload.chat_history_by_user = freshCharForFp.chat_history_by_user;
                            }
                            if (freshCharForFp.fp_moments_by_user) {
                                fpUpdatePayload.fp_moments_by_user = freshCharForFp.fp_moments_by_user;
                            }
                            // ğŸ”§ åªæœ‰çœŸæ­£æœ‰æ–°æ ‡è®°çš„æ¶ˆæ¯æ—¶æ‰æ›´æ–°DBå’Œå†™å…¥è®°å¿†
                            if (markedCount > 0) {
                                await db.characters.update(targetCharId, fpUpdatePayload);
                                console.log('[triggerAiReply] âœ… æŸ¥æ‰‹æœºæ´»åŠ¨å·²æ ‡è®°ä¸ºå·²é€šçŸ¥ï¼Œå…±æ ‡è®°', markedCount, 'æ¡');
                            
                                // â˜… å°†æŸ¥æ‰‹æœºäº‹ä»¶å†™å…¥é•¿æœŸè®°å¿†ï¼Œç¡®ä¿è§’è‰²æ°¸ä¹…è®°ä½æ­¤äº‹ï¼ˆä»…é¦–æ¬¡é€šçŸ¥æ—¶å†™å…¥ï¼‰
                                try {
                                    const fpMemoryContent = `${userName}å·å·æ‹¿äº†${char.name}çš„æ‰‹æœºï¼Œåšäº†ä»¥ä¸‹äº‹æƒ…ï¼š${_fpNpcLinesForMemory.map(l => l.trim().replace(/^[â†’â†]\s*/, '')).join('ï¼›')}ã€‚${char.name}å·²ç»å‘ç°å¹¶åšå‡ºäº†ååº”ã€‚`;
                                    await db.chat_summaries.add({
                                        accountId: accountId,
                                        chatType: 'private',
                                        chatId: String(targetCharId),
                                        time: Date.now(),
                                        content: fpMemoryContent,
                                        messageCount: 0,
                                        timeRange: '',
                                        keywords: ['æŸ¥æ‰‹æœº', 'å†’å……', 'æ‰‹æœºè¢«åŠ¨'],
                                        startTime: Date.now(),
                                        endTime: Date.now()
                                    });
                                    console.log('[triggerAiReply] âœ… æŸ¥æ‰‹æœºäº‹ä»¶å·²å†™å…¥é•¿æœŸè®°å¿†');
                                } catch (memErr) {
                                    console.warn('[triggerAiReply] å†™å…¥æŸ¥æ‰‹æœºé•¿æœŸè®°å¿†å¤±è´¥:', memErr);
                                }
                            } else {
                                console.log('[triggerAiReply] â„¹ï¸ æŸ¥æ‰‹æœºæ´»åŠ¨å·²å…¨éƒ¨é€šçŸ¥è¿‡ï¼Œè·³è¿‡é‡å¤å†™å…¥é•¿æœŸè®°å¿†');
                            }
                        }
                    } catch (fpErr) {
                        console.warn('[triggerAiReply] æ ‡è®°fpNotifiedå¤±è´¥:', fpErr);
                    }
                }
                
                // âœ… AIå›å¤å®Œæˆåï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦è‡ªåŠ¨æ€»ç»“
                try {
                    await checkAutoSummary('private', targetCharId, accountId);
                } catch (summaryError) {
                    console.error('[AutoSummary] æ£€æŸ¥è‡ªåŠ¨æ€»ç»“å¤±è´¥:', summaryError);
                }
                
            } catch (err) {
                console.error("AI å›å¤å¤±è´¥", err);
                if (chatTitleEl) chatTitleEl.innerText = originalTitle;
                
                // ä½¿ç”¨å¼¹çª—æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯ï¼Œè€Œä¸æ˜¯åœ¨èŠå¤©ç•Œé¢æ·»åŠ æ¶ˆæ¯
                showApiErrorToast(err.message || 'API è¯·æ±‚å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ– API é…ç½®');
            } finally {
                // ğŸ”§ æ¸…é™¤å®‰å…¨å®šæ—¶å™¨ï¼ˆæ­£å¸¸å®Œæˆåˆ™ä¸éœ€è¦å®ƒäº†ï¼‰
                clearTimeout(_safetyLockTimer);
                // ğŸ”§ æ— è®ºæˆåŠŸè¿˜æ˜¯å¤±è´¥ï¼Œéƒ½è¦é‡Šæ”¾é”ï¼Œå…è®¸ä¸‹æ¬¡è°ƒç”¨
                window._isGeneratingReply = false;
                window._isGeneratingReplyTime = 0;
                // ğŸ”„ æ¸…é™¤é‡å›æ ‡è®°
                window._isRegenerateMode = false;
                // ğŸ”§ é‡Šæ”¾è§’è‰²çº§å…±äº«é”
                autoChatLocks.delete(targetCharId);
                if (window._autoChatLockTimes) delete window._autoChatLockTimes[targetCharId];
                // ğŸ”§ AIå›å¤å®Œæˆåé‡ç½®ä¸»åŠ¨èŠå¤©å†·å´è®¡æ—¶å™¨
                lastAutoChatActionTime.set(targetCharId, Date.now());
                // ğŸ”§ å¦‚æœå¤„ç†äº†äº²å¯†å…³ç³»é‚€è¯·ï¼Œå°±åœ°æ›´æ–°å¡ç‰‡çŠ¶æ€ï¼ˆä¸é‡æ¸²æŸ“æ•´é¡µï¼‰
                if (window._needRefreshChatAfterIntimate) {
                    window._needRefreshChatAfterIntimate = false;
                    // å¡ç‰‡ DOM å·²ç”± _updateIntimateCardDOM åœ¨å¤„ç†é˜¶æ®µåŒæ­¥æ›´æ–°ï¼Œæ— éœ€å†æ“ä½œ
                }
            }
        }

        // é‡æ–°ç”Ÿæˆå›å¤ï¼ˆåˆ é™¤ä¸Šä¸€æ¬¡AIå›å¤çš„æ‰€æœ‰æ¶ˆæ¯å¹¶é‡æ–°ç”Ÿæˆï¼Œä¸åˆ é™¤ç”¨æˆ·æ¶ˆæ¯ï¼‰
        async function regenerateLastReply() {
            // ç¾¤èŠé‡å›
            if (window.currentGroupChatId) {
                await regenerateGroupReply();
                return;
            }
            
            if (!currentChatCharId) return;
            
            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            const history = getChatHistory(char, accountId);
            
            if (!char || !history || history.length === 0) {
                // æ²¡æœ‰èŠå¤©è®°å½•ï¼Œæ— æ³•é‡æ–°ç”Ÿæˆ
                return;
            }
            
            // æ‰¾åˆ°ä¸Šä¸€æ¬¡AIå›å¤çš„æ‰€æœ‰æ¶ˆæ¯ï¼ˆä»æœ€åå¾€å‰æ‰¾ï¼Œç›´åˆ°é‡åˆ°ç”¨æˆ·æ¶ˆæ¯ï¼‰
            let lastAiMessageStartIndex = -1;
            let lastAiMessageEndIndex = -1;
            
            // ä»åå¾€å‰æ‰¾æœ€åä¸€æ¡AIæ¶ˆæ¯
            for (let i = history.length - 1; i >= 0; i--) {
                if (history[i].role === 'char') {
                    lastAiMessageEndIndex = i;
                    break;
                }
            }
            
            // å¦‚æœæ²¡æœ‰AIå›å¤ï¼Œç›´æ¥ç”Ÿæˆæ–°çš„
            if (lastAiMessageEndIndex === -1) {
                closeChatPanel();
                await triggerAiReply();
                return;
            }
            
            // ğŸ”¥ ä¿®å¤ï¼šæ‰©å±•endIndexåˆ°åŒ…å«æœ€åä¸€æ¡charæ¶ˆæ¯ä¹‹åçš„æ‰€æœ‰éuseræ¶ˆæ¯
            // è¿™äº›systemæ¶ˆæ¯ï¼ˆæˆ³ä¸€æˆ³ã€æ”¹ç½‘åç­‰ï¼‰æ˜¯åŒä¸€æ¬¡AIå›å¤ä¸­äº§ç”Ÿçš„ï¼Œä¹Ÿåº”ä¸€å¹¶åˆ é™¤
            let actualEndIndex = lastAiMessageEndIndex;
            for (let i = lastAiMessageEndIndex + 1; i < history.length; i++) {
                if (history[i].role === 'user') {
                    break;
                }
                actualEndIndex = i;
            }
            
            // ä»æœ€åä¸€æ¡AIæ¶ˆæ¯å¾€å‰æ‰¾ï¼Œæ‰¾åˆ°è¿ç»­çš„æ‰€æœ‰AIæ¶ˆæ¯
            lastAiMessageStartIndex = lastAiMessageEndIndex;
            for (let i = lastAiMessageEndIndex - 1; i >= 0; i--) {
                if (history[i].role === 'user') {
                    // é‡åˆ°ç”¨æˆ·æ¶ˆæ¯ï¼Œåœæ­¢
                    break;
                }
                // è¿˜æ˜¯AIçš„æ¶ˆæ¯ï¼ˆåŒ…å«systemæ¶ˆæ¯å¦‚æˆ³ä¸€æˆ³ç­‰ï¼‰ï¼Œç»§ç»­å¾€å‰
                lastAiMessageStartIndex = i;
            }
            
            // åˆ é™¤æ‰€æœ‰è¿ç»­çš„AIæ¶ˆæ¯å’Œå…³è”çš„systemæ¶ˆæ¯ï¼ˆä¸åˆ é™¤ç”¨æˆ·æ¶ˆæ¯ï¼‰
            const deleteCount = actualEndIndex - lastAiMessageStartIndex + 1;
            history.splice(lastAiMessageStartIndex, deleteCount);
            await setChatHistory(char, accountId, history);
            await safeCharacterPut(char);
            
            // é‡æ–°æ¸²æŸ“èŠå¤©ç•Œé¢ï¼ˆç§»é™¤AIå›å¤æ¶ˆæ¯ï¼‰
            renderChatBody(char);
            
            // å…³é—­é¢æ¿
            closeChatPanel();
            
            // é‡æ–°ç”Ÿæˆå›å¤ï¼ˆåŸºäºåˆ é™¤åçš„å†å²è®°å½•ï¼Œç”¨æˆ·æ¶ˆæ¯è¿˜åœ¨ï¼‰
            window._isRegenerateMode = true;
            await triggerAiReply();
        }
        
        // ç¾¤èŠé‡æ–°ç”Ÿæˆå›å¤
        async function regenerateGroupReply() {
            if (!window.currentGroupChatId) return;
            
            let group = await db.group_chats.get(window.currentGroupChatId);
            if (!group || !group.chat_history || group.chat_history.length === 0) {
                showToast('æ²¡æœ‰èŠå¤©è®°å½•');
                return;
            }
            
            const history = group.chat_history;
            
            // æ‰¾åˆ°ä¸Šä¸€æ¬¡AIå›å¤çš„æ‰€æœ‰æ¶ˆæ¯ï¼ˆä»æœ€åå¾€å‰æ‰¾ï¼Œç›´åˆ°é‡åˆ°ç”¨æˆ·æ¶ˆæ¯æˆ–ç³»ç»Ÿæ¶ˆæ¯ï¼‰
            let lastAiMessageStartIndex = -1;
            let lastAiMessageEndIndex = -1;
            
            // ä»åå¾€å‰æ‰¾æœ€åä¸€æ¡AIè§’è‰²æ¶ˆæ¯
            for (let i = history.length - 1; i >= 0; i--) {
                if (history[i].role === 'char') {
                    lastAiMessageEndIndex = i;
                    break;
                }
            }
            
            // å¦‚æœæ²¡æœ‰AIå›å¤ï¼Œç›´æ¥ç”Ÿæˆæ–°çš„
            if (lastAiMessageEndIndex === -1) {
                closeChatPanel();
                await triggerAiReply();
                return;
            }
            
            // ğŸ”¥ ä¿®å¤ï¼šæ‰©å±•endIndexåˆ°åŒ…å«æœ€åä¸€æ¡charæ¶ˆæ¯ä¹‹åçš„å…³è”éuseræ¶ˆæ¯
            let actualGroupEndIndex = lastAiMessageEndIndex;
            for (let i = lastAiMessageEndIndex + 1; i < history.length; i++) {
                if (history[i].role === 'user') {
                    break;
                }
                // åªåŒ…å«ä¸AIå›å¤å…³è”çš„ç³»ç»Ÿæ¶ˆæ¯ï¼ˆçº¢åŒ…é¢†å–ã€æ”¹æ˜µç§°ç­‰ï¼‰
                if (history[i].role === 'system') {
                    const content = history[i].content || '';
                    if (content.includes('é¢†å–äº†çº¢åŒ…') || content.includes('å°†è‡ªå·±çš„ç¾¤æ˜µç§°æ”¹ä¸º')) {
                        actualGroupEndIndex = i;
                        continue;
                    }
                }
                if (history[i].role === 'char') {
                    actualGroupEndIndex = i;
                }
            }
            
            // ä»æœ€åä¸€æ¡AIæ¶ˆæ¯å¾€å‰æ‰¾ï¼Œæ‰¾åˆ°è¿ç»­çš„æ‰€æœ‰AIæ¶ˆæ¯ï¼ˆä¸åŒ…æ‹¬ç³»ç»Ÿæ¶ˆæ¯ï¼‰
            lastAiMessageStartIndex = lastAiMessageEndIndex;
            for (let i = lastAiMessageEndIndex - 1; i >= 0; i--) {
                if (history[i].role === 'user') {
                    // é‡åˆ°ç”¨æˆ·æ¶ˆæ¯ï¼Œåœæ­¢
                    break;
                }
                if (history[i].role === 'system') {
                    // ç³»ç»Ÿæ¶ˆæ¯ä¹Ÿç®—ä½œåˆ†éš”ï¼Œä½†å¦‚æœæ˜¯é¢†å–çº¢åŒ…ç­‰ç³»ç»Ÿæ¶ˆæ¯ï¼Œä¹Ÿåˆ é™¤
                    const content = history[i].content || '';
                    if (content.includes('é¢†å–äº†çº¢åŒ…') || content.includes('å°†è‡ªå·±çš„ç¾¤æ˜µç§°æ”¹ä¸º')) {
                        lastAiMessageStartIndex = i;
                        continue;
                    }
                    break;
                }
                // è¿˜æ˜¯AIçš„æ¶ˆæ¯ï¼Œç»§ç»­å¾€å‰
                lastAiMessageStartIndex = i;
            }
            
            // åˆ é™¤æ‰€æœ‰è¿ç»­çš„AIæ¶ˆæ¯å’Œç›¸å…³ç³»ç»Ÿæ¶ˆæ¯
            const deleteCount = actualGroupEndIndex - lastAiMessageStartIndex + 1;
            history.splice(lastAiMessageStartIndex, deleteCount);
            
            group.chat_history = history;
            group.updated_at = Date.now();
            await safeGroupChatPut(group);
            
            // é‡æ–°æ¸²æŸ“ç¾¤èŠç•Œé¢
            await renderGroupChatBody(group);
            
            // å…³é—­é¢æ¿
            closeChatPanel();
            
            // é‡æ–°ç”Ÿæˆç¾¤èŠå›å¤
            window._isRegenerateMode = true;
            await triggerAiReply();
        }

// --- è§’è‰²æ¡£æ¡ˆ (Character) é€»è¾‘ ---
function showCharacterPage() {
    document.getElementById('character-page').style.display = 'flex';
    loadCharacterList();
}

        function hideCharacterPage() {
            const page = document.getElementById('character-page');
            page.style.transform = 'scale(0.95)';
            page.style.opacity = '0';
            setTimeout(() => {
                page.style.display = 'none';
                page.style.transform = ''; 
                page.style.opacity = '';
            }, 200);
        }

        function switchCharacterTab(type) {
            currentCharacterType = type;
            
            // æ›´æ–°åº•éƒ¨æ ·å¼
            ['char', 'npc', 'user'].forEach(t => {
                const el = document.getElementById(`tab-${t}`);
                if (t === type) {
                    el.style.color = 'var(--ins-pink)';
                } else {
                    el.style.color = '#999';
                }
            });
            
            loadCharacterList();
        }

        async function loadCharacterList() {
            const container = document.getElementById('character-list');
            container.innerHTML = '';
            
            // ä»æ•°æ®åº“è·å–æŒ‡å®šç±»å‹çš„è§’è‰²
            const list = await db.characters.where('type').equals(currentCharacterType).toArray();
            
            if (list.length === 0) {
                container.innerHTML = `
                    <div style="grid-column: span 2; text-align:center; color:#999; margin-top:60px; display:flex; flex-direction:column; align-items:center; gap:10px;">
                        <svg class="svg-icon" style="width:40px; height:40px; stroke:#ccc;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="8" y1="15" x2="16" y2="15"></line><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg>
                        <div>è¿™é‡Œè¿˜æ²¡äººå“¦</div>
                    </div>
                `;
                return;
            }

            list.forEach(char => {
                const div = document.createElement('div');
                div.className = 'char-card';
                div.onclick = () => editCharacter(char.id);
                
                // é»˜è®¤å¤´åƒï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰
                const _cardAv = getCharAvatar(char, getCurrentAccountId());
                let bgStyle = 'background-color: #eee;';
                if (_cardAv) {
                    bgStyle = `background-image: url(${_cardAv});`;
                }
                
                div.innerHTML = `
                    <div class="char-card-img" style="${bgStyle}"></div>
                    <div class="char-card-info">
                        <div class="char-name">${char.name || 'æœªå‘½å'}</div>
                        <div class="char-nick">${char.nick || ''}</div>
                    </div>
                `;
                container.appendChild(div);
            });
        }

        function createNewCharacter() {
            editingCharId = null;
            document.getElementById('char-editor-title').innerText = "æ–°å»ºè§’è‰²";
            document.getElementById('char-name').value = '';
            document.getElementById('char-nick').value = '';
            document.getElementById('char-desc').value = '';
            document.getElementById('char-type').value = currentCharacterType; // é»˜è®¤é€‰ä¸­å½“å‰ Tab ç±»å‹
            document.getElementById('char-avatar-preview').style.backgroundImage = '';
            document.getElementById('char-avatar-placeholder').style.display = 'flex';
            
            // éšè—NPCç¼–è¾‘æç¤º
            const descHint = document.getElementById('char-desc-hint');
            if (descHint) descHint.style.display = 'none';
            
            // ğŸ¯ è‡ªåŠ¨ç”Ÿæˆæ‰‹æœºå·ï¼ˆå‰7ä½å›ºå®š 1380000ï¼Œå4ä½éšæœºï¼‰
            const autoGeneratedPhone = generateRandomPhone();
            console.log('[åˆ›å»ºè§’è‰²] è‡ªåŠ¨ç”Ÿæˆæ‰‹æœºå·:', autoGeneratedPhone);
            
            // æ¸…ç©ºè™šæ‹Ÿèº«ä»½ä¿¡æ¯
            document.getElementById('char-identity-account').value = '';
            document.getElementById('char-identity-password').value = '';
            document.getElementById('char-identity-phone').value = autoGeneratedPhone; // è‡ªåŠ¨å¡«å……æ‰‹æœºå·
            document.getElementById('char-identity-address').value = '';
            document.getElementById('char-identity-id').value = '';
            document.getElementById('char-identity-bank').value = '';
            document.getElementById('char-identity-bank-pass').value = '';

            document.getElementById('character-editor-page').style.display = 'flex';
            
            // ğŸ‰ æ˜¾ç¤ºæ‰‹æœºå·åˆ†é…å¼¹çª—
            setTimeout(() => {
                showPhoneAssignedModal(autoGeneratedPhone);
            }, 300); // ç¨å¾®å»¶è¿Ÿï¼Œç­‰å¾…ç¼–è¾‘å™¨é¡µé¢æ‰“å¼€
        }

        async function editCharacter(id) {
            editingCharId = id;
            const char = await db.characters.get(id);
            if (!char) return;
            
            document.getElementById('char-editor-title').innerText = "ç¼–è¾‘è§’è‰²";
            document.getElementById('char-name').value = char.name || '';
            document.getElementById('char-nick').value = char.nick || '';
            document.getElementById('char-desc').value = char.description || '';
            document.getElementById('char-type').value = char.type || 'char';
            
            // å¦‚æœæ˜¯NPCä¸”æœ‰æè¿°ï¼Œæ˜¾ç¤ºæç¤º
            const descHint = document.getElementById('char-desc-hint');
            if (char.type === 'npc' && char.description) {
                descHint.style.display = 'block';
            } else {
                descHint.style.display = 'none';
            }
            
            // å›æ˜¾è™šæ‹Ÿèº«ä»½ä¿¡æ¯
            const idData = char.identity || {};
            document.getElementById('char-identity-account').value = idData.account || '';
            document.getElementById('char-identity-password').value = idData.password || '';
            document.getElementById('char-identity-phone').value = idData.phone || '';
            document.getElementById('char-identity-address').value = idData.address || '';
            document.getElementById('char-identity-id').value = idData.id_card || '';
            document.getElementById('char-identity-bank').value = idData.bank_card || '';
            document.getElementById('char-identity-bank-pass').value = idData.bank_password || '';

            // âœ… æ¡£æ¡ˆå¤´åƒä½¿ç”¨åŸºç¡€å¤´åƒ(char.avatar)ï¼Œä¸å— WeChat æ¢å¤´åƒå½±å“
            const _editAv = char.avatar || '';
            if (_editAv) {
                document.getElementById('char-avatar-preview').style.backgroundImage = `url(${_editAv})`;
                document.getElementById('char-avatar-placeholder').style.display = 'none';
            } else {
                document.getElementById('char-avatar-preview').style.backgroundImage = '';
                document.getElementById('char-avatar-placeholder').style.display = 'flex';
            }
            
            // æ¸²æŸ“å…³ç³»åˆ—è¡¨
            renderRelationList(char);

            document.getElementById('character-editor-page').style.display = 'flex';
        }

        // æ¸²æŸ“ç¼–è¾‘é¡µçš„å…³ç³»åˆ—è¡¨
        async function renderRelationList(char) {
            const container = document.getElementById('char-relation-list');
            container.innerHTML = '';
            
            if (!char.relationships || char.relationships.length === 0) {
                container.innerHTML = '<div style="text-align:center; color:#ccc; font-size:12px; padding:10px;">æš‚æ— å…³ç³»è®°å½•ï¼Œç‚¹å‡»ã€Œæ·»åŠ å…³ç³»ã€å¼€å§‹æ„å»ºäººé™…å…³ç³»ç½‘</div>';
                return;
            }

            // relationships: [{ targetId, targetName, relation, desc }]
            for (let i = 0; i < char.relationships.length; i++) {
                const rel = char.relationships[i];
                // å°è¯•è·å–æœ€æ–°çš„å¤´åƒ
                let avatarUrl = '';
                if (rel.targetId) {
                    const target = await db.characters.get(rel.targetId);
                    if (target && target.avatar) avatarUrl = target.avatar;
                }
                
                const item = document.createElement('div');
                item.className = 'relation-item';
                item.innerHTML = `
                    <div class="relation-avatar" style="${avatarUrl ? `background-image:url(${avatarUrl})` : ''}"></div>
                    <div class="relation-info">
                        <div class="relation-name">${rel.targetName} <span class="relation-tag">${rel.relation}</span></div>
                        <div class="relation-desc">${rel.desc || ''}</div>
                    </div>
                    <div class="relation-actions">
                        <button title="ç¼–è¾‘å…³ç³»" onclick="editRelation(${i})">âœï¸</button>
                        <button title="åˆ é™¤å…³ç³»" onclick="deleteRelation(${i})" style="color:#ff3b30;">âœ•</button>
                    </div>
                `;
                container.appendChild(item);
            }
        }

        // ========== æ‰‹åŠ¨æ·»åŠ /ç¼–è¾‘/åˆ é™¤å…³ç³» ==========
        let _relationEditIndex = -1; // ç¼–è¾‘æ¨¡å¼ä¸‹çš„ç´¢å¼•ï¼Œ-1è¡¨ç¤ºæ–°å¢

        // æ˜¾ç¤ºæ·»åŠ å…³ç³»å¼¹çª—
        async function showAddRelationModal() {
            if (!editingCharId) {
                alert("è¯·å…ˆä¿å­˜å½“å‰è§’è‰²åå†æ·»åŠ å…³ç³»");
                return;
            }
            _relationEditIndex = -1;
            
            // é‡ç½®è¡¨å•
            document.getElementById('relation-type-custom').value = '';
            document.getElementById('relation-desc-input').value = '';
            document.getElementById('relation-reverse-type').value = '';
            document.getElementById('relation-bidirectional').checked = true;
            document.getElementById('relation-reverse-section').style.display = 'block';
            document.querySelectorAll('.relation-type-tag').forEach(t => t.classList.remove('active'));
            
            // åŠ è½½è§’è‰²ä¸‹æ‹‰åˆ—è¡¨
            await loadRelationCharSelect();
            
            document.getElementById('add-relation-modal').style.display = 'flex';
        }
        window.showAddRelationModal = showAddRelationModal;

        // åŠ è½½è§’è‰²ä¸‹æ‹‰åˆ—è¡¨
        async function loadRelationCharSelect(selectedId) {
            const select = document.getElementById('relation-char-select');
            if (!select) return;
            
            const allChars = await db.characters.toArray();
            const currentChar = await db.characters.get(editingCharId);
            const existingIds = (currentChar?.relationships || []).map(r => r.targetId);
            
            // è¿‡æ»¤ï¼šæ’é™¤è‡ªå·±ã€æ’é™¤userç±»å‹ã€æ–°å¢æ¨¡å¼ä¸‹æ’é™¤å·²æœ‰å…³ç³»
            const available = allChars.filter(c => {
                if (c.id === editingCharId) return false;
                if (c.type === 'user') return false;
                if (_relationEditIndex === -1 && existingIds.includes(c.id)) return false;
                return true;
            });
            
            select.innerHTML = '<option value="">-- è¯·é€‰æ‹©è§’è‰² --</option>';
            
            // æŒ‰ç±»å‹åˆ†ç»„ï¼šå…ˆè§’è‰²åNPC
            const chars = available.filter(c => c.type === 'char');
            const npcs = available.filter(c => c.type === 'npc');
            const others = available.filter(c => c.type !== 'char' && c.type !== 'npc');
            
            if (chars.length > 0) {
                const group = document.createElement('optgroup');
                group.label = 'è§’è‰² (Char)';
                chars.forEach(c => {
                    const opt = document.createElement('option');
                    opt.value = c.id;
                    opt.textContent = c.name + (c.nick ? ' (' + c.nick + ')' : '');
                    if (selectedId && c.id === selectedId) opt.selected = true;
                    group.appendChild(opt);
                });
                select.appendChild(group);
            }
            if (npcs.length > 0) {
                const group = document.createElement('optgroup');
                group.label = 'NPC';
                npcs.forEach(c => {
                    const opt = document.createElement('option');
                    opt.value = c.id;
                    opt.textContent = c.name + (c.nick ? ' (' + c.nick + ')' : '');
                    if (selectedId && c.id === selectedId) opt.selected = true;
                    group.appendChild(opt);
                });
                select.appendChild(group);
            }
            if (others.length > 0) {
                const group = document.createElement('optgroup');
                group.label = 'å…¶ä»–';
                others.forEach(c => {
                    const opt = document.createElement('option');
                    opt.value = c.id;
                    opt.textContent = c.name + (c.nick ? ' (' + c.nick + ')' : '');
                    if (selectedId && c.id === selectedId) opt.selected = true;
                    group.appendChild(opt);
                });
                select.appendChild(group);
            }
        }

        // é€‰æ‹©å…³ç³»ç±»å‹æ ‡ç­¾
        function selectRelationType(el, type) {
            document.querySelectorAll('.relation-type-tag').forEach(t => t.classList.remove('active'));
            el.classList.add('active');
            el.dataset.relation = type;
            document.getElementById('relation-type-custom').value = '';
            
            // è‡ªåŠ¨å¡«å……åå‘å…³ç³»
            document.getElementById('relation-reverse-type').value = getDefaultReverseRelation(type);
        }
        window.selectRelationType = selectRelationType;

        // è·å–é»˜è®¤åå‘å…³ç³»
        function getDefaultReverseRelation(relation) {
            const reverseMap = {
                'æ‹äºº': 'æ‹äºº',
                'æœ‹å‹': 'æœ‹å‹',
                'å®¶äºº': 'å®¶äºº',
                'åŒäº‹': 'åŒäº‹',
                'åŒå­¦': 'åŒå­¦',
                'å¸ˆç”Ÿ': 'å­¦ç”Ÿ',
                'å­¦ç”Ÿ': 'å¸ˆç”Ÿ',
                'è€å¸ˆ': 'å­¦ç”Ÿ',
                'ä¸Šä¸‹çº§': 'ä¸‹å±',
                'ä¸‹å±': 'ä¸Šçº§',
                'ä¸Šçº§': 'ä¸‹å±',
                'å¯¹æ‰‹': 'å¯¹æ‰‹',
                'æš§æ˜§': 'æš§æ˜§',
                'å‰ä»»': 'å‰ä»»',
                'ä»‡äºº': 'ä»‡äºº',
                'é™Œç”Ÿäºº': 'é™Œç”Ÿäºº',
                'å…³è”ä¸»è§’': 'å…³è”NPC'
            };
            return reverseMap[relation] || relation;
        }

        // ç¡®è®¤æ·»åŠ å…³ç³»
        async function confirmAddRelation() {
            if (!editingCharId) return;
            
            // ä»ä¸‹æ‹‰æ¡†è·å–é€‰ä¸­çš„è§’è‰²ID
            const selectEl = document.getElementById('relation-char-select');
            const selectedCharId = selectEl ? parseInt(selectEl.value) : null;
            
            if (!selectedCharId) {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè§’è‰²');
                return;
            }
            
            // è·å–å…³ç³»ç±»å‹
            const activeTag = document.querySelector('.relation-type-tag.active');
            const customType = document.getElementById('relation-type-custom').value.trim();
            const relationType = customType || (activeTag ? activeTag.dataset.relation : '');
            
            if (!relationType) {
                alert('è¯·é€‰æ‹©æˆ–è¾“å…¥å…³ç³»ç±»å‹');
                return;
            }
            
            const desc = document.getElementById('relation-desc-input').value.trim();
            const bidirectional = document.getElementById('relation-bidirectional').checked;
            const reverseType = document.getElementById('relation-reverse-type').value.trim() || getDefaultReverseRelation(relationType);
            
            // è·å–é€‰ä¸­è§’è‰²ä¿¡æ¯
            const targetChar = await db.characters.get(selectedCharId);
            if (!targetChar) {
                alert('é€‰ä¸­çš„è§’è‰²ä¸å­˜åœ¨');
                return;
            }
            
            // è·å–å½“å‰è§’è‰²
            const currentChar = await db.characters.get(editingCharId);
            if (!currentChar) return;
            
            if (!currentChar.relationships) currentChar.relationships = [];
            
            if (_relationEditIndex >= 0) {
                // ç¼–è¾‘æ¨¡å¼ï¼šå…ˆåˆ é™¤æ—§çš„åå‘å…³ç³»
                const oldRel = currentChar.relationships[_relationEditIndex];
                if (oldRel && oldRel.targetId) {
                    const oldTarget = await db.characters.get(oldRel.targetId);
                    if (oldTarget && oldTarget.relationships) {
                        oldTarget.relationships = oldTarget.relationships.filter(r => r.targetId !== editingCharId);
                        await safeCharacterPut(oldTarget);
                    }
                }
                // æ›´æ–°å…³ç³»
                currentChar.relationships[_relationEditIndex] = {
                    targetId: targetChar.id,
                    targetName: targetChar.name,
                    relation: relationType,
                    desc: desc
                };
            } else {
                // æ–°å¢æ¨¡å¼ï¼šæ£€æŸ¥æ˜¯å¦é‡å¤
                const exists = currentChar.relationships.some(r => r.targetId === targetChar.id);
                if (exists) {
                    alert(`å·²ç»ä¸ ${targetChar.name} å»ºç«‹äº†å…³ç³»`);
                    return;
                }
                
                currentChar.relationships.push({
                    targetId: targetChar.id,
                    targetName: targetChar.name,
                    relation: relationType,
                    desc: desc
                });
            }
            
            await safeCharacterPut(currentChar);
            
            // åŒå‘å…³ç³»ï¼šåœ¨å¯¹æ–¹çš„å…³ç³»åˆ—è¡¨ä¸­ä¹Ÿæ·»åŠ 
            if (bidirectional) {
                if (!targetChar.relationships) targetChar.relationships = [];
                // ç§»é™¤æ—§çš„æŒ‡å‘å½“å‰è§’è‰²çš„å…³ç³»ï¼ˆå¦‚æœæœ‰ï¼‰
                targetChar.relationships = targetChar.relationships.filter(r => r.targetId !== editingCharId);
                // æ·»åŠ æ–°çš„åå‘å…³ç³»
                targetChar.relationships.push({
                    targetId: currentChar.id,
                    targetName: currentChar.name,
                    relation: reverseType,
                    desc: desc
                });
                await safeCharacterPut(targetChar);
            }
            
            // åˆ·æ–°å…³ç³»åˆ—è¡¨
            renderRelationList(currentChar);
            closeModal('add-relation-modal');
            
            console.log(`[å…³ç³»] âœ… ${currentChar.name} â†” ${targetChar.name}: ${relationType}${bidirectional ? ` (åŒå‘: ${reverseType})` : ''}`);
        }
        window.confirmAddRelation = confirmAddRelation;

        // ç¼–è¾‘å…³ç³»
        async function editRelation(index) {
            if (!editingCharId) return;
            const currentChar = await db.characters.get(editingCharId);
            if (!currentChar || !currentChar.relationships || !currentChar.relationships[index]) return;
            
            const rel = currentChar.relationships[index];
            _relationEditIndex = index;
            
            // è®¾ç½®å…³ç³»ç±»å‹æ ‡ç­¾
            document.querySelectorAll('.relation-type-tag').forEach(t => {
                t.classList.remove('active');
                if (t.dataset.relation === rel.relation) {
                    t.classList.add('active');
                }
            });
            document.getElementById('relation-type-custom').value = '';
            const matchedTag = document.querySelector('.relation-type-tag.active');
            if (!matchedTag) {
                document.getElementById('relation-type-custom').value = rel.relation;
            }
            
            document.getElementById('relation-desc-input').value = rel.desc || '';
            document.getElementById('relation-bidirectional').checked = true;
            document.getElementById('relation-reverse-type').value = getDefaultReverseRelation(rel.relation);
            document.getElementById('relation-reverse-section').style.display = 'block';
            
            // åŠ è½½è§’è‰²ä¸‹æ‹‰å¹¶é€‰ä¸­å½“å‰å…³ç³»ç›®æ ‡
            await loadRelationCharSelect(rel.targetId);
            
            document.getElementById('add-relation-modal').style.display = 'flex';
        }
        window.editRelation = editRelation;

        // åˆ é™¤å…³ç³»
        async function deleteRelation(index) {
            if (!editingCharId) return;
            const currentChar = await db.characters.get(editingCharId);
            if (!currentChar || !currentChar.relationships || !currentChar.relationships[index]) return;
            
            const rel = currentChar.relationships[index];
            const confirmDel = confirm(`ç¡®å®šåˆ é™¤ä¸ ${rel.targetName} çš„ã€Œ${rel.relation}ã€å…³ç³»å—ï¼Ÿ`);
            if (!confirmDel) return;
            
            // åŒæ—¶åˆ é™¤å¯¹æ–¹çš„åå‘å…³ç³»
            if (rel.targetId) {
                const targetChar = await db.characters.get(rel.targetId);
                if (targetChar && targetChar.relationships) {
                    targetChar.relationships = targetChar.relationships.filter(r => r.targetId !== editingCharId);
                    await safeCharacterPut(targetChar);
                }
            }
            
            // åˆ é™¤å½“å‰è§’è‰²çš„å…³ç³»
            currentChar.relationships.splice(index, 1);
            await safeCharacterPut(currentChar);
            
            // åˆ·æ–°åˆ—è¡¨
            renderRelationList(currentChar);
            console.log(`[å…³ç³»] ğŸ—‘ï¸ å·²åˆ é™¤ ${currentChar.name} ä¸ ${rel.targetName} çš„å…³ç³»`);
        }
        window.deleteRelation = deleteRelation;

        // åŒå‘å¤é€‰æ¡†äº‹ä»¶
        document.addEventListener('change', function(e) {
            if (e.target && e.target.id === 'relation-bidirectional') {
                document.getElementById('relation-reverse-section').style.display = e.target.checked ? 'block' : 'none';
            }
        });

        // æ˜¾ç¤ºç”Ÿæˆ NPC å¼¹çª—
        function showNpcGenModal() {
            if (!editingCharId) {
                alert("è¯·å…ˆä¿å­˜å½“å‰è§’è‰²åå†ç”Ÿæˆå…³è” NPC");
                return;
            }
            document.getElementById('npc-gen-modal').style.display = 'flex';
        }

        // æ‰§è¡Œç”Ÿæˆé€»è¾‘
        async function doGenerateNpcs() {
            const count = document.getElementById('gen-count-range').value;
            const req = document.getElementById('gen-prompt-req').value.trim();
            const btn = document.getElementById('btn-do-gen');
            
            // è·å–æºè§’è‰²ä¿¡æ¯
            const sourceChar = await db.characters.get(editingCharId);
            if (!sourceChar) return;

            btn.innerText = "ç”Ÿæˆä¸­...";
            btn.disabled = true;

            try {
                // 1. æ„å»º Prompt
                let loreContext = "";
                let entriesCount = 0;
                const sourceLorebookIds = sourceChar.lorebookIds || (sourceChar.lorebookId ? [sourceChar.lorebookId] : []);
                if (sourceLorebookIds.length > 0) {
                    // åˆå¹¶å¤šä¸ªä¸–ç•Œä¹¦çš„æ‰€æœ‰è¯æ¡
                    let allEntries = [];
                    for (const bookId of sourceLorebookIds) {
                        const book = await db.lorebooks.get(bookId);
                        if (book && book.content && book.content.entries) {
                            const bookEntries = Object.values(book.content.entries)
                                .filter(e => e.enabled)
                                .map(e => `[è¯æ¡: ${e.key}]\n${e.content}`);
                            allEntries = allEntries.concat(bookEntries);
                        }
                    }
                    
                    entriesCount = allEntries.length;
                    if (entriesCount > 0) {
                        // ä¸ºäº†é˜²æ­¢Tokenæº¢å‡ºï¼ŒæŒ‰é•¿åº¦æˆªæ–­ï¼ˆå‡è®¾çº¦ 12000 å­—ç¬¦ä¸ºå®‰å…¨åŒºï¼Œç•™ç»™ Response å’Œ Promptï¼‰
                        const entriesText = allEntries.join('\n\n');
                        loreContext = `ã€ä¸–ç•Œè§‚èƒŒæ™¯ (Lorebook - å…±${entriesCount}æ¡è®¾å®š)ã€‘\n${entriesText.slice(0, 12000)}\n`;
                        if (entriesText.length > 12000) loreContext += `\n...(éƒ¨åˆ†è®¾å®šå› è¿‡é•¿å·²çœç•¥)`;
                    }
                }

                const prompt = `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„TRPG/å°è¯´è§’è‰²è®¾è®¡åŠ©æ‰‹ã€‚è¯·æ ¹æ®ä»¥ä¸‹ã€ä¸»è§’ä¿¡æ¯ã€‘å’Œã€ä¸–ç•Œè§‚èƒŒæ™¯ã€‘ï¼Œæ·±åº¦åˆ›ä½œ ${count} ä¸ªç›¸å…³çš„ NPC è§’è‰²ã€‚
${req ? `>>> ç‰¹åˆ«å‰§æƒ…è¦æ±‚ï¼š${req} <<<` : ''}

ã€ä¸»è§’ä¿¡æ¯ã€‘
åå­—ï¼š${sourceChar.name}
è®¾å®šï¼š${sourceChar.description}

${loreContext}

ã€ç”Ÿæˆè¦æ±‚ã€‘
1. **æ·±åº¦å…³è”**ï¼šNPC å¿…é¡»ä¸ä¸–ç•Œè§‚ï¼ˆLorebookï¼‰ç´§å¯†ç»“åˆã€‚è¯·å¼•ç”¨ä¸–ç•Œä¹¦ä¸­çš„åœ°åã€ç»„ç»‡ã€ç§æ—æˆ–å†å²äº‹ä»¶ã€‚
2. **ç»†èŠ‚ä¸°å¯Œ**ï¼šè¯·è¯¦ç»†æå†™å¤–è²Œï¼ˆè¡£ç€ã€ç‰¹å¾ï¼‰ã€æ€§æ ¼ï¼ˆå£ç™–ã€å¿ƒç†ï¼‰å’ŒèƒŒæ™¯æ•…äº‹ã€‚æ‹’ç»ç©ºæ´çš„æè¿°ã€‚
3. **å¤šæ ·æ€§**ï¼šç”Ÿæˆçš„è§’è‰²æ€§æ ¼å’Œèº«ä»½åº”å„ä¸ç›¸åŒï¼Œé™¤éã€ç‰¹åˆ«å‰§æƒ…è¦æ±‚ã€‘å¦æœ‰æŒ‡å®šã€‚

è¯·è¿”å›ä¸€ä¸ª JSON æ•°ç»„ï¼Œæ¯ä¸ªå¯¹è±¡åŒ…å«ï¼š
- name: åå­—
- nickname: æ˜µç§° (å¯é€‰)
- gender: æ€§åˆ« (ç”·/å¥³/æœªçŸ¥)
- appearance: å¤–è²Œæå†™ (è¯¦ç»†ï¼Œå¦‚å‘è‰²ã€ç³è‰²ã€æœè£…é£æ ¼)
- personality: æ€§æ ¼ç‰¹å¾ (è¯¦ç»†ï¼Œå¦‚é«˜å†·ã€çƒ­è¡€ã€è…¹é»‘)
- background: èƒŒæ™¯æ•…äº‹ (ç»“åˆä¸–ç•Œè§‚çš„ä¸ªäººç»å†)
- identity_job: èŒä¸šæˆ–èº«ä»½
- relation: ä¸ä¸»è§’çš„å…³ç³»ç±»å‹
- relation_desc: å…³ç³»è¯¦æƒ…æè¿° (å…·ä½“çš„äº’åŠ¨æ¨¡å¼)

è¯·ä¸¥æ ¼è¿”å› JSON æ ¼å¼ï¼Œä¸è¦åŒ…å« Markdown ä»£ç å—æ ‡è®°ã€‚`;

                // 2. è°ƒç”¨ AI
                const resultStr = await callAI([
                    { role: "system", content: "ä½ æ˜¯ä¸€ä¸ªåªè¾“å‡º JSON æ•°ç»„çš„è¾…åŠ©ç³»ç»Ÿã€‚" },
                    { role: "user", content: prompt }
                ]);

                // 3. è§£æ JSON
                const npcs = extractAndParseJSON(resultStr);
                if (!Array.isArray(npcs)) throw new Error("AI è¿”å›æ ¼å¼é”™è¯¯ (ä¸æ˜¯æ•°ç»„) æˆ–è§£æå¤±è´¥");

                // 4. æ‰¹é‡å†™å…¥ DB å¹¶å»ºç«‹å…³ç³»
                let newCount = 0;
                for (const npcData of npcs) {
                    // æ•´åˆè¯¦ç»†æè¿°
                    const fullDesc = `ã€å¤–è²Œã€‘\n${npcData.appearance || 'æ— '}\n\nã€æ€§æ ¼ã€‘\n${npcData.personality || 'æ— '}\n\nã€èƒŒæ™¯ã€‘\n${npcData.background || npcData.description || 'æ— '}`;
                    
                    // æ„é€  NPC æ•°æ®
                    const newNpc = {
                        name: npcData.name,
                        nick: npcData.nickname || '',
                        description: fullDesc, // å­˜å…¥æ•´åˆåçš„è¯¦ç»†æè¿°
                        type: 'npc', // é»˜è®¤ä¸º NPC ç±»å‹
                        avatar: '', // æš‚æ—¶ç•™ç©º
                        lorebookIds: sourceLorebookIds.length > 0 ? sourceLorebookIds : null, // ç»§æ‰¿å¤šä¸ªä¸–ç•Œä¹¦
                        lorebookId: sourceLorebookIds.length > 0 ? sourceLorebookIds[0] : null, // å…¼å®¹å­—æ®µ
                        identity: {
                            // åŸºç¡€èº«ä»½å ä½
                            job: npcData.identity_job
                        },
                        relationships: [
                            // å†™å…¥æŒ‡å‘ä¸»è§’çš„å…³ç³»
                            {
                                targetId: sourceChar.id,
                                targetName: sourceChar.name,
                                relation: "å…³è”ä¸»è§’", // ç›¸å¯¹å…³ç³»ï¼Œæˆ–è€…è®©AIç”Ÿæˆåå‘å…³ç³»æ¯”è¾ƒå¤æ‚ï¼Œè¿™é‡Œç®€åŒ–
                                desc: "ç”Ÿæˆæ¥æº"
                            }
                        ],
                        updated_at: Date.now()
                    };
                    
                    const newId = await db.characters.add(newNpc);
                    newCount++;
                    
                    // NPCç”Ÿæˆåé»˜è®¤ä¸ºé™Œç”Ÿäººï¼Œéœ€è¦ç”¨æˆ·è‡ªå·±æ·»åŠ å¥½å‹
                    console.log(`[NPCç”Ÿæˆ] âœ… ${newNpc.name} å·²åˆ›å»ºï¼ˆé»˜è®¤é™Œç”Ÿäººï¼Œéœ€æ‰‹åŠ¨æ·»åŠ å¥½å‹ï¼‰`);

                    // 5. æ›´æ–°ä¸»è§’çš„å…³ç³»åˆ—è¡¨
                    if (!sourceChar.relationships) sourceChar.relationships = [];
                    sourceChar.relationships.push({
                        targetId: newId,
                        targetName: newNpc.name,
                        relation: npcData.relation,
                        desc: npcData.relation_desc
                    });
                }
                
                // ä¿å­˜ä¸»è§’æ›´æ–°
                await safeCharacterPut(sourceChar);

                // 6. åˆ·æ–°ç•Œé¢
                alert(`âœ… æˆåŠŸç”Ÿæˆ ${newCount} ä¸ª NPCï¼\n\nğŸ’¡ æç¤ºï¼šä½ å¯ä»¥åœ¨ã€Œè§’è‰²æ¡£æ¡ˆ > NPCã€æ ‡ç­¾é¡µä¸­æŸ¥çœ‹å’Œç¼–è¾‘è¿™äº›ç”Ÿæˆçš„NPCã€‚`);
                closeModal('npc-gen-modal');
                // åˆ·æ–°ç¼–è¾‘é¡µçš„å…³ç³»åˆ—è¡¨
                renderRelationList(sourceChar);
                // åˆ·æ–°å¤–éƒ¨åˆ—è¡¨ (å¦‚æœåœ¨åˆ—è¡¨é¡µçš„è¯ï¼Œè™½ç„¶ç°åœ¨åœ¨å¼¹çª—é‡Œ)
                loadCharacterList();

            } catch (err) {
                console.error(err);
                alert("ç”Ÿæˆå¤±è´¥: " + err.message);
            } finally {
                btn.innerText = "å¼€å§‹ç”Ÿæˆ";
                btn.disabled = false;
            }
        }

        function hideCharacterEditor() {
            document.getElementById('character-editor-page').style.display = 'none';
            editingCharId = null;
        }

        function handleCharAvatarInput(input) {
            const file = input.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = e => {
                    document.getElementById('char-avatar-preview').style.backgroundImage = `url(${e.target.result})`;
                    document.getElementById('char-avatar-placeholder').style.display = 'none';
                };
                reader.readAsDataURL(file);
            }
        }

        async function saveCharacter() {
            const name = document.getElementById('char-name').value.trim();
            const nick = document.getElementById('char-nick').value.trim();
            const desc = document.getElementById('char-desc').value;
            const type = document.getElementById('char-type').value;
            
            // å¦‚æœæ˜¯æ›´æ–°ï¼Œå…ˆè·å–æ—§æ•°æ®ä»¥ä¿ç•™ lorebookId, wechat_registered ç­‰å­—æ®µ
            let oldData = {};
            if (editingCharId) {
                oldData = await db.characters.get(editingCharId) || {};
            }
            
            // è·å–è™šæ‹Ÿèº«ä»½æ•°æ®ï¼ˆåˆå¹¶æ—§æ•°æ®ï¼Œä¿ç•™ wechat_registered, registered_at ç­‰æ³¨å†ŒçŠ¶æ€ï¼‰
            const identity = {
                ...(oldData.identity || {}), // ä¿ç•™å·²æœ‰çš„ wechat_registered, registered_at ç­‰å­—æ®µ
                account: document.getElementById('char-identity-account').value.trim(),
                password: document.getElementById('char-identity-password').value.trim(),
                phone: document.getElementById('char-identity-phone').value.trim(),
                address: document.getElementById('char-identity-address').value.trim(),
                id_card: document.getElementById('char-identity-id').value.trim(),
                bank_card: document.getElementById('char-identity-bank').value.trim(),
                bank_password: document.getElementById('char-identity-bank-pass').value.trim()
            };

            // è·å–å¤´åƒ Base64
            let avatar = '';
            const bgImage = document.getElementById('char-avatar-preview').style.backgroundImage;
            if (bgImage && bgImage !== 'none') {
                avatar = bgImage.replace(/url\(|\)|"/g, '');
            }
            
            if (!name) {
                alert("è¯·è¾“å…¥è§’è‰²åå­—");
                return;
            }

            const charData = {
                ...oldData, // ä¿ç•™åŸæœ‰çš„ lorebookId, original_data ç­‰
                name,
                nick,
                description: desc,
                type,
                avatar,
                identity, // ä¿å­˜èº«ä»½ä¿¡æ¯
                updated_at: Date.now()
            };
            
            if (editingCharId) {
                await safeCharacterPut(charData); // ä½¿ç”¨ put è¦†ç›–å®Œæ•´å¯¹è±¡
            } else {
                await db.characters.add(charData);
            }
            
            hideCharacterEditor();
            // å¦‚æœä¿®æ”¹äº†ç±»å‹ï¼Œå¯èƒ½éœ€è¦è·³è½¬åˆ°å¯¹åº” Tab æ‰èƒ½çœ‹åˆ°ï¼Œæˆ–è€…ç›´æ¥åˆ·æ–°å½“å‰ Tab
            if (type !== currentCharacterType) {
                switchCharacterTab(type);
            } else {
                loadCharacterList();
            }
            
            // âœ… å¦‚æœå½“å‰æœ‰æ‰“å¼€çš„èŠå¤©çª—å£ä¸”æ˜¯è¿™ä¸ªè§’è‰²ï¼Œåˆ·æ–°èŠå¤©ç•Œé¢ï¼ˆå¤´åƒ/æ˜µç§°ç­‰å¯èƒ½å˜äº†ï¼‰
            if (editingCharId && currentChatCharId === editingCharId) {
                const updatedChar = await db.characters.get(editingCharId);
                if (updatedChar) {
                    // æ›´æ–°èŠå¤©æ ‡é¢˜
                    const _editAid = getCurrentAccountId();
                    const titleEl = document.getElementById('chat-title');
                    if (titleEl) titleEl.innerText = getCharDisplayName(updatedChar, _editAid);
                    // å¼ºåˆ¶åˆ·æ–°èŠå¤©æ¶ˆæ¯ï¼ˆå¤´åƒä¼šéšä¹‹æ›´æ–°ï¼‰
                    renderChatBody(updatedChar, true);
                }
            }
            
            // âœ… åˆ·æ–°å¾®ä¿¡èŠå¤©åˆ—è¡¨ï¼ˆå¤´åƒ/æ˜µç§°å¯èƒ½å˜äº†ï¼‰
            const wechatContent = document.getElementById('wechat-content');
            if (wechatContent) {
                renderWechatList(wechatContent);
            }
        }

        // æå–å¹¶è§£æ JSON çš„é€šç”¨è¾…åŠ©å‡½æ•° (å¢å¼ºé²æ£’æ€§)
        function extractAndParseJSON(text) {
            if (!text) return null;
            let str = text.trim();
            
            // 1. å°è¯•æå–æœ€å¤–å±‚çš„ { ... } æˆ– [ ... ]
            // è¿™èƒ½æœ‰æ•ˆå¿½ç•¥å‰åçš„æ‚è´¨ï¼ˆå¦‚ç”¨æˆ·çš„ ]{...} æƒ…å†µï¼‰
            const firstBrace = str.indexOf('{');
            const firstBracket = str.indexOf('[');
            
            let startIdx = -1;
            let isArray = false;
            
            // ç¡®å®šæ˜¯å¯¹è±¡è¿˜æ˜¯æ•°ç»„å¼€å§‹å¾—æ›´æ—©
            if (firstBrace !== -1 && (firstBracket === -1 || firstBrace < firstBracket)) {
                startIdx = firstBrace;
            } else if (firstBracket !== -1) {
                startIdx = firstBracket;
                isArray = true;
            }
            
            if (startIdx !== -1) {
                const endChar = isArray ? ']' : '}';
                const endIdx = str.lastIndexOf(endChar);
                
                if (endIdx !== -1 && endIdx > startIdx) {
                    const jsonCandidate = str.substring(startIdx, endIdx + 1);
                    try {
                        return JSON.parse(jsonCandidate);
                    } catch (e) {
                        // å°è¯•ä¿®å¤å¸¸è§ JSON é”™è¯¯ï¼ˆå°¾éƒ¨å¤šä½™é€—å·ï¼‰
                        try {
                            const fixed = jsonCandidate.replace(/,\s*([}\]])/g, '$1');
                            return JSON.parse(fixed);
                        } catch (e2) {
                            // console.warn("[extractJSON] æå–ç‰‡æ®µè§£æå¤±è´¥:", e2);
                        }
                    }
                }
            }
            
            // 2. å¦‚æœæå–å¤±è´¥ï¼Œå°è¯•æ¸…ç† Markdown æ ‡è®°åç›´æ¥è§£æ
            const cleanStr = str.replace(/^```json\s*/i, '').replace(/^```\s*/, '').replace(/\s*```$/, '');
            try {
                return JSON.parse(cleanStr);
            } catch (e) {
                // å†å°è¯•ä¿®å¤å°¾éƒ¨å¤šä½™é€—å·
                try {
                    const fixed = cleanStr.replace(/,\s*([}\]])/g, '$1');
                    return JSON.parse(fixed);
                } catch (e2) {
                    return null;
                }
            }
        }

        // ä»å¯èƒ½æŸåçš„ JSON æ–‡æœ¬ä¸­ï¼Œå°½é‡æå–å­—ç¬¦ä¸²å­—æ®µå€¼ï¼ˆå¦‚ reply/thoughtï¼‰
        function extractJsonStringValue(text, fieldName) {
            if (!text || !fieldName) return '';
            const key = `"${fieldName}"`;
            const keyIdx = text.indexOf(key);
            if (keyIdx === -1) return '';
            const colonIdx = text.indexOf(':', keyIdx + key.length);
            if (colonIdx === -1) return '';
            
            // æ‰¾åˆ°å†’å·åçš„ç¬¬ä¸€ä¸ªå¼•å·
            let i = colonIdx + 1;
            while (i < text.length && /\s/.test(text[i])) i++;
            if (text[i] !== '"') return '';
            i++; // è·³è¿‡èµ·å§‹å¼•å·
            
            let buf = '';
            let escaped = false;
            for (; i < text.length; i++) {
                const ch = text[i];
                if (escaped) {
                    buf += ch;
                    escaped = false;
                    continue;
                }
                if (ch === '\\') {
                    buf += ch;
                    escaped = true;
                    continue;
                }
                if (ch === '"') break; // å­—ç¬¦ä¸²ç»“æŸ
                buf += ch;
            }
            
            if (!buf) return '';
            try {
                // é€šè¿‡ JSON.parse åšä¸€æ¬¡è½¬ä¹‰è¿˜åŸ
                return JSON.parse(`"${buf}"`);
            } catch (e) {
                return buf
                    .replace(/\\n/g, '\n')
                    .replace(/\\"/g, '"')
                    .replace(/\\t/g, '\t')
                    .replace(/\\\\/g, '\\');
            }
        }

        // ========== å¤–è¯­+ä¸­æ–‡ç¿»è¯‘è¯†åˆ«åŠŸèƒ½ ==========
        // è§£æAIè¿”å›çš„å¤–è¯­+ä¸­æ–‡ç»„åˆæ¶ˆæ¯
        // æ”¯æŒæ ¼å¼ï¼š
        // 1. "å¤–è¯­ï¼ˆä¸­æ–‡ç¿»è¯‘ï¼‰" æˆ– "å¤–è¯­(ä¸­æ–‡ç¿»è¯‘)"
        // 2. "å¤–è¯­ã€Œä¸­æ–‡ç¿»è¯‘ã€"
        // 3. å¤–è¯­ä¸­åŒ…å«æ‹¬å·çš„æƒ…å†µï¼ˆå–æœ€åä¸€ä¸ªå«ä¸­æ–‡çš„æ‹¬å·ä½œä¸ºç¿»è¯‘ï¼‰
        function parseForeignWithTranslation(text) {
            if (!text) return null;
            
            // âœ… ç­–ç•¥ï¼šä»æœ«å°¾æ‰¾æœ€åä¸€ä¸ªåŒ…å«ä¸­æ–‡çš„æ‹¬å·å¯¹ï¼Œä½œä¸ºç¿»è¯‘
            // è¿™æ ·å³ä½¿å¤–è¯­æ–‡æœ¬ä¸­æœ‰æ‹¬å·ä¹Ÿä¸ä¼šè¯¯åˆ¤
            
            // æ¨¡å¼1: ä»æœ«å°¾åŒ¹é…æœ€åä¸€ä¸ªï¼ˆä¸­æ–‡ç¿»è¯‘ï¼‰æˆ– (ä¸­æ–‡ç¿»è¯‘)
            // ä½¿ç”¨è´ªå©ªåŒ¹é… .* æ¥å°½å¯èƒ½å¤šåœ°åŒ¹é…å¤–è¯­éƒ¨åˆ†ï¼ˆå–æœ€åä¸€ä¸ªæ‹¬å·ï¼‰
            const pattern1 = /^([\s\S]+)[ï¼ˆ(]([\s\S]*[\u4e00-\u9fff][\s\S]*)[ï¼‰)]$/;
            let match = text.match(pattern1);
            if (match) {
                const foreign = match[1].trim();
                const chinese = match[2].trim();
                // éªŒè¯ï¼šæ‹¬å·å†…åŒ…å«ä¸­æ–‡ï¼Œå¤–è¯­éƒ¨åˆ†ä¸ä¸ºç©ºï¼Œä¸”å¤–è¯­éƒ¨åˆ†ä¸å…¨æ˜¯ä¸­æ–‡
                if (foreign && chinese && containsChinese(chinese) && !isAllChinese(foreign)) {
                    return { foreign, chinese };
                }
            }
            
            // æ¨¡å¼2: ä»»æ„å†…å®¹ã€Œä¸­æ–‡ç¿»è¯‘ã€
            const pattern2 = /^([\s\S]+)ã€Œ([\s\S]*[\u4e00-\u9fff][\s\S]*)ã€$/;
            match = text.match(pattern2);
            if (match) {
                const foreign = match[1].trim();
                const chinese = match[2].trim();
                if (foreign && chinese && containsChinese(chinese) && !isAllChinese(foreign)) {
                    return { foreign, chinese };
                }
            }
            
            // æ¨¡å¼3: æœ«å°¾æœ‰ç¿»è¯‘ä½†å‰é¢å¯èƒ½æœ‰æ¢è¡Œ - æ¯”å¦‚ "å¤–è¯­\nï¼ˆä¸­æ–‡ç¿»è¯‘ï¼‰"
            const pattern3 = /^([\s\S]+?)\s*[ï¼ˆ(]([\s\S]*[\u4e00-\u9fff][\s\S]*)[ï¼‰)]\s*$/;
            match = text.match(pattern3);
            if (match) {
                const foreign = match[1].trim();
                const chinese = match[2].trim();
                if (foreign && chinese && containsChinese(chinese) && !isAllChinese(foreign)) {
                    return { foreign, chinese };
                }
            }
            
            return null;
        }
        
        // æ£€æŸ¥æ–‡æœ¬æ˜¯å¦å‡ ä¹å…¨æ˜¯ä¸­æ–‡ï¼ˆç”¨äºæ’é™¤çº¯ä¸­æ–‡æ¶ˆæ¯è¢«è¯¯åˆ¤ä¸ºç¿»è¯‘ï¼‰
        function isAllChinese(text) {
            if (!text) return false;
            const cleaned = text.replace(/[\s\p{P}\p{S}\d]/gu, ''); // å»é™¤ç©ºæ ¼ã€æ ‡ç‚¹ã€ç¬¦å·ã€æ•°å­—
            if (cleaned.length === 0) return false;
            const chineseChars = cleaned.match(/[\u4e00-\u9fff]/g) || [];
            return chineseChars.length / cleaned.length > 0.8; // è¶…è¿‡80%æ˜¯ä¸­æ–‡å°±è®¤ä¸ºæ˜¯çº¯ä¸­æ–‡
        }
        
        // æ£€æŸ¥æ–‡æœ¬æ˜¯å¦åŒ…å«ä¸­æ–‡
        function containsChinese(text) {
            if (!text) return false;
            const chineseRegex = /[\u4e00-\u9fff]/;
            return chineseRegex.test(text);
        }
        
        // âœ… æ ¸å¿ƒï¼šæ„å»ºè§’è‰²æ¶ˆæ¯å¯¹è±¡ï¼Œä¸€æ¬¡æ€§è§£æç¿»è¯‘ï¼ˆåªåœ¨æ­¤å¤„è°ƒç”¨ parseForeignWithTranslationï¼‰
        // æ‰€æœ‰ role:'char' çš„æ¶ˆæ¯éƒ½åº”é€šè¿‡æ­¤å‡½æ•°åˆ›å»ºï¼Œç¡®ä¿ç¿»è¯‘åªè§£æä¸€æ¬¡
        function buildCharMessage(content, isForeignLangMode, extraFields = {}) {
            const msg = { 
                role: 'char', 
                content: content, 
                time: Date.now(),
                ...extraFields
            };
            
            // å¤–è¯­ç¿»è¯‘æ¨¡å¼ï¼šåœ¨å­˜å‚¨æ—¶å°±è§£æå¥½ç¿»è¯‘ï¼Œé¿å…æ¸²æŸ“æ—¶é‡å¤è§£æ
            if (isForeignLangMode && content && typeof content === 'string') {
                // è·³è¿‡ç‰¹æ®Šæ ¼å¼æ¶ˆæ¯ï¼ˆå›¾ç‰‡ã€è¯­éŸ³ã€è¡¨æƒ…åŒ…ç­‰ï¼‰
                if (!content.startsWith('[img:') && !content.startsWith('[voice:') && 
                    !content.startsWith('[imgcard:') && !content.startsWith('[sticker:') &&
                    !content.startsWith('[emei_') && !content.startsWith('[couple_avatar_card]') &&
                    !content.startsWith('[payment_request]')) {
                    const parsed = parseForeignWithTranslation(content);
                    if (parsed) {
                        msg.foreignText = parsed.foreign;
                        msg.chineseText = parsed.chinese;
                    }
                }
            }
            
            return msg;
        }
        
        // é€šç”¨ AI è°ƒç”¨å‡½æ•°
        async function callAI(messages, options = {}) {
            let urlValue = '';
            let apiKeyValue = '';
            let modelValue = '';
            let temperature = 0.7;
            
            // ğŸ”Œ å‰¯APIæ”¯æŒï¼šå¦‚æœæŒ‡å®šäº† _useSecondary ä¸”å‰¯APIå·²é…ç½®ï¼Œä¼˜å…ˆä½¿ç”¨å‰¯API
            const useSecondary = options._useSecondary;
            let isUsingSecondary = false;
            if (useSecondary) {
                // å°è¯•ä»å‰¯APIç¼“å­˜è·å–é…ç½®
                const secUrl = _secondaryApiConfigCache.url;
                const secKey = _secondaryApiConfigCache.key;
                const secModel = _secondaryApiConfigCache.model;
                if (secUrl && secKey && secModel) {
                    // å‰¯APIå®Œæ•´é…ç½®ï¼Œç›´æ¥ä½¿ç”¨
                    urlValue = secUrl;
                    apiKeyValue = secKey;
                    modelValue = secModel;
                    isUsingSecondary = true;
                    console.log('[callAI] ğŸ”Œ ä½¿ç”¨å‰¯APIé…ç½®');
                } else if (secUrl || secKey || secModel) {
                    // å‰¯APIéƒ¨åˆ†é…ç½®ï¼Œå·²é…ç½®çš„å­—æ®µä½¿ç”¨å‰¯APIï¼Œç¼ºå¤±çš„å­—æ®µä»ä¸»APIè¡¥å…¨
                    if (secUrl) urlValue = secUrl;
                    if (secKey) apiKeyValue = secKey;
                    if (secModel) modelValue = secModel;
                    console.log('[callAI] ğŸ”Œ å‰¯APIéƒ¨åˆ†é…ç½®ï¼Œç¼ºå¤±é¡¹å°†ä»ä¸»APIè¡¥å…¨');
                    // isUsingSecondary ä¿æŒ falseï¼Œè®©åé¢çš„é€»è¾‘è¡¥å…¨ç¼ºå¤±çš„å­—æ®µ
                } else {
                    // å‰¯APIå®Œå…¨æœªé…ç½®ï¼Œé™é»˜å›é€€åˆ°ä¸»API
                    console.log('[callAI] â„¹ï¸ å‰¯APIæœªé…ç½®ï¼Œå›é€€åˆ°ä¸»API');
                }
            }
            
            // å¦‚æœä¸æ˜¯ä½¿ç”¨å‰¯APIï¼ˆæˆ–å‰¯APIæœªé…ç½®ï¼‰ï¼Œä½¿ç”¨ä¸»APIé…ç½®
            if (!isUsingSecondary) {
            // ğŸ”§ ä¿®å¤æ‰‹æœºç«¯ç¬¬äºŒæ¬¡APIè°ƒç”¨å¡æ­»ï¼šä¼˜å…ˆä½¿ç”¨å†…å­˜ç¼“å­˜ï¼Œé¿å…IndexedDBäº‹åŠ¡é˜»å¡
            if (_apiConfigCache.url && _apiConfigCache.key && _apiConfigCache.model) {
                // å†…å­˜ç¼“å­˜æœ‰æ•ˆï¼Œç›´æ¥ä½¿ç”¨ï¼ˆè·³è¿‡å¯èƒ½æŒ‚èµ·çš„DBè¯»å–ï¼‰
                urlValue = urlValue || _apiConfigCache.url;
                apiKeyValue = apiKeyValue || _apiConfigCache.key;
                modelValue = modelValue || _apiConfigCache.model;
                temperature = _apiConfigCache.temp ? parseFloat(_apiConfigCache.temp) : 0.7;
                console.log('[callAI] âœ… ä½¿ç”¨å†…å­˜ç¼“å­˜çš„APIé…ç½®');
                
                // åå°é™é»˜åˆ·æ–°ç¼“å­˜ï¼ˆä¸é˜»å¡å½“å‰è°ƒç”¨ï¼ŒåŠ è¶…æ—¶ä¿æŠ¤ï¼‰
                Promise.race([
                    (async () => {
                        try {
                            const url = await db.dexiData.get('aiBaseUrl');
                            const key = await db.dexiData.get('aiApiKey');
                            const model = await db.dexiData.get('aiCurrentModel');
                            const tempItem = await db.dexiData.get('aiTemperature');
                            const u = url?.value?.trim() || '';
                            const k = key?.value?.trim() || '';
                            const m = model?.value?.trim() || '';
                            if (u && k && m) {
                                _apiConfigCache = { url: u, key: k, model: m, temp: String(tempItem ? parseFloat(tempItem.value) : 0.7) };
                            }
                        } catch (e) {
                            console.warn('[callAI] åå°åˆ·æ–°ç¼“å­˜å¤±è´¥:', e.message);
                        }
                    })(),
                    new Promise(r => setTimeout(r, 3000)) // 3ç§’è¶…æ—¶
                ]).catch(() => {});
            } else {
                // å†…å­˜ç¼“å­˜ä¸ºç©ºï¼ˆé¦–æ¬¡è°ƒç”¨ï¼‰ï¼Œä»DBè¯»å–ï¼ŒåŠ è¶…æ—¶ä¿æŠ¤
                try {
                    const dbReadResult = await Promise.race([
                        (async () => {
                            const url = await db.dexiData.get('aiBaseUrl');
                            const key = await db.dexiData.get('aiApiKey');
                            const model = await db.dexiData.get('aiCurrentModel');
                            const tempItem = await db.dexiData.get('aiTemperature');
                            return { url, key, model, tempItem };
                        })(),
                        new Promise((_, reject) => setTimeout(() => reject(new Error('DBè¯»å–è¶…æ—¶')), 5000))
                    ]);
                    
                    urlValue = urlValue || dbReadResult.url?.value?.trim() || '';
                    apiKeyValue = apiKeyValue || dbReadResult.key?.value?.trim() || '';
                    modelValue = modelValue || dbReadResult.model?.value?.trim() || '';
                    temperature = dbReadResult.tempItem ? parseFloat(dbReadResult.tempItem.value) : 0.7;
                    
                    // æˆåŠŸè¯»å–åæ›´æ–°å†…å­˜ç¼“å­˜
                    if (urlValue && apiKeyValue && modelValue) {
                        _apiConfigCache = { url: urlValue, key: apiKeyValue, model: modelValue, temp: String(temperature) };
                        console.log('[callAI] âœ… ä»DBè¯»å–APIé…ç½®å¹¶ç¼“å­˜');
                    }
                } catch (dbErr) {
                    console.warn('[callAI] æ•°æ®åº“è¯»å–å¤±è´¥æˆ–è¶…æ—¶ï¼Œå°è¯•ä½¿ç”¨å†…å­˜ç¼“å­˜:', dbErr.message);
                }
                
                // å¦‚æœDBè¯»å–å¤±è´¥/è¶…æ—¶ï¼Œå°è¯•ä½¿ç”¨å†…å­˜ç¼“å­˜
                if (!urlValue && _apiConfigCache.url) {
                    urlValue = _apiConfigCache.url;
                }
                if (!apiKeyValue && _apiConfigCache.key) {
                    apiKeyValue = _apiConfigCache.key;
                }
                if (!modelValue && _apiConfigCache.model) {
                    modelValue = _apiConfigCache.model;
                }
            }
            } // end if (!isUsingSecondary)
            
            if (!urlValue) {
                throw new Error("è¯·å…ˆåœ¨è®¾ç½®ä¸­é…ç½® API åœ°å€");
            }
            if (!apiKeyValue) {
                throw new Error("API å¯†é’¥ä¸èƒ½ä¸ºç©ºï¼Œè¯·åœ¨è®¾ç½®ä¸­é…ç½®");
            }
            if (!modelValue) {
                throw new Error("æ¨¡å‹åç§°ä¸èƒ½ä¸ºç©ºï¼Œè¯·åœ¨è®¾ç½®ä¸­é€‰æ‹©æ¨¡å‹");
            }
            
            // æ£€æŸ¥ API Key æ ¼å¼ï¼ˆåŸºæœ¬æ£€æŸ¥ï¼‰
            if (apiKeyValue.length < 10) {
                console.warn('[callAI] API Key é•¿åº¦å¼‚å¸¸ï¼Œå¯èƒ½æ— æ•ˆ:', apiKeyValue.length);
            }
            
            // éªŒè¯æ¸©åº¦å€¼
            if (isNaN(temperature) || temperature < 0 || temperature > 2) {
                console.warn('[callAI] æ¸©åº¦å€¼æ— æ•ˆ:', temperature, 'ï¼Œä½¿ç”¨é»˜è®¤å€¼ 0.7');
                temperature = 0.7;
            }
            
            // è·å– max_tokens é…ç½®ï¼ˆå¦‚æœæä¾›ï¼‰
            const maxTokens = options.max_tokens || options.maxTokens;

            const requestUrl = getSmartUrl(urlValue, '/chat/completions');
            
            // âœ… å…¨å±€é˜²å¾¡ï¼šæ¸…æ´— messagesï¼Œé˜²æ­¢ç©ºå†…å®¹æˆ–éæ³•æ ¼å¼å¯¼è‡´ 400 é”™è¯¯
            // æ”¯æŒå¤šæ¨¡æ€æ¶ˆæ¯æ ¼å¼ï¼ˆå›¾ç‰‡è¯†åˆ«ï¼‰ï¼šcontent å¯ä»¥æ˜¯å­—ç¬¦ä¸²æˆ–æ•°ç»„
            const cleanMessages = messages.map(m => {
                // éªŒè¯ role å­—æ®µ
                let role = m.role;
                if (!role || !['system', 'user', 'assistant'].includes(role)) {
                    console.warn('[callAI] æ— æ•ˆçš„ role:', role, 'ï¼Œä½¿ç”¨ user');
                    role = 'user';
                }
                
                let content = m.content;
                
                // æ”¯æŒå¤šæ¨¡æ€å†…å®¹ï¼ˆæ•°ç»„æ ¼å¼ï¼Œç”¨äºå›¾ç‰‡è¯†åˆ«ï¼‰
                if (Array.isArray(content)) {
                    // éªŒè¯æ•°ç»„ä¸­æ¯ä¸ªå…ƒç´ 
                    const validParts = content.filter(part => {
                        if (part.type === 'text') return part.text && part.text.trim().length > 0;
                        if (part.type === 'image_url') return part.image_url && part.image_url.url;
                        return false;
                    });
                    if (validParts.length === 0) return { role, content: '' };
                    // ğŸ”§ æ ‡è®°åŒ…å«å›¾ç‰‡çš„æ¶ˆæ¯ï¼Œåç»­å¼‚æ­¥è½¬æ¢æ ¼å¼
                    return { role, content: validParts, _hasImage: true };
                }
                
                // ç¡®ä¿ content æ˜¯å­—ç¬¦ä¸²
                if (content === null || content === undefined) content = "";
                if (typeof content !== 'string') content = String(content);
                
                return {
                    role: role,
                    content: content.trim()
                };
            }).filter(m => {
                if (Array.isArray(m.content)) return m.content.length > 0;
                return m.content.length > 0;
            }); // å†æ¬¡è¿‡æ»¤ç©ºæ¶ˆæ¯

            // ğŸ”§ å¼‚æ­¥è½¬æ¢å›¾ç‰‡æ ¼å¼ï¼šå°† avif/webp ç­‰ä¸å…¼å®¹æ ¼å¼è½¬ä¸º JPEGï¼ŒHTTP URL è½¬ä¸º base64
            for (let i = 0; i < cleanMessages.length; i++) {
                const msg = cleanMessages[i];
                if (msg._hasImage && Array.isArray(msg.content)) {
                    for (let j = msg.content.length - 1; j >= 0; j--) {
                        const part = msg.content[j];
                        if (part.type === 'image_url' && part.image_url && part.image_url.url) {
                            const url = part.image_url.url;
                            // å¤„ç† HTTP URLï¼šå…ˆè½¬ä¸º base64
                            if (url.startsWith('http')) {
                                try {
                                    const base64Url = await convertHttpImageToBase64(url);
                                    if (base64Url.startsWith('data:image')) {
                                        part.image_url.url = await convertImageForAI(base64Url);
                                    } else {
                                        // CORS å¤±è´¥ï¼Œç§»é™¤å›¾ç‰‡éƒ¨åˆ†ï¼Œä¿ç•™æ–‡å­—æè¿°
                                        console.warn('[callAI] HTTPå›¾ç‰‡æ— æ³•è½¬ä¸ºbase64ï¼ˆCORSï¼‰ï¼Œç§»é™¤å›¾ç‰‡éƒ¨åˆ†');
                                        msg.content.splice(j, 1);
                                    }
                                } catch (e) {
                                    console.warn('[callAI] HTTPå›¾ç‰‡è½¬æ¢å¤±è´¥ï¼Œç§»é™¤å›¾ç‰‡éƒ¨åˆ†:', e);
                                    msg.content.splice(j, 1);
                                }
                            }
                            // å¤„ç† data: URLï¼šæ ¼å¼è½¬æ¢
                            else if (url.startsWith('data:image')) {
                                try {
                                    const converted = await convertImageForAI(url);
                                    part.image_url.url = converted;
                                } catch (e) {
                                    console.warn('[callAI] å›¾ç‰‡æ ¼å¼è½¬æ¢å¤±è´¥ï¼Œä½¿ç”¨åŸå§‹æ ¼å¼:', e);
                                }
                            }
                        }
                    }
                    delete msg._hasImage; // æ¸…ç†æ ‡è®°
                    // å¦‚æœå›¾ç‰‡éƒ½è¢«ç§»é™¤äº†ï¼Œä¸”åªå‰©æ–‡å­—ï¼Œè½¬å›å­—ç¬¦ä¸²æ ¼å¼
                    const hasImage = msg.content.some(p => p.type === 'image_url');
                    if (!hasImage && msg.content.length === 1 && msg.content[0].type === 'text') {
                        msg.content = msg.content[0].text;
                    }
                }
            }

            // å¦‚æœè¿‡æ»¤ååªå‰©ä¸‹ system æ¶ˆæ¯ï¼Œæœ‰äº›æ¨¡å‹å¯èƒ½ä¼šæŠ¥é”™ï¼Œä½†å¤§å¤šæ•°æ”¯æŒã€‚
            // è¿™é‡Œæˆ‘ä»¬ä¸åš System çš„å¼ºåˆ¶æ£€æŸ¥ï¼Œåªè¦ä¸ä¸ºç©ºå³å¯ã€‚
            if (cleanMessages.length === 0) {
                throw new Error("è¯·æ±‚ä¸­æ­¢ï¼šæ²¡æœ‰æœ‰æ•ˆçš„æ¶ˆæ¯å†…å®¹ï¼ˆå¯èƒ½æ˜¯å› ä¸ºæ¶ˆæ¯è¢«æ’¤å›æˆ–ä¸ºç©ºï¼‰");
            }
            
            // éªŒè¯æ˜¯å¦è‡³å°‘æœ‰ä¸€æ¡é system æ¶ˆæ¯
            const hasNonSystemMessage = cleanMessages.some(m => m.role !== 'system');
            if (!hasNonSystemMessage) {
                console.warn('[callAI] åªæœ‰ system æ¶ˆæ¯ï¼Œæ·»åŠ ä¸€ä¸ªå ä½ user æ¶ˆæ¯');
                // ğŸ”§ ä¿®å¤ï¼šæ·»åŠ æ›´å®Œæ•´çš„å ä½æ¶ˆæ¯ï¼Œé¿å… Gemini ä»£ç†è¿”å›ç©º choices
                cleanMessages.push({
                    role: 'user',
                    content: 'è¯·æ ¹æ®ä½ çš„äººè®¾ï¼Œå‘é€ä¸€æ¡æ¶ˆæ¯ã€‚ä¿æŒè§’è‰²æ‰®æ¼”ï¼Œè‡ªç„¶åœ°å¼€å§‹æˆ–ç»§ç»­å¯¹è¯ã€‚'
                });
            }

            let rawText = '';
            
            // æ„å»ºè¯·æ±‚ä½“
            const requestBody = {
                apiUrl: requestUrl,
                apiKey: apiKeyValue,
                model: modelValue,
                messages: cleanMessages,
                temperature: temperature
            };
            
            // æ·»åŠ è¯¦ç»†çš„è°ƒè¯•æ—¥å¿—
            console.log('[callAI] ğŸš€ å‡†å¤‡å‘é€è¯·æ±‚');
            console.log('[callAI] API URL:', requestUrl);
            console.log('[callAI] Model:', modelValue);
            console.log('[callAI] API Key length:', apiKeyValue.length);
            console.log('[callAI] Temperature:', temperature);
            console.log('[callAI] Messages count:', cleanMessages.length);
            console.log('[callAI] Messages preview:', cleanMessages.map(m => ({
                role: m.role,
                content: Array.isArray(m.content) 
                    ? `[å¤šæ¨¡æ€: ${m.content.map(p => p.type === 'image_url' ? 'ğŸ–¼ï¸å›¾ç‰‡' : p.text?.substring(0, 50)).join(' + ')}]`
                    : m.content.substring(0, 100) + (m.content.length > 100 ? '...' : '')
            })));
            
            // çº¯å‰ç«¯ï¼šç›´æ¥è°ƒç”¨ AI APIï¼ˆéœ€è¦é…ç½®æ”¯æŒ CORS çš„ API ç«¯ç‚¹ï¼‰
            try {
                // ğŸ”¥ æ„å»ºè¯·æ±‚ä½“ï¼Œæ”¯æŒ response_format å¼ºåˆ¶ JSON è¾“å‡º
                const fetchBody = {
                    model: modelValue,
                    messages: cleanMessages,
                    temperature: temperature
                };
                
                // å¦‚æœè°ƒç”¨æ–¹è¦æ±‚ JSON è¾“å‡ºï¼Œæ·»åŠ  response_format å‚æ•°
                if (options.json_mode) {
                    fetchBody.response_format = { type: "json_object" };
                    console.log('[callAI] ğŸ“‹ å·²å¯ç”¨ JSON æ¨¡å¼ (response_format: json_object)');
                }
                
                // å¦‚æœæœ‰ max_tokens å‚æ•°
                if (maxTokens) {
                    fetchBody.max_tokens = maxTokens;
                }
                
                const res = await fetch(requestUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKeyValue}`
                    },
                    body: JSON.stringify(fetchBody)
                });

                if (!res.ok) {
                    const errText = await res.text();
                    console.error('[callAI] âŒ API è¯·æ±‚å¤±è´¥');
                    console.error('[callAI] çŠ¶æ€ç :', res.status);
                    console.error('[callAI] é”™è¯¯å“åº”:', errText);
                    
                    try {
                        const errJson = JSON.parse(errText);
                        console.error('[callAI] è§£æåçš„é”™è¯¯:', errJson);
                        if (errJson.error) {
                            const errorMsg = `AIè¯·æ±‚å¤±è´¥ (${res.status}): ${errJson.error}${errJson.details ? '\nè¯¦æƒ…: ' + errJson.details : ''}`;
                            throw new Error(errorMsg);
                        }
                    } catch(parseErr) {
                        // å¦‚æœä¸æ˜¯ JSON æ ¼å¼çš„é”™è¯¯
                        if (parseErr instanceof SyntaxError) {
                            console.error('[callAI] é”™è¯¯å“åº”ä¸æ˜¯ JSON æ ¼å¼');
                        }
                    }
                    
                    throw new Error(`API è¯·æ±‚å¤±è´¥: ${res.status} - ${errText.substring(0, 200)}`);
                }

                // âœ… å…³é”®æ”¹åŠ¨ï¼šå…ˆè·å–åŸå§‹æ–‡æœ¬ï¼Œè€Œä¸æ˜¯ç›´æ¥ .json()
                rawText = await res.text();
                
                // å°è¯•è§£æä¸º JSON
                let data;
                try {
                    data = JSON.parse(rawText);
                } catch (parseErr) {
                    // è¿”å›çš„ä¸æ˜¯ JSONï¼ˆå¯èƒ½æ˜¯ HTML é”™è¯¯é¡µã€çº¯æ–‡æœ¬ç­‰ï¼‰
                    console.warn('[callAI] è¿”å›å†…å®¹ä¸æ˜¯æœ‰æ•ˆçš„ JSONï¼Œç›´æ¥ä½¿ç”¨åŸå§‹æ–‡æœ¬');
                    console.log('[callAI] åŸå§‹è¿”å›:', rawText.substring(0, 500));
                    
                    // ç›´æ¥è¿”å›åŸå§‹æ–‡æœ¬ï¼ˆå»é™¤ HTML æ ‡ç­¾å’Œç‰¹æ®Šå­—ç¬¦ï¼‰
                    return rawText
                        .replace(/<[^>]*>/g, '') // ç§»é™¤ HTML æ ‡ç­¾
                        .replace(/[â—‡â—†â˜…â˜†â—â—‹â– â–¡â–²â–³]/g, '') // ç§»é™¤è£…é¥°å­—ç¬¦
                        .replace(/\s*\[DONE\]\s*$/i, '') // ç§»é™¤æœ«å°¾ [DONE]
                        .trim();
                }
                
                // ğŸš¨ æ£€æµ‹ç©ºçš„ choices æ•°ç»„ï¼ˆAPIè°ƒç”¨æˆåŠŸä½†æ²¡æœ‰è¿”å›å†…å®¹ï¼‰
                if (data?.choices && Array.isArray(data.choices) && data.choices.length === 0) {
                    console.error('[callAI] âŒ APIè¿”å›äº†ç©ºçš„choicesæ•°ç»„');
                    console.error('[callAI] å®Œæ•´å“åº”:', JSON.stringify(data, null, 2));
                    
                    let errorMsg = 'APIè°ƒç”¨æˆåŠŸï¼Œä½†æ²¡æœ‰è¿”å›å†…å®¹';
                    
                    // æ£€æŸ¥usageä¿¡æ¯ï¼Œåˆ¤æ–­å¯èƒ½çš„åŸå› 
                    if (data.usage) {
                        const { prompt_tokens, completion_tokens, total_tokens } = data.usage;
                        if (prompt_tokens === 0 && completion_tokens === 0) {
                            errorMsg += '\n\nğŸ’¡ å¯èƒ½çš„åŸå› ï¼š\n';
                            errorMsg += '- å†…å®¹è¢«å®‰å…¨è¿‡æ»¤æ‹¦æˆª\n';
                            errorMsg += '- æ¨¡å‹ä¸æ”¯æŒå½“å‰è¯·æ±‚\n';
                            errorMsg += '- APIé…é¢ä¸è¶³æˆ–é™æµ\n';
                            errorMsg += '- è¯·æ±‚å‚æ•°æ ¼å¼é”™è¯¯';
                        }
                    }
                    
                    throw new Error(errorMsg);
                }
                
                // âœ… å…¼å®¹å¤šç§è¿”å›è·¯å¾„ï¼ˆåŒ…æ‹¬Geminiï¼‰
                let content = '';
                
                // 1. Geminiæ ¼å¼ï¼šdata.candidates[0].content.parts[0].text
                if (data?.candidates?.[0]?.content?.parts?.[0]?.text) {
                    content = data.candidates[0].content.parts[0].text;
                    console.log('[callAI] âœ… ä½¿ç”¨Geminiæ ¼å¼æå–å†…å®¹');
                }
                // 2. OpenAIæ ‡å‡†æ ¼å¼ï¼šdata.choices[0].message.content
                else if (data?.choices?.[0]?.message?.content) {
                    content = data.choices[0].message.content;
                    console.log('[callAI] âœ… ä½¿ç”¨OpenAIæ ¼å¼æå–å†…å®¹');
                }
                // 3. å…¶ä»–å…¼å®¹æ ¼å¼
                else {
                    content = 
                        data?.choices?.[0]?.text ??              // ä¸€äº›æ—§ç‰ˆ API
                        data?.output_text ??                     // ä¸€äº›è‡ªå®šä¹‰æ ¼å¼
                        data?.message ??                         // ç®€åŒ–æ ¼å¼
                        data?.content ??                         // ç›´æ¥è¿”å›å†…å®¹
                        data?.reply ??                           // è‡ªå®šä¹‰å­—æ®µ
                        '';
                }
                
                // âœ… æ¸…ç†æœ«å°¾çš„ [DONE] / [done]ï¼ˆæŸäº›APIä»£ç†ä¼šæŠŠSSEç»ˆæ­¢ä¿¡å·æ··å…¥å†…å®¹ï¼‰
                if (content) {
                    content = content.replace(/\s*\[DONE\]\s*$/i, '').replace(/\s*\[done\]\s*$/i, '').trim();
                }
                
                if (!content) {
                    // å¦‚æœæ‰€æœ‰è·¯å¾„éƒ½æ²¡æœ‰å†…å®¹ï¼Œè®°å½•è¯¦ç»†æ—¥å¿—
                    console.error('[callAI] âŒ æ— æ³•ä»ä»»ä½•è·¯å¾„æå–å†…å®¹');
                    console.error('[callAI] å®Œæ•´å“åº”ç»“æ„:', JSON.stringify(data, null, 2).substring(0, 1000));
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯Geminiçš„ç©ºè¿”å›
                    if (data?.candidates && Array.isArray(data.candidates) && data.candidates.length === 0) {
                        throw new Error('Gemini APIè¿”å›äº†ç©ºçš„candidatesæ•°ç»„ï¼Œå¯èƒ½æ˜¯å†…å®¹è¢«è¿‡æ»¤æˆ–è¯·æ±‚æ ¼å¼é”™è¯¯');
                    }
                    
                    // å¦‚æœdataæœ¬èº«å°±æ˜¯å­—ç¬¦ä¸²ï¼Œæ£€æŸ¥æ˜¯å¦æ˜¯JSONå­—ç¬¦ä¸²
                    if (typeof data === 'string') {
                        // å¦‚æœæ˜¯JSONå­—ç¬¦ä¸²ï¼Œå°è¯•è§£æ
                        try {
                            const parsed = JSON.parse(data);
                            // å¦‚æœè§£ææˆåŠŸï¼Œé€’å½’è°ƒç”¨æå–é€»è¾‘
                            if (parsed.candidates?.[0]?.content?.parts?.[0]?.text) {
                                return parsed.candidates[0].content.parts[0].text;
                            }
                            if (parsed.choices?.[0]?.message?.content) {
                                return parsed.choices[0].message.content;
                            }
                        } catch {
                            // ä¸æ˜¯JSONï¼Œç›´æ¥è¿”å›å­—ç¬¦ä¸²
                            return data;
                        }
                    }
                    
                    // ğŸš¨ æœ€åæ£€æŸ¥ï¼šå¦‚æœrawTextçœ‹èµ·æ¥åƒJSONå¯¹è±¡ï¼Œä¸è¦è¿”å›å®ƒ
                    if (rawText.trim().startsWith('{') && rawText.trim().endsWith('}')) {
                        console.error('[callAI] âŒ æ£€æµ‹åˆ°è¿”å›çš„æ˜¯åŸå§‹JSONå¯¹è±¡ï¼Œä¸åº”è¯¥æ˜¾ç¤ºç»™ç”¨æˆ·');
                        throw new Error('APIè¿”å›äº†åŸå§‹JSONå¯¹è±¡è€Œéæ–‡æœ¬å†…å®¹ã€‚è¿™å¯èƒ½æ˜¯APIé…ç½®é—®é¢˜æˆ–æ¨¡å‹å“åº”æ ¼å¼é”™è¯¯ã€‚');
                    }
                    
                    // æœ€åå°è¯•ï¼šè¿”å›æ¸…ç†åçš„åŸå§‹æ–‡æœ¬ï¼ˆä½†è¿™ç§æƒ…å†µä¸åº”è¯¥å‘ç”Ÿï¼‰
                    const fallback = rawText
                        .replace(/<[^>]*>/g, '')
                        .replace(/[â—‡â—†â˜…â˜†â—â—‹â– â–¡â–²â–³]/g, '')
                        .trim();
                    
                    if (fallback && fallback.length > 10 && !fallback.startsWith('{')) {
                        console.warn('[callAI] âš ï¸ ä½¿ç”¨åŸå§‹æ–‡æœ¬ä½œä¸ºfallback');
                        return fallback;
                    }
                    
                    throw new Error('APIè¿”å›äº†ç©ºå†…å®¹ï¼Œæ— æ³•æå–æœ‰æ•ˆæ–‡æœ¬ã€‚è¯·æ£€æŸ¥APIé…ç½®å’Œæ¨¡å‹å“åº”ã€‚');
                }
                
                return content;
                
            } catch (err) {
                console.error("[callAI] é”™è¯¯è¯¦æƒ…:", err);
                console.log("[callAI] åŸå§‹è¿”å›å†…å®¹:", rawText.substring(0, 500));
                throw err;
            }
        }

        // âœ… æµå¼AIè°ƒç”¨å‡½æ•°ï¼ˆä¸‰é˜¶æ®µå¤„ç†æ¨¡å‹ï¼‰
        async function callAIStream(messages, options = {}) {
            let urlValue = '';
            let apiKeyValue = '';
            let modelValue = '';
            let temperature = 0.7;
            
            try {
                const url = await db.dexiData.get('aiBaseUrl');
                const key = await db.dexiData.get('aiApiKey');
                const model = await db.dexiData.get('aiCurrentModel');
                
                urlValue = url?.value?.trim() || '';
                apiKeyValue = key?.value?.trim() || '';
                modelValue = model?.value?.trim() || '';
                
                const tempItem = await db.dexiData.get('aiTemperature');
                temperature = tempItem ? parseFloat(tempItem.value) : 0.7;
            } catch (dbErr) {
                console.warn('[callAIStream] æ•°æ®åº“è¯»å–å¤±è´¥:', dbErr.message);
            }
            
            if (!urlValue || !apiKeyValue || !modelValue) {
                throw new Error("è¯·å…ˆåœ¨è®¾ç½®ä¸­é…ç½® API åœ°å€ã€å¯†é’¥å’Œæ¨¡å‹");
            }
            
            const requestUrl = getSmartUrl(urlValue, '/chat/completions');
            
            // æ¸…æ´— messagesï¼ˆå¤ç”¨ callAI çš„é€»è¾‘ï¼‰
            const cleanMessages = messages.map(m => {
                let role = m.role;
                if (!role || !['system', 'user', 'assistant'].includes(role)) {
                    role = 'user';
                }
                
                let content = m.content;
                if (Array.isArray(content)) {
                    const validParts = content.filter(part => {
                        if (part.type === 'text') return part.text && part.text.trim().length > 0;
                        if (part.type === 'image_url') return part.image_url && part.image_url.url;
                        return false;
                    });
                    if (validParts.length === 0) return { role, content: '' };
                    return { role, content: validParts };
                }
                
                if (content === null || content === undefined) content = "";
                if (typeof content !== 'string') content = String(content);
                
                return {
                    role: role,
                    content: content.trim()
                };
            }).filter(m => {
                if (Array.isArray(m.content)) return m.content.length > 0;
                return m.content.length > 0;
            });
            
            if (cleanMessages.length === 0) {
                throw new Error("è¯·æ±‚ä¸­æ­¢ï¼šæ²¡æœ‰æœ‰æ•ˆçš„æ¶ˆæ¯å†…å®¹");
            }
            
            // ğŸ¯ ç¬¬ä¸€é˜¶æ®µï¼šæµå¼å±‚ - åªåšå­—ç¬¦ä¸²æ‹¼æ¥
            let rawText = '';
            let buffer = '';
            const decoder = new TextDecoder();
            
            try {
                const res = await fetch(requestUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKeyValue}`
                    },
                    body: JSON.stringify({
                        model: modelValue,
                        messages: cleanMessages,
                        temperature: temperature,
                        stream: true  // å¯ç”¨æµå¼å“åº”
                    })
                });
                
                if (!res.ok) {
                    const errText = await res.text();
                    throw new Error(`API è¯·æ±‚å¤±è´¥: ${res.status} - ${errText.substring(0, 200)}`);
                }
                
                const reader = res.body.getReader();
                
                // âœ… æ­£ç¡®çš„ SSE è§£ææ–¹å¼ï¼šä½¿ç”¨ \n\n ä½œä¸ºè¾¹ç•Œ
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    buffer += decoder.decode(value, { stream: true });
                    
                    let boundary;
                    while ((boundary = buffer.indexOf('\n\n')) !== -1) {
                        const chunk = buffer.slice(0, boundary);
                        buffer = buffer.slice(boundary + 2);
                        
                        if (!chunk.startsWith('data:')) continue;
                        
                        const jsonStr = chunk.replace(/^data:\s*/, '').trim();
                        
                        if (!jsonStr) continue;
                        
                        // âœ… ä¸¥æ ¼è¿‡æ»¤ [DONE]
                        if (jsonStr === '[DONE]' || jsonStr === '[done]') {
                            continue;
                        }
                        
                        let data;
                        try {
                            data = JSON.parse(jsonStr);
                        } catch (e) {
                            console.warn('[callAIStream] Stream JSON parse error:', jsonStr);
                            continue;
                        }
                        
                        const delta = data?.choices?.[0]?.delta?.content;
                        if (!delta) continue;
                        
                        // âœ… æµå¼é˜¶æ®µï¼šåªåšå­—ç¬¦ä¸²æ‹¼æ¥ï¼Œä¸åšä»»ä½•è§£æ
                        rawText += delta;
                        
                        // âœ… æµå¼é˜¶æ®µï¼šåªæ›´æ–°çº¯æ–‡æœ¬æ˜¾ç¤ºï¼Œä¸åšä»»ä½• split / æ­£åˆ™ / markdown
                        // è¿™é‡Œåªä¼ é€’åŸå§‹æ–‡æœ¬ï¼Œè®© UI å±‚åªåš textContent æ›´æ–°
                        if (options.onStreamUpdate) {
                            // ç›´æ¥ä¼ é€’ rawTextï¼Œä¸åšä»»ä½•å¤„ç†
                            options.onStreamUpdate(rawText);
                        }
                    }
                }
                
                // å¤„ç†å‰©ä½™çš„ buffer
                if (buffer.trim()) {
                    const jsonStr = buffer.replace(/^data:\s*/, '').trim();
                    if (jsonStr && jsonStr !== '[DONE]' && jsonStr !== '[done]') {
                        try {
                            const data = JSON.parse(jsonStr);
                            const delta = data?.choices?.[0]?.delta?.content;
                            if (delta) {
                                rawText += delta;
                                // æµå¼é˜¶æ®µï¼šåªæ›´æ–°çº¯æ–‡æœ¬
                                if (options.onStreamUpdate) {
                                    options.onStreamUpdate(rawText);
                                }
                            }
                        } catch (e) {
                            // å¿½ç•¥è§£æé”™è¯¯
                        }
                    }
                }
                
            } catch (err) {
                console.error("[callAIStream] é”™è¯¯è¯¦æƒ…:", err);
                throw err;
            }
            
            // âœ… æµç»“æŸåï¼Œæ‰åšå¤„ç†
            // âœ… æ¸…ç†æœ«å°¾çš„ [DONE] / [done]ï¼ˆé˜²æ­¢SSEç»ˆæ­¢ä¿¡å·æ³„å…¥å†…å®¹ï¼‰
            rawText = rawText.replace(/\s*\[DONE\]\s*$/i, '').trim();
            // ğŸ¯ ç¬¬äºŒé˜¶æ®µï¼šå®Œæˆå±‚ - ç»Ÿä¸€åšç¿»è¯‘/ç»“æ„è§£æ
            const finalText = rawText;
            const processed = processTranslationAndStructure(finalText);
            
            // ğŸ¯ ç¬¬ä¸‰é˜¶æ®µï¼šæ¸²æŸ“å±‚ - æœ€åä¸€æ¬¡æ€§æ¸²æŸ“ markdown
            if (options.onComplete) {
                options.onComplete(processed);
            } else {
                // å¦‚æœæ²¡æœ‰æä¾› onComplete å›è°ƒï¼Œä½¿ç”¨é»˜è®¤çš„ renderMarkdown
                renderMarkdown(processed);
            }
            
            return processed;
        }
        
        // âœ… å¤„ç†ç¿»è¯‘å’Œç»“æ„æ‹†åˆ†ï¼ˆä¸åœ¨æµå¼é˜¶æ®µæ‰§è¡Œï¼‰
        // âš ï¸ é‡è¦ï¼šè¿™ä¸ªå‡½æ•°åªåœ¨æµç»“æŸåè°ƒç”¨ï¼Œå¤„ç†å®Œæ•´çš„æ–‡æœ¬
        function processTranslationAndStructure(text) {
            if (!text || !text.trim()) return text;
            
            // ğŸ¯ ç¬¬äºŒé˜¶æ®µï¼šå®Œæˆå±‚å¤„ç†
            // åœ¨è¿™é‡Œåš split / æ­£åˆ™ / ç¿»è¯‘æ‹†åˆ†
            // æµå¼é˜¶æ®µå·²ç»ç»“æŸï¼Œæ–‡æœ¬æ˜¯å®Œæ•´çš„
            
            let processed = text;
            
            // 1. å¤„ç†ç¿»è¯‘æ ¼å¼ï¼ˆå¤–è¯­ï¼ˆä¸­æ–‡ç¿»è¯‘ï¼‰ï¼‰
            // å¦‚æœæ–‡æœ¬åŒ…å«ç¿»è¯‘æ ¼å¼ï¼Œåœ¨è¿™é‡Œè§£æ
            // ä¾‹å¦‚ï¼šparseForeignWithTranslation(processed)
            // ä½†ä¸è¦åœ¨æµå¼é˜¶æ®µæ‹†åˆ†ï¼Œç­‰å®Œæ•´æ–‡æœ¬åå†å¤„ç†
            
            // 2. å¤„ç†ç»“æ„æ‹†åˆ†ï¼ˆå¦‚ ||| åˆ†éš”ç¬¦ï¼‰
            // å¦‚æœéœ€è¦æŒ‰åˆ†éš”ç¬¦æ‹†åˆ†ï¼Œåœ¨è¿™é‡Œå¤„ç†
            // ä¾‹å¦‚ï¼šprocessed.split('|||').map(...)
            
            // 3. æ¸…ç†å’Œæ ¼å¼åŒ–
            // ç§»é™¤å¤šä½™çš„è£…é¥°å­—ç¬¦ã€ä¿®å¤æ ¼å¼ç­‰
            // processed = processed.replace(/[â—‡â—†â˜…â˜†â—â—‹â– â–¡â–²â–³]/g, '');
            
            // è¿”å›å¤„ç†åçš„æ–‡æœ¬
            return processed;
        }
        
        // âœ… æ›´æ–°æµå¼æ–‡æœ¬æ˜¾ç¤ºï¼ˆçº¯æ–‡æœ¬ï¼Œä¸æ¸²æŸ“markdownï¼‰
        // âš ï¸ é‡è¦ï¼šè¿™ä¸ªå‡½æ•°åªåšçº¯æ–‡æœ¬æ˜¾ç¤ºï¼Œä¸åšä»»ä½•è§£æ
        // ä¸åšç¿»è¯‘è¯†åˆ«ã€ä¸åšæ­£åˆ™æ‹†åˆ†ã€ä¸åš markdown æ¸²æŸ“
        function updateStreamingText(text) {
            // âœ… æµå¼é˜¶æ®µï¼šåªæ›´æ–° textContentï¼Œä¸åšä»»ä½•è§£æ
            // ä¸åš splitã€ä¸åšæ­£åˆ™ã€ä¸åš markdownã€ä¸åšç¿»è¯‘è¯†åˆ«
            
            // ç¤ºä¾‹å®ç°ï¼šç›´æ¥æ›´æ–° DOM çš„ textContentï¼ˆçº¯æ–‡æœ¬ï¼‰
            // const element = document.getElementById('streaming-text');
            // if (element) {
            //     element.textContent = text;  // åªåšçº¯æ–‡æœ¬æ›´æ–°
            // }
            
            // è°ƒè¯•æ—¥å¿—
            console.log('[updateStreamingText] çº¯æ–‡æœ¬æ›´æ–°ï¼Œé•¿åº¦:', text.length);
        }
        
        // âœ… æ¸²æŸ“æœ€ç»ˆmarkdownï¼ˆåœ¨æµç»“æŸåä¸€æ¬¡æ€§æ¸²æŸ“ï¼‰
        // âš ï¸ é‡è¦ï¼šè¿™ä¸ªå‡½æ•°åªåœ¨æµç»“æŸåè°ƒç”¨ï¼Œä¸€æ¬¡æ€§æ¸²æŸ“å®Œæ•´å†…å®¹
        function renderMarkdown(processedText) {
            // ğŸ¯ ç¬¬ä¸‰é˜¶æ®µï¼šæ¸²æŸ“å±‚
            // åœ¨æµç»“æŸåï¼Œä¸€æ¬¡æ€§æ¸²æŸ“ markdown
            // ä¸åšæµå¼æ›´æ–°ï¼Œåªåšæœ€ç»ˆæ¸²æŸ“
            
            // ç¤ºä¾‹å®ç°ï¼šæ¸²æŸ“ markdown åˆ° DOM
            // const element = document.getElementById('streaming-text');
            // if (element) {
            //     // ä½¿ç”¨ markdown æ¸²æŸ“åº“ï¼ˆå¦‚ markedã€markdown-itï¼‰
            //     element.innerHTML = marked.parse(processedText);
            // }
            
            // è°ƒè¯•æ—¥å¿—
            console.log('[renderMarkdown] æœ€ç»ˆæ¸²æŸ“ï¼Œé•¿åº¦:', processedText.length);
        }

        // ç”Ÿæˆè™šæ‹Ÿèº«ä»½
        async function generateIdentity() {
            const name = document.getElementById('char-name').value;
            const desc = document.getElementById('char-desc').value;
            
            if (!name) {
                alert("è¯·å…ˆè¾“å…¥è§’è‰²åå­—");
                return;
            }

            const btnText = document.getElementById('gen-btn-text');
            const spinner = document.getElementById('gen-spinner');
            btnText.style.display = 'none';
            spinner.style.display = 'block';

            try {
                const prompt = `ä½ æ˜¯ä¸€ä¸ªè§’è‰²å¡è¾…åŠ©å·¥å…·ã€‚è¯·æ ¹æ®è§’è‰²ã€${name}ã€‘çš„è®¾å®šï¼ˆ${desc || 'æš‚æ— è¯¦ç»†æè¿°'}ï¼‰ï¼Œä¸ºä»–/å¥¹ç”Ÿæˆä¸€å¥—è™šæ‹Ÿçš„ç°ä»£ç¤¾ä¼šèº«ä»½ä¿¡æ¯ã€‚
è¯·ä¸¥æ ¼è¿”å›çº¯ JSON æ ¼å¼æ•°æ®ï¼ˆä¸è¦åŒ…å« Markdown ä»£ç å—æ ‡è®°ï¼‰ï¼ŒåŒ…å«ä»¥ä¸‹å­—æ®µï¼š
- account: è™šæ‹Ÿç¤¾äº¤è´¦å·ï¼ˆè‹±æ–‡+æ•°å­—ï¼‰
- password: ç™»å½•å¯†ç ï¼ˆå¤æ‚ä¸€ç‚¹ï¼‰
- phone: æ‰‹æœºå·ï¼ˆå¿…é¡»ä¸¥æ ¼ä¸º 7 ä½æ•°å­—ï¼‰
- address: å®¶åº­ä½å€ï¼ˆç¬¦åˆè§’è‰²èƒŒæ™¯çš„è™šæ„åœ°å€ï¼‰
- id_card: èº«ä»½è¯å·ï¼ˆå¿…é¡»ä¸¥æ ¼ä¸º 9 ä½æ•°å­—ï¼‰
- bank_card: é“¶è¡Œå¡å·ï¼ˆå¿…é¡»ä¸¥æ ¼ä¸º 8 ä½æ•°å­—ï¼‰
- bank_password: é“¶è¡Œå¡å¯†ç ï¼ˆå¿…é¡»ä¸¥æ ¼ä¸º 4 ä½æ•°å­—ï¼‰`;

                const content = await callAI([
                    { role: "system", content: "ä½ æ˜¯ä¸€ä¸ªåªè¾“å‡º JSON çš„æ•°æ®ç”ŸæˆåŠ©æ‰‹ã€‚" },
                    { role: "user", content: prompt }
                ]);

                const data = extractAndParseJSON(content);
                if (!data) throw new Error("æ— æ³•è§£æ AI è¿”å›çš„ JSON æ•°æ®");
                
                // å¡«å…¥è¡¨å•
                document.getElementById('char-identity-account').value = data.account || '';
                document.getElementById('char-identity-password').value = data.password || '';
                document.getElementById('char-identity-phone').value = data.phone || '';
                document.getElementById('char-identity-address').value = data.address || '';
                document.getElementById('char-identity-id').value = data.id_card || '';
                document.getElementById('char-identity-bank').value = data.bank_card || '';
                document.getElementById('char-identity-bank-pass').value = data.bank_password || '';

            } catch (err) {
                console.error(err);
                alert("ç”Ÿæˆå¤±è´¥: " + err.message);
            } finally {
                btnText.style.display = 'inline';
                spinner.style.display = 'none';
            }
        }

        async function deleteCharacter() {
            if (!editingCharId) return;
            if (confirm("ç¡®å®šè¦åˆ é™¤è¿™ä¸ªè§’è‰²å—ï¼Ÿ")) {
                await db.characters.delete(editingCharId);
                hideCharacterEditor();
                loadCharacterList();
            }
        }

        // è¾…åŠ©å‡½æ•°ï¼šè‡ªåŠ¨å¯¼å…¥å†…åµŒçš„ä¸–ç•Œä¹¦
        async function importCharacterBook(bookData, charName) {
            if (!bookData) return null;
            
            try {
                const bookName = bookData.name || `${charName}çš„ä¸–ç•Œä¹¦`;
                
                // å­˜å…¥ lorebooks è¡¨
                const id = await db.lorebooks.add({
                    name: bookName,
                    content: bookData,
                    created_at: Date.now()
                });
                
                return id;
            } catch (e) {
                console.error("å¯¼å…¥ä¸–ç•Œä¹¦å¤±è´¥", e);
                return null;
            }
        }

        // å¯¼å…¥è§’è‰²å¯†ç éªŒè¯
        function requestImportCharacter() {
            // å¦‚æœå·²ç»éªŒè¯è¿‡ï¼Œç›´æ¥æ‰“å¼€æ–‡ä»¶é€‰æ‹©
            if (sessionStorage.getItem('import_char_unlocked') === '1') {
                document.getElementById('character-import').click();
                return;
            }
            
            // åˆ›å»ºå¯†ç éªŒè¯å¼¹çª—
            const overlay = document.createElement('div');
            overlay.id = 'import-lock-modal';
            overlay.dataset.target = 'character';
            overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.3);display:flex;align-items:center;justify-content:center;z-index:99999;';
            overlay.onclick = (e) => { if (e.target === overlay) overlay.remove(); };
            
            overlay.innerHTML = `
                <div style="background:#fff;border-radius:14px;padding:28px 24px;width:280px;box-shadow:0 8px 30px rgba(0,0,0,0.08);font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;">
                    <div style="text-align:center;margin-bottom:20px;">
                        <svg viewBox="0 0 24 24" style="width:32px;height:32px;fill:none;stroke:#333;stroke-width:1.5;stroke-linecap:round;stroke-linejoin:round;margin-bottom:8px;"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>
                        <div style="font-size:15px;font-weight:600;color:#262626;letter-spacing:0.3px;">å¯¼å…¥éœ€è¦éªŒè¯</div>
                        <div style="font-size:12px;color:#8e8e8e;margin-top:4px;">è¯·è¾“å…¥å¯†ç ä»¥è§£é”å¯¼å…¥åŠŸèƒ½</div>
                    </div>
                    <input type="password" id="import-lock-pwd" placeholder="è¯·è¾“å…¥å¯†ç " 
                        style="width:100%;padding:12px 14px;border:1px solid #efefef;border-radius:10px;font-size:14px;outline:none;box-sizing:border-box;background:#fafafa;transition:border 0.2s;"
                        onfocus="this.style.borderColor='#333'" onblur="this.style.borderColor='#efefef'">
                    <div id="import-lock-error" style="color:#ff3b30;font-size:12px;margin-top:6px;text-align:center;min-height:16px;"></div>
                    <div style="display:flex;gap:10px;margin-top:14px;">
                        <div onclick="this.closest('#import-lock-modal').remove()" 
                            style="flex:1;text-align:center;padding:11px;border-radius:10px;font-size:14px;color:#8e8e8e;background:#f5f5f5;cursor:pointer;">å–æ¶ˆ</div>
                        <div onclick="verifyImportPassword()" 
                            style="flex:1;text-align:center;padding:11px;border-radius:10px;font-size:14px;color:#fff;background:#262626;cursor:pointer;font-weight:500;">ç¡®è®¤</div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // è‡ªåŠ¨èšç„¦ & å›è½¦æäº¤
            setTimeout(() => {
                const pwdInput = document.getElementById('import-lock-pwd');
                if (pwdInput) {
                    pwdInput.focus();
                    pwdInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') verifyImportPassword();
                    });
                }
            }, 100);
        }
        
        function verifyImportPassword() {
            const pwd = document.getElementById('import-lock-pwd').value;
            const modal = document.getElementById('import-lock-modal');
            const target = modal ? modal.dataset.target : 'character';
            
            if (pwd === 'kkk200856') {
                if (target === 'lorebook') {
                    sessionStorage.setItem('import_lorebook_unlocked', '1');
                } else {
                    sessionStorage.setItem('import_char_unlocked', '1');
                }
                if (modal) modal.remove();
                // éªŒè¯æˆåŠŸï¼Œæ‰“å¼€å¯¹åº”çš„æ–‡ä»¶é€‰æ‹©
                if (target === 'lorebook') {
                    document.getElementById('lorebook-import').click();
                } else {
                    document.getElementById('character-import').click();
                }
            } else {
                const errEl = document.getElementById('import-lock-error');
                if (errEl) errEl.textContent = 'å¯†ç é”™è¯¯ï¼Œè¯·é‡è¯•';
                const pwdInput = document.getElementById('import-lock-pwd');
                if (pwdInput) {
                    pwdInput.value = '';
                    pwdInput.style.borderColor = '#ff3b30';
                    pwdInput.focus();
                    setTimeout(() => { pwdInput.style.borderColor = '#efefef'; }, 1500);
                }
            }
        }

        // å¯¼å…¥è§’è‰² (JSON æˆ– PNG)
        function importCharacterFile(input) {
            const file = input.files[0];
            if (!file) return;
            
            if (file.type.includes('image') || file.name.endsWith('.png')) {
                // å¤„ç† PNG
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        // 1. å…ˆå°è¯•å½“åšå›¾ç‰‡è¯»å–æ˜¾ç¤º
                        const avatarBase64 = e.target.result;
                        
                        // 2. è§£æ PNG å…ƒæ•°æ®ä¸­çš„ JSON
                        const arrayBuffer = await file.arrayBuffer();
                        const jsonStr = extractPngText(new Uint8Array(arrayBuffer));
                        
                        if (!jsonStr) {
                            alert("æœªåœ¨è¿™å¼ å›¾ç‰‡ä¸­æ‰¾åˆ°è§’è‰²æ•°æ® (tEXt chunk)");
                            createNewCharacter();
                            document.getElementById('char-avatar-preview').style.backgroundImage = `url(${avatarBase64})`;
                            document.getElementById('char-avatar-placeholder').style.display = 'none';
                            input.value = '';
                            return;
                        }
                        
                        const json = JSON.parse(jsonStr);
                        // å¤„ç†ä¸åŒæ ¼å¼ (TavernAI V1/V2)
                        let charData = {};
                        if (json.data) {
                            // V2 spec
                            charData = json.data;
                        } else {
                            // V1 æˆ–ç›´æ¥ç»“æ„
                            charData = json;
                        }
                        
                        // å°è¯•å¯¼å…¥ä¸–ç•Œä¹¦
                        let lorebookId = null;
                        if (charData.character_book) {
                             lorebookId = await importCharacterBook(charData.character_book, charData.name);
                        }
                        
                        // å­˜å…¥ DB
                        await db.characters.add({
                            name: charData.name || 'æœªå‘½å',
                            nick: charData.nickname || '', 
                            description: charData.description || charData.personality || '', 
                            type: currentCharacterType, 
                            avatar: avatarBase64,
                            original_data: json,
                            lorebookIds: lorebookId ? [lorebookId] : null, // å…³è”ä¸–ç•Œä¹¦IDæ•°ç»„
                            lorebookId: lorebookId, // å…¼å®¹å­—æ®µ
                            updated_at: Date.now()
                        });
                        
                        let msg = `âœ… æˆåŠŸå¯¼å…¥è§’è‰²: ${charData.name}`;
                        if (lorebookId) msg += `\nğŸ“š å¹¶è‡ªåŠ¨å¯¼å…¥äº†ä¸–ç•Œä¹¦`;
                        alert(msg);
                        loadCharacterList();
                        
                    } catch (err) {
                        console.error(err);
                        alert("è§£æ PNG å¤±è´¥: " + err.message);
                    }
                };
                reader.readAsDataURL(file);
                
            } else {
                // å¤„ç† JSON
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const json = JSON.parse(e.target.result);
                        // å…¼å®¹æ€§å¤„ç†
                        let charData = json;
                        if (json.data) charData = json.data; // Spec V2
                        
                        // å°è¯•å¯¼å…¥ä¸–ç•Œä¹¦
                        let lorebookId = null;
                        if (charData.character_book) {
                             lorebookId = await importCharacterBook(charData.character_book, charData.name);
                        }
                        
                        await db.characters.add({
                            name: charData.name || 'æœªå‘½å',
                            nick: charData.nickname || '',
                            description: charData.description || charData.personality || '',
                            type: currentCharacterType,
                            avatar: '', 
                            original_data: json,
                            lorebookId: lorebookId, // å…³è”ä¸–ç•Œä¹¦ID
                            updated_at: Date.now()
                        });
                        
                        let msg = `âœ… æˆåŠŸå¯¼å…¥è§’è‰²: ${charData.name}`;
                        if (lorebookId) msg += `\nğŸ“š å¹¶è‡ªåŠ¨å¯¼å…¥äº†ä¸–ç•Œä¹¦`;
                        alert(msg);
                        loadCharacterList();
                    } catch (err) {
                        alert("JSON è§£æå¤±è´¥: " + err.message);
                    }
                };
                reader.readAsText(file);
            }
            input.value = '';
        }

        // ç®€æ˜“ PNG tEXt æå–å™¨ (ä¿®å¤ä¸­æ–‡ä¹±ç ç‰ˆ)
        function extractPngText(uint8Array) {
            // PNG Header: 89 50 4E 47 0D 0A 1A 0A
            let offset = 8;
            const textDecoder = new TextDecoder();
            
            while (offset < uint8Array.length) {
                // è¯»å– Chunk Length (4 bytes, Big Endian)
                const length = (uint8Array[offset] << 24) | (uint8Array[offset+1] << 16) | (uint8Array[offset+2] << 8) | uint8Array[offset+3];
                offset += 4;
                
                // è¯»å– Chunk Type (4 bytes)
                const type = String.fromCharCode(...uint8Array.slice(offset, offset + 4));
                offset += 4;
                
                if (type === 'tEXt') {
                    const data = uint8Array.slice(offset, offset + length);
                    // tEXt æ ¼å¼: Keyword + null separator + Text string
                    // æŸ¥æ‰¾ null separator (0x00)
                    let nullIndex = -1;
                    for (let i = 0; i < length; i++) {
                        if (data[i] === 0) {
                            nullIndex = i;
                            break;
                        }
                    }
                    
                    if (nullIndex > -1) {
                        const keyword = textDecoder.decode(data.slice(0, nullIndex));
                        const textBytes = data.slice(nullIndex + 1);
                        const text = textDecoder.decode(textBytes);
                        
                        if (keyword === 'chara') {
                            // TavernAI æ ¼å¼é€šå¸¸æ˜¯ Base64 ç¼–ç çš„ JSON
                            try {
                                // ä¿®å¤ä¹±ç çš„å…³é”®æ­¥éª¤ï¼š
                                // 1. atob è§£ç  base64 -> binary string
                                const binaryString = atob(text);
                                // 2. binary string -> Uint8Array
                                const bytes = new Uint8Array(binaryString.length);
                                for (let i = 0; i < binaryString.length; i++) {
                                    bytes[i] = binaryString.charCodeAt(i);
                                }
                                // 3. TextDecoder è§£ç  utf-8
                                const decoded = new TextDecoder('utf-8').decode(bytes);
                                return decoded;
                            } catch (e) {
                                // ä¹Ÿè®¸ä¸æ˜¯ Base64ï¼Œæˆ–è€…è§£ç å¤±è´¥ï¼Œç›´æ¥è¿”å›åŸå§‹æ–‡æœ¬
                                return text;
                            }
                        }
                    }
                }
                
                // è·³è¿‡ Data å’Œ CRC (4 bytes)
                offset += length + 4;
                
                if (type === 'IEND') break;
            }
            return null;
        }

        // --- ä¸–ç•Œä¹¦ (Lorebook) é€»è¾‘ ---
function showLorebookPage() {
    document.getElementById('lorebook-page').style.display = 'flex';
    loadLorebookList();
}

        function hideLorebookPage() {
            const page = document.getElementById('lorebook-page');
            page.style.transform = 'scale(0.95)';
            page.style.opacity = '0';
            setTimeout(() => {
                page.style.display = 'none';
                page.style.transform = ''; 
                page.style.opacity = '';
            }, 200);
        }

        async function loadLorebookList() {
            const list = await db.lorebooks.toArray();
            const container = document.getElementById('lorebook-list');
            container.innerHTML = '';
            
            if (list.length === 0) {
                container.innerHTML = `
                    <div style="text-align:center; color:#999; margin-top:40px; font-size:14px; display:flex; flex-direction:column; align-items:center; gap:10px;">
                        <svg class="svg-icon" style="width:40px; height:40px; stroke:#ccc;" viewBox="0 0 24 24"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg>
                        <div>ç©ºç©ºå¦‚ä¹Ÿ<br>ç‚¹å‡»ä¸Šæ–¹å¯¼å…¥æˆ–æ–°å»º</div>
                    </div>
                `;
                return;
            }

            list.forEach(book => {
                const count = book.content && book.content.entries ? Object.keys(book.content.entries).length : 0;
                const scope = book.scope || 'personal';
                const scopeLabel = scope === 'global' ? 'å…¨å±€' : 'å•äºº';
                const scopeColor = scope === 'global' ? '#34c759' : '#007aff';
                
                const div = document.createElement('div');
                div.className = 'lorebook-card';
                div.innerHTML = `
                    <div class="lorebook-info">
                        <div style="display:flex; align-items:center; gap:6px;">
                            <h3 style="margin:0;">${book.name}</h3>
                            <span class="lb-scope-badge" style="background:${scopeColor};" onclick="event.stopPropagation(); toggleLorebookScope(${book.id})" title="ç‚¹å‡»åˆ‡æ¢">${scopeLabel}</span>
                        </div>
                        <p>${count} ä¸ªè¯æ¡</p>
                    </div>
                    <div class="lorebook-actions">
                        <div class="lorebook-btn lb-edit" onclick="editLorebook(${book.id})">ç¼–è¾‘</div>
                        <div class="lorebook-btn lb-del" onclick="deleteLorebook(${book.id})">åˆ é™¤</div>
                    </div>
                `;
                container.appendChild(div);
            });
        }

        // ä¸–ç•Œä¹¦å¯¼å…¥åŠ é”
        function requestImportLorebook() {
            if (sessionStorage.getItem('import_lorebook_unlocked') === '1') {
                document.getElementById('lorebook-import').click();
                return;
            }
            // åˆ›å»ºå¯†ç éªŒè¯å¼¹çª—
            const existing = document.getElementById('import-lock-modal');
            if (existing) existing.remove();
            
            const overlay = document.createElement('div');
            overlay.id = 'import-lock-modal';
            overlay.dataset.target = 'lorebook';
            overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.3);display:flex;align-items:center;justify-content:center;z-index:99999;';
            overlay.onclick = (e) => { if (e.target === overlay) overlay.remove(); };
            
            overlay.innerHTML = `
                <div style="background:#fff;border-radius:14px;padding:28px 24px;width:280px;box-shadow:0 8px 30px rgba(0,0,0,0.08);font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;">
                    <div style="text-align:center;margin-bottom:20px;">
                        <svg viewBox="0 0 24 24" style="width:32px;height:32px;fill:none;stroke:#333;stroke-width:1.5;stroke-linecap:round;stroke-linejoin:round;margin-bottom:8px;"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>
                        <div style="font-size:15px;font-weight:600;color:#262626;letter-spacing:0.3px;">å¯¼å…¥éœ€è¦éªŒè¯</div>
                        <div style="font-size:12px;color:#8e8e8e;margin-top:4px;">è¯·è¾“å…¥å¯†ç ä»¥è§£é”å¯¼å…¥åŠŸèƒ½</div>
                    </div>
                    <input type="password" id="import-lock-pwd" placeholder="è¯·è¾“å…¥å¯†ç " 
                        style="width:100%;padding:12px 14px;border:1px solid #efefef;border-radius:10px;font-size:14px;outline:none;box-sizing:border-box;background:#fafafa;transition:border 0.2s;"
                        onfocus="this.style.borderColor='#333'" onblur="this.style.borderColor='#efefef'">
                    <div id="import-lock-error" style="color:#ff3b30;font-size:12px;margin-top:6px;text-align:center;min-height:16px;"></div>
                    <div style="display:flex;gap:10px;margin-top:14px;">
                        <div onclick="this.closest('#import-lock-modal').remove()" 
                            style="flex:1;text-align:center;padding:11px;border-radius:10px;font-size:14px;color:#8e8e8e;background:#f5f5f5;cursor:pointer;">å–æ¶ˆ</div>
                        <div onclick="verifyImportPassword()" 
                            style="flex:1;text-align:center;padding:11px;border-radius:10px;font-size:14px;color:#fff;background:#262626;cursor:pointer;font-weight:500;">ç¡®è®¤</div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            setTimeout(() => {
                const pwdInput = document.getElementById('import-lock-pwd');
                if (pwdInput) {
                    pwdInput.focus();
                    pwdInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') verifyImportPassword();
                    });
                }
            }, 100);
        }

        // å¯¼å…¥ä¸–ç•Œä¹¦æ–‡ä»¶ï¼ˆæ”¯æŒ .json å’Œ .txtï¼‰
        function importLorebookFile(input) {
            const file = input.files[0];
            if (!file) return;
            
            const fileName = file.name.toLowerCase();
            const isTxt = fileName.endsWith('.txt');
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    let name = file.name.replace(/\.(json|txt)$/i, '');
                    
                    if (isTxt) {
                        // TXT æ ¼å¼ï¼šæŒ‰è¡Œè§£æä¸ºè¯æ¡
                        const text = e.target.result;
                        const lines = text.split(/\r?\n/).filter(l => l.trim());
                        
                        if (lines.length === 0) {
                            alert('âŒ æ–‡ä»¶ä¸ºç©º');
                            input.value = '';
                            return;
                        }
                        
                        // æ„å»º entries å¯¹è±¡
                        const entries = {};
                        let entryIndex = 0;
                        let currentKey = '';
                        let currentContent = '';
                        
                        for (const line of lines) {
                            // æ”¯æŒæ ¼å¼1ï¼škey: contentï¼ˆå†’å·åˆ†éš”çš„é”®å€¼å¯¹ï¼‰
                            // æ”¯æŒæ ¼å¼2ï¼škey:: contentï¼ˆåŒå†’å·åˆ†éš”ï¼ŒSillyTaverné£æ ¼ï¼‰
                            // æ”¯æŒæ ¼å¼3ï¼šçº¯æ–‡æœ¬ï¼Œæ¯è¡Œä½œä¸ºä¸€ä¸ªè¯æ¡
                            const colonMatch = line.match(/^(.+?)::?\s+(.+)$/);
                            
                            if (colonMatch) {
                                // æœ‰é”®å€¼å¯¹æ ¼å¼
                                const key = colonMatch[1].trim();
                                const content = colonMatch[2].trim();
                                entries[String(entryIndex)] = {
                                    uid: entryIndex,
                                    key: key.split(/[,ï¼Œã€]/).map(k => k.trim()).filter(k => k),
                                    content: content,
                                    comment: key,
                                    enabled: true
                                };
                                entryIndex++;
                            } else {
                                // çº¯æ–‡æœ¬è¡Œï¼Œæ•´è¡Œä½œä¸º contentï¼Œç¬¬ä¸€ä¸ªè¯ä½œä¸º key
                                const trimmed = line.trim();
                                const firstWord = trimmed.split(/[\s,ï¼Œã€]/)[0];
                                entries[String(entryIndex)] = {
                                    uid: entryIndex,
                                    key: [firstWord],
                                    content: trimmed,
                                    comment: `è¯æ¡ #${entryIndex}`,
                                    enabled: true
                                };
                                entryIndex++;
                            }
                        }
                        
                        const newId = await db.lorebooks.add({
                            name: name,
                            content: { entries: entries },
                            scope: 'personal',
                            created_at: Date.now()
                        });
                        
                        alert(`âœ… æˆåŠŸå¯¼å…¥: ${name}ï¼ˆ${Object.keys(entries).length} ä¸ªè¯æ¡ï¼‰`);
                        loadLorebookList();
                        showLorebookDetail(newId);
                        
                    } else {
                        // JSON æ ¼å¼
                        const json = JSON.parse(e.target.result);
                        // ç®€å•çš„æ ¼å¼æ ¡éªŒï¼šé€šå¸¸æœ‰ entries
                        if (!json.entries && !Array.isArray(json)) {
                            if(!confirm("è¿™ä¼¼ä¹ä¸æ˜¯æ ‡å‡†çš„ SillyTavern æ ¼å¼ï¼Œç¡®å®šè¦å¯¼å…¥å—ï¼Ÿ")) {
                                input.value = '';
                                return;
                            }
                        }
                        
                        if (json.name) name = json.name;

                        const newId = await db.lorebooks.add({
                            name: name,
                            content: json,
                            scope: 'personal',
                            created_at: Date.now()
                        });
                        
                        alert(`âœ… æˆåŠŸå¯¼å…¥: ${name}`);
                        loadLorebookList();
                        showLorebookDetail(newId);
                    }
                } catch (err) {
                    alert('âŒ è§£æå¤±è´¥: ' + err.message);
                }
            };
            reader.readAsText(file);
            input.value = '';
        }

        async function createNewLorebook() {
            const name = prompt("è¯·è¾“å…¥æ–°ä¸–ç•Œä¹¦åç§°ï¼š", "æ–°ä¸–ç•Œä¹¦");
            if (!name) return;
            
            // åˆå§‹åŒ–ç©ºç»“æ„ï¼Œé»˜è®¤ä¸ºå•äºº
            const newBook = {
                entries: {}
            };
            
            const newId = await db.lorebooks.add({
                name: name,
                content: newBook,
                scope: 'personal',
                created_at: Date.now()
            });
            loadLorebookList();
            // åˆ›å»ºåç›´æ¥æ‰“å¼€ç¼–è¾‘é¡µï¼Œå¯åœ¨é‡Œé¢è®¾ç½®ä½œç”¨åŸŸ
            showLorebookDetail(newId);
        }

        async function deleteLorebook(id) {
            if (confirm("ç¡®å®šè¦åˆ é™¤è¿™æœ¬ä¸–ç•Œä¹¦å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚")) {
                await db.lorebooks.delete(id);
                loadLorebookList();
            }
        }

        // åˆ‡æ¢ä¸–ç•Œä¹¦ä½œç”¨åŸŸï¼ˆå…¨å±€ <-> å•äººï¼‰â€”â€” ä»å¡ç‰‡ä¸Šç‚¹å‡»å¾½ç« 
        async function toggleLorebookScope(id) {
            const book = await db.lorebooks.get(id);
            if (!book) return;
            const currentScope = book.scope || 'personal';
            book.scope = currentScope === 'global' ? 'personal' : 'global';
            await db.lorebooks.put(book);
            loadLorebookList();
        }

        // åœ¨è¯¦æƒ…é¡µä¸­åˆ‡æ¢ä¸–ç•Œä¹¦ä½œç”¨åŸŸ
        async function saveLorebookScope(scope) {
            if (!currentBookId) return;
            const book = await db.lorebooks.get(currentBookId);
            if (!book) return;
            book.scope = scope;
            await db.lorebooks.put(book);
            // æ›´æ–°æ ‡é¢˜
            const scopeLabel = scope === 'global' ? ' [å…¨å±€]' : ' [å•äºº]';
            document.getElementById('lb-detail-title').innerText = book.name + scopeLabel;
            // æ›´æ–°é€‰ä¸­çŠ¶æ€
            document.querySelectorAll('.lb-scope-option').forEach(el => {
                el.classList.toggle('active', el.dataset.scope === scope);
            });
        }

        // å…¨å±€å˜é‡ï¼šå½“å‰æ“ä½œçš„ä¸–ç•Œä¹¦IDå’Œè¯æ¡ID
        let currentBookId = null;
        let currentEntryId = null;

        function editLorebook(id) {
            showLorebookDetail(id);
        }

        // æ˜¾ç¤ºä¸–ç•Œä¹¦è¯¦æƒ… (è¯æ¡åˆ—è¡¨)
        async function showLorebookDetail(id) {
            currentBookId = id;
            const book = await db.lorebooks.get(id);
            if (!book) return;

            const scope = book.scope || 'personal';
            const scopeLabel = scope === 'global' ? ' [å…¨å±€]' : ' [å•äºº]';
            document.getElementById('lb-detail-title').innerText = book.name + scopeLabel;
            document.getElementById('lb-detail-page').style.display = 'flex';
            
            // è®¾ç½®ä½œç”¨åŸŸé€‰æ‹©å™¨çŠ¶æ€
            document.querySelectorAll('.lb-scope-option').forEach(el => {
                el.classList.toggle('active', el.dataset.scope === scope);
            });
            
            renderEntryList(book.content.entries);
        }

        function hideLorebookDetail() {
            const page = document.getElementById('lb-detail-page');
            page.style.display = 'none';
            currentBookId = null;
            loadLorebookList(); // è¿”å›æ—¶åˆ·æ–°åˆ—è¡¨
        }

        // ä¿å­˜æŒ‰é’®ï¼šåˆ·æ–°åˆ—è¡¨å¹¶æç¤º
        async function saveAndRefreshLorebook() {
            await loadLorebookList();
            // çŸ­æš‚æç¤º
            const btn = event.target;
            const origText = btn.innerText;
            btn.innerText = 'å·²ä¿å­˜ âœ“';
            btn.style.color = '#34c759';
            setTimeout(() => {
                btn.innerText = origText;
                btn.style.color = '';
            }, 1200);
        }

        // æ¸²æŸ“è¯æ¡åˆ—è¡¨
        function renderEntryList(entries) {
            const container = document.getElementById('lb-entry-list');
            container.innerHTML = '';
            
            if (!entries || Object.keys(entries).length === 0) {
                container.innerHTML = `<div style="text-align:center; color:#999; margin-top:40px;">æš‚æ— è¯æ¡</div>`;
                return;
            }

            // æŒ‰ key æ’åº (é€šå¸¸æ˜¯æ•°å­—ç´¢å¼•ï¼Œä½†ä¹Ÿå¯èƒ½æ˜¯éšæœºå­—ç¬¦ä¸²)
            const keys = Object.keys(entries).sort((a,b) => parseInt(a) - parseInt(b));

            keys.forEach(key => {
                const entry = entries[key];
                const title = entry.comment || entry.key?.join(', ') || `è¯æ¡ #${key}`;
                const keysText = entry.key ? entry.key.join(', ') : 'æ— å…³é”®å­—';
                const isEnabled = entry.enabled !== false; // é»˜è®¤å¯ç”¨
                
                const div = document.createElement('div');
                div.className = 'lb-entry-item';
                div.style.opacity = isEnabled ? '1' : '0.5';
                div.innerHTML = `
                    <label class="lb-entry-toggle" onclick="event.stopPropagation();">
                        <input type="checkbox" ${isEnabled ? 'checked' : ''} onchange="toggleEntryEnabled('${key}', this.checked)">
                        <span class="lb-toggle-slider"></span>
                    </label>
                    <div style="flex:1; overflow:hidden; cursor:pointer;" onclick="showEntryEditor(currentBookId, '${key}')">
                        <div class="lb-entry-title">${title}</div>
                        <div class="lb-entry-keys">${keysText}</div>
                    </div>
                    <div style="color:#c7c7cc; cursor:pointer;" onclick="showEntryEditor(currentBookId, '${key}')">â€º</div>
                `;
                container.appendChild(div);
            });
        }

        // æ˜¾ç¤ºè¯æ¡ç¼–è¾‘å™¨
        async function showEntryEditor(bookId, entryId) {
            currentEntryId = entryId;
            const page = document.getElementById('lb-entry-page');
            const titleDom = document.getElementById('lb-entry-title');
            const keysInput = document.getElementById('entry-keys');
            const contentInput = document.getElementById('entry-content');
            
            // æ¸…ç©ºè¾“å…¥
            keysInput.value = '';
            contentInput.value = '';

            if (entryId !== null) {
                // ç¼–è¾‘ç°æœ‰è¯æ¡
                titleDom.innerText = "ç¼–è¾‘è¯æ¡";
                const book = await db.lorebooks.get(bookId);
                const entry = book.content.entries[entryId];
                if (entry) {
                    keysInput.value = entry.key ? entry.key.join(', ') : '';
                    contentInput.value = entry.content || '';
                }
            } else {
                // æ–°å»ºè¯æ¡
                titleDom.innerText = "æ–°å»ºè¯æ¡";
            }

            page.style.display = 'flex';
        }

        function hideEntryEditor() {
            document.getElementById('lb-entry-page').style.display = 'none';
            currentEntryId = null;
        }

        // ä¿å­˜è¯æ¡
        async function saveEntry() {
            if (!currentBookId) return;

            const keysStr = document.getElementById('entry-keys').value.trim();
            const content = document.getElementById('entry-content').value;
            
            // ç®€å•çš„æ ¡éªŒ
            if (!content && !keysStr) {
                alert("è¯·å¡«å†™å†…å®¹æˆ–å…³é”®å­—");
                return;
            }

            // å¤„ç†å…³é”®å­—æ•°ç»„
            const keys = keysStr.split(/[,ï¼Œ]/).map(k => k.trim()).filter(k => k);

            try {
                const book = await db.lorebooks.get(currentBookId);
                if (!book) return;

                // ç¡®ä¿ entries å¯¹è±¡å­˜åœ¨
                if (!book.content.entries) book.content.entries = {};

                let entryId = currentEntryId;
                if (entryId === null) {
                    // ç”Ÿæˆæ–°IDï¼šæ‰¾åˆ°æœ€å¤§ID + 1
                    const existingIds = Object.keys(book.content.entries).map(k => parseInt(k)).filter(n => !isNaN(n));
                    const maxId = existingIds.length > 0 ? Math.max(...existingIds) : -1;
                    entryId = (maxId + 1).toString();
                }

                // æ„é€ è¯æ¡å¯¹è±¡ (ä¿ç•™å…¶ä»–æœªä¿®æ”¹å­—æ®µå¦‚æœå­˜åœ¨)
                const oldEntry = book.content.entries[entryId] || {};
                book.content.entries[entryId] = {
                    ...oldEntry,
                    uid: oldEntry.uid !== undefined ? oldEntry.uid : entryId, // SillyTavern å¸¸ç”¨ uid
                    key: keys,
                    content: content,
                    comment: keys[0] || `è¯æ¡ #${entryId}`, // ç”¨ç¬¬ä¸€ä¸ªå…³é”®å­—åšæ³¨é‡Šå
                    enabled: true
                };

                await db.lorebooks.put(book);
                
                // åˆ·æ–°åˆ—è¡¨å¹¶å…³é—­ç¼–è¾‘å™¨
                renderEntryList(book.content.entries);
                hideEntryEditor();

            } catch (err) {
                alert("ä¿å­˜å¤±è´¥: " + err.message);
            }
        }

        // åˆ é™¤è¯æ¡
        async function deleteEntry() {
            if (!currentBookId || currentEntryId === null) return;
            
            if (!confirm("ç¡®å®šè¦åˆ é™¤æ­¤è¯æ¡å—ï¼Ÿ")) return;

            try {
                const book = await db.lorebooks.get(currentBookId);
                if (book && book.content.entries) {
                    delete book.content.entries[currentEntryId];
                    await db.lorebooks.put(book);
                    
                    renderEntryList(book.content.entries);
                    hideEntryEditor();
                }
            } catch (err) {
                alert("åˆ é™¤å¤±è´¥: " + err.message);
            }
        }

        // åˆ‡æ¢æ¡ç›®å¯ç”¨/ç¦ç”¨
        async function toggleEntryEnabled(entryKey, enabled) {
            if (!currentBookId) return;
            try {
                const book = await db.lorebooks.get(currentBookId);
                if (book && book.content && book.content.entries && book.content.entries[entryKey]) {
                    book.content.entries[entryKey].enabled = enabled;
                    await db.lorebooks.put(book);
                    renderEntryList(book.content.entries);
                }
            } catch (err) {
                console.error('åˆ‡æ¢æ¡ç›®çŠ¶æ€å¤±è´¥:', err);
            }
        }

        async function exportLorebook(id) {
            const book = await db.lorebooks.get(id);
            if (!book) return;
            
            const blob = new Blob([JSON.stringify(book.content, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${book.name}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // æ ¸å¿ƒï¼šä»DEXieæ¢å¤æ‰€æœ‰è®¾ç½®
        async function restoreSetting() {
            // è·å–æ‰€æœ‰å­˜å‚¨çš„æ•°æ®
            const allData = await db.dexiData.toArray();
            const dataMap = {};
            allData.forEach(item => {
                dataMap[item.key] = item.value;
            });
            
            // API é…ç½®æ— éœ€åœ¨é¦–é¡µæ˜¾ç¤ºï¼Œåªåœ¨å±•å¼€æ—¶åŠ è½½

            // æ¢å¤å£çº¸
            if (dataMap.wallpaper) document.getElementById('desktop-body').style.backgroundImage = `url(${dataMap.wallpaper})`;
            // æ¢å¤å°ç»„ä»¶
            if (dataMap.widgetIcon) document.getElementById('widget-icon').style.backgroundImage = `url(${dataMap.widgetIcon})`;
            if (dataMap.widgetTitle) document.getElementById('widget-title').innerText = dataMap.widgetTitle;
            if (dataMap.widgetSubtext) document.getElementById('widget-subtext').innerText = dataMap.widgetSubtext;
            // æ¢å¤æ‹ç«‹å¾—
            if (dataMap.photoLeft) document.getElementById('img-left').style.backgroundImage = `url(${dataMap.photoLeft})`;
            if (dataMap.photoRight) document.getElementById('img-right').style.backgroundImage = `url(${dataMap.photoRight})`;
            // æ¢å¤å¤´åƒ
            if (dataMap.avatar1) {
                const img1 = document.getElementById('avatar-img-1');
                img1.style.backgroundImage = `url(${dataMap.avatar1})`;
                img1.classList.add('has-image');
            }
            if (dataMap.avatar2) {
                const img2 = document.getElementById('avatar-img-2');
                img2.style.backgroundImage = `url(${dataMap.avatar2})`;
                img2.classList.add('has-image');
            }
            if (dataMap.avatar1Bubble) {
                document.getElementById('avatar-bubble1').innerText = dataMap.avatar1Bubble;
                const input1b = document.getElementById('avatar1-bubble-input');
                if (input1b) input1b.value = dataMap.avatar1Bubble;
            }
            if (dataMap.avatar1Name) {
                document.getElementById('avatar-name1').innerText = dataMap.avatar1Name;
                const input1n = document.getElementById('avatar1-name-input');
                if (input1n) input1n.value = dataMap.avatar1Name;
            }
            if (dataMap.avatar2Bubble) {
                document.getElementById('avatar-bubble2').innerText = dataMap.avatar2Bubble;
                const input2b = document.getElementById('avatar2-bubble-input');
                if (input2b) input2b.value = dataMap.avatar2Bubble;
            }
            if (dataMap.avatar2Name) {
                document.getElementById('avatar-name2').innerText = dataMap.avatar2Name;
                const input2n = document.getElementById('avatar2-name-input');
                if (input2n) input2n.value = dataMap.avatar2Name;
            }
            // æ¢å¤å€’æ•°æ—¥
            if (dataMap.daysText) {
                document.getElementById('days-text').innerText = dataMap.daysText;
                const daysInput = document.getElementById('days-input');
                if (daysInput) daysInput.value = dataMap.daysText;
            }
            // æ¢å¤å°ç»„ä»¶æ–‡æœ¬åˆ°è¾“å…¥æ¡†
            if (dataMap.widgetTitle) {
                const wtInput = document.getElementById('widget-title-input');
                if (wtInput) wtInput.value = dataMap.widgetTitle;
            }
            if (dataMap.widgetSubtext) {
                const wsInput = document.getElementById('widget-subtext-input');
                if (wsInput) wsInput.value = dataMap.widgetSubtext;
            }
            // æ¢å¤åº”ç”¨å›¾æ ‡
            const iconIds = ['appstore','notes','remind','facetime','photo','xianyu','cabin','icity','findphone'];
            iconIds.forEach(id => {
                const key = `icon${id.charAt(0).toUpperCase() + id.slice(1)}`;
                const el = document.getElementById(`icon-${id}`)?.querySelector('.icon');
                if (dataMap[key] && el) el.style.backgroundImage = `url(${dataMap[key]})`;
            });
            // æ¢å¤Dockå›¾æ ‡
            const dockIds = ['setting','custom','message','phone'];
            dockIds.forEach(id => {
                const key = `dock${id.charAt(0).toUpperCase() + id.slice(1)}`;
                const el = document.getElementById(`dock-${id}`)?.querySelector('.icon');
                if (dataMap[key] && el) el.style.backgroundImage = `url(${dataMap[key]})`;
            });
            
        // æ¢å¤æ¤­åœ†å½¢é¢œè‰²
        if (dataMap.heartColor) {
            document.documentElement.style.setProperty('--heart-color', dataMap.heartColor);
            const hcInput = document.getElementById('heart-color-input');
            if (hcInput) hcInput.value = dataMap.heartColor;
        }
        if (dataMap.capsuleColor) {
            document.documentElement.style.setProperty('--capsule-bg', dataMap.capsuleColor);
            const ccInput = document.getElementById('capsule-color-input');
            if (ccInput) ccInput.value = dataMap.capsuleColor;
        }
        if (dataMap.bubbleColor) {
            document.documentElement.style.setProperty('--bubble-bg', dataMap.bubbleColor);
            const bcInput = document.getElementById('bubble-color-input');
            if (bcInput) bcInput.value = dataMap.bubbleColor;
        }
        
        // æ¢å¤æ¡Œé¢æ–‡å­—é¢œè‰²
        if (dataMap.desktopTextColor && dataMap.desktopTextColor !== '#999999') {
            applyDesktopTextColor(dataMap.desktopTextColor);
            const dtcInput = document.getElementById('desktop-text-color-input');
            if (dtcInput) dtcInput.value = dataMap.desktopTextColor;
        }
        
        // æ¢å¤å…¨å±€å­—ä½“å¤§å°
        if (dataMap.globalFontSize && dataMap.globalFontSize !== '') {
            const slider = document.getElementById('global-font-size-slider');
            const label = document.getElementById('global-font-size-value');
            if (slider) slider.value = dataMap.globalFontSize;
            if (label) label.textContent = dataMap.globalFontSize + 'px';
            applyGlobalFontSize(dataMap.globalFontSize);
        }
        
        // æ¢å¤è‡ªå®šä¹‰å­—ä½“
        if (dataMap.customFontUrl && dataMap.customFontName) {
            // å¡«å……è¾“å…¥æ¡†
            document.getElementById('custom-font-input').value = dataMap.customFontUrl;
            document.getElementById('custom-font-name-input').value = dataMap.customFontName;
            // åŠ è½½å¹¶åº”ç”¨å…¨å±€å­—ä½“
            loadCustomFont(dataMap.customFontUrl, dataMap.customFontName, false);
        }

        // æ¢å¤è‡ªå®šä¹‰CSS
        if (dataMap.customCssCode) {
            const cssInput = document.getElementById('custom-css-input');
            if (cssInput) cssInput.value = dataMap.customCssCode;
            applyCustomCSS();
        }
    }

    // ===== è‡ªå®šä¹‰CSSåŠŸèƒ½ =====

    // åº”ç”¨è‡ªå®šä¹‰CSS
    function applyCustomCSS() {
        const cssCode = document.getElementById('custom-css-input').value;
        let styleEl = document.getElementById('user-custom-css');
        if (!styleEl) {
            styleEl = document.createElement('style');
            styleEl.id = 'user-custom-css';
            document.head.appendChild(styleEl);
        }
        styleEl.textContent = cssCode || '';
    }

    // æ¸…ç©ºè‡ªå®šä¹‰CSS
    function clearCustomCSS() {
        document.getElementById('custom-css-input').value = '';
        applyCustomCSS();
        if (typeof showToast === 'function') showToast('å·²æ¸…ç©ºè‡ªå®šä¹‰CSS');
    }

    /**
     * ä¿å­˜å½“å‰å…¨å±€è‡ªå®šä¹‰CSSä¸ºé¢„è®¾
     * å°†textareaä¸­çš„CSSä»£ç ä»¥å‘½åé¢„è®¾çš„æ–¹å¼æŒä¹…åŒ–åˆ°IndexedDB
     */
    async function saveGlobalCSSPreset() {
        const cssCode = document.getElementById('custom-css-input')?.value?.trim();
        if (!cssCode) {
            showToast('å½“å‰æ²¡æœ‰CSSä»£ç å¯ä¿å­˜');
            return;
        }

        const presetName = prompt('è¯·è¾“å…¥é¢„è®¾åç§°ï¼š');
        if (!presetName || !presetName.trim()) return;

        try {
            const existing = await db.dexiData.get('globalCSSPresets');
            const presets = existing ? existing.value : [];

            // æ£€æŸ¥æ˜¯å¦é‡å
            if (presets.find(p => p.name === presetName.trim())) {
                if (!confirm(`é¢„è®¾"${presetName.trim()}"å·²å­˜åœ¨ï¼Œæ˜¯å¦è¦†ç›–ï¼Ÿ`)) return;
                const idx = presets.findIndex(p => p.name === presetName.trim());
                if (idx !== -1) presets.splice(idx, 1);
            }

            presets.push({
                name: presetName.trim(),
                cssCode: cssCode,
                time: Date.now()
            });

            await db.dexiData.put({ key: 'globalCSSPresets', value: presets });
            showToast(`CSSé¢„è®¾"${presetName.trim()}"å·²ä¿å­˜ï¼`);
        } catch (e) {
            console.error('[å…¨å±€CSS] ä¿å­˜é¢„è®¾å¤±è´¥:', e);
            showToast('ä¿å­˜é¢„è®¾å¤±è´¥');
        }
    }

    /**
     * åŠ è½½å…¨å±€CSSé¢„è®¾åˆ—è¡¨
     * ä»IndexedDBè¯»å–å·²ä¿å­˜çš„CSSé¢„è®¾å¹¶å±•ç¤ºä¸ºå¯æ“ä½œåˆ—è¡¨
     */
    async function loadGlobalCSSPreset() {
        try {
            const existing = await db.dexiData.get('globalCSSPresets');
            const presets = existing ? existing.value : [];

            if (presets.length === 0) {
                showToast('æš‚æ— ä¿å­˜çš„CSSé¢„è®¾');
                return;
            }

            const listEl = document.getElementById('global-css-preset-list');
            if (!listEl) return;

            // åˆ‡æ¢æ˜¾ç¤º/éšè—
            if (listEl.style.display !== 'none' && listEl.innerHTML !== '') {
                listEl.style.display = 'none';
                return;
            }

            let html = '';
            for (let i = 0; i < presets.length; i++) {
                const p = presets[i];
                const timeStr = p.time ? new Date(p.time).toLocaleDateString() : '';
                const preview = (p.cssCode || '').substring(0, 50).replace(/</g, '&lt;') + (p.cssCode?.length > 50 ? '...' : '');

                html += `
                    <div style="display:flex; align-items:center; padding:10px 12px; background:#fff; border:1px solid #e8e8e8; border-radius:10px; margin-bottom:8px;">
                        <div style="flex:1; min-width:0;">
                            <div style="font-size:13px; font-weight:500; color:#333; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${p.name}</div>
                            <div style="font-size:10px; color:#aaa; margin-top:3px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${preview} ${timeStr ? 'Â· ' + timeStr : ''}</div>
                        </div>
                        <div style="display:flex; gap:6px; flex-shrink:0; margin-left:8px;">
                            <div onclick="applyGlobalCSSPreset(${i})" style="padding:5px 12px; font-size:11px; background:#007aff; color:#fff; border-radius:6px; cursor:pointer; font-weight:500;">åº”ç”¨</div>
                            <div onclick="deleteGlobalCSSPreset(${i})" style="padding:5px 10px; font-size:11px; background:#f5f5f5; color:#ff3b30; border-radius:6px; cursor:pointer;">åˆ é™¤</div>
                        </div>
                    </div>
                `;
            }

            listEl.innerHTML = html;
            listEl.style.display = 'block';
        } catch (e) {
            console.error('[å…¨å±€CSS] åŠ è½½é¢„è®¾å¤±è´¥:', e);
            showToast('åŠ è½½é¢„è®¾å¤±è´¥');
        }
    }

    /**
     * åº”ç”¨æŒ‡å®šçš„å…¨å±€CSSé¢„è®¾
     * å°†é¢„è®¾ä¸­çš„CSSä»£ç å›å¡«åˆ°textareaå¹¶ç«‹å³ç”Ÿæ•ˆ
     */
    async function applyGlobalCSSPreset(index) {
        try {
            const existing = await db.dexiData.get('globalCSSPresets');
            const presets = existing ? existing.value : [];
            if (index < 0 || index >= presets.length) return;

            const p = presets[index];
            const cssInput = document.getElementById('custom-css-input');
            if (cssInput) {
                cssInput.value = p.cssCode || '';
            }

            // ç«‹å³åº”ç”¨CSS
            applyCustomCSS();

            showToast(`å·²åº”ç”¨CSSé¢„è®¾"${p.name}"`);

            // éšè—é¢„è®¾åˆ—è¡¨
            const listEl = document.getElementById('global-css-preset-list');
            if (listEl) listEl.style.display = 'none';
        } catch (e) {
            console.error('[å…¨å±€CSS] åº”ç”¨é¢„è®¾å¤±è´¥:', e);
            showToast('åº”ç”¨é¢„è®¾å¤±è´¥');
        }
    }

    /**
     * åˆ é™¤æŒ‡å®šçš„å…¨å±€CSSé¢„è®¾
     * ä»IndexedDBä¸­ç§»é™¤å¹¶åˆ·æ–°é¢„è®¾åˆ—è¡¨
     */
    async function deleteGlobalCSSPreset(index) {
        try {
            const existing = await db.dexiData.get('globalCSSPresets');
            const presets = existing ? existing.value : [];
            if (index < 0 || index >= presets.length) return;

            const name = presets[index].name;
            if (!confirm(`ç¡®å®šè¦åˆ é™¤CSSé¢„è®¾"${name}"å—ï¼Ÿ`)) return;

            presets.splice(index, 1);
            await db.dexiData.put({ key: 'globalCSSPresets', value: presets });

            showToast(`å·²åˆ é™¤CSSé¢„è®¾"${name}"`);

            // åˆ·æ–°åˆ—è¡¨
            const listEl = document.getElementById('global-css-preset-list');
            if (listEl) {
                listEl.style.display = 'none';
                listEl.innerHTML = '';
            }
            if (presets.length > 0) {
                loadGlobalCSSPreset();
            }
        } catch (e) {
            console.error('[å…¨å±€CSS] åˆ é™¤é¢„è®¾å¤±è´¥:', e);
            showToast('åˆ é™¤é¢„è®¾å¤±è´¥');
        }
    }

    /**
     * æ˜¾ç¤ºCSSç±»åå‚è€ƒå¼¹çª—
     * åˆ—å‡ºèŠå¤©é¡µé¢å„åŒºåŸŸçš„CSSç±»åï¼Œæ–¹ä¾¿ç”¨æˆ·ç¼–å†™è‡ªå®šä¹‰CSS
     */
    function showCSSClassReference() {
        let modal = document.getElementById('css-class-ref-modal');
        if (modal) {
            modal.style.display = 'flex';
            return;
        }
        modal = document.createElement('div');
        modal.id = 'css-class-ref-modal';
        modal.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:10001; display:flex; align-items:center; justify-content:center; backdrop-filter:blur(3px); -webkit-backdrop-filter:blur(3px);';
        modal.onclick = function(e) { if (e.target === modal) modal.style.display = 'none'; };

        const sections = [
            {
                title: 'ğŸ“± èŠå¤©é¡µé¢ Â· æ•´ä½“ç»“æ„',
                items: [
                    ['.chat-window', 'èŠå¤©çª—å£ï¼ˆæ•´ä¸ªé¡µé¢å®¹å™¨ï¼‰'],
                    ['.chat-header', 'é¡¶æ ï¼ˆåŒ…å«è¿”å›/æ ‡é¢˜/æŒ‰é’®ï¼‰'],
                    ['.chat-back', 'è¿”å›æŒ‰é’®ï¼ˆå·¦ä¸Šè§’ â†ï¼‰'],
                    ['.chat-title', 'æ ‡é¢˜ï¼ˆè§’è‰²åå­—ï¼‰'],
                    ['.chat-more', 'å³ä¾§æŒ‰é’®ï¼ˆçº¿ä¸‹æ¨¡å¼ / èŠå¤©è¯¦æƒ… Â·Â·Â·ï¼‰'],
                    ['.chat-body', 'æ¶ˆæ¯åˆ—è¡¨åŒºåŸŸï¼ˆä¸­é—´æ»šåŠ¨åŒºï¼‰'],
                    ['.chat-footer', 'åº•æ ï¼ˆè¾“å…¥æ¡†åŒºåŸŸå®¹å™¨ï¼‰'],
                ]
            },
            {
                title: 'âŒ¨ï¸ è¾“å…¥åŒºåŸŸ',
                items: [
                    ['.chat-input-bar', 'è¾“å…¥æ ï¼ˆä¸€è¡Œï¼šé­”æ³•æ£’+è¾“å…¥æ¡†+æŒ‰é’®ï¼‰'],
                    ['.chat-icon-btn', 'å›¾æ ‡æŒ‰é’®ï¼ˆæ¥æ”¶å›å¤ğŸª„ / è¡¨æƒ…ğŸ˜Š / èœå•âŠ•ï¼‰'],
                    ['.chat-input', 'æ–‡å­—è¾“å…¥æ¡†'],
                    ['.chat-send-btn', 'å‘é€æŒ‰é’®'],
                    ['.chat-panel-container', 'åº•éƒ¨é¢æ¿å®¹å™¨ï¼ˆè¡¨æƒ…/èœå•å…±ç”¨ï¼‰'],
                    ['.emoji-panel', 'è¡¨æƒ…é¢æ¿ï¼ˆEmoji åˆ—è¡¨ï¼‰'],
                    ['.action-panel', 'èœå•é¢æ¿ï¼ˆ+å·å±•å¼€çš„åŠŸèƒ½é¢æ¿ï¼‰'],
                    ['.action-panel-page', 'èœå•é¢æ¿åˆ†é¡µ'],
                    ['.action-item', 'èœå•åŠŸèƒ½é¡¹ï¼ˆè¯­éŸ³/ç›¸å†Œ/è½¬è´¦ç­‰ï¼‰'],
                    ['.action-icon-box', 'èœå•åŠŸèƒ½é¡¹å›¾æ ‡å®¹å™¨'],
                    ['.action-name', 'èœå•åŠŸèƒ½é¡¹æ–‡å­—'],
                ]
            },
            {
                title: 'ğŸ’¬ æ¶ˆæ¯æ°”æ³¡',
                items: [
                    ['.message-row', 'æ¶ˆæ¯è¡Œï¼ˆæ¯æ¡æ¶ˆæ¯çš„å®¹å™¨ï¼‰'],
                    ['.message-row.other', 'å¯¹æ–¹æ¶ˆæ¯è¡Œ'],
                    ['.message-row.self', 'æˆ‘çš„æ¶ˆæ¯è¡Œ'],
                    ['.message-content', 'æ¶ˆæ¯æ°”æ³¡ï¼ˆæ–‡å­—å†…å®¹åŒºï¼‰'],
                    ['.ai-bubble', 'å¯¹æ–¹æ°”æ³¡ï¼ˆç”¨äºè§’è‰²å•ç‹¬CSSï¼‰'],
                    ['.user-bubble', 'æˆ‘çš„æ°”æ³¡ï¼ˆç”¨äºè§’è‰²å•ç‹¬CSSï¼‰'],
                    ['.message-avatar', 'æ¶ˆæ¯å¤´åƒ'],
                    ['.message-timestamp', 'æ—¶é—´æˆ³ï¼ˆæ¶ˆæ¯é—´çš„æ—¶é—´åˆ†éš”ï¼‰'],
                ]
            },
            {
                title: 'ğŸ¤ è¯­éŸ³æ°”æ³¡',
                items: [
                    ['.voice-bubble', 'è¯­éŸ³æ¶ˆæ¯æ°”æ³¡ï¼ˆæ•´ä¸ªè¯­éŸ³æ¡ï¼‰'],
                    ['.voice-bubble-header', 'è¯­éŸ³æ¡å¤´éƒ¨ï¼ˆå›¾æ ‡+æ³¢çº¹+æ—¶é•¿ï¼‰'],
                    ['.voice-icon', 'è¯­éŸ³å›¾æ ‡'],
                    ['.voice-bars', 'è¯­éŸ³æ³¢çº¹åŠ¨ç”»'],
                    ['.voice-duration', 'è¯­éŸ³æ—¶é•¿æ–‡å­—'],
                    ['.voice-text-content', 'è¯­éŸ³è½¬æ–‡å­—å†…å®¹ï¼ˆå±•å¼€åæ˜¾ç¤ºï¼‰'],
                    ['.message-row.other .voice-bubble', 'å¯¹æ–¹è¯­éŸ³æ°”æ³¡'],
                    ['.message-row.self .voice-bubble', 'æˆ‘çš„è¯­éŸ³æ°”æ³¡'],
                ]
            },
            {
                title: 'ğŸ’³ å¡ç‰‡æ¶ˆæ¯',
                items: [
                    ['.transfer-card', 'è½¬è´¦å¡ç‰‡'],
                    ['.transfer-card.done', 'å·²æ”¶æ¬¾çš„è½¬è´¦å¡ç‰‡'],
                    ['.transfer-card.returned', 'å·²é€€å›çš„è½¬è´¦å¡ç‰‡'],
                    ['.t-amount', 'è½¬è´¦é‡‘é¢'],
                    ['.t-desc', 'è½¬è´¦å¤‡æ³¨'],
                    ['.t-footer', 'è½¬è´¦åº•éƒ¨çŠ¶æ€æ '],
                    ['.redpacket-card', 'çº¢åŒ…å¡ç‰‡'],
                    ['.family-card-msg', 'äº²å±å¡æ¶ˆæ¯å¡ç‰‡'],
                    ['.spr-card', 'ä¸“å±çº¢åŒ… / ç¤¼ç‰©å¡ç‰‡'],
                    ['.intimate-req-card', 'äº²å¯†å…³ç³»è¯·æ±‚å¡ç‰‡'],
                    ['.location-card', 'ä½ç½®å¡ç‰‡ï¼ˆæ•´ä½“ï¼‰'],
                    ['.location-card-text', 'ä½ç½®å¡ç‰‡æ–‡å­—åŒº'],
                    ['.location-card-name', 'ä½ç½®åç§°'],
                    ['.location-card-map', 'ä½ç½®å¡ç‰‡åœ°å›¾åŒº'],
                ]
            },
            {
                title: 'ğŸ’¬ å¼•ç”¨ & å…¶ä»–',
                items: [
                    ['.quote-preview', 'å¼•ç”¨é¢„è§ˆåŒºï¼ˆè¾“å…¥æ¡†ä¸Šæ–¹ï¼‰'],
                    ['.quote-preview-name', 'å¼•ç”¨çš„å‘é€è€…åå­—'],
                    ['.quote-preview-msg', 'å¼•ç”¨çš„æ¶ˆæ¯å†…å®¹'],
                    ['.quoted-message', 'æ°”æ³¡ä¸­çš„å¼•ç”¨æ¶ˆæ¯å—'],
                    ['.quoted-message-name', 'å¼•ç”¨æ¶ˆæ¯ä¸­çš„åå­—'],
                    ['#sticker-suggestion-bar', 'æ™ºèƒ½è¡¨æƒ…æ¨èæ '],
                ]
            },
            {
                title: 'ğŸ“‹ å¾®ä¿¡åˆ—è¡¨é¡µ',
                items: [
                    ['.wechat-page', 'å¾®ä¿¡é¡µé¢å®¹å™¨'],
                    ['.wechat-header', 'å¾®ä¿¡é¡µé¢é¡¶æ '],
                    ['.wechat-tab-bar', 'å¾®ä¿¡åº•éƒ¨Tabæ '],
                    ['.wechat-tab-item', 'åº•éƒ¨Tabé¡¹'],
                    ['.wechat-list-item', 'èŠå¤©åˆ—è¡¨é¡¹ï¼ˆä¼šè¯æ¡ç›®ï¼‰'],
                ]
            },
            {
                title: 'ğŸ  æ¡Œé¢',
                items: [
                    ['.top-widget', 'é¡¶éƒ¨ç£¨ç ‚å°ç»„ä»¶'],
                    ['.dock', 'åº•éƒ¨Dockæ '],
                    ['.app-icon', 'åº”ç”¨å›¾æ ‡'],
                    ['.app-icon .name', 'åº”ç”¨å›¾æ ‡æ–‡å­—'],
                ]
            },
        ];

        let html = '<div style="width:90%; max-width:420px; max-height:85vh; background:#fff; border-radius:20px; display:flex; flex-direction:column; overflow:hidden; box-shadow:0 10px 40px rgba(0,0,0,0.3);">';
        html += '<div style="padding:16px 20px; border-bottom:1px solid #eee; display:flex; align-items:center; justify-content:space-between; flex-shrink:0; background:#f8f8f8;">';
        html += '<div style="font-size:17px; font-weight:600; color:#333;">ğŸ“‹ CSSç±»åé€ŸæŸ¥</div>';
        html += '<div onclick="document.getElementById(\'css-class-ref-modal\').style.display=\'none\'" style="width:30px; height:30px; display:flex; align-items:center; justify-content:center; cursor:pointer; font-size:20px; color:#999; border-radius:50%; background:#f0f0f0;">Ã—</div>';
        html += '</div>';
        html += '<div style="flex:1; overflow-y:auto; -webkit-overflow-scrolling:touch; padding:16px 20px;">';
        html += '<div style="font-size:11px; color:#999; margin-bottom:12px; line-height:1.5;">ç‚¹å‡»ç±»åå¯å¤åˆ¶ã€‚åœ¨è‡ªå®šä¹‰CSSä¸­ä½¿ç”¨è¿™äº›ç±»åæ¥ä¿®æ”¹å¯¹åº”å…ƒç´ çš„æ ·å¼ã€‚</div>';

        for (const sec of sections) {
            html += '<div style="margin-bottom:16px;">';
            html += '<div style="font-size:14px; font-weight:600; color:#333; margin-bottom:8px; padding-bottom:6px; border-bottom:1px solid #f0f0f0;">' + sec.title + '</div>';
            for (const [cls, desc] of sec.items) {
                html += '<div style="display:flex; align-items:flex-start; gap:8px; margin-bottom:6px; line-height:1.4;">';
                html += '<code onclick="navigator.clipboard.writeText(\'' + cls + '\');this.style.background=\'#d4edda\';setTimeout(()=>{this.style.background=\'#f0f0f0\'},600)" style="background:#f0f0f0; padding:2px 6px; border-radius:4px; font-size:11px; color:#c7254e; cursor:pointer; flex-shrink:0; white-space:nowrap; transition:background 0.2s; user-select:all; -webkit-user-select:all;">' + cls + '</code>';
                html += '<span style="font-size:12px; color:#666;">' + desc + '</span>';
                html += '</div>';
            }
            html += '</div>';
        }

        html += '</div></div>';
        modal.innerHTML = html;
        document.body.appendChild(modal);
    }

    // é¢„è§ˆè‡ªå®šä¹‰CSSæ•ˆæœï¼ˆèŠå¤©é¡µé¢ï¼‰
    function previewCustomCSS() {
        const cssCode = document.getElementById('custom-css-input').value;
        const modal = document.getElementById('css-preview-modal');
        if (!modal) return;
        
        // æ˜¾ç¤ºæ¨¡æ€æ¡†
        modal.style.display = 'flex';
        
        // åˆ›å»ºé¢„è§ˆä¸“ç”¨çš„styleæ ‡ç­¾ï¼ˆåªä½œç”¨äºé¢„è§ˆåŒºåŸŸï¼‰
        let previewStyleEl = document.getElementById('css-preview-style');
        if (!previewStyleEl) {
            previewStyleEl = document.createElement('style');
            previewStyleEl.id = 'css-preview-style';
            document.head.appendChild(previewStyleEl);
        }
        
        // åˆ·æ–°é¢„è§ˆ
        refreshCSSPreview();
    }
    
    // å°†CSSä½œç”¨åŸŸé™åˆ¶åœ¨é¢„è§ˆæ¨¡æ€æ¡†å†…
    function scopeCSSForPreview(cssCode) {
        if (!cssCode) return '';
        
        // ç®€å•çš„CSSä½œç”¨åŸŸå¤„ç†ï¼šåœ¨æ¯ä¸ªé€‰æ‹©å™¨å‰æ·»åŠ  #css-preview-modal
        // å¤„ç† @è§„åˆ™ï¼ˆå¦‚ @mediaï¼‰å’Œæ³¨é‡Š
        let scoped = cssCode;
        
        // ç§»é™¤æ³¨é‡Š
        scoped = scoped.replace(/\/\*[\s\S]*?\*\//g, '');
        
        // å¤„ç† @è§„åˆ™ï¼ˆä¿ç•™åŸæ ·ï¼Œä½†å†…å®¹éœ€è¦ä½œç”¨åŸŸï¼‰
        const atRules = [];
        scoped = scoped.replace(/@[^{]+{[\s\S]*?}/g, (match) => {
            const id = `__AT_RULE_${atRules.length}__`;
            atRules.push({ id, content: match });
            return id;
        });
        
        // ä¸ºä¸»è¦è§„åˆ™æ·»åŠ ä½œç”¨åŸŸ
        scoped = scoped.replace(/([^{}]+){([^{}]+)}/g, (match, selector, rules) => {
            const trimmedSelector = selector.trim();
            // è·³è¿‡ @è§„åˆ™å ä½ç¬¦
            if (trimmedSelector.startsWith('__AT_RULE_')) {
                return match;
            }
            // ä¸ºé€‰æ‹©å™¨æ·»åŠ ä½œç”¨åŸŸ
            return `#css-preview-modal ${trimmedSelector}{${rules}}`;
        });
        
        // æ¢å¤ @è§„åˆ™
        atRules.forEach(rule => {
            scoped = scoped.replace(rule.id, rule.content);
        });
        
        return scoped;
    }

    // å…³é—­CSSé¢„è§ˆ
    function closeCSSPreview() {
        const modal = document.getElementById('css-preview-modal');
        if (modal) {
            modal.style.display = 'none';
        }
        // ç§»é™¤é¢„è§ˆæ ·å¼ï¼ˆå¯é€‰ï¼Œå¦‚æœæƒ³ä¿ç•™é¢„è§ˆæ•ˆæœå¯ä»¥æ³¨é‡Šæ‰ï¼‰
        // const previewStyleEl = document.getElementById('css-preview-style');
        // if (previewStyleEl) {
        //     previewStyleEl.textContent = '';
        // }
    }

    // åˆ·æ–°CSSé¢„è§ˆ
    function refreshCSSPreview() {
        const cssCode = document.getElementById('custom-css-input').value;
        const previewStyleEl = document.getElementById('css-preview-style');
        if (previewStyleEl) {
            // ç›´æ¥åº”ç”¨CSSï¼Œå› ä¸ºé¢„è§ˆåŒºåŸŸå·²ç»æœ‰æ­£ç¡®çš„ç±»åç»“æ„
            // ä¸éœ€è¦æ·»åŠ ä½œç”¨åŸŸï¼Œè®©CSSç›´æ¥åº”ç”¨åˆ°é¢„è§ˆå…ƒç´ ä¸Š
            previewStyleEl.textContent = cssCode || '';
        }
    }

    // ä»é¢„è§ˆåº”ç”¨CSS
    function applyCSSFromPreview() {
        applyCustomCSS();
        closeCSSPreview();
        if (typeof showToast === 'function') showToast('CSSå·²åº”ç”¨');
    }

    // å®æ—¶æ›´æ–°CSSé¢„è§ˆï¼ˆå½“é¢„è§ˆçª—å£æ‰“å¼€æ—¶ï¼‰
    function updateCSSPreview() {
        const modal = document.getElementById('css-preview-modal');
        if (modal && modal.style.display === 'flex') {
            refreshCSSPreview();
        }
    }

    // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
    document.addEventListener('click', function(e) {
        const modal = document.getElementById('css-preview-modal');
        if (modal && e.target === modal) {
            closeCSSPreview();
        }
    });

// --- å…¨å±€è¡¨æƒ…åŒ…ç®¡ç†é€»è¾‘ ---
function showStickerPage() {
    console.log('[showStickerPage] Function called');
    const page = document.getElementById('sticker-page');
    console.log('[showStickerPage] sticker-page element:', page);
    if (!page) {
        console.error('[showStickerPage] sticker-page element not found');
        return;
    }
    console.log('[showStickerPage] Setting display to flex and ensuring position fixed');
    // ç¡®ä¿é¡µé¢æ˜¯ fixed å®šä½å¹¶æ˜¾ç¤ºï¼ˆä¸è®¾å›ºå®šé«˜åº¦ï¼Œç”¨ top:0+bottom:0 è‡ªåŠ¨æ’‘æ»¡ï¼‰
    page.style.position = 'fixed';
    page.style.top = '0';
    page.style.left = '0';
    page.style.right = '0';
    page.style.bottom = '0';
    page.style.width = '100vw';
    page.style.zIndex = '200';
    page.style.display = 'flex';
    console.log('[showStickerPage] Calling renderStickerCategories');
    // ç¡®ä¿æ˜¾ç¤ºåˆ—è¡¨è§†å›¾
    const listView = document.getElementById('sticker-list-view');
    const detailView = document.getElementById('sticker-detail-view');
    if (listView) listView.style.display = 'flex';
    if (detailView) detailView.style.display = 'none';
    currentStickerCategoryId = null;
    renderStickerCategories();
    console.log('[showStickerPage] Done');
}
// ç¡®ä¿å‡½æ•°åœ¨å…¨å±€ä½œç”¨åŸŸå¯è®¿é—®
window.showStickerPage = showStickerPage;

function hideStickerPage() {
    const page = document.getElementById('sticker-page');
    if (!page) {
        console.error('sticker-page element not found');
        return;
    }
    page.style.transform = 'scale(0.95)';
    page.style.opacity = '0';
    setTimeout(() => {
        page.style.display = 'none';
        page.style.transform = ''; 
        page.style.opacity = '';
    }, 200);
}
// ç¡®ä¿å‡½æ•°åœ¨å…¨å±€ä½œç”¨åŸŸå¯è®¿é—®
window.hideStickerPage = hideStickerPage;

async function renderStickerCategories() {
    const list = await db.sticker_categories.toArray();
    const listContainer = document.getElementById('sticker-category-list');
    
    if (!listContainer) {
        console.error('sticker-category-list element not found');
        return;
    }
    
    // å¦‚æœæ²¡æœ‰åˆ†ç±»ï¼Œæ˜¾ç¤ºç©ºçŠ¶æ€
    if (list.length === 0) {
        listContainer.innerHTML = `
            <div class="sticker-empty-state">
                <svg class="svg-icon" style="width:64px; height:64px; stroke:#e5e5ea;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg>
                <div style="color:#999; margin-top:16px;">æš‚æ— è¡¨æƒ…åŒ…åˆ†ç±»</div>
                <button onclick="showCreateCategoryModal()" style="margin-top:20px; padding:8px 20px; background:var(--ins-pink); color:#fff; border:none; border-radius:20px; font-size:14px;">æ–°å»ºåˆ†ç±»</button>
                <div style="margin-top:10px;">
                    <input type="file" id="import-sticker-json" accept=".json" style="display:none" onchange="importStickerCategory(this)">
                    <button onclick="document.getElementById('import-sticker-json').click()" style="padding:8px 20px; background:#f2f2f7; color:#333; border:none; border-radius:20px; font-size:14px;">å¯¼å…¥é…ç½®</button>
                </div>
            </div>
        `;
        return;
    }

    // æ¸²æŸ“åˆ†ç±»åˆ—è¡¨
    listContainer.innerHTML = list.map(cat => {
        const stickerCount = (cat.stickers || []).length;
        return `
            <div class="sticker-category-item" onclick="openStickerCategoryDetail(${cat.id})">
                <div style="flex:1;">
                    <div style="font-size:16px; font-weight:500; color:#333; margin-bottom:4px;">${cat.name}</div>
                    <div style="font-size:12px; color:#999;">${stickerCount} ä¸ªè¡¨æƒ…</div>
                </div>
                <div style="display:flex; gap:8px; align-items:center;">
                    <div class="sticker-category-action" onclick="event.stopPropagation(); exportStickerCategory(${cat.id})" style="padding:6px 12px; background:var(--ins-pink-light); color:var(--ins-pink); border-radius:6px; font-size:12px;">å¯¼å‡º</div>
                    <div class="sticker-category-action" onclick="event.stopPropagation(); deleteStickerCategory(${cat.id})" style="padding:6px 12px; background:#ffe5e5; color:#ff3b30; border-radius:6px; font-size:12px;">åˆ é™¤</div>
                    <svg class="svg-icon" style="width:16px; height:16px; color:#ccc;" viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"></polyline></svg>
                </div>
            </div>
        `;
    }).join('');
}

// æ‰“å¼€åˆ†ç±»è¯¦æƒ…é¡µ
async function openStickerCategoryDetail(id) {
    currentStickerCategoryId = id;
    const listView = document.getElementById('sticker-list-view');
    const detailView = document.getElementById('sticker-detail-view');
    
    if (listView) listView.style.display = 'none';
    if (detailView) detailView.style.display = 'flex';
    
    await renderStickerCategoryDetail();
}

// è¿”å›åˆ†ç±»åˆ—è¡¨
function backToStickerList() {
    const listView = document.getElementById('sticker-list-view');
    const detailView = document.getElementById('sticker-detail-view');
    
    if (listView) listView.style.display = 'flex';
    if (detailView) detailView.style.display = 'none';
    
    currentStickerCategoryId = null;
    renderStickerCategories();
}

// æ¸²æŸ“åˆ†ç±»è¯¦æƒ…
async function renderStickerCategoryDetail() {
    if (!currentStickerCategoryId) return;
    
    const cat = await db.sticker_categories.get(currentStickerCategoryId);
    if (!cat) return;
    
    const titleEl = document.getElementById('sticker-detail-title');
    const contentEl = document.getElementById('sticker-detail-content');
    
    if (titleEl) titleEl.innerText = cat.name;
    if (!contentEl) return;
    
    contentEl.innerHTML = `
        <div style="padding: 16px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px; padding:12px; background:#f9f9f9; border-radius:12px;">
                <div>
                    <div style="font-size:14px; color:#999; margin-bottom:4px;">è¡¨æƒ…æ•°é‡</div>
                    <div style="font-size:20px; font-weight:600; color:#333;">${(cat.stickers || []).length}</div>
                </div>
                <div style="display:flex; gap:10px; flex-wrap:wrap;">
                    <button onclick="exportStickerCategory(${cat.id})" style="padding:8px 16px; background:var(--ins-pink-light); color:var(--ins-pink); border:none; border-radius:8px; font-size:14px; font-weight:500;">å¯¼å‡º</button>
                    <input type="file" id="import-sticker-json-detail" accept=".json" style="display:none" onchange="importStickerCategory(this)">
                    <button onclick="document.getElementById('import-sticker-json-detail').click()" style="padding:8px 16px; background:#f2f2f7; color:#666; border:none; border-radius:8px; font-size:14px; font-weight:500;">å¯¼å…¥</button>
                    <input type="file" id="batch-import-sticker-txt" accept=".txt,.text,.md,.docx,.doc" style="display:none" onchange="batchImportStickersFromText(this)">
                    <button onclick="document.getElementById('batch-import-sticker-txt').click()" style="padding:8px 16px; background:#e8f5e9; color:#2e7d32; border:none; border-radius:8px; font-size:14px; font-weight:500;" title="æ”¯æŒ.txt/.md/.docxæ–‡ä»¶ï¼Œæ ¼å¼ï¼šæè¿°ï¼šå›¾ç‰‡é“¾æ¥">æ‰¹é‡å¯¼å…¥</button>
                </div>
            </div>
            
            <div class="sticker-grid-view">
                <!-- æ·»åŠ æŒ‰é’® -->
                <div class="sticker-grid-item add-btn" onclick="showAddStickerModal()">
                    <svg class="svg-icon" style="width:24px; height:24px;" viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                    <div style="font-size:12px; color:#999; margin-top:8px;">æ·»åŠ è¡¨æƒ…</div>
                </div>
                ${(cat.stickers || []).map((s, idx) => `
                    <div class="sticker-grid-item" onclick="previewSticker(${idx})">
                        <img src="${s.url}" class="sticker-img" style="object-fit:cover;" onerror="this.onerror=null; this.style.cssText='width:100%; height:100%; display:flex; align-items:center; justify-content:center; background:#f5f5f5; border-radius:8px;'; this.outerHTML='<div class=\\'sticker-img\\' style=\\'display:flex; align-items:center; justify-content:center; background:#f5f5f5; color:#ccc; font-size:10px;\\'>å¤±è´¥</div>';" />
                        ${s.description ? `<div class="sticker-desc-tag">AIå¯è¯†</div>` : ''}
                        <div class="sticker-del-btn" onclick="deleteSticker(${idx}, event)">
                            <svg style="width:12px; height:12px; stroke:#fff; stroke-width:2;" viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                        </div>
                    </div>
                `).join('')}
            </div>
        </div>
    `;
}

// æ˜¾ç¤ºåˆ›å»ºåˆ†ç±»å¼¹çª—
function showCreateCategoryModal() {
    const name = prompt("è¯·è¾“å…¥åˆ†ç±»åç§°", "æˆ‘çš„è¡¨æƒ…");
    if (name && name.trim()) {
        createNewStickerCategory(name.trim());
    }
}

async function createNewStickerCategory(name) {
    try {
        const id = await db.sticker_categories.add({
            name: name,
            stickers: []
        });
        renderStickerCategories();
    } catch (err) {
        console.error('åˆ›å»ºåˆ†ç±»å¤±è´¥:', err);
        alert('åˆ›å»ºåˆ†ç±»å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
}

async function deleteStickerCategory(id) {
    if (confirm("ç¡®å®šè¦åˆ é™¤è¿™ä¸ªåˆ†ç±»å—ï¼Ÿåˆ é™¤åæ— æ³•æ¢å¤ï¼")) {
        try {
            await db.sticker_categories.delete(id);
            if (currentStickerCategoryId === id) {
                // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰æŸ¥çœ‹çš„åˆ†ç±»ï¼Œè¿”å›åˆ—è¡¨
                backToStickerList();
            } else {
                renderStickerCategories();
            }
        } catch (err) {
            console.error('åˆ é™¤åˆ†ç±»å¤±è´¥:', err);
            alert('åˆ é™¤å¤±è´¥ï¼Œè¯·é‡è¯•');
        }
    }
}

    // æ˜¾ç¤ºæ·»åŠ è¡¨æƒ…å¼¹çª—
    function showAddStickerModal() {
        const modal = document.createElement('div');
        modal.className = 'sticker-modal-overlay';
        modal.id = 'add-sticker-modal';
        modal.innerHTML = `
            <div class="sticker-modal-box">
                <h3 style="text-align:center; margin-bottom:20px;">æ·»åŠ è¡¨æƒ…</h3>
                
                <div style="margin-bottom:16px;">
                    <label style="display:block; color:#666; font-size:14px; margin-bottom:8px;">å›¾ç‰‡æ¥æº</label>
                    <div style="display:flex; gap:10px;">
                        <button onclick="document.getElementById('sticker-file-input').click()" style="flex:1; padding:10px; background:#f5f5f5; border:1px solid #eee; border-radius:8px;">æœ¬åœ°ä¸Šä¼ </button>
                        <input type="file" id="sticker-file-input" accept="image/*" style="display:none" onchange="handleStickerFileSelect(this)">
                    </div>
                    <div id="sticker-preview-area" style="margin-top:10px; height:100px; background:#f9f9f9; border-radius:8px; display:none; align-items:center; justify-content:center; background-size:contain; background-repeat:no-repeat; background-position:center;"></div>
                </div>

                <div style="margin-bottom:16px;">
                    <label style="display:block; color:#666; font-size:14px; margin-bottom:8px;">å›¾ç‰‡é“¾æ¥ (å¯é€‰)</label>
                    <input type="text" id="sticker-url-input" placeholder="https://..." style="width:100%; padding:10px; border:1px solid #eee; border-radius:8px; outline:none;" oninput="handleStickerUrlInput(this)">
                </div>

                <div style="margin-bottom:20px;">
                    <label style="display:block; color:#666; font-size:14px; margin-bottom:8px;">æè¿° (AIè¯†åˆ«ç”¨)</label>
                    <input type="text" id="sticker-desc-input" placeholder="ä¾‹å¦‚ï¼šä¸€åªæƒŠè®¶çš„ç™½çŒ«" style="width:100%; padding:10px; border:1px solid #eee; border-radius:8px; outline:none;">
                </div>

                <div style="display:flex; gap:10px;">
                    <button onclick="document.getElementById('add-sticker-modal').remove()" style="flex:1; padding:12px; background:#f2f2f7; border:none; border-radius:8px;">å–æ¶ˆ</button>
                    <button onclick="confirmAddSticker()" style="flex:1; padding:12px; background:var(--ins-pink); color:#white; border:none; border-radius:8px; color:#fff;">æ·»åŠ </button>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
    }

    let tempStickerData = null; // ä¸´æ—¶å­˜å‚¨ä¸Šä¼ çš„ base64 æˆ– URL

    function handleStickerFileSelect(input) {
        const file = input.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = e => {
                tempStickerData = e.target.result;
                const preview = document.getElementById('sticker-preview-area');
                preview.style.display = 'flex';
                preview.style.backgroundImage = `url(${tempStickerData})`;
                document.getElementById('sticker-url-input').value = ''; // æ¸…ç©ºURLè¾“å…¥
            };
            reader.readAsDataURL(file);
        }
    }

    function handleStickerUrlInput(input) {
        const url = input.value.trim();
        if (url) {
            tempStickerData = url;
            const preview = document.getElementById('sticker-preview-area');
            preview.style.display = 'flex';
            preview.style.backgroundImage = `url(${url})`;
        }
    }

    async function confirmAddSticker() {
        const desc = document.getElementById('sticker-desc-input').value.trim();
        
        if (!tempStickerData) {
            alert("è¯·å…ˆä¸Šä¼ å›¾ç‰‡æˆ–è¾“å…¥é“¾æ¥");
            return;
        }
        
        if (!desc) {
             if(!confirm("æœªå¡«å†™æè¿°ï¼ŒAIå¯èƒ½æ— æ³•å‡†ç¡®ç†è§£è¿™ä¸ªè¡¨æƒ…ã€‚ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ")) return;
        }

        const cat = await db.sticker_categories.get(currentStickerCategoryId);
        if (cat) {
            cat.stickers.push({
                url: tempStickerData,
                description: desc,
                created_at: Date.now()
            });
            await db.sticker_categories.put(cat);
            renderStickerCategoryDetail();
            document.getElementById('add-sticker-modal').remove();
            tempStickerData = null;
        }
    }

async function deleteSticker(index, e) {
    e.stopPropagation();
    if (confirm("åˆ é™¤è¿™å¼ è¡¨æƒ…ï¼Ÿ")) {
        const cat = await db.sticker_categories.get(currentStickerCategoryId);
        cat.stickers.splice(index, 1);
        await db.sticker_categories.put(cat);
        renderStickerCategoryDetail();
    }
}

// é¢„è§ˆè¡¨æƒ…è¯¦æƒ…ï¼ˆå¯ç¼–è¾‘æè¿°ï¼‰
async function previewSticker(index) {
    const cat = await db.sticker_categories.get(currentStickerCategoryId);
    const sticker = cat.stickers[index];
    
    const newDesc = prompt("ç¼–è¾‘æè¿° (AIè¯†åˆ«ç”¨)", sticker.description || "");
    if (newDesc !== null) {
        sticker.description = newDesc;
        await db.sticker_categories.put(cat);
        renderStickerCategoryDetail();
    }
}

    // å¯¼å‡ºåˆ†ç±»
    async function exportStickerCategory(id) {
        const cat = await db.sticker_categories.get(id);
        const blob = new Blob([JSON.stringify(cat, null, 2)], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `è¡¨æƒ…åŒ…-${cat.name}.json`;
        a.click();
        URL.revokeObjectURL(url);
    }

// å¯¼å…¥åˆ†ç±»
function importStickerCategory(input) {
    const file = input.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const json = JSON.parse(e.target.result);
            // ç®€å•çš„æ ¼å¼æ ¡éªŒ
            if (!json.name || !Array.isArray(json.stickers)) {
                throw new Error("æ ¼å¼ä¸æ­£ç¡®");
            }
            
            // å¦‚æœå½“å‰åœ¨è¯¦æƒ…é¡µï¼Œè¯¢é—®æ˜¯å¯¼å…¥ä¸ºæ–°åˆ†ç±»è¿˜æ˜¯æ›¿æ¢å½“å‰åˆ†ç±»
            if (currentStickerCategoryId) {
                const action = confirm(`å¯¼å…¥æ–¹å¼ï¼š\nç¡®å®š = æ›¿æ¢å½“å‰åˆ†ç±»\nå–æ¶ˆ = åˆ›å»ºæ–°åˆ†ç±»`);
                if (action) {
                    // æ›¿æ¢å½“å‰åˆ†ç±»
                    const cat = await db.sticker_categories.get(currentStickerCategoryId);
                    if (cat) {
                        cat.name = json.name;
                        cat.stickers = json.stickers;
                        await db.sticker_categories.put(cat);
                        alert(`æˆåŠŸå¯¼å…¥å¹¶æ›¿æ¢åˆ†ç±»ï¼š${json.name}`);
                        renderStickerCategoryDetail();
                    }
                } else {
                    // åˆ›å»ºæ–°åˆ†ç±»
                    delete json.id;
                    await db.sticker_categories.add(json);
                    alert(`æˆåŠŸå¯¼å…¥ä¸ºæ–°åˆ†ç±»ï¼š${json.name}`);
                    backToStickerList();
                }
            } else {
                // åœ¨åˆ—è¡¨é¡µï¼Œåˆ›å»ºæ–°åˆ†ç±»
                delete json.id;
                await db.sticker_categories.add(json);
                alert(`æˆåŠŸå¯¼å…¥åˆ†ç±»ï¼š${json.name}`);
                renderStickerCategories();
            }
        } catch (err) {
            alert("å¯¼å…¥å¤±è´¥: " + err.message);
        }
        // æ¸…ç©ºinputï¼Œå…è®¸é‡å¤å¯¼å…¥åŒä¸€æ–‡ä»¶
        input.value = '';
    };
    reader.readAsText(file);
}
// æ‰¹é‡å¯¼å…¥è¡¨æƒ…åŒ…ï¼ˆä»æ–‡æœ¬æ–‡ä»¶ï¼‰
async function batchImportStickersFromText(input) {
    const file = input.files[0];
    if (!file) return;
    
    if (!currentStickerCategoryId) {
        alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªåˆ†ç±»');
        input.value = '';
        return;
    }
    
    const fileName = file.name.toLowerCase();
    const isDocx = fileName.endsWith('.docx') || fileName.endsWith('.doc');
    
    // å¦‚æœæ˜¯ .docx æ–‡ä»¶ï¼Œä½¿ç”¨ JSZip è§£æ
    if (isDocx) {
        try {
            const arrayBuffer = await file.arrayBuffer();
            const zip = await JSZip.loadAsync(arrayBuffer);
            const docXml = await zip.file('word/document.xml').async('string');
            
            // â”€â”€ 1. å…ˆæå–è¶…é“¾æ¥ URL æ˜ å°„ï¼ˆWord æŠŠé“¾æ¥åœ°å€å­˜åœ¨ rels æ–‡ä»¶é‡Œï¼‰ â”€â”€
            const hyperlinkMap = {};
            try {
                const relsFile = zip.file('word/_rels/document.xml.rels');
                if (relsFile) {
                    const relsXml = await relsFile.async('string');
                    const relRegex = /<Relationship[^>]+Id="([^"]+)"[^>]+Target="([^"]+)"[^>]*>/g;
                    let relMatch;
                    while ((relMatch = relRegex.exec(relsXml)) !== null) {
                        hyperlinkMap[relMatch[1]] = relMatch[2];
                    }
                }
            } catch(e) { /* rels æ–‡ä»¶è¯»å–å¤±è´¥ä¸å½±å“ä¸»æµç¨‹ */ }
            
            // â”€â”€ 2. æŒ‰æ®µè½ï¼ˆ<w:p>ï¼‰æå–æ–‡æœ¬ï¼Œä¿ç•™æ¢è¡Œ â”€â”€
            const paragraphs = docXml.split(/<\/w:p>/);
            const lines = [];
            
            for (const para of paragraphs) {
                let lineText = '';
                
                // å¤„ç†è¶…é“¾æ¥èŠ‚ç‚¹ï¼š<w:hyperlink r:id="rId5"><w:r><w:t>æ˜¾ç¤ºæ–‡å­—</w:t></w:r></w:hyperlink>
                // ä¼˜å…ˆä½¿ç”¨ rels ä¸­çš„çœŸå® URL è€Œéæ˜¾ç¤ºæ–‡æœ¬
                let processedPara = para.replace(/<w:hyperlink[^>]*r:id="([^"]*)"[^>]*>([\s\S]*?)<\/w:hyperlink>/g, (fullMatch, rId, innerXml) => {
                    const realUrl = hyperlinkMap[rId];
                    if (realUrl && (realUrl.startsWith('http://') || realUrl.startsWith('https://'))) {
                        lineText += realUrl;
                        return ''; // å·²å¤„ç†ï¼Œä»å‰©ä½™ XML ä¸­ç§»é™¤
                    }
                    return fullMatch; // æ— æœ‰æ•ˆ URLï¼Œä¿ç•™åŸæ ·è®©åç»­ <w:t> æå–
                });
                
                // æå–å‰©ä½™çš„ <w:t> æ ‡ç­¾æ–‡æœ¬
                const textMatches = processedPara.match(/<w:t[^>]*>([^<]*)<\/w:t>/g) || [];
                for (const tm of textMatches) {
                    const content = tm.replace(/<w:t[^>]*>/, '').replace(/<\/w:t>/, '');
                    lineText += content;
                }
                
                lineText = lineText.trim();
                if (lineText) lines.push(lineText);
            }
            
            const extractedText = lines.join('\n');
            console.log('[DOCXå¯¼å…¥] æå–åˆ°', lines.length, 'è¡Œæ–‡æœ¬');
            
            // å¤„ç†æå–çš„æ–‡æœ¬
            await processStickerText(extractedText, input);
        } catch (err) {
            console.error('è§£æ .docx æ–‡ä»¶å¤±è´¥:', err);
            alert('è§£æ Word æ–‡æ¡£å¤±è´¥ï¼Œè¯·ç¡®ä¿æ–‡ä»¶æ ¼å¼æ­£ç¡®ã€‚\nå»ºè®®ï¼šå°† Word æ–‡æ¡£å¦å­˜ä¸º .txt çº¯æ–‡æœ¬æ–‡ä»¶åå†å¯¼å…¥ã€‚\n\né”™è¯¯ä¿¡æ¯: ' + err.message);
            input.value = '';
        }
        return;
    }
    
    // å¤„ç†çº¯æ–‡æœ¬æ–‡ä»¶ (.txt, .md ç­‰)
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const text = e.target.result;
            await processStickerText(text, input);
        } catch (err) {
            console.error('æ‰¹é‡å¯¼å…¥å¤±è´¥:', err);
            alert('å¯¼å…¥å¤±è´¥: ' + err.message);
            input.value = '';
        }
    };
    reader.readAsText(file, 'UTF-8');
}

// å¤„ç†è¡¨æƒ…åŒ…æ–‡æœ¬å†…å®¹çš„é€šç”¨å‡½æ•°
async function processStickerText(text, input) {
    try {
        const lines = text.split(/\r?\n/).filter(line => line.trim());
        
        if (lines.length === 0) {
            alert('æ–‡ä»¶ä¸ºç©ºæˆ–æ ¼å¼ä¸æ­£ç¡®');
            input.value = '';
            return;
        }
        
        const stickers = [];
        let successCount = 0;
        let failCount = 0;
        const errors = [];
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue;
            
            // è§£ææ ¼å¼ï¼šæè¿°ï¼šurl æˆ– æè¿°:url
            // æ”¯æŒä¸­è‹±æ–‡å†’å·ï¼ˆï¼š:ï¼‰ã€å†’å·åæœ‰ç©ºæ ¼/å…¨è§’ç©ºæ ¼/å¤šä½™ç©ºæ ¼ã€å†’å·å‰æœ‰ç©ºæ ¼
            // ä¹Ÿæ”¯æŒã€Œæè¿° urlã€ç”¨ç©ºæ ¼åˆ†éš”çš„æƒ…å†µï¼ˆå½“æ²¡æœ‰å†’å·æ—¶ï¼Œä»¥æœ€åä¸€ä¸ªhttpå¼€å¤´çš„éƒ¨åˆ†ä¸ºURLï¼‰
            let description = '';
            let url = '';
            let parsed = false;
            
            // æ–¹å¼1ï¼šç”¨å†’å·åˆ†éš”ï¼ˆä¸­æ–‡ï¼šã€è‹±æ–‡:ï¼‰
            const colonMatch = line.match(/^(.+?)\s*[ï¼š:]\s*(.+)$/);
            if (colonMatch) {
                description = colonMatch[1].trim();
                url = colonMatch[2].trim();
                parsed = true;
            }
            
            // æ–¹å¼2ï¼šæ²¡åŒ¹é…åˆ°å†’å·ï¼Œå°è¯•ç”¨ç©ºæ ¼åˆ†éš”ï¼ˆæè¿° + ç©ºæ ¼ + URLï¼‰
            if (!parsed) {
                const spaceMatch = line.match(/^(.+?)\s+(https?:\/\/.+)$/i);
                if (spaceMatch) {
                    description = spaceMatch[1].trim();
                    url = spaceMatch[2].trim();
                    parsed = true;
                }
            }
            
            // æ–¹å¼3ï¼šæ•´è¡Œå°±æ˜¯ä¸€ä¸ªURL
            if (!parsed && (line.startsWith('http://') || line.startsWith('https://') || line.startsWith('data:image'))) {
                url = line;
                parsed = true;
            }
            
            if (parsed && url) {
                // æ¸…ç† URLï¼šå»æ‰é¦–å°¾ç©ºç™½ã€å…¨è§’ç©ºæ ¼
                url = url.replace(/[\s\u3000]+$/, '').replace(/^[\s\u3000]+/, '');
                
                // éªŒè¯URLæ ¼å¼
                if (url.startsWith('http://') || url.startsWith('https://') || url.startsWith('data:image')) {
                    stickers.push({
                        url: url,
                        description: description,
                        created_at: Date.now()
                    });
                    successCount++;
                } else {
                    failCount++;
                    errors.push(`ç¬¬${i+1}è¡Œï¼šURLæ ¼å¼ä¸æ­£ç¡® - ${line}`);
                }
            } else {
                failCount++;
                errors.push(`ç¬¬${i+1}è¡Œï¼šæ ¼å¼ä¸æ­£ç¡® - ${line}`);
            }
        }
        
        if (stickers.length === 0) {
            alert('æœªèƒ½è§£æå‡ºä»»ä½•è¡¨æƒ…åŒ…ã€‚\næ ¼å¼åº”ä¸ºï¼šæè¿°ï¼šå›¾ç‰‡é“¾æ¥\nä¾‹å¦‚ï¼šä¸€åªçŒ«ï¼šhttps://example.com/cat.jpg');
            input.value = '';
            return;
        }
        
        // æ·»åŠ åˆ°åˆ†ç±»
        const cat = await db.sticker_categories.get(currentStickerCategoryId);
        if (!cat) {
            alert('åˆ†ç±»ä¸å­˜åœ¨');
            input.value = '';
            return;
        }
        
        if (!cat.stickers) cat.stickers = [];
        cat.stickers.push(...stickers);
        await db.sticker_categories.put(cat);
        
        // æ˜¾ç¤ºç»“æœ
        let message = `âœ… æˆåŠŸå¯¼å…¥ ${successCount} ä¸ªè¡¨æƒ…åŒ…`;
        if (failCount > 0) {
            message += `\nâŒ å¤±è´¥ ${failCount} ä¸ª`;
            if (errors.length <= 5) {
                message += '\n\né”™è¯¯è¯¦æƒ…ï¼š\n' + errors.join('\n');
            } else {
                message += `\n\nå‰5ä¸ªé”™è¯¯ï¼š\n${errors.slice(0, 5).join('\n')}\n...è¿˜æœ‰${errors.length - 5}ä¸ªé”™è¯¯`;
            }
            message += '\n\næç¤ºï¼šæ ¼å¼åº”ä¸º"æè¿°ï¼šå›¾ç‰‡é“¾æ¥"ï¼Œä¾‹å¦‚ï¼š\nä¸€åªçŒ«ï¼šhttps://example.com/cat.jpg';
        }
        
        // ä½¿ç”¨æ›´å‹å¥½çš„æç¤ºæ–¹å¼
        if (failCount === 0) {
            alert(message);
        } else {
            // å¦‚æœæœ‰é”™è¯¯ï¼Œä½¿ç”¨confirmè®©ç”¨æˆ·é€‰æ‹©æ˜¯å¦æŸ¥çœ‹è¯¦æƒ…
            const showDetails = confirm(message + '\n\næ˜¯å¦æŸ¥çœ‹è¯¦ç»†é”™è¯¯ä¿¡æ¯ï¼Ÿ');
            if (showDetails && errors.length > 0) {
                alert('è¯¦ç»†é”™è¯¯ä¿¡æ¯ï¼š\n\n' + errors.join('\n'));
            }
        }
        
        // åˆ·æ–°é¡µé¢
        renderStickerCategoryDetail();
        input.value = '';
    } catch (err) {
        console.error('å¤„ç†è¡¨æƒ…åŒ…æ–‡æœ¬å¤±è´¥:', err);
        alert('å¯¼å…¥å¤±è´¥: ' + err.message);
        input.value = '';
    }
}

// ç¡®ä¿å‡½æ•°åœ¨å…¨å±€ä½œç”¨åŸŸå¯è®¿é—®
window.importStickerCategory = importStickerCategory;
window.openStickerCategoryDetail = openStickerCategoryDetail;
window.backToStickerList = backToStickerList;
window.showCreateCategoryModal = showCreateCategoryModal;
window.batchImportStickersFromText = batchImportStickersFromText;
window.processStickerText = processStickerText;
window.switchStickerCategory = switchStickerCategory;
window.searchStickers = searchStickers;
window.detectAndSuggestStickers = detectAndSuggestStickers;
window.sendSuggestedSticker = sendSuggestedSticker;

// å½“å‰é€‰ä¸­çš„è¡¨æƒ…åŒ…åˆ†ç±»ID
let currentActiveStickerCategoryId = null;

// æ›´æ–°èŠå¤©é¢æ¿ä¸­çš„è¡¨æƒ…åˆ—è¡¨ï¼ˆåœ¨æ‰“å¼€é¢æ¿æ—¶è°ƒç”¨ï¼‰
// æ³¨æ„ï¼šç”¨æˆ·å¯ä»¥çœ‹åˆ°æ‰€æœ‰è¡¨æƒ…åŒ…ï¼Œä½†è§’è‰²åªèƒ½ä½¿ç”¨æŒ‚è½½çš„
async function updateChatStickerPanel() {
    const tabsContainer = document.getElementById('sticker-category-tabs');
    const contentContainer = document.getElementById('sticker-content');
    if (!tabsContainer || !contentContainer) return;
    
    try {
        // è·å–æ‰€æœ‰è¡¨æƒ…åŒ…åˆ†ç±»ï¼ˆç”¨æˆ·å¯ä»¥çœ‹åˆ°æ‰€æœ‰ï¼‰
        const allCategories = await db.sticker_categories.toArray();
        
        if (allCategories.length === 0) {
            tabsContainer.innerHTML = '';
            contentContainer.innerHTML = `<div style="text-align:center; grid-column:span 4; color:#999; margin-top:20px;">æš‚æ— è¡¨æƒ…åŒ…<br>è¯·å»ã€æˆ‘-è¡¨æƒ…ã€‘æ·»åŠ </div>`;
            return;
        }
        
        // è·å–å½“å‰è§’è‰²æŒ‚è½½çš„åˆ†ç±»IDï¼ˆç”¨äºé™åˆ¶å‘é€ï¼‰
        let mountedIds = [];
        if (currentChatCharId) {
            const char = await db.characters.get(currentChatCharId);
            mountedIds = char?.mounted_sticker_categories || [];
        }
        
        // è¿‡æ»¤å‡ºæœ‰æœ‰æ•ˆè¡¨æƒ…åŒ…çš„åˆ†ç±»ï¼ˆç¡®ä¿stickersæ•°ç»„å­˜åœ¨ä¸”æœ‰urlæœ‰æ•ˆçš„è¡¨æƒ…ï¼‰
        const validCategories = allCategories.filter(cat => {
            if (!cat.stickers || cat.stickers.length === 0) return false;
            // è‡³å°‘æœ‰ä¸€ä¸ªurlæœ‰æ•ˆçš„è¡¨æƒ…
            return cat.stickers.some(s => s && s.url);
        });
        
        if (validCategories.length === 0) {
            tabsContainer.innerHTML = '';
            contentContainer.innerHTML = `<div style="text-align:center; grid-column:span 4; color:#999; margin-top:20px;">æš‚æ— è¡¨æƒ…åŒ…<br>è¯·å»ã€æˆ‘-è¡¨æƒ…ã€‘æ·»åŠ </div>`;
            return;
        }
        
        // å¦‚æœè¿˜æ²¡æœ‰é€‰ä¸­çš„åˆ†ç±»ï¼Œé»˜è®¤é€‰ä¸­ç¬¬ä¸€ä¸ª
        if (!currentActiveStickerCategoryId || !validCategories.find(c => c.id === currentActiveStickerCategoryId)) {
            currentActiveStickerCategoryId = validCategories[0].id;
        }
        
        // ç”Ÿæˆåˆ†ç±»æ ‡ç­¾
        let tabsHtml = '';
        for (const cat of validCategories) {
            const isActive = cat.id === currentActiveStickerCategoryId;
            const isMounted = mountedIds.includes(cat.id);
            const mountTag = isMounted ? 'âœ“' : '';
            tabsHtml += `
                <div class="sticker-category-tab ${isActive ? 'active' : ''}" onclick="switchStickerCategory(${cat.id})" style="
                    flex-shrink: 0;
                    padding: 10px 16px;
                    font-size: 13px;
                    color: ${isActive ? 'var(--ins-pink)' : '#666'};
                    border-bottom: 2px solid ${isActive ? 'var(--ins-pink)' : 'transparent'};
                    cursor: pointer;
                    white-space: nowrap;
                    transition: all 0.2s;
                ">
                    ${cat.name} ${mountTag}
                </div>
            `;
        }
        tabsContainer.innerHTML = tabsHtml;
        
        // æ˜¾ç¤ºå½“å‰é€‰ä¸­åˆ†ç±»çš„è¡¨æƒ…åŒ…
        const currentCategory = validCategories.find(c => c.id === currentActiveStickerCategoryId);
        if (!currentCategory) return;
        
        let contentHtml = '';
        currentCategory.stickers.forEach(s => {
            // âœ… è·³è¿‡æ— æ•ˆçš„è¡¨æƒ…åŒ…æ¡ç›®ï¼ˆurlç¼ºå¤±æˆ–éå­—ç¬¦ä¸²ï¼‰
            if (!s || !s.url || typeof s.url !== 'string') return;
            const safeUrl = s.url.replace(/'/g, "\\'").replace(/"/g, '&quot;');
            const safeDesc = (s.description || '').replace(/'/g, "\\'").replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            contentHtml += `<div class="emoji-item" onclick="sendGlobalSticker(${currentCategory.id}, '${safeUrl}')" style="display:flex; flex-direction:column; align-items:center; gap:4px; cursor:pointer;">
                <img src="${s.url}" style="width:60px; height:60px; border-radius:8px; object-fit:cover;" onerror="this.onerror=null; this.style.cssText='width:60px; height:60px; display:flex; align-items:center; justify-content:center; background:#f5f5f5; border-radius:8px;'; this.outerHTML='<div style=\\'width:60px; height:60px; display:flex; align-items:center; justify-content:center; background:#f5f5f5; border-radius:8px; color:#ccc; font-size:10px;\\'>å¤±è´¥</div>';" />
                ${safeDesc ? `<div style="font-size:10px; color:#999; text-align:center; max-width:60px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${safeDesc}</div>` : ''}
            </div>`;
        });
        
        contentContainer.innerHTML = contentHtml || `<div style="text-align:center; grid-column:span 4; color:#999; margin-top:20px;">è¯¥åˆ†ç±»ä¸‹æš‚æ— æœ‰æ•ˆè¡¨æƒ…åŒ…</div>`;
    } catch (e) {
        console.error('[è¡¨æƒ…åŒ…é¢æ¿] åŠ è½½å¤±è´¥:', e);
        contentContainer.innerHTML = `<div style="text-align:center; grid-column:span 4; color:#999; margin-top:20px;">è¡¨æƒ…åŒ…åŠ è½½å¤±è´¥<br>è¯·åˆ·æ–°é¡µé¢é‡è¯•</div>`;
    }
}

// åˆ‡æ¢è¡¨æƒ…åŒ…åˆ†ç±»
async function switchStickerCategory(categoryId) {
    currentActiveStickerCategoryId = categoryId;
    // æ¸…ç©ºæœç´¢æ¡†
    const searchInput = document.getElementById('sticker-search-input');
    if (searchInput) searchInput.value = '';
    await updateChatStickerPanel();
}

// æœç´¢è¡¨æƒ…åŒ…
async function searchStickers(keyword) {
    const contentContainer = document.getElementById('sticker-content');
    const tabsContainer = document.getElementById('sticker-category-tabs');
    if (!contentContainer) return;
    
    keyword = keyword.trim().toLowerCase();
    
    // å¦‚æœæœç´¢ä¸ºç©ºï¼Œæ¢å¤æ­£å¸¸æ˜¾ç¤º
    if (!keyword) {
        if (tabsContainer) tabsContainer.style.display = 'flex';
        await updateChatStickerPanel();
        return;
    }
    
    // éšè—åˆ†ç±»æ ‡ç­¾
    if (tabsContainer) tabsContainer.style.display = 'none';
    
    // è·å–æ‰€æœ‰è¡¨æƒ…åŒ…åˆ†ç±»
    const allCategories = await db.sticker_categories.toArray();
    
    // æœç´¢åŒ¹é…çš„è¡¨æƒ…åŒ…
    let matchedStickers = [];
    for (const cat of allCategories) {
        if (cat.stickers && cat.stickers.length > 0) {
            cat.stickers.forEach(s => {
                if (s.description && s.description.toLowerCase().includes(keyword)) {
                    matchedStickers.push({
                        ...s,
                        categoryId: cat.id,
                        categoryName: cat.name
                    });
                }
            });
        }
    }
    
    // æ˜¾ç¤ºæœç´¢ç»“æœ
    if (matchedStickers.length === 0) {
        contentContainer.innerHTML = `<div style="text-align:center; grid-column:span 4; color:#999; margin-top:20px;">æœªæ‰¾åˆ°ç›¸å…³è¡¨æƒ…åŒ…</div>`;
        return;
    }
    
    let contentHtml = '';
    matchedStickers.forEach(s => {
        // âœ… è·³è¿‡æ— æ•ˆçš„è¡¨æƒ…åŒ…æ¡ç›®
        if (!s || !s.url || typeof s.url !== 'string') return;
        const safeUrl = s.url.replace(/'/g, "\\'").replace(/"/g, '&quot;');
        const safeDesc = (s.description || '').replace(/'/g, "\\'").replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        contentHtml += `<div class="emoji-item" onclick="sendGlobalSticker(${s.categoryId}, '${safeUrl}')" style="display:flex; flex-direction:column; align-items:center; gap:4px; cursor:pointer;">
            <img src="${s.url}" style="width:60px; height:60px; border-radius:8px; object-fit:cover;" onerror="this.onerror=null; this.style.cssText='width:60px; height:60px; display:flex; align-items:center; justify-content:center; background:#f5f5f5; border-radius:8px;'; this.outerHTML='<div style=\\'width:60px; height:60px; display:flex; align-items:center; justify-content:center; background:#f5f5f5; border-radius:8px; color:#ccc; font-size:10px;\\'>å¤±è´¥</div>';" />
            ${safeDesc ? `<div style="font-size:10px; color:#999; text-align:center; max-width:60px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${safeDesc}</div>` : ''}
        </div>`;
    });
    
    contentContainer.innerHTML = contentHtml;
}

// æ™ºèƒ½è¡¨æƒ…æ¨èï¼ˆåœ¨è¾“å…¥æ¡†è¾“å…¥æ—¶è§¦å‘ï¼‰
let stickerSuggestionDebounce = null;
async function detectAndSuggestStickers(inputText) {
    const suggestionBar = document.getElementById('sticker-suggestion-bar');
    if (!suggestionBar) return;
    
    // æ¸…é™¤ä¹‹å‰çš„é˜²æŠ–
    if (stickerSuggestionDebounce) {
        clearTimeout(stickerSuggestionDebounce);
    }
    
    // é˜²æŠ–ï¼š300ms åæ‰§è¡Œ
    stickerSuggestionDebounce = setTimeout(async () => {
        const text = inputText.trim().toLowerCase();
        
        // å¦‚æœè¾“å…¥ä¸ºç©ºæˆ–å¤ªçŸ­ï¼Œéšè—æ¨èæ 
        if (!text || text.length < 2) {
            suggestionBar.style.display = 'none';
            return;
        }
        
        // è·å–æ‰€æœ‰è¡¨æƒ…åŒ…
        const allCategories = await db.sticker_categories.toArray();
        
        // æŸ¥æ‰¾åŒ¹é…çš„è¡¨æƒ…åŒ…ï¼ˆæœ€å¤šæ˜¾ç¤º 8 ä¸ªï¼‰
        let matchedStickers = [];
        for (const cat of allCategories) {
            if (cat.stickers && cat.stickers.length > 0) {
                for (const s of cat.stickers) {
                    if (s.description && s.description.toLowerCase().includes(text)) {
                        matchedStickers.push({
                            ...s,
                            categoryId: cat.id
                        });
                        if (matchedStickers.length >= 8) break;
                    }
                }
                if (matchedStickers.length >= 8) break;
            }
        }
        
        // å¦‚æœæ²¡æœ‰åŒ¹é…çš„ï¼Œéšè—æ¨èæ 
        if (matchedStickers.length === 0) {
            suggestionBar.style.display = 'none';
            return;
        }
        
        // æ˜¾ç¤ºæ¨èçš„è¡¨æƒ…åŒ…
        let html = '';
        matchedStickers.forEach(s => {
            if (!s || !s.url || typeof s.url !== 'string') return;
            const safeUrl = s.url.replace(/'/g, "\\'").replace(/"/g, '&quot;');
            html += `<div onclick="sendSuggestedSticker(${s.categoryId}, '${safeUrl}')" style="
                display: inline-flex;
                flex-direction: column;
                align-items: center;
                margin-right: 8px;
                cursor: pointer;
                vertical-align: top;
            ">
                <img src="${s.url}" style="width:50px; height:50px; border-radius:8px; object-fit:cover; border: 2px solid transparent; transition: border-color 0.2s;" onmouseover="this.style.borderColor='var(--ins-pink)'" onmouseout="this.style.borderColor='transparent'" onerror="this.onerror=null; this.style.cssText='width:50px; height:50px; display:flex; align-items:center; justify-content:center; background:#f5f5f5; border-radius:8px;'; this.outerHTML='<div style=\\'width:50px; height:50px; display:flex; align-items:center; justify-content:center; background:#f5f5f5; border-radius:8px; color:#ccc; font-size:9px;\\'>å¤±è´¥</div>';" />
            </div>`;
        });
        
        suggestionBar.innerHTML = html;
        suggestionBar.style.display = 'block';
    }, 300);
}

// å‘é€æ¨èçš„è¡¨æƒ…åŒ…
async function sendSuggestedSticker(catId, url) {
    // æ¸…ç©ºè¾“å…¥æ¡†
    const inputBox = document.getElementById('chat-input-box');
    if (inputBox) inputBox.value = '';
    
    // éšè—æ¨èæ 
    const suggestionBar = document.getElementById('sticker-suggestion-bar');
    if (suggestionBar) suggestionBar.style.display = 'none';
    
    // éšè—å‘é€æŒ‰é’®ï¼Œæ˜¾ç¤ºæ›´å¤šæŒ‰é’®
    const btnSend = document.getElementById('btn-send');
    const btnMore = document.getElementById('btn-more');
    if (btnSend) btnSend.style.display = 'none';
    if (btnMore) btnMore.style.display = 'flex';
    
    // å‘é€è¡¨æƒ…åŒ…
    await sendGlobalSticker(catId, url);
}

async function sendGlobalSticker(catId, url) {
    // ç”¨æˆ·å‘é€è¡¨æƒ…åŒ…ï¼šå¯ä»¥å‘é€æ‰€æœ‰è¡¨æƒ…åŒ…ï¼Œä¸éœ€è¦æ£€æŸ¥æŒ‚è½½
    // è§’è‰²å‘é€è¡¨æƒ…åŒ…ï¼šåªèƒ½å‘é€æŒ‚è½½çš„ï¼ˆè¿™ä¸ªé™åˆ¶åœ¨è§’è‰²è‡ªåŠ¨å›å¤æ—¶æ£€æŸ¥ï¼‰
    
    const msgContent = `[img:${url}]`; // å›¾ç‰‡æ˜¾ç¤ºå†…å®¹
    
    // âœ… æ”¯æŒç¾¤èŠæ¨¡å¼ï¼šå’Œç§èŠä¸€æ ·ï¼Œè¿½åŠ æ¶ˆæ¯åˆ°UIå³å¯
    if (window.currentGroupChatId) {
        const group = await db.group_chats.get(window.currentGroupChatId);
        if (!group) return;
        
        if (!group.chat_history) group.chat_history = [];
        const msg = {
            role: 'user',
            content: msgContent,
            time: Date.now()
        };
        group.chat_history.push(msg);
        group.updated_at = Date.now();
        await safeGroupChatPut(group);
        
        await appendUserGroupMessageToUI(msg, group);
        closeChatPanel();
        return;
    }
    
    if (!currentChatCharId) {
        alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠå¤©å¯¹è±¡');
        return;
    }
    
    let char = await db.characters.get(currentChatCharId);
    const accountId = getCurrentAccountId();
    
    // æŸ¥æ‰¾æè¿°
    let desc = '';
    const cat = await db.sticker_categories.get(catId);
    if (cat) {
        const s = cat.stickers.find(sticker => sticker.url === url);
        if (s) desc = s.description;
    }
    
    // å‘é€æ¶ˆæ¯ - ä½¿ç”¨æŒ‰è´¦å·éš”ç¦»çš„èŠå¤©è®°å½•
    let history = getChatHistory(char, accountId);
    
    history.push({
        role: 'user',
        content: msgContent,
        imageDescription: desc, // æ–°å¢å­—æ®µï¼šå›¾ç‰‡æè¿°
        time: Date.now()
    });
    
    await setChatHistory(char, accountId, history);
    appendMessageToUI('user', msgContent);
    closeChatPanel();
    
    // âœ… å¦‚æœæ˜¯è”æœºå¥½å‹ï¼Œå‘é€è¡¨æƒ…åŒ…åˆ°æœåŠ¡å™¨
    if (char.isOnlineFriend && char.onlineData?.wx_account) {
        const onlineUserChar = await getOrCreateOnlineUserChar();
        
        if (onlineUserChar && onlineConnected) {
            const fromWxAccount = onlineUserChar.identity.account;
            const toWxAccount = char.onlineData.wx_account;
            const sent = sendOnlineMessage(toWxAccount, msgContent, fromWxAccount);
            if (sent) {
                console.log('[Online] è¡¨æƒ…åŒ…å·²å‘é€åˆ°æœåŠ¡å™¨:', url);
            } else {
                console.warn('[Online] è¡¨æƒ…åŒ…å‘é€å¤±è´¥');
                showToast('è¡¨æƒ…åŒ…å‘é€å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨è¿æ¥');
            }
        } else {
            console.warn('[Online] æ— æ³•å‘é€è”æœºè¡¨æƒ…åŒ…ï¼šæœªè¿æ¥æœåŠ¡å™¨');
            showToast('è¯·ç¡®ä¿å·²è¿æ¥æœåŠ¡å™¨');
        }
    }
    
    // âœ… ä¸å†è‡ªåŠ¨è§¦å‘ AI å›å¤ï¼Œéœ€è¦ç”¨æˆ·ç‚¹å‡»"æ¥å—å›å¤"æŒ‰é’®
    // triggerAiReply();
}

// --- æ¡Œé¢å›¾æ ‡æ‹–æ‹½é€»è¾‘ ---
let desktopSortable = null;

function initDesktopDrag() {
    const grid = document.getElementById('app-grid');
    if (!grid) return;

    // æ£€æµ‹æ˜¯å¦æ˜¯ç§»åŠ¨è®¾å¤‡
    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

    desktopSortable = new Sortable(grid, {
        animation: 350, // åŠ¨ç”»æ—¶é•¿ï¼Œæ¯«ç§’ - ç¨æ…¢ä¸€ç‚¹æ›´åƒiOS
        delay: isTouchDevice ? 150 : 0, // è§¦æ‘¸è®¾å¤‡é•¿æŒ‰150msè§¦å‘ï¼ˆä¼˜åŒ–ï¼šä»300msç¼©çŸ­åˆ°150msï¼Œæ›´çµæ•ï¼‰
        delayOnTouchOnly: true, // ä»…åœ¨è§¦æ‘¸æ—¶å¯ç”¨å»¶è¿Ÿ
        touchStartThreshold: 8, // æ‰‹æŒ‡ç§»åŠ¨è¶…è¿‡8pxå–æ¶ˆé•¿æŒ‰åˆ¤å®šï¼ˆä¼˜åŒ–ï¼šä»5pxå¢åŠ åˆ°8pxï¼Œå‡å°‘è¯¯è§¦å–æ¶ˆï¼‰
        
        // å…³é”®ï¼šä½¿ç”¨éåŸç”Ÿæ‹–æ‹½ï¼Œå®ç°æ›´ä¸æ»‘çš„ JS æ¨¡æ‹Ÿæ•ˆæœ
        forceFallback: true, 
        fallbackTolerance: 3, // é¼ æ ‡æŒ‰ä¸‹ç§»åŠ¨3pxæ‰ç®—æ‹–æ‹½
        fallbackOnBody: true, // å°†æ‹–æ‹½å…ƒç´ è¿½åŠ åˆ° bodyï¼Œé¿å… overflow é—®é¢˜
        
        ghostClass: 'sortable-ghost', // å ä½ç¬¦æ ·å¼ç±» (æ‹–æ‹½åŸä½ç½®çš„è™šå½±)
        dragClass: 'sortable-drag',   // æ‹–æ‹½ä¸­å…ƒç´ æ ·å¼ç±» (è·Ÿéšé¼ æ ‡çš„é‚£ä¸ª)
        chosenClass: 'sortable-chosen', // é€‰ä¸­é¡¹æ ·å¼
        
        easing: "cubic-bezier(0.2, 0.8, 0.2, 1)", // iOS é£æ ¼ç¼“åŠ¨

        // æ»šåŠ¨é…ç½®ä¼˜åŒ–
        scroll: true, 
        scrollSensitivity: 60, // è·ç¦»è¾¹ç¼˜å¤šå°‘åƒç´ å¼€å§‹æ»šåŠ¨
        scrollSpeed: 15, // æ»šåŠ¨é€Ÿåº¦
        
        onStart: function (evt) {
            // éœ‡åŠ¨åé¦ˆ
            if (navigator.vibrate) navigator.vibrate(50);
            // æ‹–æ‹½å¼€å§‹æ—¶ï¼Œç»™ body æ·»åŠ ç±»ä»¥ä¾¿æ§åˆ¶å…¨å±€å…‰æ ‡
            document.body.classList.add('dragging-mode');
        },
        onEnd: function (evt) {
            saveDesktopOrder();
            document.body.classList.remove('dragging-mode');
        }
    });
}

async function saveDesktopOrder() {
    const grid = document.getElementById('app-grid');
    // è·å–å½“å‰é¡ºåºçš„æ‰€æœ‰å­å…ƒç´ ID
    const order = Array.from(grid.children)
        .map(child => child.id)
        .filter(id => id); // è¿‡æ»¤æ‰æ²¡æœ‰IDçš„å…ƒç´ 
    
    // ä¿å­˜åˆ° Dexie
    try {
        await db.dexiData.put({ key: 'desktopOrder', value: JSON.stringify(order) });
        console.log('[Desktop] Order saved');
    } catch (e) {
        console.error('[Desktop] Failed to save order', e);
    }
}

async function restoreDesktopOrder() {
    try {
        const record = await db.dexiData.get('desktopOrder');
        if (!record || !record.value) return;
        
        const order = JSON.parse(record.value);
        const grid = document.getElementById('app-grid');
        if (!grid) return;
        
        // åˆ›å»ºç°æœ‰å…ƒç´ çš„æ˜ å°„
        const elements = {};
        Array.from(grid.children).forEach(el => {
            if (el.id) elements[el.id] = el;
        });
        
        // åˆ›å»ºæ–‡æ¡£ç‰‡æ®µä»¥ä¼˜åŒ–æ€§èƒ½
        const fragment = document.createDocumentFragment();
        
        // æŒ‰ä¿å­˜çš„é¡ºåºé‡æ–°æ·»åŠ 
        order.forEach(id => {
            const el = elements[id];
            if (el) {
                fragment.appendChild(el);
                delete elements[id]; // æ ‡è®°å·²å¤„ç†
            }
        });
        
        // æ·»åŠ å‰©ä½™çš„å…ƒç´ ï¼ˆå¦‚æœæœ‰æ–°å¢çš„å›¾æ ‡ï¼‰
        Object.values(elements).forEach(el => {
            fragment.appendChild(el);
        });
        
        grid.appendChild(fragment);
        console.log('[Desktop] Order restored');
    } catch (e) {
        console.error('[Desktop] Failed to restore desktop order', e);
    }
}

/* =================
   æœåŠ¡é¡µé¢é€»è¾‘ (ä¼˜åŒ–åŠ¨ç”»ç‰ˆ)
   ================= */

function showServicePage() {
    const page = document.getElementById('service-main-page');
    page.style.display = 'flex';
    page.offsetHeight; 
    page.classList.add('slide-in');
}

function hideServicePage() {
    const page = document.getElementById('service-main-page');
    page.classList.remove('slide-in');
}

// =================
//  æ‰‹æœºå……å€¼åŠŸèƒ½
// =================

// ç”Ÿæˆè™šæ‹Ÿç”µè¯å·ç ï¼ˆå…¨å±€å‡½æ•°ï¼‰
function generateVirtualPhoneNumber(id) {
    // ç®€å•å“ˆå¸Œç”Ÿæˆä¸€ä¸ªä¼ªå·ç 
    let hash = 0;
    for (let i = 0; i < String(id).length; i++) {
        hash = (hash << 5) - hash + String(id).charCodeAt(i);
        hash |= 0;
    }
    return '13' + Math.abs(hash).toString().substring(0, 9).padEnd(9, '0');
}

// ä½™é¢ç®¡ç†ï¼ˆlocalStorageåŒæ­¥è®¿é—® + IndexedDBå¼‚æ­¥å¤‡ä»½ï¼ŒåŒé‡ä¿éšœï¼‰
function getPhoneBalance() {
    const balance = localStorage.getItem('phone_balance');
    return balance ? parseFloat(balance) : 50.0; // é»˜è®¤50å…ƒ
}

function setPhoneBalance(amount) {
    safeLocalStorageSet('phone_balance', amount.toFixed(2));
    // å¼‚æ­¥å¤‡ä»½åˆ°IndexedDBï¼ˆä¸é˜»å¡ä¸»æµç¨‹ï¼‰
    saveFinanceData('phone_balance', amount.toFixed(2)).catch(e => console.warn('[Finance] phone_balanceå¤‡ä»½å¤±è´¥:', e));
}

function addPhoneBalance(amount) {
    const current = getPhoneBalance();
    setPhoneBalance(current + amount);
    return getPhoneBalance();
}

function deductPhoneBalance(amount) {
    const current = getPhoneBalance();
    if (current < amount) {
        return false; // ä½™é¢ä¸è¶³
    }
    setPhoneBalance(current - amount);
    return true;
}

// æ˜¾ç¤ºæ”¯ä»˜æ–¹å¼é€‰æ‹©å¼¹çª—ï¼ˆä½™é¢ or äº²å±å¡ï¼‰
async function showPaymentMethodSelection(amount, description) {
    return new Promise(async (resolve) => {
        const accountId = getCurrentAccountId();
        if (!accountId) {
            resolve({ success: false, method: null });
            return;
        }
        
        // è·å–å¯ç”¨çš„äº²å±å¡
        const user = await db.characters.get(parseInt(accountId));
        const familyCards = user?.identity?.familyCardsReceived || [];
        
        // è·å–è”æœºå¥½å‹çš„äº²å±å¡
        let onlineFamilyCards = [];
        if (onlineConnected && onlineSocket) {
            const onlineUserChar = await getOrCreateOnlineUserChar();
            if (onlineUserChar) {
                const myWxAccount = onlineUserChar.identity.account;
                // ä»æœåŠ¡å™¨è·å–äº²å±å¡åˆ—è¡¨ï¼ˆè¿™é‡Œæˆ‘ä»¬éœ€è¦å…ˆå®ç°åŒæ­¥è·å–ï¼‰
                // æš‚æ—¶ä»æœ¬åœ°ç¼“å­˜è·å–
                onlineFamilyCards = JSON.parse(localStorage.getItem('online_family_cards_received') || '[]');
            }
        }
        
        const allFamilyCards = [...familyCards, ...onlineFamilyCards];
        
        // å¦‚æœæ²¡æœ‰äº²å±å¡ï¼Œç›´æ¥ä½¿ç”¨ä½™é¢
        if (allFamilyCards.length === 0) {
            const success = deductPhoneBalance(amount);
            resolve({ success, method: 'balance' });
            return;
        }
        
        // åˆ›å»ºé€‰æ‹©å¼¹çª—
        const modal = document.createElement('div');
        modal.className = 'payment-method-modal';
        modal.innerHTML = `
            <div class="payment-method-overlay"></div>
            <div class="payment-method-content">
                <div class="payment-method-header">
                    <span>é€‰æ‹©æ”¯ä»˜æ–¹å¼</span>
                    <span class="payment-method-amount">Â¥${amount.toFixed(2)}</span>
                </div>
                <div class="payment-method-desc">${description || 'æ¶ˆè´¹'}</div>
                <div class="payment-method-list">
                    <div class="payment-method-item" data-method="balance">
                        <div class="payment-method-icon">ğŸ’°</div>
                        <div class="payment-method-name">
                            <div>é›¶é’±</div>
                            <div class="payment-method-sub">ä½™é¢: Â¥${getPhoneBalance().toFixed(2)}</div>
                        </div>
                        <div class="payment-method-radio"></div>
                    </div>
                    ${allFamilyCards.map((card, index) => {
                        const isOnline = card.from_wx_account !== undefined;
                        const cardName = isOnline ? 'è”æœºå¥½å‹äº²å±å¡' : 'äº²å±å¡';
                        const monthlyLimit = isOnline ? card.monthly_limit : card.monthlyLimit;
                        const usedThisMonth = isOnline ? card.used_this_month : card.usedThisMonth;
                        const limitText = monthlyLimit > 0 ? `æœ¬æœˆå‰©ä½™: Â¥${(monthlyLimit - usedThisMonth).toFixed(2)}` : 'ä¸é™é¢åº¦';
                        
                        return `
                            <div class="payment-method-item" data-method="family_card" data-card-index="${index}" data-is-online="${isOnline}">
                                <div class="payment-method-icon">ğŸ’³</div>
                                <div class="payment-method-name">
                                    <div>${cardName}</div>
                                    <div class="payment-method-sub">${limitText}</div>
                                </div>
                                <div class="payment-method-radio"></div>
                            </div>
                        `;
                    }).join('')}
                </div>
                <div class="payment-method-buttons">
                    <button class="payment-method-cancel">å–æ¶ˆ</button>
                    <button class="payment-method-confirm">ç¡®è®¤æ”¯ä»˜</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        let selectedMethod = 'balance';
        let selectedCardIndex = -1;
        let selectedIsOnline = false;
        
        // é»˜è®¤é€‰ä¸­ä½™é¢
        modal.querySelector('[data-method="balance"] .payment-method-radio').classList.add('selected');
        
        // é€‰æ‹©æ”¯ä»˜æ–¹å¼
        modal.querySelectorAll('.payment-method-item').forEach(item => {
            item.addEventListener('click', () => {
                modal.querySelectorAll('.payment-method-radio').forEach(r => r.classList.remove('selected'));
                item.querySelector('.payment-method-radio').classList.add('selected');
                selectedMethod = item.dataset.method;
                selectedCardIndex = parseInt(item.dataset.cardIndex) || -1;
                selectedIsOnline = item.dataset.isOnline === 'true';
            });
        });
        
        // å–æ¶ˆæŒ‰é’®
        modal.querySelector('.payment-method-cancel').addEventListener('click', () => {
            document.body.removeChild(modal);
            resolve({ success: false, method: null });
        });
        
        // ç¡®è®¤æ”¯ä»˜æŒ‰é’®
        modal.querySelector('.payment-method-confirm').addEventListener('click', async () => {
            document.body.removeChild(modal);
            
            if (selectedMethod === 'balance') {
                const success = deductPhoneBalance(amount);
                resolve({ success, method: 'balance' });
            } else if (selectedMethod === 'family_card' && selectedCardIndex >= 0) {
                const card = allFamilyCards[selectedCardIndex];
                
                if (selectedIsOnline) {
                    // ä½¿ç”¨è”æœºäº²å±å¡
                    const onlineUserChar = await getOrCreateOnlineUserChar();
                    if (onlineUserChar && onlineConnected) {
                        onlineSocket.send(JSON.stringify({
                            type: 'use_family_card',
                            my_wx_account: onlineUserChar.identity.account,
                            payer_wx_account: card.from_wx_account,
                            amount: amount,
                            description: description || 'æ¶ˆè´¹'
                        }));
                        // ç­‰å¾…æœåŠ¡å™¨å“åº”ï¼ˆæš‚æ—¶å‡è®¾æˆåŠŸï¼‰
                        showToast('äº²å±å¡æ”¯ä»˜ä¸­...');
                        resolve({ success: true, method: 'family_card', isOnline: true });
                    } else {
                        showToast('æœªè¿æ¥æœåŠ¡å™¨');
                        resolve({ success: false, method: null });
                    }
                } else {
                    // ä½¿ç”¨æœ¬åœ°äº²å±å¡
                    const monthlyLimit = card.monthlyLimit || 0;
                    const usedThisMonth = card.usedThisMonth || 0;
                    
                    // æ£€æŸ¥é¢åº¦
                    if (monthlyLimit > 0 && (usedThisMonth + amount) > monthlyLimit) {
                        showToast('äº²å±å¡æœ¬æœˆé¢åº¦ä¸è¶³');
                        resolve({ success: false, method: null });
                        return;
                    }
                    
                    // æ›´æ–°ä½¿ç”¨é‡‘é¢
                    card.usedThisMonth = (usedThisMonth || 0) + amount;
                    if (!card.records) card.records = [];
                    card.records.push({
                        amount: amount,
                        description: description || 'æ¶ˆè´¹',
                        time: Date.now()
                    });
                    
                    // ä¿å­˜åˆ°ç”¨æˆ·æ•°æ®
                    await safeCharacterPut(user);
                    
                    // é€šçŸ¥ä»˜æ¬¾æ–¹ï¼ˆè§’è‰²ï¼‰
                    const payerChar = await db.characters.get(card.charId);
                    if (payerChar) {
                        // å‘é€æ¶ˆæ¯é€šçŸ¥
                        showToast('äº²å±å¡æ”¯ä»˜æˆåŠŸ');
                    }
                    
                    resolve({ success: true, method: 'family_card', isOnline: false });
                }
            }
        });
    });
}

// å……å€¼è®°å½•ç®¡ç†
function getRechargeHistory() {
    return JSON.parse(localStorage.getItem('phone_recharge_history') || '[]');
}

function addRechargeRecord(amount) {
    const history = getRechargeHistory();
    history.unshift({
        amount: amount,
        time: Date.now(),
        date: new Date().toLocaleString('zh-CN')
    });
    // åªä¿ç•™æœ€è¿‘20æ¡
    if (history.length > 20) {
        history.pop();
    }
    safeLocalStorageSet('phone_recharge_history', JSON.stringify(history));
    saveFinanceData('phone_recharge_history', history).catch(e => console.warn('[Finance] phone_recharge_historyå¤‡ä»½å¤±è´¥:', e));
}

// æ˜¾ç¤ºå……å€¼é¡µé¢
async function showPhoneRechargePage() {
    const page = document.getElementById('phone-recharge-page');
    page.style.display = 'flex';
    page.offsetHeight;
    page.classList.add('slide-in');
    
    // è·å–å½“å‰è´¦å·çš„æ‰‹æœºå·
    const accountId = getCurrentAccountId();
    let phoneNumber = 'æœªç»‘å®š';
    if (accountId) {
        const myChar = await db.characters.get(parseInt(accountId));
        if (myChar) {
            phoneNumber = myChar.identity?.phone || generateVirtualPhoneNumber(myChar.id);
        }
    }
    
    // æ›´æ–°é¡µé¢ä¿¡æ¯
    document.getElementById('recharge-phone-number').textContent = phoneNumber;
    updateRechargePage();
}

function hidePhoneRechargePage() {
    const page = document.getElementById('phone-recharge-page');
    page.classList.remove('slide-in');
    setTimeout(() => {
        page.style.display = 'none';
    }, 300);
}

// æ›´æ–°å……å€¼é¡µé¢æ˜¾ç¤º
function updateRechargePage() {
    const balance = getPhoneBalance();
    document.getElementById('recharge-balance').textContent = `Â¥${balance.toFixed(2)}`;
    
    // æ›´æ–°å……å€¼è®°å½•
    const history = getRechargeHistory();
    const historyEl = document.getElementById('recharge-history');
    if (history.length === 0) {
        historyEl.textContent = 'æš‚æ— å……å€¼è®°å½•';
        historyEl.style.color = '#999';
    } else {
        historyEl.innerHTML = history.slice(0, 5).map(record => 
            `<div style="display:flex; justify-content:space-between; padding:8px 0; border-bottom:1px solid #f5f5f5;">
                <span>å……å€¼ Â¥${record.amount.toFixed(2)}</span>
                <span style="color:#999; font-size:12px;">${record.date}</span>
            </div>`
        ).join('');
        historyEl.style.color = '#333';
    }
}

// é€‰æ‹©å……å€¼é‡‘é¢
let selectedRechargeAmount = 0;

function selectRechargeAmount(amount) {
    selectedRechargeAmount = amount;
    
    // æ›´æ–°æŒ‰é’®æ ·å¼
    document.querySelectorAll('.recharge-amount-btn').forEach(btn => {
        btn.classList.remove('selected');
        if (parseFloat(btn.dataset.amount) === amount) {
            btn.classList.add('selected');
        }
    });
    
    // å¯ç”¨å……å€¼æŒ‰é’®
    const submitBtn = document.getElementById('recharge-submit-btn');
    submitBtn.disabled = false;
    submitBtn.style.opacity = '1';
    submitBtn.style.cursor = 'pointer';
    submitBtn.textContent = `å……å€¼ Â¥${amount.toFixed(2)}`;
}

// æäº¤å……å€¼
function submitRecharge() {
    if (selectedRechargeAmount <= 0) {
        alert('è¯·é€‰æ‹©å……å€¼é‡‘é¢');
        return;
    }
    
    if (!confirm(`ç¡®è®¤å……å€¼ Â¥${selectedRechargeAmount.toFixed(2)} å—ï¼Ÿ`)) {
        return;
    }
    
    // å¢åŠ ä½™é¢
    const newBalance = addPhoneBalance(selectedRechargeAmount);
    
    // æ·»åŠ å……å€¼è®°å½•
    addRechargeRecord(selectedRechargeAmount);
    
    // æ›´æ–°é¡µé¢
    updateRechargePage();
    
    // é‡ç½®é€‰æ‹©
    selectedRechargeAmount = 0;
    document.querySelectorAll('.recharge-amount-btn').forEach(btn => {
        btn.classList.remove('selected');
    });
    const submitBtn = document.getElementById('recharge-submit-btn');
    submitBtn.disabled = true;
    submitBtn.style.opacity = '0.5';
    submitBtn.style.cursor = 'not-allowed';
    submitBtn.textContent = 'è¯·é€‰æ‹©å……å€¼é‡‘é¢';
    
    alert(`å……å€¼æˆåŠŸï¼å½“å‰ä½™é¢ï¼šÂ¥${newBalance.toFixed(2)}`);
}

// å¯¼å‡ºåˆ°å…¨å±€ä½œç”¨åŸŸ
window.showPhoneRechargePage = showPhoneRechargePage;
window.hidePhoneRechargePage = hidePhoneRechargePage;

// å€Ÿé’±é¡µé¢ç›¸å…³å‡½æ•°
let selectedLoanAmount = 0;
let selectedLoanTerm = 6;

function showLoanPage() {
    const page = document.getElementById('loan-page');
    page.style.display = 'flex';
    page.offsetHeight;
    page.classList.add('slide-in');
    
    // é‡ç½®é€‰æ‹©
    selectedLoanAmount = 0;
    selectedLoanTerm = 6;
    document.getElementById('loan-term-select').value = '6';
    document.getElementById('loan-custom-input').value = '';
    updateLoanButtons();
    updateLoanInfo();
    loadLoanHistory();
}

function hideLoanPage() {
    const page = document.getElementById('loan-page');
    page.classList.remove('slide-in');
    setTimeout(() => {
        page.style.display = 'none';
    }, 300);
}

function selectLoanAmount(amount) {
    selectedLoanAmount = amount;
    // æ¸…é™¤è‡ªå®šä¹‰è¾“å…¥
    document.getElementById('loan-custom-input').value = '';
    // æ›´æ–°æŒ‰é’®çŠ¶æ€
    updateLoanButtons();
    updateLoanInfo();
}

function handleCustomLoanAmount(value) {
    const amount = parseInt(value) || 0;
    if (amount >= 100 && amount <= 50000) {
        selectedLoanAmount = amount;
        // æ¸…é™¤é¢„è®¾æŒ‰é’®é€‰æ‹©
        document.querySelectorAll('.loan-amount-btn').forEach(btn => {
            btn.classList.remove('selected');
        });
        updateLoanInfo();
    } else {
        selectedLoanAmount = 0;
    }
    updateLoanButtons();
}

function updateLoanButtons() {
    const submitBtn = document.getElementById('loan-submit-btn');
    if (selectedLoanAmount > 0) {
        submitBtn.disabled = false;
        submitBtn.textContent = `ç«‹å³å€Ÿæ¬¾ Â¥${selectedLoanAmount.toLocaleString()}`;
    } else {
        submitBtn.disabled = true;
        submitBtn.textContent = 'è¯·é€‰æ‹©å€Ÿæ¬¾é‡‘é¢';
    }
}

function updateLoanInfo() {
    selectedLoanTerm = parseInt(document.getElementById('loan-term-select').value) || 6;
    
    if (selectedLoanAmount > 0) {
        // è®¡ç®—æ€»è¿˜æ¬¾é¢ï¼šæœ¬é‡‘ + åˆ©æ¯
        // æ—¥åˆ©ç‡ 0.05%ï¼Œæœˆåˆ©ç‡çº¦ 1.5%
        const monthlyRate = 0.015;
        const totalInterest = selectedLoanAmount * monthlyRate * selectedLoanTerm;
        const totalAmount = selectedLoanAmount + totalInterest;
        
        document.getElementById('loan-total-amount').textContent = `Â¥${totalAmount.toLocaleString('zh-CN', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
    } else {
        document.getElementById('loan-total-amount').textContent = 'Â¥0.00';
    }
}

async function submitLoan() {
    if (selectedLoanAmount <= 0) {
        return;
    }
    
    // è®¡ç®—è¿˜æ¬¾ä¿¡æ¯
    const monthlyRate = 0.015;
    const totalInterest = selectedLoanAmount * monthlyRate * selectedLoanTerm;
    const totalAmount = selectedLoanAmount + totalInterest;
    const monthlyPayment = totalAmount / selectedLoanTerm;
    
    // ç¡®è®¤å¯¹è¯æ¡†
    const confirmMsg = `ç¡®è®¤å€Ÿæ¬¾ä¿¡æ¯ï¼š\n\nå€Ÿæ¬¾é‡‘é¢ï¼šÂ¥${selectedLoanAmount.toLocaleString()}\nå€Ÿæ¬¾æœŸé™ï¼š${selectedLoanTerm}ä¸ªæœˆ\næ—¥åˆ©ç‡ï¼š0.05%\né¢„è®¡è¿˜æ¬¾æ€»é¢ï¼šÂ¥${totalAmount.toLocaleString('zh-CN', {minimumFractionDigits: 2, maximumFractionDigits: 2})}\næ¯æœˆè¿˜æ¬¾ï¼šÂ¥${monthlyPayment.toLocaleString('zh-CN', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
    
    if (confirm(confirmMsg)) {
        if (!currentMyCharId) {
            alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ª User èº«ä»½');
            return;
        }
        
        // æ·»åŠ å€Ÿæ¬¾é‡‘é¢åˆ°ä½™é¢
        const user = await db.characters.get(parseInt(currentMyCharId));
        if (!user) {
            alert('æœªæ‰¾åˆ°ç”¨æˆ·ä¿¡æ¯');
            return;
        }
        
        let userBalance = parseFloat(user.identity?.balance || 0);
        userBalance = userBalance + selectedLoanAmount;
        
        if (!user.identity) user.identity = {};
        user.identity.balance = userBalance.toFixed(2);
        await safeCharacterPut(user);
        
        // æ›´æ–°ä½™é¢æ˜¾ç¤º
        await updateBalancePageDisplay();
        await updateWalletBalanceDisplay();
        
        // ä¿å­˜å€Ÿæ¬¾è®°å½•åˆ°æœ¬åœ°å­˜å‚¨
        const now = Date.now();
        const dueTime = now + (selectedLoanTerm * 12 * 60 * 60 * 1000); // 1ä¸ªæœˆ=12å°æ—¶
        
        const loanRecord = {
            id: now,
            amount: selectedLoanAmount,
            term: selectedLoanTerm,
            totalAmount: totalAmount,
            monthlyPayment: monthlyPayment,
            date: new Date().toISOString(),
            dueTime: dueTime, // åˆ°æœŸæ—¶é—´æˆ³
            status: 'pending', // pending, repaid, overdue
            paidAmount: 0, // å·²è¿˜é‡‘é¢
            remainingAmount: totalAmount, // å‰©ä½™åº”è¿˜é‡‘é¢
            firstReminderSent: false, // ç¬¬ä¸€æ¬¡æé†’å·²å‘é€
            secondReminderSent: false, // ç¬¬äºŒæ¬¡æé†’å·²å‘é€
            userId: currentMyCharId // å€Ÿæ¬¾äººID
        };
        
        let loanHistory = JSON.parse(localStorage.getItem('loanHistory') || '[]');
        loanHistory.unshift(loanRecord);
        safeLocalStorageSet('loanHistory', JSON.stringify(loanHistory));
        saveFinanceData('loanHistory', loanHistory).catch(e => console.warn('[Finance] loanHistoryå¤‡ä»½å¤±è´¥:', e));
        
        // æ˜¾ç¤ºæˆåŠŸæç¤º
        alert(`å€Ÿæ¬¾æˆåŠŸ\n\nå€Ÿæ¬¾é‡‘é¢ï¼šÂ¥${selectedLoanAmount.toLocaleString()}\nå·²æ·»åŠ åˆ°é’±åŒ…ä½™é¢`);
        
        // é‡ç½®é¡µé¢
        selectedLoanAmount = 0;
        document.getElementById('loan-custom-input').value = '';
        document.querySelectorAll('.loan-amount-btn').forEach(btn => {
            btn.classList.remove('selected');
        });
        updateLoanButtons();
        updateLoanInfo();
        loadLoanHistory();
    }
}

function loadLoanHistory() {
    const historyList = document.getElementById('loan-history-list');
    const loanHistory = JSON.parse(localStorage.getItem('loanHistory') || '[]');
    
    if (loanHistory.length === 0) {
        historyList.innerHTML = '<div class="loan-empty-state">æš‚æ— å€Ÿæ¬¾è®°å½•</div>';
        return;
    }
    
    historyList.innerHTML = loanHistory.map(record => {
        const date = new Date(record.date);
        const dateStr = date.toLocaleDateString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit' });
        const statusText = {
            'pending': 'å¾…è¿˜æ¬¾',
            'repaid': 'å·²è¿˜æ¸…',
            'overdue': 'å·²é€¾æœŸ'
        };
        
        const remainingAmount = record.remainingAmount !== undefined ? record.remainingAmount : record.totalAmount;
        const paidAmount = record.paidAmount || 0;
        
        return `
            <div class="loan-history-item" onclick="showRepayPage(${record.id})" style="cursor: pointer;">
                <div class="loan-history-info">
                    <div class="loan-history-amount">Â¥${record.amount.toLocaleString()}</div>
                    <div class="loan-history-date">${dateStr} Â· ${record.term}ä¸ªæœˆ</div>
                    ${record.status === 'pending' ? `<div style="font-size: 12px; color: #999; margin-top: 4px;">å‰©ä½™åº”è¿˜ï¼šÂ¥${remainingAmount.toFixed(2)}</div>` : ''}
                </div>
                <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 8px;">
                    <div class="loan-history-status ${record.status}">${statusText[record.status]}</div>
                    ${record.status === 'pending' ? '<div class="loan-repay-btn-small">è¿˜æ¬¾</div>' : ''}
                </div>
            </div>
        `;
    }).join('');
}

// åˆå§‹åŒ–å€Ÿæ¬¾é‡‘é¢æŒ‰é’®ç‚¹å‡»äº‹ä»¶
document.addEventListener('DOMContentLoaded', function() {
    // ä¸ºé¢„è®¾é‡‘é¢æŒ‰é’®æ·»åŠ é€‰ä¸­çŠ¶æ€åˆ‡æ¢
    document.querySelectorAll('.loan-amount-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            document.querySelectorAll('.loan-amount-btn').forEach(b => b.classList.remove('selected'));
            this.classList.add('selected');
        });
    });
});

window.showLoanPage = showLoanPage;
window.hideLoanPage = hideLoanPage;
window.selectLoanAmount = selectLoanAmount;
window.handleCustomLoanAmount = handleCustomLoanAmount;
window.updateLoanInfo = updateLoanInfo;
window.submitLoan = submitLoan;

// =================
// è¿˜æ¬¾åŠŸèƒ½
// =================

let currentRepayLoanId = null;
let currentRepayLoan = null;
let selectedRepayAmount = 0;

// æ˜¾ç¤ºè¿˜æ¬¾é¡µé¢
async function showRepayPage(loanId) {
    const page = document.getElementById('repay-page');
    page.style.display = 'flex';
    page.offsetHeight;
    page.classList.add('slide-in');
    
    currentRepayLoanId = loanId;
    
    // åŠ è½½å€Ÿæ¬¾ä¿¡æ¯
    const loanHistory = JSON.parse(localStorage.getItem('loanHistory') || '[]');
    currentRepayLoan = loanHistory.find(loan => loan.id === loanId);
    
    if (!currentRepayLoan) {
        alert('æœªæ‰¾åˆ°å€Ÿæ¬¾è®°å½•');
        hideRepayPage();
        return;
    }
    
    // æ›´æ–°ä½™é¢æ˜¾ç¤º
    await updateRepayBalance();
    
    // æ›´æ–°é¡µé¢ä¿¡æ¯
    updateRepayPageInfo();
    
    // é‡ç½®é€‰æ‹©
    selectedRepayAmount = 0;
    document.getElementById('repay-custom-input').value = '';
    updateRepayButtons();
}

// éšè—è¿˜æ¬¾é¡µé¢
function hideRepayPage() {
    const page = document.getElementById('repay-page');
    page.classList.remove('slide-in');
    setTimeout(() => {
        page.style.display = 'none';
    }, 300);
    
    currentRepayLoanId = null;
    currentRepayLoan = null;
    selectedRepayAmount = 0;
}

// æ›´æ–°ä½™é¢æ˜¾ç¤º
async function updateRepayBalance() {
    if (!currentMyCharId) {
        document.getElementById('repay-current-balance').textContent = 'Â¥0.00';
        return;
    }
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    const balance = user?.identity?.balance || 0;
    document.getElementById('repay-current-balance').textContent = `Â¥${parseFloat(balance).toFixed(2)}`;
}

// æ›´æ–°è¿˜æ¬¾é¡µé¢ä¿¡æ¯
function updateRepayPageInfo() {
    if (!currentRepayLoan) return;
    
    const date = new Date(currentRepayLoan.date);
    const dateStr = date.toLocaleDateString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit' });
    
    const remainingAmount = currentRepayLoan.remainingAmount !== undefined ? currentRepayLoan.remainingAmount : currentRepayLoan.totalAmount;
    const paidAmount = currentRepayLoan.paidAmount || 0;
    const monthlyPayment = currentRepayLoan.monthlyPayment || 0;
    
    document.getElementById('repay-loan-amount').textContent = `Â¥${currentRepayLoan.amount.toLocaleString()}`;
    document.getElementById('repay-loan-date').textContent = dateStr;
    document.getElementById('repay-loan-term').textContent = `${currentRepayLoan.term}ä¸ªæœˆ`;
    document.getElementById('repay-total-amount').textContent = `Â¥${currentRepayLoan.totalAmount.toFixed(2)}`;
    document.getElementById('repay-paid-amount').textContent = `Â¥${paidAmount.toFixed(2)}`;
    document.getElementById('repay-remaining-amount').textContent = `Â¥${remainingAmount.toFixed(2)}`;
    
    // æ›´æ–°è¿˜æ¬¾é€‰é¡¹
    document.getElementById('repay-monthly-value').textContent = `Â¥${monthlyPayment.toFixed(2)}`;
    document.getElementById('repay-half-value').textContent = `Â¥${(remainingAmount / 2).toFixed(2)}`;
    document.getElementById('repay-all-value').textContent = `Â¥${remainingAmount.toFixed(2)}`;
}

// é€‰æ‹©è¿˜æ¬¾é‡‘é¢
function selectRepayAmount(type) {
    if (!currentRepayLoan) return;
    
    const remainingAmount = currentRepayLoan.remainingAmount !== undefined ? currentRepayLoan.remainingAmount : currentRepayLoan.totalAmount;
    const monthlyPayment = currentRepayLoan.monthlyPayment || 0;
    
    // æ¸…é™¤è‡ªå®šä¹‰è¾“å…¥
    document.getElementById('repay-custom-input').value = '';
    
    // æ¸…é™¤å…¶ä»–æŒ‰é’®é€‰ä¸­çŠ¶æ€
    document.querySelectorAll('#repay-page .loan-amount-btn').forEach(btn => {
        btn.classList.remove('selected');
    });
    
    // è®¾ç½®é€‰ä¸­é‡‘é¢
    if (type === 'monthly') {
        selectedRepayAmount = Math.min(monthlyPayment, remainingAmount);
        event.target.closest('.loan-amount-btn').classList.add('selected');
    } else if (type === 'half') {
        selectedRepayAmount = remainingAmount / 2;
        event.target.closest('.loan-amount-btn').classList.add('selected');
    } else if (type === 'all') {
        selectedRepayAmount = remainingAmount;
        event.target.closest('.loan-amount-btn').classList.add('selected');
    }
    
    updateRepayButtons();
}

// å¤„ç†è‡ªå®šä¹‰è¿˜æ¬¾é‡‘é¢
function handleCustomRepayAmount(value) {
    const amount = parseFloat(value) || 0;
    const remainingAmount = currentRepayLoan.remainingAmount !== undefined ? currentRepayLoan.remainingAmount : currentRepayLoan.totalAmount;
    
    if (amount > 0 && amount <= remainingAmount) {
        selectedRepayAmount = amount;
        // æ¸…é™¤é¢„è®¾æŒ‰é’®é€‰æ‹©
        document.querySelectorAll('#repay-page .loan-amount-btn').forEach(btn => {
            btn.classList.remove('selected');
        });
    } else {
        selectedRepayAmount = 0;
    }
    updateRepayButtons();
}

// æ›´æ–°è¿˜æ¬¾æŒ‰é’®çŠ¶æ€
function updateRepayButtons() {
    const submitBtn = document.getElementById('repay-submit-btn');
    if (selectedRepayAmount > 0 && currentRepayLoan) {
        const remainingAmount = currentRepayLoan.remainingAmount !== undefined ? currentRepayLoan.remainingAmount : currentRepayLoan.totalAmount;
        if (selectedRepayAmount <= remainingAmount) {
            submitBtn.disabled = false;
            submitBtn.textContent = `ç¡®è®¤è¿˜æ¬¾ Â¥${selectedRepayAmount.toFixed(2)}`;
        } else {
            submitBtn.disabled = true;
            submitBtn.textContent = 'è¿˜æ¬¾é‡‘é¢ä¸èƒ½è¶…è¿‡å‰©ä½™åº”è¿˜';
        }
    } else {
        submitBtn.disabled = true;
        submitBtn.textContent = 'è¯·é€‰æ‹©è¿˜æ¬¾é‡‘é¢';
    }
}

// æäº¤è¿˜æ¬¾
async function submitRepay() {
    if (!currentMyCharId || !currentRepayLoan || selectedRepayAmount <= 0) {
        return;
    }
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    if (!user) {
        alert('æœªæ‰¾åˆ°ç”¨æˆ·ä¿¡æ¯');
        return;
    }
    
    const remainingAmount = currentRepayLoan.remainingAmount !== undefined ? currentRepayLoan.remainingAmount : currentRepayLoan.totalAmount;
    
    if (selectedRepayAmount > remainingAmount) {
        alert('è¿˜æ¬¾é‡‘é¢ä¸èƒ½è¶…è¿‡å‰©ä½™åº”è¿˜é‡‘é¢');
        return;
    }
    
    let userBalance = parseFloat(user.identity?.balance || 0);
    
    // æ£€æŸ¥ä½™é¢
    if (userBalance < selectedRepayAmount) {
        alert(`ä½™é¢ä¸è¶³\nå½“å‰ä½™é¢ï¼šÂ¥${userBalance.toFixed(2)}\néœ€è¦ï¼šÂ¥${selectedRepayAmount.toFixed(2)}`);
        return;
    }
    
    // ç¡®è®¤å¯¹è¯æ¡†
    const confirmMsg = `ç¡®è®¤è¿˜æ¬¾ä¿¡æ¯ï¼š\n\nè¿˜æ¬¾é‡‘é¢ï¼šÂ¥${selectedRepayAmount.toFixed(2)}\nå‰©ä½™åº”è¿˜ï¼šÂ¥${remainingAmount.toFixed(2)}\n\nç¡®è®¤è¿˜æ¬¾ï¼Ÿ`;
    
    if (confirm(confirmMsg)) {
        // æ‰£æ¬¾
        userBalance = userBalance - selectedRepayAmount;
        if (!user.identity) user.identity = {};
        user.identity.balance = userBalance.toFixed(2);
        await safeCharacterPut(user);
        
        // æ›´æ–°ä½™é¢æ˜¾ç¤º
        await updateRepayBalance();
        await updateBalancePageDisplay();
        await updateWalletBalanceDisplay();
        
        // æ›´æ–°å€Ÿæ¬¾è®°å½•
        const loanHistory = JSON.parse(localStorage.getItem('loanHistory') || '[]');
        const loanIndex = loanHistory.findIndex(loan => loan.id === currentRepayLoanId);
        
        if (loanIndex !== -1) {
            const loan = loanHistory[loanIndex];
            const newPaidAmount = (loan.paidAmount || 0) + selectedRepayAmount;
            const newRemainingAmount = remainingAmount - selectedRepayAmount;
            
            loan.paidAmount = newPaidAmount;
            loan.remainingAmount = newRemainingAmount;
            
            // å¦‚æœå…¨éƒ¨è¿˜æ¸…ï¼Œæ›´æ–°çŠ¶æ€
            if (newRemainingAmount <= 0.01) {
                loan.status = 'repaid';
                loan.remainingAmount = 0;
            }
            
            loanHistory[loanIndex] = loan;
            safeLocalStorageSet('loanHistory', JSON.stringify(loanHistory));
            saveFinanceData('loanHistory', loanHistory).catch(e => console.warn('[Finance] loanHistoryå¤‡ä»½å¤±è´¥:', e));
            
            // æ›´æ–°å½“å‰æ˜¾ç¤ºçš„å€Ÿæ¬¾ä¿¡æ¯
            currentRepayLoan = loan;
        }
        
        // æ˜¾ç¤ºæˆåŠŸæç¤º
        if (currentRepayLoan.remainingAmount <= 0.01) {
            alert(`è¿˜æ¬¾æˆåŠŸ\n\nå·²è¿˜æ¸…å…¨éƒ¨å€Ÿæ¬¾`);
            hideRepayPage();
        } else {
            alert(`è¿˜æ¬¾æˆåŠŸ\n\nè¿˜æ¬¾é‡‘é¢ï¼šÂ¥${selectedRepayAmount.toFixed(2)}\nå‰©ä½™åº”è¿˜ï¼šÂ¥${currentRepayLoan.remainingAmount.toFixed(2)}`);
        }
        
        // æ›´æ–°é¡µé¢
        updateRepayPageInfo();
        selectedRepayAmount = 0;
        document.getElementById('repay-custom-input').value = '';
        document.querySelectorAll('#repay-page .loan-amount-btn').forEach(btn => {
            btn.classList.remove('selected');
        });
        updateRepayButtons();
        
        // åˆ·æ–°å€Ÿæ¬¾è®°å½•åˆ—è¡¨ï¼ˆå¦‚æœè¿˜åœ¨å€Ÿé’±é¡µé¢ï¼‰
        if (typeof loadLoanHistory === 'function') {
            loadLoanHistory();
        }
    }
}

// å¯¼å‡ºå‡½æ•°
window.showRepayPage = showRepayPage;
window.hideRepayPage = hideRepayPage;
window.selectRepayAmount = selectRepayAmount;
window.handleCustomRepayAmount = handleCustomRepayAmount;
window.submitRepay = submitRepay;

// =================
// å€Ÿæ¬¾é€¾æœŸæé†’ç³»ç»Ÿ
// =================

// æ£€æŸ¥é€¾æœŸå€Ÿæ¬¾å¹¶å‘é€æé†’
async function checkOverdueLoans() {
    const loanHistory = JSON.parse(localStorage.getItem('loanHistory') || '[]');
    const now = Date.now();
    
    let hasChanges = false;
    
    for (let loan of loanHistory) {
        // åªæ£€æŸ¥å¾…è¿˜æ¬¾çŠ¶æ€çš„å€Ÿæ¬¾
        if (loan.status !== 'pending' || !loan.dueTime) continue;
        
        const overdueTime = now - loan.dueTime;
        
        // ç¬¬ä¸€æ¬¡æé†’ï¼šåˆšé€¾æœŸï¼ˆ0-5åˆ†é’Ÿå†…ï¼Œé¿å…é‡å¤æ£€æŸ¥ï¼‰
        if (overdueTime >= 0 && overdueTime < 5 * 60 * 1000 && !loan.firstReminderSent) {
            await sendFirstReminder(loan);
            loan.firstReminderSent = true;
            loan.status = 'overdue';
            hasChanges = true;
            console.log(`[å€Ÿæ¬¾æé†’] ç¬¬ä¸€æ¬¡æé†’å·²å‘é€ - å€Ÿæ¬¾ID: ${loan.id}`);
        }
        
        // ç¬¬äºŒæ¬¡æé†’ï¼šé€¾æœŸ12å°æ—¶å
        const secondReminderTime = 12 * 60 * 60 * 1000; // 12å°æ—¶
        if (overdueTime >= secondReminderTime && !loan.secondReminderSent) {
            await sendSecondReminder(loan);
            loan.secondReminderSent = true;
            hasChanges = true;
            console.log(`[å€Ÿæ¬¾æé†’] ç¬¬äºŒæ¬¡æé†’å·²å‘é€ - å€Ÿæ¬¾ID: ${loan.id}`);
        }
    }
    
    // å¦‚æœæœ‰å˜åŒ–ï¼Œä¿å­˜æ›´æ–°
    if (hasChanges) {
        safeLocalStorageSet('loanHistory', JSON.stringify(loanHistory));
        saveFinanceData('loanHistory', loanHistory).catch(e => console.warn('[Finance] loanHistoryå¤‡ä»½å¤±è´¥:', e));
        // åˆ·æ–°å€Ÿæ¬¾è®°å½•æ˜¾ç¤º
        if (typeof loadLoanHistory === 'function') {
            loadLoanHistory();
        }
    }
}

// ç¬¬ä¸€æ¬¡æé†’ï¼šå‘çŸ­ä¿¡ç»™å€Ÿæ¬¾äººæœ¬äºº
async function sendFirstReminder(loan) {
    if (!loan.userId) return;
    
    const user = await db.characters.get(parseInt(loan.userId));
    if (!user) return;
    
    const borrowDate = new Date(loan.date).toLocaleDateString('zh-CN', { 
        year: 'numeric', 
        month: '2-digit', 
        day: '2-digit' 
    });
    
    const message = `ã€å€Ÿæ¬¾æé†’ã€‘
å°Šæ•¬çš„ç”¨æˆ·ï¼Œæ‚¨äº${borrowDate}å€Ÿæ¬¾Â¥${loan.amount.toLocaleString()}å·²åˆ°æœŸï¼Œå‰©ä½™åº”è¿˜é‡‘é¢Â¥${loan.remainingAmount.toFixed(2)}ã€‚

è¯·å°½å¿«è¿˜æ¬¾ï¼Œé¿å…é€¾æœŸå½±å“ä¿¡ç”¨ã€‚
ç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…å¹¶è¿˜æ¬¾ã€‚

- å¾®ä¿¡æ”¯ä»˜`;
    
    // å‘é€åˆ°ä¿¡æ¯Appï¼ˆçŸ­ä¿¡å½¢å¼ï¼‰
    await sendSystemSMS(loan.userId, message, 'å¾®ä¿¡æ”¯ä»˜');
    
    console.log(`[ç¬¬ä¸€æ¬¡æé†’] å·²å‘é€çŸ­ä¿¡ç»™ç”¨æˆ· ${user.name}`);
}

// ç¬¬äºŒæ¬¡æé†’ï¼šå‘çŸ­ä¿¡ç»™æ‰€æœ‰å¥½å‹
async function sendSecondReminder(loan) {
    if (!loan.userId) return;
    
    const user = await db.characters.get(parseInt(loan.userId));
    if (!user) return;
    
    const overdueHours = Math.floor((Date.now() - loan.dueTime) / (60 * 60 * 1000));
    const overdueMonths = Math.floor(overdueHours / 12); // 12å°æ—¶ = 1ä¸ªæœˆ
    
    // æ ¹æ®é€¾æœŸæ—¶é—´æ˜¾ç¤ºä¸åŒçš„å•ä½
    let overdueText = '';
    if (overdueMonths >= 1) {
        overdueText = `${overdueMonths}ä¸ªæœˆ`;
    } else {
        overdueText = `${overdueHours}å°æ—¶`;
    }
    
    const message = `ã€é€¾æœŸæé†’ã€‘${user.name}åœ¨å¾®ä¿¡å€Ÿæ¬¾Â¥${loan.amount.toLocaleString()}å·²é€¾æœŸ${overdueText}æœªè¿˜ï¼Œå‰©ä½™Â¥${loan.remainingAmount.toFixed(2)}ï¼Œè¯·æé†’TAå°½å¿«è¿˜æ¬¾ã€‚`;
    
    // è·å–æ‰€æœ‰å¥½å‹åˆ—è¡¨
    const friends = await getAllFriends(loan.userId);
    
    // å‘é€ç»™æ¯ä¸ªå¥½å‹ï¼ˆçŸ­ä¿¡å½¢å¼ï¼‰
    for (let friend of friends) {
        if (friend.type === 'local') {
            // æœ¬åœ°è§’è‰²ï¼šå¦‚æœå…³è”äº†Userï¼Œå‘é€çŸ­ä¿¡
            if (friend.linkedUserId) {
                await sendSystemSMS(friend.linkedUserId, message, 'å¾®ä¿¡æ”¯ä»˜');
                console.log(`[ç¬¬äºŒæ¬¡æé†’] å·²å‘é€çŸ­ä¿¡ç»™è§’è‰² ${friend.name} å…³è”çš„User`);
            }
            // åŒæ—¶æ·»åŠ åˆ°AIä¸Šä¸‹æ–‡æç¤º
            await addLoanReminderToCharContext(friend.id, message, user.name);
            
        } else if (friend.type === 'online') {
            // è”æœºå¥½å‹ï¼šå‘é€çŸ­ä¿¡åˆ°ä¿¡æ¯App
            await sendSystemSMS(friend.id, message, 'å¾®ä¿¡æ”¯ä»˜');
            console.log(`[ç¬¬äºŒæ¬¡æé†’] å·²å‘é€çŸ­ä¿¡ç»™è”æœºå¥½å‹ ${friend.name}`);
            
        } else if (friend.type === 'user') {
            // Userç±»å‹ï¼šç›´æ¥å‘é€çŸ­ä¿¡
            await sendSystemSMS(friend.id, message, 'å¾®ä¿¡æ”¯ä»˜');
            console.log(`[ç¬¬äºŒæ¬¡æé†’] å·²å‘é€çŸ­ä¿¡ç»™User ${friend.name}`);
        }
    }
    
    console.log(`[ç¬¬äºŒæ¬¡æé†’] å·²å‘é€çŸ­ä¿¡ç»™ ${friends.length} ä½å¥½å‹`);
}

// è·å–æ‰€æœ‰å¥½å‹ï¼ˆåŒ…æ‹¬æœ¬åœ°è§’è‰²å’Œè”æœºå¥½å‹ï¼‰
async function getAllFriends(userId) {
    const friends = [];
    
    // 1. è·å–æœ¬åœ°è§’è‰²å¥½å‹
    const allChars = await db.characters.toArray();
    for (let char of allChars) {
        // æ’é™¤Userç±»å‹å’Œè‡ªå·±
        if (char.type === 'User' || char.id === parseInt(userId)) continue;
        friends.push({
            id: char.id,
            name: char.name,
            type: 'local',
            linkedUserId: char.linked_user_id // å…³è”çš„User ID
        });
    }
    
    // 2. è·å–è”æœºå¥½å‹ï¼ˆå¦‚æœæœ‰è”æœºåŠŸèƒ½ï¼‰
    try {
        // ä»localStorageè·å–è”æœºå¥½å‹åˆ—è¡¨
        const onlineFriends = JSON.parse(localStorage.getItem('onlineFriends') || '[]');
        for (let friend of onlineFriends) {
            if (friend.id && friend.id !== userId) {
                friends.push({
                    id: friend.accountId || friend.id, // ä½¿ç”¨accountIdä½œä¸ºæ¥æ”¶çŸ­ä¿¡çš„ID
                    name: friend.name || friend.nickname || 'è”æœºå¥½å‹',
                    type: 'online',
                    originalId: friend.id // åŸå§‹ID
                });
            }
        }
    } catch (e) {
        console.warn('[è·å–è”æœºå¥½å‹å¤±è´¥]', e);
    }
    
    // 3. è·å–æ‰€æœ‰Userç±»å‹çš„è§’è‰²ï¼ˆä»–ä»¬ä¹Ÿèƒ½æ”¶åˆ°çŸ­ä¿¡ï¼‰
    const allUsers = allChars.filter(char => char.type === 'User' && char.id !== parseInt(userId));
    for (let user of allUsers) {
        friends.push({
            id: user.id,
            name: user.name,
            type: 'user'
        });
    }
    
    return friends;
}

// æ·»åŠ å€Ÿæ¬¾æé†’åˆ°è§’è‰²AIä¸Šä¸‹æ–‡
async function addLoanReminderToCharContext(charId, message, borrowerName) {
    const char = await db.characters.get(charId);
    if (!char) return;
    
    // åˆå§‹åŒ– loanReminders å­—æ®µ
    if (!char.loanReminders) {
        char.loanReminders = [];
    }
    
    // æ·»åŠ æé†’è®°å½•
    char.loanReminders.push({
        message: message,
        borrowerName: borrowerName,
        timestamp: Date.now(),
        read: false
    });
    
    // ä¿å­˜åˆ°æ•°æ®åº“
    await safeCharacterPut(char);
    
    console.log(`[å€Ÿæ¬¾æé†’] å·²æ·»åŠ åˆ°è§’è‰² ${char.name} çš„ä¸Šä¸‹æ–‡`);
}

// è¿™ä¸ªå‡½æ•°å·²ä¸å†éœ€è¦ï¼Œç›´æ¥åœ¨ä¸»å¾ªç¯ä¸­å‘é€

// å‘é€ç³»ç»ŸçŸ­ä¿¡ï¼ˆåˆ°ä¿¡æ¯Appï¼‰
async function sendSystemSMS(userId, message, senderName = 'ç³»ç»Ÿé€šçŸ¥') {
    console.log(`[å‘é€çŸ­ä¿¡] ç»™ç”¨æˆ· ${userId}ï¼Œå‘é€è€…ï¼š${senderName}`);
    
    const accountId = String(userId);
    
    // æ·»åŠ åˆ° Dexie æ•°æ®åº“
    await db.sms_messages.add({
        accountId: accountId,
        charId: null, // ç³»ç»Ÿæ¶ˆæ¯æ²¡æœ‰è§’è‰²ID
        type: 'received',  // æ¥æ”¶çš„æ¶ˆæ¯
        sender: senderName,
        number: senderName,
        content: message,
        time: Date.now(),
        read: false
    });
    
    console.log(`[å‘é€çŸ­ä¿¡] âœ… çŸ­ä¿¡å·²æ·»åŠ åˆ°æ•°æ®åº“`);
    
    // åˆ·æ–°ä¸»é¡µé¢çš„æ¶ˆæ¯åˆ—è¡¨
    if (typeof renderMessageList === 'function') {
        await renderMessageList();
        console.log(`[å‘é€çŸ­ä¿¡] âœ… æ¶ˆæ¯åˆ—è¡¨å·²åˆ·æ–°`);
    }
}

// å¯åŠ¨å®šæ—¶æ£€æŸ¥ï¼ˆæ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡ï¼‰
let loanCheckInterval = null;

function startLoanReminderSystem() {
    // æ¸…é™¤æ—§çš„å®šæ—¶å™¨
    if (loanCheckInterval) {
        clearInterval(loanCheckInterval);
    }
    
    // ç«‹å³æ‰§è¡Œä¸€æ¬¡æ£€æŸ¥
    checkOverdueLoans();
    
    // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
    loanCheckInterval = setInterval(() => {
        checkOverdueLoans();
    }, 60 * 1000); // 60ç§’
    
    console.log('[å€Ÿæ¬¾æé†’ç³»ç»Ÿ] å·²å¯åŠ¨ï¼Œæ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡');
}

// é¡µé¢åŠ è½½æ—¶å¯åŠ¨
if (typeof window !== 'undefined') {
    // å»¶è¿Ÿå¯åŠ¨å€Ÿæ¬¾æé†’ï¼Œé¿å…ä¸ä¸»åˆå§‹åŒ–åŒæ—¶äº‰æŠ¢ä¸»çº¿ç¨‹
    const _startLoanDelay = () => setTimeout(startLoanReminderSystem, 3000);
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', _startLoanDelay);
    } else {
        _startLoanDelay();
    }
}

// =================
// æµ‹è¯•åŠŸèƒ½
// =================

let testReminderClickCount = 0;
let testLoanRecord = null;

async function testLoanReminder() {
    const statusDiv = document.getElementById('test-reminder-status');
    
    testReminderClickCount++;
    
    if (testReminderClickCount === 1) {
        // ç¬¬ä¸€æ¬¡ç‚¹å‡»ï¼šåˆ›å»ºæµ‹è¯•å€Ÿæ¬¾å¹¶å‘é€ç¬¬ä¸€æ¬¡æé†’
        if (!currentMyCharId) {
            alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ª User èº«ä»½');
            testReminderClickCount = 0;
            return;
        }
        
        const user = await db.characters.get(parseInt(currentMyCharId));
        if (!user) {
            alert('æœªæ‰¾åˆ°ç”¨æˆ·ä¿¡æ¯');
            testReminderClickCount = 0;
            return;
        }
        
        // åˆ›å»ºä¸€ä¸ªæµ‹è¯•å€Ÿæ¬¾è®°å½•ï¼ˆé€¾æœŸ1ä¸ªæœˆ = 12å°æ—¶ï¼‰
        const now = Date.now();
        const oneMonthAgo = now - (12 * 60 * 60 * 1000); // 12å°æ—¶å‰
        testLoanRecord = {
            id: now,
            amount: 5000,
            term: 3,
            totalAmount: 5225,
            monthlyPayment: 1741.67,
            date: new Date(oneMonthAgo - (3 * 12 * 60 * 60 * 1000)).toISOString(), // å€Ÿæ¬¾æ—¥æœŸï¼š4ä¸ªæœˆå‰
            dueTime: oneMonthAgo, // åˆ°æœŸæ—¶é—´ï¼š1ä¸ªæœˆå‰ï¼ˆå·²é€¾æœŸ12å°æ—¶ï¼‰
            status: 'pending',
            paidAmount: 0,
            remainingAmount: 5225,
            firstReminderSent: false,
            secondReminderSent: false,
            userId: currentMyCharId,
            isTest: true // æ ‡è®°ä¸ºæµ‹è¯•è®°å½•
        };
        
        // å‘é€ç¬¬ä¸€æ¬¡æé†’
        await sendFirstReminder(testLoanRecord);
        testLoanRecord.firstReminderSent = true;
        
        if (statusDiv) {
            statusDiv.textContent = 'âœ… ç¬¬ä¸€æ¬¡æé†’å·²å‘é€ï¼ˆçŸ­ä¿¡ç»™æœ¬äººï¼‰\nå†ç‚¹å‡»ä¸€æ¬¡å‘é€ç¬¬äºŒæ¬¡æé†’';
            statusDiv.style.color = '#07c160';
        }
        
        alert('æµ‹è¯•ï¼šç¬¬ä¸€æ¬¡æé†’å·²å‘é€\n\nå·²å‘é€çŸ­ä¿¡ç»™å€Ÿæ¬¾äººæœ¬äºº\nè¯·æŸ¥çœ‹å¾®ä¿¡æ¶ˆæ¯');
        
    } else if (testReminderClickCount === 2) {
        // ç¬¬äºŒæ¬¡ç‚¹å‡»ï¼šå‘é€ç¬¬äºŒæ¬¡æé†’
        if (!testLoanRecord) {
            alert('è¯·å…ˆç‚¹å‡»ç¬¬ä¸€æ¬¡å‘é€ç¬¬ä¸€æ¬¡æé†’');
            testReminderClickCount = 0;
            return;
        }
        
        // å‘é€ç¬¬äºŒæ¬¡æé†’
        await sendSecondReminder(testLoanRecord);
        testLoanRecord.secondReminderSent = true;
        
        // è·å–å¥½å‹æ•°é‡
        const friends = await getAllFriends(testLoanRecord.userId);
        
        if (statusDiv) {
            statusDiv.textContent = `âœ… ç¬¬äºŒæ¬¡æé†’å·²å‘é€\nå·²é€šçŸ¥ ${friends.length} ä½å¥½å‹ï¼ˆæœ¬åœ°è§’è‰² + è”æœºå¥½å‹ï¼‰`;
            statusDiv.style.color = '#07c160';
        }
        
        alert(`æµ‹è¯•ï¼šç¬¬äºŒæ¬¡æé†’å·²å‘é€\n\nå·²å‘é€ç»™ ${friends.length} ä½å¥½å‹\n\n- æœ¬åœ°è§’è‰²ï¼šä¼šåœ¨èŠå¤©æ—¶æ”¶åˆ°ä¸Šä¸‹æ–‡æç¤º\n- è”æœºå¥½å‹ï¼šä¼šæ”¶åˆ°çŸ­ä¿¡\n\nå†æ¬¡ç‚¹å‡»å¯é‡ç½®æµ‹è¯•`);
        
    } else {
        // ç¬¬ä¸‰æ¬¡ç‚¹å‡»ï¼šé‡ç½®
        testReminderClickCount = 0;
        testLoanRecord = null;
        
        if (statusDiv) {
            statusDiv.textContent = 'å·²é‡ç½®ï¼Œç‚¹å‡»å¼€å§‹æ–°çš„æµ‹è¯•';
            statusDiv.style.color = '#999';
        }
        
        alert('æµ‹è¯•å·²é‡ç½®\n\nç‚¹å‡»æŒ‰é’®å¼€å§‹æ–°çš„æµ‹è¯•');
    }
}

window.testLoanReminder = testLoanReminder;

// =================
// åˆ®åˆ®ä¹åŠŸèƒ½
// =================

const SCRATCH_CARD_PRICE = 10; // æ¯å¼ åˆ®åˆ®ä¹ä»·æ ¼
let currentScratchCard = null; // å½“å‰åˆ®åˆ®ä¹æ•°æ®
let isScratching = false; // æ˜¯å¦æ­£åœ¨åˆ®å¥–
let scratchProgress = 0; // åˆ®å¼€è¿›åº¦ (0-100)

// æ˜¾ç¤ºåˆ®åˆ®ä¹é¡µé¢
async function showScratchCardPage() {
    const page = document.getElementById('scratch-card-page');
    page.style.display = 'flex';
    page.offsetHeight;
    page.classList.add('slide-in');
    
    // æ›´æ–°ä½™é¢æ˜¾ç¤º
    await updateScratchBalance();
    
    // é‡ç½®åˆ®åˆ®ä¹çŠ¶æ€
    resetScratchCard();
    
    // åŠ è½½å†å²è®°å½•
    loadScratchHistory();
}

// éšè—åˆ®åˆ®ä¹é¡µé¢
function hideScratchCardPage() {
    const page = document.getElementById('scratch-card-page');
    page.classList.remove('slide-in');
    setTimeout(() => {
        page.style.display = 'none';
    }, 300);
}

// æ›´æ–°ä½™é¢æ˜¾ç¤º
async function updateScratchBalance() {
    if (!currentMyCharId) {
        document.getElementById('scratch-current-balance').textContent = 'Â¥0.00';
        return;
    }
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    const balance = user?.identity?.balance || 0;
    document.getElementById('scratch-current-balance').textContent = `Â¥${parseFloat(balance).toFixed(2)}`;
    
    // æ›´æ–°è´­ä¹°æŒ‰é’®çŠ¶æ€
    const buyBtn = document.getElementById('scratch-buy-btn');
    if (parseFloat(balance) < SCRATCH_CARD_PRICE) {
        buyBtn.disabled = true;
        buyBtn.querySelector('#scratch-buy-text').textContent = `ä½™é¢ä¸è¶³ (éœ€è¦ Â¥${SCRATCH_CARD_PRICE})`;
    } else {
        buyBtn.disabled = false;
        buyBtn.querySelector('#scratch-buy-text').textContent = `è´­ä¹°åˆ®åˆ®ä¹ (Â¥${SCRATCH_CARD_PRICE})`;
    }
}

// é‡ç½®åˆ®åˆ®ä¹
function resetScratchCard() {
    currentScratchCard = null;
    isScratching = false;
    scratchProgress = 0;
    
    const cover = document.getElementById('scratch-cover');
    const content = document.getElementById('scratch-content');
    const resultIcon = document.getElementById('scratch-result-icon');
    const canvas = cover.querySelector('canvas');
    
    // æ¸…é™¤canvas
    if (canvas) {
        canvas.remove();
    }
    
    cover.classList.remove('scratched');
    cover.style.opacity = '1';
    cover.style.pointerEvents = 'auto';
    
    // é‡ç½®å›¾æ ‡æ˜¾ç¤º
    if (resultIcon) {
        resultIcon.style.display = 'none';
        resultIcon.textContent = '';
    }
    
    // éšè—å†…å®¹
    if (content) {
        content.style.display = 'none';
    }
}

// è´­ä¹°åˆ®åˆ®ä¹
async function buyScratchCard() {
    if (!currentMyCharId) {
        alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ª User èº«ä»½');
        return;
    }
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    if (!user) {
        alert('æœªæ‰¾åˆ°ç”¨æˆ·ä¿¡æ¯');
        return;
    }
    
    let userBalance = parseFloat(user.identity?.balance || 0);
    
    // æ£€æŸ¥ä½™é¢
    if (userBalance < SCRATCH_CARD_PRICE) {
        alert(`ä½™é¢ä¸è¶³ï¼\nå½“å‰ä½™é¢ï¼šÂ¥${userBalance.toFixed(2)}\néœ€è¦ï¼šÂ¥${SCRATCH_CARD_PRICE}`);
        return;
    }
    
    // æ‰£æ¬¾
    userBalance = userBalance - SCRATCH_CARD_PRICE;
    if (!user.identity) user.identity = {};
    user.identity.balance = userBalance.toFixed(2);
    await safeCharacterPut(user);
    
    // æ›´æ–°ä½™é¢æ˜¾ç¤º
    await updateScratchBalance();
    await updateBalancePageDisplay();
    await updateWalletBalanceDisplay();
    
    // ç”Ÿæˆåˆ®åˆ®ä¹ç»“æœ
    const prize = generateScratchPrize();
    currentScratchCard = {
        prize: prize,
        cost: SCRATCH_CARD_PRICE,
        time: Date.now()
    };
    
    // æ˜¾ç¤ºåˆ®åˆ®ä¹
    showScratchCard(prize);
    
    // åˆå§‹åŒ–åˆ®å¥–äº¤äº’
    initScratchInteraction();
}

// ç”Ÿæˆä¸­å¥–é‡‘é¢ï¼ˆæ¦‚ç‡åˆ†å¸ƒï¼‰
function generateScratchPrize() {
    const rand = Math.random();
    
    // æ¦‚ç‡åˆ†å¸ƒï¼ˆæ¯å¼ Â¥10ï¼‰ï¼š
    // 5%  - æœªä¸­å¥– Â¥0ï¼ˆäºÂ¥10ï¼‰
    // 60% - å›æœ¬åŒº Â¥8~Â¥12ï¼ˆåŸºæœ¬ä¸èµšä¸äºï¼‰
    // 25% - å°èµšåŒº Â¥15~Â¥30ï¼ˆå°èµšï¼‰
    // 7%  - ä¸­å¥–åŒº Â¥50~Â¥100ï¼ˆä¸­ç­‰å¥–ï¼‰
    // 2.5% - å¤§å¥–åŒº Â¥200~Â¥500ï¼ˆå¤§å¥–ï¼‰
    // 0.5% - å¤´å¥– Â¥1000ï¼ˆå¤´å¥–ï¼‰
    
    if (rand < 0.05) {
        return 0; // 5% æœªä¸­å¥–ï¼ˆäºé’±ï¼‰
    } else if (rand < 0.65) {
        return Math.floor(Math.random() * 5) + 8; // 60% å›æœ¬åŒº Â¥8~Â¥12
    } else if (rand < 0.90) {
        return Math.floor(Math.random() * 16) + 15; // 25% å°èµš Â¥15~Â¥30
    } else if (rand < 0.97) {
        return Math.floor(Math.random() * 51) + 50; // 7% ä¸­ç­‰å¥– Â¥50~Â¥100
    } else if (rand < 0.995) {
        return Math.floor(Math.random() * 301) + 200; // 2.5% å¤§å¥– Â¥200~Â¥500
    } else {
        return 1000; // 0.5% å¤´å¥– Â¥1000
    }
}

// æ˜¾ç¤ºåˆ®åˆ®ä¹
function showScratchCard(prize) {
    const cover = document.getElementById('scratch-cover');
    const content = document.getElementById('scratch-content');
    const resultIcon = document.getElementById('scratch-result-icon');
    const resultText = document.getElementById('scratch-result-text');
    const resultAmount = document.getElementById('scratch-result-amount');
    
    // æ˜¾ç¤ºå†…å®¹å±‚
    content.style.display = 'flex';
    
    // è®¾ç½®ç»“æœ
    if (prize === 0) {
        resultIcon.textContent = '';
        resultIcon.style.display = 'none';
        resultText.textContent = 'å¾ˆé—æ†¾ï¼Œæœªä¸­å¥–';
        resultAmount.textContent = 'Â¥0';
        resultAmount.style.color = '#999';
    } else {
        resultIcon.textContent = '';
        resultIcon.style.display = 'none';
        resultText.textContent = 'æ­å–œä¸­å¥–';
        resultAmount.textContent = `Â¥${prize}`;
        resultAmount.style.color = '#ffb6c1';
    }
    
    // é‡ç½®è¦†ç›–å±‚
    cover.style.opacity = '1';
    cover.style.pointerEvents = 'auto';
    cover.classList.remove('scratched');
    scratchProgress = 0;
}

// åˆå§‹åŒ–åˆ®å¥–äº¤äº’
function initScratchInteraction() {
    const cover = document.getElementById('scratch-cover');
    const card = document.getElementById('scratch-card');
    
    // æ¸…é™¤æ—§çš„canvas
    const oldCanvas = cover.querySelector('canvas');
    if (oldCanvas) {
        oldCanvas.remove();
    }
    
    // åˆ›å»ºcanvasç”¨äºåˆ®å¥–æ•ˆæœ
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const rect = card.getBoundingClientRect();
    
    canvas.width = rect.width;
    canvas.height = rect.height;
    canvas.style.position = 'absolute';
    canvas.style.top = '0';
    canvas.style.left = '0';
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.zIndex = '3';
    canvas.style.mixBlendMode = 'destination-out';
    
    // åˆå§‹åŒ–canvasä¸ºä¸é€æ˜
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    cover.appendChild(canvas);
    
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    
    // è·å–åæ ‡
    function getCoordinates(e) {
        const rect = card.getBoundingClientRect();
        if (e.touches) {
            return {
                x: e.touches[0].clientX - rect.left,
                y: e.touches[0].clientY - rect.top
            };
        } else {
            return {
                x: e.offsetX,
                y: e.offsetY
            };
        }
    }
    
    // ç»˜åˆ¶åˆ®ç—•
    function drawScratch(x, y) {
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath();
        ctx.arc(x, y, 25, 0, Math.PI * 2);
        ctx.fill();
        
        // å¦‚æœèµ·ç‚¹å’Œç»ˆç‚¹éƒ½æœ‰ï¼Œç”»ä¸€æ¡çº¿
        if (lastX > 0 && lastY > 0) {
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(x, y);
            ctx.lineWidth = 50;
            ctx.lineCap = 'round';
            ctx.strokeStyle = 'rgba(0,0,0,1)';
            ctx.globalCompositeOperation = 'destination-out';
            ctx.stroke();
        }
        
        lastX = x;
        lastY = y;
        
        // è®¡ç®—åˆ®å¼€è¿›åº¦ï¼ˆä½¿ç”¨é‡‡æ ·æ–¹å¼æé«˜æ€§èƒ½ï¼‰
        if (Math.random() < 0.1) { // åªé‡‡æ ·10%çš„æ£€æŸ¥ï¼Œå‡å°‘æ€§èƒ½æ¶ˆè€—
            const sampleSize = 100;
            const stepX = Math.floor(canvas.width / sampleSize);
            const stepY = Math.floor(canvas.height / sampleSize);
            let transparentCount = 0;
            
            for (let sy = 0; sy < canvas.height; sy += stepY) {
                for (let sx = 0; sx < canvas.width; sx += stepX) {
                    const imageData = ctx.getImageData(sx, sy, 1, 1);
                    if (imageData.data[3] === 0) { // alphaä¸º0è¡¨ç¤ºé€æ˜
                        transparentCount++;
                    }
                }
            }
            
            scratchProgress = (transparentCount / (sampleSize * sampleSize)) * 100;
            
            // å¦‚æœåˆ®å¼€è¶…è¿‡30%ï¼Œè‡ªåŠ¨å®Œæˆ
            if (scratchProgress >= 30) {
                finishScratching();
            }
        } else {
            // ç®€å•ä¼°ç®—ï¼šæ¯æ¬¡ç»˜åˆ¶å¢åŠ ä¸€ç‚¹è¿›åº¦
            scratchProgress = Math.min(scratchProgress + 0.5, 100);
            if (scratchProgress >= 30) {
                finishScratching();
            }
        }
    }
    
    // é¼ æ ‡äº‹ä»¶
    card.onmousedown = (e) => {
        if (currentScratchCard && !isScratching) {
            isDrawing = true;
            const coords = getCoordinates(e);
            lastX = coords.x;
            lastY = coords.y;
            drawScratch(coords.x, coords.y);
        }
    };
    
    card.onmousemove = (e) => {
        if (isDrawing && currentScratchCard && !isScratching) {
            const coords = getCoordinates(e);
            drawScratch(coords.x, coords.y);
        }
    };
    
    card.onmouseup = () => {
        isDrawing = false;
        lastX = 0;
        lastY = 0;
    };
    
    card.onmouseleave = () => {
        isDrawing = false;
        lastX = 0;
        lastY = 0;
    };
    
    // è§¦æ‘¸äº‹ä»¶
    card.ontouchstart = (e) => {
        if (currentScratchCard && !isScratching) {
            e.preventDefault();
            isDrawing = true;
            const coords = getCoordinates(e);
            lastX = coords.x;
            lastY = coords.y;
            drawScratch(coords.x, coords.y);
        }
    };
    
    card.ontouchmove = (e) => {
        if (isDrawing && currentScratchCard && !isScratching) {
            e.preventDefault();
            const coords = getCoordinates(e);
            drawScratch(coords.x, coords.y);
        }
    };
    
    card.ontouchend = () => {
        isDrawing = false;
        lastX = 0;
        lastY = 0;
    };
}

// åˆ®å¥–æ“ä½œï¼ˆå·²åºŸå¼ƒï¼Œä½¿ç”¨canvaså®ç°ï¼‰
function scratchAt(x, y) {
    // æ­¤å‡½æ•°å·²è¢«canvaså®ç°æ›¿ä»£
}

// å®Œæˆåˆ®å¥–
async function finishScratching() {
    if (isScratching || !currentScratchCard) return;
    isScratching = true;
    
    const cover = document.getElementById('scratch-cover');
    const canvas = cover.querySelector('canvas');
    const content = document.getElementById('scratch-content');
    
    // å®Œå…¨æ¸…é™¤è¦†ç›–å±‚
    if (canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
    
    // ç¡®ä¿å†…å®¹å±‚æ˜¾ç¤º
    if (content) {
        content.style.display = 'flex';
    }
    
    // å»¶è¿Ÿæ˜¾ç¤ºå®Œæˆæ•ˆæœ
    setTimeout(() => {
        cover.classList.add('scratched');
        cover.style.opacity = '0';
        cover.style.pointerEvents = 'none';
        
        // ç¡®ä¿é‡‘é¢æ˜¾ç¤ºæ­£ç¡®
        const resultAmount = document.getElementById('scratch-result-amount');
        const resultText = document.getElementById('scratch-result-text');
        const resultIcon = document.getElementById('scratch-result-icon');
        
        if (currentScratchCard) {
            if (currentScratchCard.prize === 0) {
                if (resultIcon) {
                    resultIcon.textContent = '';
                    resultIcon.style.display = 'none';
                }
                if (resultText) resultText.textContent = 'å¾ˆé—æ†¾ï¼Œæœªä¸­å¥–';
                if (resultAmount) {
                    resultAmount.textContent = 'Â¥0';
                    resultAmount.style.color = '#999';
                }
            } else {
                if (resultIcon) {
                    resultIcon.textContent = '';
                    resultIcon.style.display = 'none';
                }
                if (resultText) resultText.textContent = 'æ­å–œä¸­å¥–';
                if (resultAmount) {
                    resultAmount.textContent = `Â¥${currentScratchCard.prize}`;
                    resultAmount.style.color = '#ffb6c1';
                }
            }
        }
        
        // å¦‚æœæœ‰ä¸­å¥–ï¼Œæ·»åŠ åˆ°ä½™é¢
        if (currentScratchCard && currentScratchCard.prize > 0) {
            addScratchPrize(currentScratchCard.prize);
        }
        
        // ä¿å­˜è®°å½•
        saveScratchRecord(currentScratchCard);
        
        // é‡æ–°åŠ è½½å†å²
        loadScratchHistory();
        
        // é‡ç½®çŠ¶æ€ï¼Œå‡†å¤‡ä¸‹ä¸€å¼ 
        setTimeout(() => {
            isScratching = false;
            currentScratchCard = null;
            scratchProgress = 0;
        }, 2000);
    }, 300);
}

// æ·»åŠ ä¸­å¥–é‡‘é¢åˆ°ä½™é¢
async function addScratchPrize(amount) {
    if (!currentMyCharId) return;
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    if (!user) return;
    
    let userBalance = parseFloat(user.identity?.balance || 0);
    userBalance = userBalance + amount;
    
    if (!user.identity) user.identity = {};
    user.identity.balance = userBalance.toFixed(2);
    await safeCharacterPut(user);
    
    // æ›´æ–°æ˜¾ç¤º
    await updateScratchBalance();
    await updateBalancePageDisplay();
    await updateWalletBalanceDisplay();
    
    // æ˜¾ç¤ºä¸­å¥–æç¤º
    setTimeout(() => {
        alert(`æ­å–œä¸­å¥–\n\nå¥–é‡‘ï¼šÂ¥${amount}\nå·²æ·»åŠ åˆ°é’±åŒ…ä½™é¢`);
    }, 500);
}

// ä¿å­˜åˆ®åˆ®ä¹è®°å½•
function saveScratchRecord(record) {
    let history = JSON.parse(localStorage.getItem('scratchHistory') || '[]');
    history.unshift({
        prize: record.prize,
        cost: record.cost,
        time: record.time,
        net: record.prize - record.cost // å‡€æ”¶ç›Š
    });
    // åªä¿ç•™æœ€è¿‘50æ¡è®°å½•
    if (history.length > 50) {
        history = history.slice(0, 50);
    }
    safeLocalStorageSet('scratchHistory', JSON.stringify(history));
    saveFinanceData('scratchHistory', history).catch(e => console.warn('[Finance] scratchHistoryå¤‡ä»½å¤±è´¥:', e));
}

// åŠ è½½å†å²è®°å½•
function loadScratchHistory() {
    const historyList = document.getElementById('scratch-history-list');
    const history = JSON.parse(localStorage.getItem('scratchHistory') || '[]');
    
    if (history.length === 0) {
        historyList.innerHTML = '<div class="loan-empty-state">æš‚æ— ä¸­å¥–è®°å½•</div>';
        return;
    }
    
    historyList.innerHTML = history.map(record => {
        const date = new Date(record.time);
        const dateStr = date.toLocaleDateString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit' });
        const timeStr = date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
        const netClass = record.net >= 0 ? 'profit' : 'loss';
        const netText = record.net >= 0 ? `+Â¥${record.net}` : `Â¥${record.net}`;
        
        return `
            <div class="loan-history-item">
                <div class="loan-history-info">
                    <div class="loan-history-amount">${record.prize > 0 ? `ä¸­å¥– Â¥${record.prize}` : 'æœªä¸­å¥–'}</div>
                    <div class="loan-history-date">${dateStr} ${timeStr} Â· èŠ±è´¹ Â¥${record.cost}</div>
                </div>
                <div class="loan-history-status ${netClass}">${netText}</div>
            </div>
        `;
    }).join('');
}

// å¯¼å‡ºå‡½æ•°
window.showScratchCardPage = showScratchCardPage;
window.hideScratchCardPage = hideScratchCardPage;
window.buyScratchCard = buyScratchCard;
window.selectRechargeAmount = selectRechargeAmount;
window.submitRecharge = submitRecharge;

// --- æœ‹å‹åœˆé€»è¾‘ ---
let momentsScrollInit = false;

async function showMomentsPage() {
    const page = document.getElementById('moments-page');
    page.style.display = 'block'; // æœ‹å‹åœˆé¡µé¢æ˜¯ block å¸ƒå±€
    page.offsetHeight; 
    page.classList.add('slide-in');
    
    // åˆå§‹åŒ–æ»šåŠ¨ç›‘å¬
    if (!momentsScrollInit) {
        initMomentsScroll();
        momentsScrollInit = true;
    }
    
    // æ¸²æŸ“ç”¨æˆ·ä¿¡æ¯å’Œå°é¢
    await renderMomentsUserInfo();
    
    // æ¸²æŸ“åˆ—è¡¨
    await renderMomentsList();
}

function hideMomentsPage() {
    const page = document.getElementById('moments-page');
    page.classList.remove('slide-in');
    setTimeout(() => {
        page.style.display = 'none';
    }, 300);
}

function initMomentsScroll() {
    const page = document.getElementById('moments-page');
    const navBar = document.getElementById('moments-nav-bar');
    
    page.addEventListener('scroll', () => {
        if (page.scrollTop > 200) {
            navBar.classList.add('scrolled');
        } else {
            navBar.classList.remove('scrolled');
        }
    });
}

async function renderMomentsUserInfo() {
    // è·å–å½“å‰ User
    let user = null;
    if (currentMyCharId) {
        user = await db.characters.get(parseInt(currentMyCharId));
    }
    
    // å¦‚æœæ²¡æœ‰ Userï¼Œå°è¯•æ‰¾ä¸€ä¸ª
    if (!user) {
        const users = await db.characters.where('type').equals('user').toArray();
        if (users.length > 0) user = users[0];
    }
    
    const nameEl = document.getElementById('moments-user-name');
    const avatarEl = document.getElementById('moments-user-avatar');
    const coverEl = document.getElementById('moments-cover-area');
    
    // ç»™å¤´åƒæ·»åŠ ç‚¹å‡»äº‹ä»¶ï¼Œæ‰“å¼€"æˆ‘çš„æœ‹å‹åœˆ"
    avatarEl.onclick = (e) => {
        e.stopPropagation(); // é˜»æ­¢è§¦å‘å°é¢çš„ç‚¹å‡»äº‹ä»¶
        showMyMomentsPage();
    };
    
    if (user) {
        nameEl.innerText = user.name;
        if (user.avatar) {
            avatarEl.style.backgroundImage = `url(${user.avatar})`;
        } else {
            avatarEl.style.backgroundColor = '#eee';
        }
        
        // å°é¢å›¾ (åªè¯»å–å½“å‰è´¦å·çš„æ•°æ®ï¼Œå®ç°éš”ç¦»)
        const cover = user.identity?.cover;
        if (cover) {
            coverEl.style.backgroundImage = `url(${cover})`;
        } else {
            // å¦‚æœæ²¡è®¾ç½®ï¼Œæ˜¾ç¤ºé»˜è®¤ç°è‰²ï¼Œæ¸…ç©ºå¯èƒ½å­˜åœ¨çš„æ—§å›¾
            coverEl.style.backgroundImage = ''; 
        }
    } else {
        nameEl.innerText = "æœªç™»å½•";
        // æœªç™»å½•æ—¶æ¸…é™¤å°é¢å’Œå¤´åƒ
        avatarEl.style.backgroundImage = '';
        coverEl.style.backgroundImage = '';
    }
}

async function renderMomentsList() {
    const container = document.getElementById('moments-list');
    container.innerHTML = '';
    
    // è·å–å½“å‰è´¦å·ID
    const currentAccountId = currentMyCharId ? parseInt(currentMyCharId) : null;
    if (!currentAccountId) {
        container.innerHTML = `<div style="text-align:center; color:#ccc; margin-top:100px; font-size:14px;">è¯·å…ˆç™»å½•è´¦å·</div>`;
        return;
    }

    // ğŸ¯ ä¿®æ”¹ï¼šè·å–å½“å‰è´¦å·çš„åŠ¨æ€ + æ‰€æœ‰å¥½å‹çš„åŠ¨æ€
    const allChars = await db.characters.toArray();
    const friendIds = allChars
        .filter(char => {
            const status = getFriendStatus(char, currentAccountId);
            return status === 'friend'; // åªæ˜¾ç¤ºå¥½å‹çš„æœ‹å‹åœˆ
        })
        .map(char => char.id);
    
    // åŒ…æ‹¬è‡ªå·±å’Œæ‰€æœ‰å¥½å‹ï¼ˆç»Ÿä¸€è½¬ä¸ºæ•°å­—è¿›è¡Œæ¯”è¾ƒï¼‰
    const visibleUserIds = [currentAccountId, ...friendIds].map(id => parseInt(id));
    
    // è·å–æ‰€æœ‰æœ‹å‹åœˆï¼Œç„¶åè¿‡æ»¤
    let allMoments = await db.moments.toArray();
    let moments = allMoments.filter(m => visibleUserIds.includes(parseInt(m.userId)));
    
    // âœ… æŒ‰ç½®é¡¶å’Œæ—¶é—´æ’åºï¼šç½®é¡¶çš„åœ¨å‰ï¼Œç„¶åæŒ‰æ—¶é—´å€’åºï¼ˆæœ€æ–°çš„åœ¨ä¸Šé¢ï¼‰
    moments.sort((a, b) => {
        // å¦‚æœæ˜¯è‡ªå·±å‘çš„ä¸”ç½®é¡¶äº†ï¼Œæ’åœ¨æœ€å‰é¢
        const aIsPinned = (parseInt(a.userId) === currentAccountId && a.pinned);
        const bIsPinned = (parseInt(b.userId) === currentAccountId && b.pinned);
        
        if (aIsPinned && !bIsPinned) return -1;
        if (bIsPinned && !aIsPinned) return 1;
        
        // éƒ½æ˜¯ç½®é¡¶æˆ–éƒ½ä¸æ˜¯ç½®é¡¶ï¼ŒæŒ‰æ—¶é—´å€’åºï¼ˆæ–°çš„åœ¨å‰ï¼‰
        return (b.time || 0) - (a.time || 0);
    });
    
    if (moments.length === 0) {
        container.innerHTML = `<div style="text-align:center; color:#ccc; margin-top:100px; font-size:14px;">æš‚æ— åŠ¨æ€</div>`;
        return;
    }
    
    // è·å–æ‰€æœ‰è§’è‰²ä¿¡æ¯ç¼“å­˜ï¼Œé¿å…å¾ªç¯æŸ¥è¯¢
    const chars = await db.characters.toArray();
    const charMap = {};
    chars.forEach(c => charMap[c.id] = c);
    
    for (const m of moments) {
        const char = charMap[m.userId]; // userId å¯èƒ½æ˜¯ number æˆ– string
        if (!char) continue;
        
        const div = document.createElement('div');
        div.className = 'moment-item';
        
        // å›¾ç‰‡å±•ç¤º HTML - ä½¿ç”¨æ–‡å­—å›¾ç‰‡å¡ç‰‡å½¢å¼
        let imagesHtml = '';
        // ä¼˜å…ˆä½¿ç”¨æ–°çš„å¡ç‰‡å½¢å¼ï¼ˆimageCount + imageDescï¼‰
        if (m.imageCount && m.imageCount > 0) {
            const desc = m.imageDesc || '';
            const count = Math.min(m.imageCount, 9); // æœ€å¤š9å¼ 
            const gridClass = `grid-${count}`;
            let squares = '';
            for (let imgIdx = 0; imgIdx < count; imgIdx++) {
                squares += `<div class="moment-img-placeholder" onclick="event.stopPropagation(); showMomentImageDesc('${escapeHtml(desc).replace(/'/g, "\\'")}')">
                    <div class="moment-img-placeholder-inner">
                        <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
                        ${count === 1 ? '<div class="moment-img-placeholder-hint">ç‚¹å‡»æŸ¥çœ‹æ–‡å­—</div>' : ''}
                    </div>
                </div>`;
            }
            imagesHtml = `<div class="moment-image-grid ${gridClass}">${squares}</div>`;
        }
        // å…¼å®¹æ—§æ•°æ®ï¼šå¦‚æœæœ‰çœŸå®å›¾ç‰‡URL
        else if (m.images && m.images.length > 0) {
            let gridClass = 'cols-3';
            if (m.images.length === 1) gridClass = 'cols-1';
            else if (m.images.length === 2 || m.images.length === 4) gridClass = 'cols-2';
            
            imagesHtml = `<div class="moment-grid ${gridClass}">
                ${m.images.map(img => `<div class="moment-img" style="background-image:url(${img})" onclick="previewImage('${img}')"></div>`).join('')}
            </div>`;
        }
        
        // æ—¶é—´æ ¼å¼åŒ–
        const date = new Date(m.time);
        const timeStr = `${date.getMonth()+1}æœˆ${date.getDate()}æ—¥ ${date.getHours()}:${date.getMinutes().toString().padStart(2,'0')}`;
        
        // åˆ é™¤æŒ‰é’® (å¦‚æœæ˜¯è‡ªå·±å‘çš„)
        const isSelf = (currentMyCharId && parseInt(currentMyCharId) == m.userId);
        const delBtn = isSelf ? `<span class="moment-delete" onclick="deleteMoment(${m.id})">åˆ é™¤</span>` : '';
        
        // ç½®é¡¶æ ‡è¯†ï¼ˆåªæœ‰è‡ªå·±å‘çš„ä¸”ç½®é¡¶äº†æ‰æ˜¾ç¤ºï¼‰
        const pinnedBadge = (isSelf && m.pinned) ? `<span style="display:inline-block; background:#ffc107; color:#fff; font-size:10px; padding:2px 6px; border-radius:3px; margin-left:6px;">ç½®é¡¶</span>` : '';

        // å¤„ç†ç‚¹èµæ˜¾ç¤º
        let likesHtml = '';
        // æ£€æŸ¥æˆ‘æ˜¯å¦ç‚¹èµ
        // likes: [{userId, name}]
        const myLikeIndex = (m.likes || []).findIndex(l => l.userId == currentMyCharId);
        const isLiked = myLikeIndex !== -1;
        
        if (m.likes && m.likes.length > 0) {
            const names = m.likes.map(l => l.name);
            likesHtml = names.join('ï¼Œ');
        }

        // å¤„ç†è¯„è®ºæ˜¾ç¤ºï¼ˆæ”¯æŒå›å¤æ ¼å¼å’Œç‚¹å‡»å›å¤ï¼‰
        let commentsHtml = '';
        if (m.comments && m.comments.length > 0) {
            commentsHtml = m.comments.map((c, idx) => {
                const replyPart = c.replyTo ? ` å›å¤ <span class="comment-user">${escapeHtml(c.replyTo)}</span>` : '';
                const isMyComment = c.userId == currentMyCharId;
                // éè‡ªå·±çš„è¯„è®ºå¯ä»¥ç‚¹å‡»å›å¤
                const clickHandler = !isMyComment ? `onclick="replyToMomentComment(${m.id}, '${escapeHtml(c.name).replace(/'/g, "\\'")}', ${idx})"` : '';
                const cursorStyle = 'cursor:pointer;user-select:none;';
                return `<div class="comment-item" ${clickHandler} style="${cursorStyle}" oncontextmenu="event.preventDefault();showCommentContextMenu(event,${m.id},${idx})" ontouchstart="startCommentLongPress(event,${m.id},${idx})" ontouchend="cancelCommentLongPress()" ontouchmove="cancelCommentLongPress()">
                    <span class="comment-user">${escapeHtml(c.name)}</span>${replyPart}ï¼š<span class="comment-content">${escapeHtml(c.content)}</span>
                </div>`;
            }).join('');
        }

        const hasLikes = m.likes && m.likes.length > 0;
        const hasComments = m.comments && m.comments.length > 0;
        
        div.innerHTML = `
            <div class="moment-avatar" style="background-image:url(${getCharAvatar(char, getCurrentAccountId())})"></div>
            <div class="moment-content">
                <div class="moment-name">${char.name}${pinnedBadge}</div>
                <div class="moment-text">${escapeHtml(m.content || '')}</div>
                ${imagesHtml}
                <div class="moment-meta">
                    <div style="display:flex; align-items:center;">
                        <span class="moment-time">${timeStr}</span>
                        ${delBtn}
                    </div>
                    <div class="moment-action-area">
                        <!-- å¼¹å‡ºèœå• -->
                        <div class="moment-popup-menu ins-style" id="moment-menu-${m.id}">
                            <div class="moment-menu-item" onclick="likeMoment(${m.id})">
                                <svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>
                                <span>${isLiked ? 'å–æ¶ˆ' : 'èµ'}</span>
                            </div>
                            <div class="moment-menu-divider"></div>
                            <div class="moment-menu-item" onclick="commentMoment(${m.id})">
                                <svg viewBox="0 0 24 24"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></svg>
                                <span>è¯„è®º</span>
                            </div>
                            <div class="moment-menu-divider"></div>
                            <div class="moment-menu-item" onclick="deleteMoment(${m.id})" style="color:#ff3b30;">
                                <svg viewBox="0 0 24 24" style="fill:#ff3b30;"><path d="M3 6h18M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2m3 0v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6h14" fill="none" stroke="#ff3b30" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>
                                <span>åˆ é™¤</span>
                            </div>
                        </div>
                        <div class="moment-action-btn" onclick="toggleMomentMenu(${m.id}, event)">
                            <div class="moment-action-dot"></div>
                            <div class="moment-action-dot"></div>
                        </div>
                    </div>
                </div>
                <!-- äº’åŠ¨åŒº -->
                <div class="moment-interactions" style="display: ${hasLikes || hasComments ? 'block' : 'none'}">
                    <div class="moment-likes" style="display: ${hasLikes ? 'flex' : 'none'}">
                        <svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>
                        <span>${likesHtml}</span>
                    </div>
                    <div class="moment-comments" style="display: ${hasComments ? 'block' : 'none'}">
                        ${commentsHtml}
                    </div>
                </div>
            </div>
        `;
        container.appendChild(div);
    }
}

// å°é¢æ›´æ¢
function changeMomentsCover() {
    document.getElementById('moments-cover-input').click();
}

function handleCoverChange(input) {
    const file = input.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = async (e) => {
        const base64 = e.target.result;
        document.getElementById('moments-cover-area').style.backgroundImage = `url(${base64})`;
        
        // ä¿å­˜åˆ°å½“å‰ User
        if (currentMyCharId) {
            const user = await db.characters.get(parseInt(currentMyCharId));
            if (user) {
                if (!user.identity) user.identity = {};
                user.identity.cover = base64;
                await safeCharacterPut(user);
            }
        }
        // åŒæ—¶ä¹Ÿå­˜ä¸€ä»½æœ¬åœ°ç¼“å­˜ï¼Œä½œä¸ºå…œåº•
        localStorage.setItem('moments_cover', base64);
    };
    reader.readAsDataURL(file);
    input.value = '';
}

// å‘å¸ƒåŠ¨æ€é€»è¾‘
let currentMomentPrivacy = 'public'; // é»˜è®¤å…¬å¼€

function showMomentsPublish() {
    document.getElementById('moments-publish-page').style.display = 'block';
    // æ¸…ç©º
    document.getElementById('moments-pub-text').value = '';
    const grid = document.getElementById('moments-pub-grid');
    // ä¿ç•™æ·»åŠ æŒ‰é’®ï¼Œç§»é™¤å›¾ç‰‡
    Array.from(grid.children).forEach(child => {
        if (!child.classList.contains('moments-add-btn')) {
            child.remove();
        }
    });
    window.tempPubImages = [];
    // é‡ç½®æƒé™ä¸ºå…¬å¼€
    currentMomentPrivacy = 'public';
    selectedPrivacyFriends = [];
    document.getElementById('privacy-selected-text').textContent = 'å…¬å¼€';
}

function hideMomentsPublish() {
    const pubPage = document.getElementById('moments-publish-page');
    pubPage.style.display = 'none';
    // å¦‚æœæ˜¯FPæ¨¡å¼ï¼Œæ¢å¤z-index
    if (window._fpMomentMode) {
        pubPage.style.zIndex = '';
        window._fpMomentMode = false;
    }
}

// æƒé™é€‰æ‹©ç›¸å…³
function showPrivacySelector() {
    document.getElementById('privacy-selector-page').style.display = 'block';
    // æ›´æ–°é€‰ä¸­çŠ¶æ€
    updatePrivacyCheckmarks();
}

function hidePrivacySelector() {
    document.getElementById('privacy-selector-page').style.display = 'none';
}

function selectPrivacy(value, text) {
    currentMomentPrivacy = value;
    document.getElementById('privacy-selected-text').textContent = text;
    updatePrivacyCheckmarks();
    hidePrivacySelector();
}

function updatePrivacyCheckmarks() {
    const options = ['public', 'private'];
    options.forEach(opt => {
        const checkEl = document.getElementById(`privacy-check-${opt}`);
        if (checkEl) {
            checkEl.textContent = (opt === currentMomentPrivacy) ? 'âœ“' : '';
        }
    });
    // æ›´æ–°éƒ¨åˆ†å¯è§å’Œä¸ç»™è°çœ‹çš„æè¿°
    const partialDesc = document.getElementById('partial-desc');
    const excludeDesc = document.getElementById('exclude-desc');
    if (partialDesc) {
        if (currentMomentPrivacy === 'partial' && selectedPrivacyFriends.length > 0) {
            partialDesc.textContent = `å·²é€‰ ${selectedPrivacyFriends.length} äºº`;
        } else {
            partialDesc.textContent = 'é€‰ä¸­çš„æœ‹å‹å¯è§';
        }
    }
    if (excludeDesc) {
        if (currentMomentPrivacy === 'exclude' && selectedPrivacyFriends.length > 0) {
            excludeDesc.textContent = `å·²é€‰ ${selectedPrivacyFriends.length} äºº`;
        } else {
            excludeDesc.textContent = 'é€‰ä¸­çš„æœ‹å‹ä¸å¯è§';
        }
    }
}

// å¥½å‹é€‰æ‹©ç›¸å…³
let selectedPrivacyFriends = []; // é€‰ä¸­çš„å¥½å‹IDåˆ—è¡¨
let currentPrivacyMode = ''; // 'partial' æˆ– 'exclude'

async function showFriendSelector(mode) {
    currentPrivacyMode = mode;
    const page = document.getElementById('friend-selector-page');
    const list = document.getElementById('friend-selector-list');
    const title = document.getElementById('friend-selector-title');
    
    title.textContent = mode === 'partial' ? 'è°å¯ä»¥çœ‹' : 'ä¸ç»™è°çœ‹';
    
    // å¦‚æœåˆ‡æ¢äº†æ¨¡å¼ï¼Œæ¸…ç©ºå·²é€‰æ‹©çš„
    if (currentMomentPrivacy !== mode) {
        selectedPrivacyFriends = [];
    }
    
    // è·å–å¥½å‹åˆ—è¡¨
    const accountId = getCurrentAccountId();
    const allChars = await db.characters.toArray();
    const friends = allChars.filter(char => {
        if (char.id == accountId) return false; // æ’é™¤è‡ªå·±
        const status = getFriendStatus(char, accountId);
        return status === 'friend';
    });
    
    list.innerHTML = '';
    
    if (friends.length === 0) {
        list.innerHTML = '<div style="padding:40px; text-align:center; color:#999;">æš‚æ— å¥½å‹</div>';
    } else {
        for (const friend of friends) {
            const isChecked = selectedPrivacyFriends.includes(friend.id);
            const item = document.createElement('div');
            item.className = 'friend-select-item';
            item.onclick = () => toggleFriendSelection(friend.id);
            item.innerHTML = `
                <div class="friend-select-checkbox ${isChecked ? 'checked' : ''}" id="friend-check-${friend.id}">
                    ${isChecked ? 'âœ“' : ''}
                </div>
                <div class="friend-select-avatar" style="background-image:url(${friend.avatar || ''})"></div>
                <div class="friend-select-name">${friend.remark || friend.wx_nickname || friend.name}</div>
            `;
            list.appendChild(item);
        }
    }
    
    page.style.display = 'block';
}

function hideFriendSelector() {
    document.getElementById('friend-selector-page').style.display = 'none';
}

function toggleFriendSelection(friendId) {
    const idx = selectedPrivacyFriends.indexOf(friendId);
    if (idx > -1) {
        selectedPrivacyFriends.splice(idx, 1);
    } else {
        selectedPrivacyFriends.push(friendId);
    }
    
    // æ›´æ–°UI
    const checkEl = document.getElementById(`friend-check-${friendId}`);
    if (checkEl) {
        const isChecked = selectedPrivacyFriends.includes(friendId);
        checkEl.className = `friend-select-checkbox ${isChecked ? 'checked' : ''}`;
        checkEl.textContent = isChecked ? 'âœ“' : '';
    }
}

function confirmFriendSelection() {
    if (selectedPrivacyFriends.length === 0) {
        alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ä½å¥½å‹');
        return;
    }
    
    currentMomentPrivacy = currentPrivacyMode;
    const text = currentPrivacyMode === 'partial' ? `éƒ¨åˆ†å¯è§(${selectedPrivacyFriends.length}äºº)` : `ä¸ç»™è°çœ‹(${selectedPrivacyFriends.length}äºº)`;
    document.getElementById('privacy-selected-text').textContent = text;
    
    hideFriendSelector();
    hidePrivacySelector();
    updatePrivacyCheckmarks();
}

function handlePubImages(input) {
    const files = input.files;
    if (!files || files.length === 0) return;
    
    if (!window.tempPubImages) window.tempPubImages = [];
    
    const grid = document.getElementById('moments-pub-grid');
    const addBtn = grid.querySelector('.moments-add-btn');
    
    Array.from(files).forEach(file => {
        const reader = new FileReader();
        reader.onload = e => {
            const base64 = e.target.result;
            window.tempPubImages.push(base64);
            
            const div = document.createElement('div');
            div.className = 'moments-pub-img';
            div.style.backgroundImage = `url(${base64})`;
            div.innerHTML = `<div class="moments-pub-img-del" onclick="removePubImage(this, '${base64}')">Ã—</div>`;
            
            grid.insertBefore(div, addBtn);
        };
        reader.readAsDataURL(file);
    });
    
    input.value = '';
}

function removePubImage(el, base64) {
    el.parentElement.remove();
    const idx = window.tempPubImages.indexOf(base64);
    if (idx > -1) window.tempPubImages.splice(idx, 1);
}

async function doPublishMoment() {
    // â˜… åˆ¤æ–­æ˜¯å¦æ˜¯æŸ¥æ‰‹æœºFPæ¨¡å¼ï¼ˆä»¥è§’è‰²èº«ä»½å‘æœ‹å‹åœˆï¼‰
    if (window._fpMomentMode) {
        await doPublishFpMoment();
        return;
    }

    if (!currentMyCharId) {
        alert("è¯·å…ˆè®¾ç½® User èº«ä»½");
        return;
    }
    
    const text = document.getElementById('moments-pub-text').value.trim();
    const images = window.tempPubImages || [];
    
    if (!text && images.length === 0) {
        alert("å†™ç‚¹ä»€ä¹ˆå§...");
        return;
    }
    
    const momentId = await db.moments.add({
        userId: parseInt(currentMyCharId),
        content: text,
        images: images,
        time: Date.now(),
        ownerUserId: parseInt(currentMyCharId), // æ ‡è®°æ‰€å±è´¦å·
        privacy: currentMomentPrivacy, // ä¿å­˜æƒé™è®¾ç½®
        privacyList: selectedPrivacyFriends.slice(), // ä¿å­˜é€‰ä¸­çš„å¥½å‹åˆ—è¡¨
        likes: [],
        comments: []
    });
    
    hideMomentsPublish();
    renderMomentsList();
    renderMyMomentsList();
    
    // æ»šåŠ¨åˆ°é¡¶éƒ¨
    document.getElementById('moments-page').scrollTop = 0;
    
    // âœ… è§¦å‘å¥½å‹è‡ªåŠ¨ç‚¹èµè¯„è®ºï¼ˆå»¶è¿Ÿæ‰§è¡Œï¼Œæ¨¡æ‹ŸçœŸå®åœºæ™¯ï¼‰
    setTimeout(() => {
        generateFriendInteractions(momentId, currentMomentPrivacy, selectedPrivacyFriends.slice());
    }, 2000);
}

// â˜… æŸ¥æ‰‹æœºFPæ¨¡å¼ - ä»¥è§’è‰²èº«ä»½å‘æœ‹å‹åœˆï¼ˆå¤ç”¨åŸç‰ˆå‘å¸ƒé¡µé¢ï¼‰
async function doPublishFpMoment() {
    const text = document.getElementById('moments-pub-text').value.trim();
    const images = window.tempPubImages || [];

    if (!text && images.length === 0) {
        alert("å†™ç‚¹ä»€ä¹ˆå§...");
        return;
    }

    const roleId = window._fpWechatRoleId;
    const accountId = findPhoneTargetAccountId;
    if (!roleId || !accountId) {
        showToast('å‘å¸ƒå¤±è´¥ï¼šç¼ºå°‘ä¿¡æ¯');
        return;
    }

    const roleChar = await db.characters.get(parseInt(roleId));
    if (!roleChar) {
        showToast('å‘å¸ƒå¤±è´¥ï¼šè§’è‰²ä¸å­˜åœ¨');
        return;
    }

    // æ„å»ºæœ‹å‹åœˆæ•°æ®ï¼ˆå’ŒåŸç‰ˆæ ¼å¼ä¸€è‡´ï¼Œå«å›¾ç‰‡ï¼‰
    const newMoment = {
        id: Date.now(),
        userId: parseInt(roleId),
        content: text,
        images: images,
        time: Date.now(),
        likes: [],
        comments: [],
        fpSent: true // å†…éƒ¨æ ‡è®°ï¼šè¿™æ˜¯ç”¨æˆ·é€šè¿‡æŸ¥æ‰‹æœºå‘çš„
    };

    // ä¿å­˜åˆ°è§’è‰²çš„æœ‹å‹åœˆæ•°æ®
    if (!roleChar.fp_moments_by_user) roleChar.fp_moments_by_user = {};
    if (!roleChar.fp_moments_by_user[accountId]) roleChar.fp_moments_by_user[accountId] = [];
    roleChar.fp_moments_by_user[accountId].push(newMoment);
    await safeCharacterPut(roleChar);

    console.log('[FPæœ‹å‹åœˆ] âœ… ä»¥è§’è‰²èº«ä»½å‘å¸ƒæœ‹å‹åœˆ:', text);

    // å…³é—­ç¼–è¾‘é¡µï¼Œåˆ·æ–°æœ‹å‹åœˆåˆ—è¡¨
    hideMomentsPublish();
    renderFpMomentsList();

    showToast('å‘å¸ƒæˆåŠŸ');

    // â˜… è‡ªåŠ¨è°ƒç”¨AIè®©NPCå¥½å‹æ¥è¯„è®ºå’Œç‚¹èµ
    setTimeout(() => {
        triggerFpMomentNpcInteractions(roleChar.id, accountId, newMoment.id);
    }, 1500);
}

// âœ… ç”Ÿæˆå¥½å‹è‡ªåŠ¨ç‚¹èµè¯„è®ºï¼ˆè°ƒç”¨AIï¼‰
async function generateFriendInteractions(momentId, privacy, privacyList) {
    try {
        const moment = await db.moments.get(momentId);
        if (!moment) return;
        
        const accountId = getCurrentAccountId();
        const myChar = await db.characters.get(parseInt(currentMyCharId));
        const myName = myChar?.name || 'æˆ‘';
        
        // è·å–æ‰€æœ‰å¥½å‹ï¼ˆæ’é™¤è”æœºå¥½å‹ï¼‰
        const allChars = await db.characters.toArray();
        let friends = allChars.filter(c => {
            if (c.type === 'user') return false;
            if (c.isOnlineFriend === true) return false; // æ’é™¤è”æœºå¥½å‹
            const status = getFriendStatus(c, accountId);
            return status === 'friend';
        });
        
        // âœ… æ ¹æ®æƒé™è¿‡æ»¤å¥½å‹
        if (privacy === 'partial' && privacyList.length > 0) {
            // éƒ¨åˆ†å¯è§ï¼šåªæœ‰ privacyList ä¸­çš„å¥½å‹å¯ä»¥çœ‹åˆ°
            friends = friends.filter(f => privacyList.includes(f.id));
        } else if (privacy === 'exclude' && privacyList.length > 0) {
            // ä¸ç»™è°çœ‹ï¼šæ’é™¤ privacyList ä¸­çš„å¥½å‹
            friends = friends.filter(f => !privacyList.includes(f.id));
        } else if (privacy === 'private') {
            // ç§å¯†ï¼šæ²¡æœ‰å¥½å‹å¯ä»¥çœ‹åˆ°
            friends = [];
        }
        
        if (friends.length === 0) {
            console.log('[æœ‹å‹åœˆäº’åŠ¨] æ²¡æœ‰å¯è§çš„å¥½å‹ï¼Œè·³è¿‡ç”Ÿæˆäº’åŠ¨');
            return;
        }
        
        console.log(`[æœ‹å‹åœˆäº’åŠ¨] å¼€å§‹ç”Ÿæˆï¼Œå¯è§å¥½å‹: ${friends.length}äºº`);
        
        // éšæœºé€‰æ‹©å¥½å‹æ¥ç‚¹èµï¼ˆ50%-90%çš„å¯è§å¥½å‹ï¼‰
        const likeRatio = 0.5 + Math.random() * 0.4;
        const shuffledForLikes = [...friends].sort(() => Math.random() - 0.5);
        const likersCount = Math.max(1, Math.floor(shuffledForLikes.length * likeRatio));
        const likers = shuffledForLikes.slice(0, likersCount);
        
        // æ‰€æœ‰å¯è§å¥½å‹éƒ½æ¥è¯„è®ºï¼ˆæ‰“ä¹±é¡ºåºè®©è¯„è®ºæ›´è‡ªç„¶ï¼‰
        const commenters = [...friends].sort(() => Math.random() - 0.5);
        
        // ç”Ÿæˆç‚¹èµï¼ˆä½¿ç”¨å¾®ä¿¡æ˜¾ç¤ºåï¼‰
        const _likeAid = getCurrentAccountId();
        const likes = likers.map(f => ({
            userId: f.id,
            name: getCharDisplayName(f, _likeAid)
        }));
        
        // âœ… è°ƒç”¨AIç”Ÿæˆè¯„è®º
        const comments = [];
        
        if (commenters.length > 0) {
            try {
                // åˆ†æ‰¹å¤„ç†ï¼ˆæ¯æ‰¹æœ€å¤š15äººï¼Œé¿å…AI tokenæº¢å‡ºï¼‰
                const BATCH_SIZE = 15;
                const batches = [];
                for (let i = 0; i < commenters.length; i += BATCH_SIZE) {
                    batches.push(commenters.slice(i, i + BATCH_SIZE));
                }
                
                for (const batch of batches) {
                    try {
                        // æ„å»ºè§’è‰²ä¿¡æ¯ï¼ˆä½¿ç”¨å¾®ä¿¡æ˜¾ç¤ºåï¼‰
                        const _cmtAid = getCurrentAccountId();
                        const commenterInfos = batch.map(c => {
                            const displayName = getCharDisplayName(c, _cmtAid);
                            return `- ${displayName}ï¼š${c.description || c.personality || 'æ™®é€šæœ‹å‹'}`;
                        }).join('\n');
                        
                        const batchPrompt = `${myName} å‘äº†ä¸€æ¡æœ‹å‹åœˆï¼š
"${moment.content}"
${moment.images?.length > 0 || moment.imageCount > 0 ? `ï¼ˆé™„å¸¦${moment.imageCount || moment.images.length}å¼ å›¾ç‰‡${moment.imageDesc ? 'ï¼š' + moment.imageDesc : ''}ï¼‰` : ''}

ä»¥ä¸‹å¥½å‹çœ‹åˆ°äº†è¿™æ¡æœ‹å‹åœˆï¼Œè¯·ä¸ºæ¯ä¸ªäººç”Ÿæˆä¸€æ¡ç¬¦åˆå…¶æ€§æ ¼çš„è¯„è®ºï¼š
${commenterInfos}

è¦æ±‚ï¼š
1. æ¯æ¡è¯„è®ºç®€çŸ­è‡ªç„¶ï¼ˆ3-20å­—ï¼‰
2. å¯ä»¥ç”¨è¡¨æƒ…ã€è¯­æ°”è¯
3. ç¬¦åˆæ¯ä¸ªè§’è‰²çš„æ€§æ ¼ç‰¹ç‚¹
4. é¼“åŠ±å¥½å‹ä¹‹é—´äº’ç›¸å›å¤ï¼ˆä½¿ç”¨ replyTo å­—æ®µæŒ‡å®šå›å¤çš„äººåï¼‰
5. ä¸æ˜¯æ‰€æœ‰äººéƒ½è¦äº’ç›¸å›å¤ï¼Œä½†è‡³å°‘æœ‰ä¸€äº›å¥½å‹ä¹‹é—´ä¼šæœ‰å¯¹è¯

è¯·è¿”å›JSONæ•°ç»„æ ¼å¼ï¼š
[{"name": "è§’è‰²å", "content": "è¯„è®ºå†…å®¹"}, {"name": "è§’è‰²å", "replyTo": "è¢«å›å¤çš„è§’è‰²å", "content": "å›å¤å†…å®¹"}, ...]`;

                        const result = await callAI([
                            { role: 'system', content: 'ä½ æ˜¯ä¸€ä¸ªç¤¾äº¤åª’ä½“è¯„è®ºç”ŸæˆåŠ©æ‰‹ï¼Œåªè¿”å›JSONæ•°ç»„ï¼Œä¸è¦ä»»ä½•å…¶ä»–æ–‡å­—ã€‚' },
                            { role: 'user', content: batchPrompt }
                        ], { _useSecondary: true });
                        
                        // è§£æç»“æœ
                        let aiComments = [];
                        try {
                            let cleanResult = result.trim();
                            if (cleanResult.startsWith('```')) {
                                cleanResult = cleanResult.replace(/```json?\n?/g, '').replace(/```$/g, '').trim();
                            }
                            aiComments = JSON.parse(cleanResult);
                        } catch (e) {
                            console.warn('[æœ‹å‹åœˆäº’åŠ¨] AIè¯„è®ºè§£æå¤±è´¥ï¼ˆæ‰¹æ¬¡ï¼‰ï¼Œä½¿ç”¨é¢„è®¾è¯„è®º');
                        }
                        
                        // å°†AIç”Ÿæˆçš„è¯„è®ºæ·»åŠ åˆ°åˆ—è¡¨ï¼ˆåŒ¹é…æ˜¾ç¤ºåï¼‰
                        const _matchAid = getCurrentAccountId();
                        for (const aiComment of aiComments) {
                            const commenter = batch.find(c => {
                                const displayName = getCharDisplayName(c, _matchAid);
                                return displayName === aiComment.name || c.name === aiComment.name;
                            });
                            if (commenter && aiComment.content) {
                                const commentObj = {
                                    userId: commenter.id,
                                    name: commenter.remark || commenter.wx_nickname || commenter.name,
                                    content: aiComment.content,
                                    time: Date.now() + Math.random() * 60000
                                };
                                // æ”¯æŒå¥½å‹ä¹‹é—´äº’ç›¸å›å¤
                                if (aiComment.replyTo) {
                                    commentObj.replyTo = aiComment.replyTo;
                                }
                                comments.push(commentObj);
                            }
                        }
                    } catch (batchError) {
                        console.warn('[æœ‹å‹åœˆäº’åŠ¨] æ‰¹æ¬¡AIè°ƒç”¨å¤±è´¥:', batchError);
                    }
                }
                
            } catch (apiError) {
                console.warn('[æœ‹å‹åœˆäº’åŠ¨] AIè°ƒç”¨å¤±è´¥ï¼Œä½¿ç”¨é¢„è®¾è¯„è®º:', apiError);
            }
        }
        
        // å¦‚æœAIç”Ÿæˆå¤±è´¥ï¼Œä½¿ç”¨é¢„è®¾è¯„è®º
        if (comments.length === 0 && commenters.length > 0) {
            const presetComments = [
                'ğŸ‘', 'â¤ï¸', 'å¤ªæ£’äº†ï¼', 'çœŸå¥½çœ‹~', 'å“‡ï¼', 'èµï¼',
                'ç¾¡æ…•ï¼', 'å‰å®³å•Š', 'å¤ªç¾äº†', 'ğŸ”¥', 'ç»äº†', 'çˆ±äº†'
            ];
            for (const commenter of commenters) {
                comments.push({
                    userId: commenter.id,
                    name: commenter.remark || commenter.wx_nickname || commenter.name,
                    content: presetComments[Math.floor(Math.random() * presetComments.length)],
                    time: Date.now() + Math.random() * 60000
                });
            }
        }
        
        // æ ¡éªŒ replyToï¼šç¡®ä¿è¢«å›å¤çš„äººç¡®å®æœ‰è¯„è®ºï¼Œå¦åˆ™å»æ‰ replyTo
        const allCommentNames = new Set(comments.map(c => c.name));
        for (const c of comments) {
            if (c.replyTo && !allCommentNames.has(c.replyTo)) {
                console.log(`[æœ‹å‹åœˆäº’åŠ¨] âš ï¸ replyTo "${c.replyTo}" ä¸å­˜åœ¨ï¼Œå·²ç§»é™¤å›å¤æ ‡è®°`);
                delete c.replyTo;
            }
        }
        
        // æ›´æ–°æœ‹å‹åœˆ
        moment.likes = likes;
        moment.comments = comments;
        await db.moments.put(moment);
        
        console.log(`[æœ‹å‹åœˆäº’åŠ¨] ç”Ÿæˆå®Œæˆ: ${likes.length}ä¸ªç‚¹èµ, ${comments.length}æ¡è¯„è®º`);
        
        // åˆ·æ–°æ˜¾ç¤º
        renderMomentsList();
        
        // ğŸ¯ æœ‹å‹åœˆç§ä¿¡åŠŸèƒ½ï¼šéƒ¨åˆ†å¥½å‹å¯èƒ½ä¼šå› ä¸ºæœ‹å‹åœˆå†…å®¹ç§èŠç”¨æˆ·
        try {
            if (friends.length > 0) {
                // éšæœºé€‰æ‹©10%-30%çš„å¥½å‹æ¥ç§ä¿¡ï¼ˆè‡³å°‘0ä¸ªï¼Œæœ€å¤š3ä¸ªï¼‰
                const dmRatio = 0.1 + Math.random() * 0.2;
                const dmCount = Math.min(3, Math.max(0, Math.floor(friends.length * dmRatio)));
                
                if (dmCount > 0) {
                    // æ‰“ä¹±é¡ºåºåå–å‰dmCountä¸ª
                    const shuffledForDM = [...friends].sort(() => Math.random() - 0.5);
                    const dmFriends = shuffledForDM.slice(0, dmCount);
                    
                    console.log(`[æœ‹å‹åœˆç§ä¿¡] é€‰ä¸­ ${dmFriends.length} ä¸ªå¥½å‹æ¥ç§ä¿¡`);
                    
                    // æ„å»ºè§’è‰²ä¿¡æ¯
                    const _dmAid = getCurrentAccountId();
                    const dmInfos = dmFriends.map(c => {
                        const displayName = getCharDisplayName(c, _dmAid);
                        return `- ${displayName}ï¼š${c.description || c.personality || 'æ™®é€šæœ‹å‹'}`;
                    }).join('\n');
                    
                    const dmPrompt = `${myName} å‘äº†ä¸€æ¡æœ‹å‹åœˆï¼š
"${moment.content}"
${moment.images?.length > 0 || moment.imageCount > 0 ? `ï¼ˆé™„å¸¦${moment.imageCount || moment.images.length}å¼ å›¾ç‰‡${moment.imageDesc ? 'ï¼š' + moment.imageDesc : ''}ï¼‰` : ''}

ä»¥ä¸‹å¥½å‹çœ‹åˆ°äº†è¿™æ¡æœ‹å‹åœˆåï¼Œå†³å®šç§èŠ ${myName}ï¼Œè¯·ä¸ºæ¯ä¸ªäººç”Ÿæˆä¸€æ¡ç§ä¿¡å†…å®¹ï¼š
${dmInfos}

è¦æ±‚ï¼š
1. ç§ä¿¡å†…å®¹è¦è·Ÿæœ‹å‹åœˆå†…å®¹ç›¸å…³
2. æ¯æ¡ç§ä¿¡ç®€çŸ­è‡ªç„¶ï¼ˆ5-30å­—ï¼‰ï¼Œåƒå¾®ä¿¡ç§èŠä¸€æ ·éšæ„
3. å¯ä»¥ç”¨è¡¨æƒ…ã€è¯­æ°”è¯
4. ç¬¦åˆæ¯ä¸ªè§’è‰²çš„æ€§æ ¼ç‰¹ç‚¹å’Œä¸ ${myName} çš„å…³ç³»
5. ä¸è¦è·Ÿæœ‹å‹åœˆè¯„è®ºé‡å¤ï¼Œç§ä¿¡æ›´ç§å¯†ã€æ›´éšæ„
6. å¯ä»¥æ˜¯å…³å¿ƒã€è°ƒä¾ƒã€å¥½å¥‡ã€ç¾¡æ…•ç­‰å„ç§ååº”

è¯·è¿”å›JSONæ•°ç»„æ ¼å¼ï¼š
[{"name": "è§’è‰²å", "content": "ç§ä¿¡å†…å®¹"}, ...]`;

                    const dmResult = await callAI([
                        { role: 'system', content: 'ä½ æ˜¯ä¸€ä¸ªç¤¾äº¤åª’ä½“ç§ä¿¡ç”ŸæˆåŠ©æ‰‹ï¼Œåªè¿”å›JSONæ•°ç»„ï¼Œä¸è¦ä»»ä½•å…¶ä»–æ–‡å­—ã€‚' },
                        { role: 'user', content: dmPrompt }
                    ], { _useSecondary: true });
                    
                    // è§£æAIè¿”å›çš„ç§ä¿¡å†…å®¹
                    let aiDMs = [];
                    try {
                        let cleanDMResult = dmResult.trim();
                        if (cleanDMResult.startsWith('```')) {
                            cleanDMResult = cleanDMResult.replace(/```json?\n?/g, '').replace(/```$/g, '').trim();
                        }
                        aiDMs = JSON.parse(cleanDMResult);
                    } catch (e) {
                        console.warn('[æœ‹å‹åœˆç§ä¿¡] AIç§ä¿¡JSONè§£æå¤±è´¥:', e);
                    }
                    
                    // å°†ç§ä¿¡å†™å…¥èŠå¤©è®°å½•
                    const _dmMatchAid = getCurrentAccountId();
                    let dmSentCount = 0;
                    
                    for (const aiDM of aiDMs) {
                        const dmChar = dmFriends.find(c => {
                            const displayName = getCharDisplayName(c, _dmMatchAid);
                            return displayName === aiDM.name || c.name === aiDM.name;
                        });
                        
                        if (dmChar && aiDM.content) {
                            try {
                                // å»¶è¿Ÿå‘é€ï¼Œæ¨¡æ‹ŸçœŸå®æ„Ÿï¼ˆæ¯æ¡é—´éš”2-8ç§’ï¼‰
                                const delay = (2000 + Math.random() * 6000) * (dmSentCount + 1);
                                
                                setTimeout(async () => {
                                    try {
                                        const freshDMChar = await db.characters.get(dmChar.id);
                                        if (!freshDMChar) return;
                                        
                                        let history = getChatHistory(freshDMChar, _dmMatchAid);
                                        
                                        // æ„å»ºè§’è‰²æ¶ˆæ¯
                                        const dmMsg = buildCharMessage(aiDM.content, !!freshDMChar.foreign_lang_mode);
                                        dmMsg.momentDM = true; // æ ‡è®°ä¸ºæœ‹å‹åœˆè§¦å‘çš„ç§ä¿¡
                                        
                                        history.push(dmMsg);
                                        await setChatHistory(freshDMChar, _dmMatchAid, history);
                                        
                                        console.log(`[æœ‹å‹åœˆç§ä¿¡] ${freshDMChar.name} ç§ä¿¡äº† ${myName}: ${aiDM.content}`);
                                        
                                        // å¦‚æœç”¨æˆ·æ­£åœ¨æŸ¥çœ‹è¿™ä¸ªèŠå¤©ï¼Œæ›´æ–°UI
                                        if (currentChatCharId === freshDMChar.id) {
                                            await appendMessageToUI('char', aiDM.content, freshDMChar.avatar);
                                        }
                                        
                                        // å‘é€é€šçŸ¥
                                        sendSystemNotification(freshDMChar.name, aiDM.content);
                                        
                                        // åˆ·æ–°å¾®ä¿¡åˆ—è¡¨
                                        if (currentChatCharId !== freshDMChar.id) {
                                            const wechatPage = document.getElementById('wechat-page');
                                            if (wechatPage && wechatPage.style.display !== 'none') {
                                                const activeTab = document.querySelector('.wechat-tab-item.active .tab-name');
                                                if (activeTab && activeTab.innerText === 'å¾®ä¿¡') {
                                                    renderWechatList(document.getElementById('wechat-content'));
                                                }
                                            }
                                        }
                                    } catch (dmErr) {
                                        console.error('[æœ‹å‹åœˆç§ä¿¡] å‘é€ç§ä¿¡å¤±è´¥:', dmErr);
                                    }
                                }, delay);
                                
                                dmSentCount++;
                            } catch (dmErr) {
                                console.error('[æœ‹å‹åœˆç§ä¿¡] å¤„ç†ç§ä¿¡å¤±è´¥:', dmErr);
                            }
                        }
                    }
                    
                    console.log(`[æœ‹å‹åœˆç§ä¿¡] âœ… å·²å®‰æ’ ${dmSentCount} æ¡ç§ä¿¡å‘é€`);
                }
            }
        } catch (dmError) {
            console.error('[æœ‹å‹åœˆç§ä¿¡] ç§ä¿¡åŠŸèƒ½æ‰§è¡Œå¤±è´¥:', dmError);
        }
        
    } catch (error) {
        console.error('[æœ‹å‹åœˆäº’åŠ¨] ç”Ÿæˆå¤±è´¥:', error);
    }
}

async function deleteMoment(id) {
    if (confirm("ç¡®å®šåˆ é™¤è¿™æ¡åŠ¨æ€å—ï¼Ÿ")) {
        await db.moments.delete(id);
        renderMomentsList();
    }
}

// ğŸ¯ è§’è‰²å‘å¸ƒæœ‹å‹åœˆï¼ˆç”±AIè§¦å‘ï¼‰
async function publishMomentsByCharacter(char, content, imageCount = 0, imageDesc = '', options = {}) {
    // è·å–å½“å‰ç”¨æˆ·IDï¼ˆç”¨äºownerUserIdï¼Œç¡®ä¿æ•°æ®éš”ç¦»æ­£ç¡®ï¼‰
    const currentAccountId = getCurrentAccountId();
    
    const momentData = {
        userId: char.id, // å‘å¸ƒè€…æ˜¯è§’è‰²
        content: content,
        images: [], // ä¸å†ä½¿ç”¨éšæœºå›¾ç‰‡URL
        imageCount: imageCount, // ä¿ç•™å›¾ç‰‡æ•°é‡ä¿¡æ¯
        imageDesc: imageDesc || '', // å›¾ç‰‡æè¿°ï¼Œç”¨äºå¡ç‰‡å±•ç¤º
        time: Date.now(),
        ownerUserId: currentAccountId || char.id,
        likes: [],
        comments: options.preComments || [] // æ”¯æŒä¼ å…¥é¢„ç”Ÿæˆçš„è¯„è®º
    };
    
    // å¦‚æœæœ‰é¢„ç”Ÿæˆçš„ç‚¹èµ
    if (options.preLikes && options.preLikes.length > 0) {
        momentData.likes = options.preLikes;
    }
    
    const momentId = await db.moments.add(momentData);
    
    console.log(`[Moments] ${char.name} å‘å¸ƒäº†æœ‹å‹åœˆ: ${content}${imageCount > 0 ? ` [é…å›¾${imageCount}å¼ : ${imageDesc}]` : ''}`);
    
    // å¦‚æœå½“å‰åœ¨æœ‹å‹åœˆé¡µé¢ï¼Œåˆ·æ–°åˆ—è¡¨
    const momentsPage = document.getElementById('moments-page');
    if (momentsPage && momentsPage.style.display !== 'none') {
        renderMomentsList();
    }
    
    // å¦‚æœå·²æœ‰é¢„ç”Ÿæˆè¯„è®ºï¼Œæ ‡è®°å·²å¤„ç†NPCè¯„è®ºï¼Œä¸å†å•ç‹¬è°ƒç”¨
    if (options.preComments && options.preComments.length > 0) {
        try {
            const m = await db.moments.get(momentId);
            if (m) {
                m._npcCommented = true;
                await db.moments.put(m);
            }
        } catch (e) {}
        console.log(`[Moments] âœ… å·²é™„å¸¦ ${options.preComments.length} æ¡é¢„ç”Ÿæˆè¯„è®º`);
    } else if (!options.skipComments) {
        // ğŸ”¥ è§¦å‘å…±åŒå¥½å‹NPCè‡ªåŠ¨è¯„è®ºï¼ˆå»¶è¿Ÿæ‰§è¡Œï¼Œä¸é˜»å¡å‘å¸ƒæµç¨‹ï¼‰
        setTimeout(() => {
            triggerMutualFriendComments(momentId);
        }, 2000);
    }
    
    return momentId;
}

// ğŸ§ª æµ‹è¯•å‡½æ•°ï¼šæ‰‹åŠ¨è®©å½“å‰èŠå¤©è§’è‰²å‘å¸ƒæœ‹å‹åœˆ
window.testPublishMoments = async function() {
    if (!currentChatCharId) {
        alert('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªèŠå¤©');
        return;
    }
    const char = await db.characters.get(currentChatCharId);
    if (!char) {
        alert('æ‰¾ä¸åˆ°è§’è‰²');
        return;
    }
    
    await publishMomentsByCharacter(char, 'è¿™æ˜¯ä¸€æ¡æµ‹è¯•æœ‹å‹åœˆ~', 1, 'ä¸€å¼ æµ‹è¯•å›¾ç‰‡');
    alert('æœ‹å‹åœˆå‘å¸ƒæˆåŠŸï¼è¯·æŸ¥çœ‹æœ‹å‹åœˆé¡µé¢');
};

// æœ‹å‹åœˆå›¾ç‰‡æè¿°å¼¹çª—
function showMomentImageDesc(desc) {
    if (!desc) {
        showToast('æš‚æ— å›¾ç‰‡æè¿°');
        return;
    }
    const overlay = document.createElement('div');
    overlay.className = 'moment-img-desc-overlay';
    overlay.onclick = () => overlay.remove();
    overlay.innerHTML = `
        <div class="moment-img-desc-content" onclick="event.stopPropagation()">
            <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
            <p>${escapeHtml(desc)}</p>
            <div class="close-hint">ç‚¹å‡»ç©ºç™½å¤„å…³é—­</div>
        </div>
    `;
    document.body.appendChild(overlay);
}

// ç®€å•çš„é¢„è§ˆå›¾ç‰‡
function previewImage(url) {
    // ç®€å•å…¨å±é¢„è§ˆ
    const div = document.createElement('div');
    div.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:9999;display:flex;align-items:center;justify-content:center;';
    div.innerHTML = `<img src="${url}" style="max-width:100%;max-height:100%;">`;
    div.onclick = () => div.remove();
    document.body.appendChild(div);
}

// æœ‹å‹åœˆäº¤äº’é€»è¾‘
let activeMomentMenuId = null;

function toggleMomentMenu(id, e) {
    e.stopPropagation(); // é˜»æ­¢å†’æ³¡
    
    // å¦‚æœå·²ç»æ‰“å¼€äº†åˆ«çš„ï¼Œå…ˆå…³é—­åˆ«çš„
    if (activeMomentMenuId && activeMomentMenuId !== id) {
        const prev = document.getElementById(`moment-menu-${activeMomentMenuId}`);
        if (prev) prev.classList.remove('show');
    }
    
    const menu = document.getElementById(`moment-menu-${id}`);
    if (menu) {
        if (menu.classList.contains('show')) {
            menu.classList.remove('show');
            activeMomentMenuId = null;
        } else {
            menu.classList.add('show');
            activeMomentMenuId = id;
            
            // ç»‘å®šä¸€æ¬¡æ€§å…¨å±€ç‚¹å‡»äº‹ä»¶æ¥å…³é—­èœå•
            document.addEventListener('click', closeMomentMenuOutside, { once: true });
        }
    }
}

function closeMomentMenuOutside(e) {
    if (activeMomentMenuId) {
        const menu = document.getElementById(`moment-menu-${activeMomentMenuId}`);
        if (menu && !menu.contains(e.target)) {
            menu.classList.remove('show');
            activeMomentMenuId = null;
        }
    }
}

async function likeMoment(id) {
    // ç«‹å³å…³é—­èœå•
    const menu = document.getElementById(`moment-menu-${id}`);
    if (menu) menu.classList.remove('show');
    activeMomentMenuId = null;

    if (!currentMyCharId) return;
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    const moment = await db.moments.get(id);
    
    if (user && moment) {
        if (!moment.likes) moment.likes = [];
        
        const idx = moment.likes.findIndex(l => l.userId == user.id);
        if (idx > -1) {
            // å–æ¶ˆç‚¹èµ
            moment.likes.splice(idx, 1);
        } else {
            // ç‚¹èµ
            moment.likes.push({ userId: user.id, name: user.name });
        }
        
        await db.moments.put(moment);
        renderMomentsList(); // åˆ·æ–°åˆ—è¡¨
    }
}

async function commentMoment(id) {
    // ç«‹å³å…³é—­èœå•
    const menu = document.getElementById(`moment-menu-${id}`);
    if (menu) menu.classList.remove('show');
    activeMomentMenuId = null;

    if (!currentMyCharId) return;
    
    // ä½¿ç”¨ setTimeout è®©èœå•å…ˆå…³é—­ï¼Œå†å¼¹å‡º prompt
    setTimeout(async () => {
        const content = prompt("è¯·è¾“å…¥è¯„è®ºå†…å®¹ï¼š");
        if (content && content.trim()) {
            const user = await db.characters.get(parseInt(currentMyCharId));
            const moment = await db.moments.get(id);
            
            if (user && moment) {
                if (!moment.comments) moment.comments = [];
                
                moment.comments.push({
                    userId: user.id,
                    name: user.name,
                    content: content.trim(),
                    time: Date.now()
                });
                
                await db.moments.put(moment);
                renderMomentsList(); // åˆ·æ–°åˆ—è¡¨
                
                // ğŸ”¥ è§¦å‘æœ‹å‹åœˆå‘å¸ƒè€…AIå›å¤ç”¨æˆ·çš„è¯„è®º
                generateMomentOwnerReply(id, user.name, content.trim());
            }
        }
    }, 50);
}

// === æœ‹å‹åœˆè¯„è®ºé•¿æŒ‰èœå• ===
let _commentLongPressTimer = null;

function startCommentLongPress(e, momentId, commentIdx) {
    _commentLongPressTimer = setTimeout(() => {
        _commentLongPressTimer = null;
        // è§¦å‘è§¦è§‰åé¦ˆï¼ˆå¦‚æœæ”¯æŒï¼‰
        if (navigator.vibrate) navigator.vibrate(20);
        showCommentContextMenu(e, momentId, commentIdx);
    }, 500);
}

function cancelCommentLongPress() {
    if (_commentLongPressTimer) {
        clearTimeout(_commentLongPressTimer);
        _commentLongPressTimer = null;
    }
}

function showCommentContextMenu(e, momentId, commentIdx) {
    // ç§»é™¤å·²å­˜åœ¨çš„èœå•
    const old = document.getElementById('comment-context-menu');
    if (old) old.remove();

    const menu = document.createElement('div');
    menu.id = 'comment-context-menu';
    menu.style.cssText = `
        position:fixed; z-index:99999;
        background:#fff; border-radius:10px;
        box-shadow:0 6px 24px rgba(0,0,0,0.18);
        overflow:hidden; min-width:120px;
        animation: fadeIn 0.15s ease;
    `;

    // å®šä½ï¼šä¼˜å…ˆåœ¨æ‰‹æŒ‡/é¼ æ ‡ä½ç½®é™„è¿‘
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    menu.style.left = Math.min(clientX, window.innerWidth - 140) + 'px';
    menu.style.top = Math.min(clientY - 10, window.innerHeight - 100) + 'px';

    const btnStyle = 'padding:12px 20px; font-size:15px; color:#333; cursor:pointer; border:none; background:none; width:100%; text-align:left; display:block;';
    const dividerStyle = 'height:1px; background:#f0f0f0; margin:0;';

    menu.innerHTML = `
        <button style="${btnStyle}" ontouchstart="this.style.background='#f5f5f5'" ontouchend="this.style.background=''" onclick="copyMomentComment(${momentId},${commentIdx})">å¤åˆ¶</button>
        <div style="${dividerStyle}"></div>
        <button style="${btnStyle}color:#ff3b30;" ontouchstart="this.style.background='#f5f5f5'" ontouchend="this.style.background=''" onclick="deleteMomentComment(${momentId},${commentIdx})">åˆ é™¤</button>
    `;

    document.body.appendChild(menu);

    // ç‚¹å‡»å…¶ä»–åŒºåŸŸå…³é—­èœå•
    const dismiss = (ev) => {
        if (!menu.contains(ev.target)) {
            menu.remove();
            document.removeEventListener('click', dismiss, true);
            document.removeEventListener('touchstart', dismiss, true);
        }
    };
    setTimeout(() => {
        document.addEventListener('click', dismiss, true);
        document.addEventListener('touchstart', dismiss, true);
    }, 50);
}

// å¤åˆ¶è¯„è®ºå†…å®¹
async function copyMomentComment(momentId, commentIdx) {
    document.getElementById('comment-context-menu')?.remove();
    try {
        const moment = await db.moments.get(momentId);
        if (moment && moment.comments && moment.comments[commentIdx]) {
            const text = moment.comments[commentIdx].content || '';
            await navigator.clipboard.writeText(text);
            showToast('å·²å¤åˆ¶');
        }
    } catch (e) {
        console.error('[æœ‹å‹åœˆ] å¤åˆ¶è¯„è®ºå¤±è´¥:', e);
    }
}

// åˆ é™¤è¯„è®º
async function deleteMomentComment(momentId, commentIdx) {
    document.getElementById('comment-context-menu')?.remove();
    try {
        const moment = await db.moments.get(momentId);
        if (moment && moment.comments && moment.comments[commentIdx]) {
            moment.comments.splice(commentIdx, 1);
            await db.moments.put(moment);
            renderMomentsList();
            showToast('è¯„è®ºå·²åˆ é™¤');
        }
    } catch (e) {
        console.error('[æœ‹å‹åœˆ] åˆ é™¤è¯„è®ºå¤±è´¥:', e);
    }
}

// å›å¤æœ‹å‹åœˆä¸­æŸä¸ªè§’è‰²çš„è¯„è®º
async function replyToMomentComment(momentId, replyToName, commentIdx) {
    if (!currentMyCharId) return;
    
    setTimeout(async () => {
        const content = prompt(`å›å¤ ${replyToName}ï¼š`);
        if (content && content.trim()) {
            const user = await db.characters.get(parseInt(currentMyCharId));
            const moment = await db.moments.get(momentId);
            
            if (user && moment) {
                if (!moment.comments) moment.comments = [];
                
                // æ·»åŠ ç”¨æˆ·çš„å›å¤
                moment.comments.push({
                    userId: user.id,
                    name: user.name,
                    replyTo: replyToName,
                    content: content.trim(),
                    time: Date.now()
                });
                
                await db.moments.put(moment);
                renderMomentsList();
                
                // è§¦å‘è¢«å›å¤çš„è§’è‰²è‡ªåŠ¨å›å¤
                generateReplyToUserComment(momentId, replyToName, content.trim());
            }
        }
    }, 50);
}

// AIç”Ÿæˆè§’è‰²å¯¹ç”¨æˆ·å›å¤çš„å†å›å¤
async function generateReplyToUserComment(momentId, charName, userComment) {
    try {
        const moment = await db.moments.get(momentId);
        if (!moment) return;
        
        const accountId = getCurrentAccountId();
        const myChar = await db.characters.get(parseInt(currentMyCharId));
        const myName = myChar?.name || 'æˆ‘';
        
        // æ‰¾åˆ°è¿™ä¸ªè§’è‰²
        const allChars = await db.characters.toArray();
        const targetChar = allChars.find(c => {
            const displayName = getCharDisplayName(c, accountId);
            return displayName === charName || c.name === charName;
        });
        
        if (!targetChar) return;
        
        // è·å–ç”¨æˆ·ä¸è§’è‰²çš„å…³ç³»ä¸Šä¸‹æ–‡
        let relationContext = '';
        try {
            if (myChar) {
                relationContext += `\nã€${myName}ï¼ˆå›å¤ä½ çš„äººï¼‰çš„ä¿¡æ¯ã€‘\n`;
                relationContext += `åå­—ï¼š${myName}\n`;
                if (myChar.description) relationContext += `è®¾å®šï¼š${myChar.description}\n`;
            }
            if (targetChar.remark) {
                relationContext += `${targetChar.name} å¯¹ ${myName} çš„å¤‡æ³¨/ç§°å‘¼ï¼š${targetChar.remark}\n`;
            }
            // æœ€è¿‘èŠå¤©è®°å½•
            const history = getChatHistory(targetChar, accountId);
            if (history && history.length > 0) {
                const recent = history.slice(-10).map(m => {
                    const role = m.role === 'char' ? targetChar.name : myName;
                    return `${role}: ${m.content}`;
                }).join('\n');
                relationContext += `\nã€${targetChar.name}ä¸${myName}çš„æœ€è¿‘èŠå¤©ã€‘\n${recent}\n`;
            }
        } catch (e) {
            console.warn('[æœ‹å‹åœˆå›å¤] è·å–å…³ç³»ä¸Šä¸‹æ–‡å¤±è´¥:', e);
        }
        
        // æ‰¾åˆ°è§’è‰²ä¹‹å‰åœ¨è¿™æ¡æœ‹å‹åœˆä¸‹çš„è¯„è®º
        const charPrevComments = (moment.comments || [])
            .filter(c => {
                const cName = c.name;
                return cName === charName;
            })
            .map(c => c.content)
            .join('ï¼›');
        
        const prompt = `ä½ æ˜¯ ${targetChar.name}ï¼Œä½ åœ¨ ${myName} çš„æœ‹å‹åœˆä¸‹è¯„è®ºäº†ï¼š"${charPrevComments}"
${relationContext}
${myName} å›å¤äº†ä½ ï¼š"${userComment}"

è¯·ä»¥ ${targetChar.name} çš„èº«ä»½ï¼Œç”¨ç®€çŸ­è‡ªç„¶çš„è¯­æ°”å†å›å¤ ${myName}ï¼ˆ3-20å­—ï¼Œå¯ä»¥ç”¨è¡¨æƒ…ã€è¯­æ°”è¯ï¼‰ã€‚
æ³¨æ„ï¼šä½ å’Œ ${myName} æ˜¯è®¤è¯†çš„ï¼Œè¯·æ ¹æ®ä½ ä»¬çš„å…³ç³»äº²å¯†ç¨‹åº¦æ¥å›å¤ã€‚

äººè®¾å‚è€ƒï¼š${targetChar.description || targetChar.personality || 'æ™®é€šæœ‹å‹'}

åªè¿”å›å›å¤å†…å®¹ï¼Œä¸è¦JSONï¼Œä¸è¦å¼•å·ã€‚`;
        
        const result = await callAI([
            { role: 'system', content: 'ä½ æ˜¯ä¸€ä¸ªç¤¾äº¤åª’ä½“è¯„è®ºè§’è‰²æ‰®æ¼”åŠ©æ‰‹ï¼Œç›´æ¥è¿”å›å›å¤å†…å®¹ï¼Œä¸è¦ä»»ä½•æ ¼å¼æ ‡è®°ã€‚' },
            { role: 'user', content: prompt }
        ], { _useSecondary: true });
        
        const replyContent = result.trim().replace(/^["'"]|["'"]$/g, '');
        if (replyContent) {
            // é‡æ–°è·å–æœ€æ–°çš„momentï¼ˆé˜²æ­¢å¹¶å‘ä¿®æ”¹ï¼‰
            const freshMoment = await db.moments.get(momentId);
            if (freshMoment) {
                if (!freshMoment.comments) freshMoment.comments = [];
                freshMoment.comments.push({
                    userId: targetChar.id,
                    name: targetChar.remark || targetChar.wx_nickname || targetChar.name,
                    replyTo: myName,
                    content: replyContent,
                    time: Date.now()
                });
                await db.moments.put(freshMoment);
                renderMomentsList();
            }
        }
    } catch (err) {
        console.error('[æœ‹å‹åœˆå›å¤] AIå›å¤ç”Ÿæˆå¤±è´¥:', err);
    }
}

// ğŸ”¥ æœ‹å‹åœˆå‘å¸ƒè€…AIå›å¤ç”¨æˆ·çš„è¯„è®º
async function generateMomentOwnerReply(momentId, userName, userComment) {
    try {
        const moment = await db.moments.get(momentId);
        if (!moment) return;
        
        // æ‰¾åˆ°å‘å¸ƒè€…
        const ownerChar = await db.characters.get(moment.userId);
        if (!ownerChar) return;
        
        // å¦‚æœå‘å¸ƒè€…æ˜¯ç”¨æˆ·è‡ªå·±ï¼Œä¸éœ€è¦AIå›å¤
        if (parseInt(currentMyCharId) === ownerChar.id) return;
        
        const myChar = await db.characters.get(parseInt(currentMyCharId));
        const myName = myChar?.name || userName;
        
        // è·å–ç”¨æˆ·ä¸è§’è‰²çš„å…³ç³»ä¸Šä¸‹æ–‡
        const accountId = getCurrentAccountId();
        let relationContext = '';
        try {
            // ç”¨æˆ·ä¿¡æ¯
            if (myChar) {
                relationContext += `\nã€${myName}ï¼ˆè¯„è®ºè€…ï¼‰çš„ä¿¡æ¯ã€‘\n`;
                relationContext += `åå­—ï¼š${myName}\n`;
                if (myChar.description) relationContext += `è®¾å®šï¼š${myChar.description}\n`;
            }
            // è§’è‰²å¤‡æ³¨ï¼ˆè§’è‰²ç»™ç”¨æˆ·çš„å¤‡æ³¨ï¼‰
            if (ownerChar.remark_by_user && ownerChar.remark_by_user[accountId]) {
                relationContext += `${myName} ç»™ ${ownerChar.name} çš„å¤‡æ³¨ï¼š${ownerChar.remark_by_user[accountId]}\n`;
            }
            if (ownerChar.remark) {
                relationContext += `${ownerChar.name} å¯¹ ${myName} çš„å¤‡æ³¨/ç§°å‘¼ï¼š${ownerChar.remark}\n`;
            }
            // æœ€è¿‘èŠå¤©è®°å½•
            const history = getChatHistory(ownerChar, accountId);
            if (history && history.length > 0) {
                const recent = history.slice(-10).map(m => {
                    const role = m.role === 'char' ? ownerChar.name : myName;
                    return `${role}: ${m.content}`;
                }).join('\n');
                relationContext += `\nã€${ownerChar.name}ä¸${myName}çš„æœ€è¿‘èŠå¤©ã€‘\n${recent}\n`;
            }
        } catch (e) {
            console.warn('[æœ‹å‹åœˆå›å¤] è·å–å…³ç³»ä¸Šä¸‹æ–‡å¤±è´¥:', e);
        }
        
        // è·å–å·²æœ‰çš„æ‰€æœ‰è¯„è®ºï¼Œç”¨äºä¸Šä¸‹æ–‡
        const existingComments = (moment.comments || []).map(c => {
            const replyPart = c.replyTo ? ` å›å¤ ${c.replyTo}` : '';
            return `${c.name}${replyPart}ï¼š${c.content}`;
        }).join('\n');
        
        const promptText = `ä½ æ˜¯ ${ownerChar.name}ï¼Œä½ å‘äº†ä¸€æ¡æœ‹å‹åœˆï¼š"${moment.content}"
${relationContext}
${existingComments ? `æœ‹å‹åœˆä¸‹å·²æœ‰çš„è¯„è®ºï¼š\n${existingComments}\n` : ''}
${myName} è¯„è®ºäº†ä½ çš„æœ‹å‹åœˆï¼š"${userComment}"

è¯·ä»¥ ${ownerChar.name} çš„èº«ä»½å›å¤ ${myName} çš„è¯„è®ºã€‚è¦æ±‚ï¼š
- ç®€çŸ­è‡ªç„¶ï¼ˆ3-30å­—ï¼‰
- ç¬¦åˆä½ çš„æ€§æ ¼å’Œè¯´è¯é£æ ¼
- ç¬¦åˆä½ å’Œ ${myName} ä¹‹é—´çš„å…³ç³»å’Œäº²å¯†ç¨‹åº¦
- å¯ä»¥ç”¨è¡¨æƒ…ã€è¯­æ°”è¯
- åƒçœŸäººå›å¤æœ‹å‹åœˆè¯„è®ºä¸€æ ·éšæ„

äººè®¾å‚è€ƒï¼š${ownerChar.description || ownerChar.personality || ''}

åªè¿”å›å›å¤å†…å®¹ï¼Œä¸è¦JSONï¼Œä¸è¦å¼•å·ã€‚`;
        
        // å»¶è¿Ÿ2-5ç§’åå›å¤ï¼Œæ¨¡æ‹ŸçœŸäºº
        const delay = 2000 + Math.random() * 3000;
        await new Promise(r => setTimeout(r, delay));
        
        const result = await callAI([
            { role: 'system', content: 'ä½ æ˜¯ä¸€ä¸ªç¤¾äº¤åª’ä½“è¯„è®ºè§’è‰²æ‰®æ¼”åŠ©æ‰‹ï¼Œç›´æ¥è¿”å›å›å¤å†…å®¹ï¼Œä¸è¦ä»»ä½•æ ¼å¼æ ‡è®°ã€‚' },
            { role: 'user', content: promptText }
        ], { _useSecondary: true });
        
        const replyContent = result.trim().replace(/^["'"""]+|["'"""]+$/g, '');
        if (replyContent) {
            const freshMoment = await db.moments.get(momentId);
            if (freshMoment) {
                if (!freshMoment.comments) freshMoment.comments = [];
                freshMoment.comments.push({
                    userId: ownerChar.id,
                    name: ownerChar.remark || ownerChar.wx_nickname || ownerChar.name,
                    replyTo: myName,
                    content: replyContent,
                    time: Date.now()
                });
                await db.moments.put(freshMoment);
                renderMomentsList();
                console.log(`[æœ‹å‹åœˆ] ${ownerChar.name} å›å¤äº† ${myName} çš„è¯„è®º: ${replyContent}`);
            }
        }
    } catch (err) {
        console.error('[æœ‹å‹åœˆ] å‘å¸ƒè€…AIå›å¤å¤±è´¥:', err);
    }
}

// ğŸ”¥ å…±åŒå¥½å‹NPCè‡ªåŠ¨è¯„è®ºæœ‹å‹åœˆ
async function triggerMutualFriendComments(momentId) {
    try {
        const moment = await db.moments.get(momentId);
        if (!moment) return;
        
        // å¦‚æœå·²ç»è§¦å‘è¿‡NPCè¯„è®ºï¼Œè·³è¿‡ï¼ˆé˜²æ­¢é‡å¤ï¼‰
        if (moment._npcCommented) return;
        
        const accountId = getCurrentAccountId();
        if (!accountId) return;
        
        // æ‰¾åˆ°å‘å¸ƒè€…
        const ownerChar = await db.characters.get(moment.userId);
        if (!ownerChar) return;
        
        // è·å–å‘å¸ƒè€…çš„å…³è”è§’è‰²/NPC
        const relationships = ownerChar.relationships || [];
        if (relationships.length === 0) return;
        
        // æ‰¾åˆ°å‘å¸ƒè€…çš„æ‰€æœ‰å…³è”NPCï¼ˆä¸å†é™åˆ¶å¿…é¡»æ˜¯å…±åŒå¥½å‹ï¼‰
        const allChars = await db.characters.toArray();
        const relatedNPCs = [];
        
        for (const rel of relationships) {
            if (!rel.targetId) continue;
            const npc = allChars.find(c => c.id === rel.targetId);
            if (!npc) continue;
            // æ’é™¤ç”¨æˆ·è§’è‰²ï¼Œä¸è¦ç»™ç”¨æˆ·è‡ªåŠ¨ç”Ÿæˆè¯„è®º
            if (npc.type === 'user') continue;
            
            relatedNPCs.push({ npc, relation: rel.relation, desc: rel.desc || '' });
        }
        
        if (relatedNPCs.length === 0) return;
        
        console.log(`[æœ‹å‹åœˆNPC] å‘ç° ${relatedNPCs.length} ä¸ªå…³è”NPCå¯ä»¥è¯„è®º ${ownerChar.name} çš„æœ‹å‹åœˆ`);
        
        // æ ‡è®°å·²è§¦å‘NPCè¯„è®º
        const markMoment = await db.moments.get(momentId);
        if (markMoment) {
            markMoment._npcCommented = true;
            await db.moments.put(markMoment);
        }
        
        // éšæœºé€‰å–1-3ä¸ªNPCæ¥è¯„è®ºï¼ˆä¸æ˜¯æ‰€æœ‰äººéƒ½ä¼šè¯„è®ºï¼‰
        const shuffled = relatedNPCs.sort(() => Math.random() - 0.5);
        const commentCount = Math.min(shuffled.length, 1 + Math.floor(Math.random() * 3));
        const selectedNPCs = shuffled.slice(0, commentCount);
        
        // ğŸ”¥ ä¸€æ¬¡APIè°ƒç”¨æ‰¹é‡ç”Ÿæˆæ‰€æœ‰NPCè¯„è®ºï¼ˆä¸å†é€ä¸ªå•ç‹¬è°ƒç”¨ï¼‰
        try {
            const freshMoment = await db.moments.get(momentId);
            if (!freshMoment) return;
            
            // æ„å»ºæ‰€æœ‰é€‰ä¸­NPCçš„ä¿¡æ¯
            const npcInfos = selectedNPCs.map(({ npc, relation }) => {
                const displayName = npc.remark || npc.wx_nickname || npc.name;
                return `- ${displayName}ï¼ˆå’Œ${ownerChar.name}çš„å…³ç³»ï¼š${relation}ï¼‰ï¼š${npc.description || npc.personality || 'æ™®é€šæœ‹å‹'}`;
            }).join('\n');
            
            const batchPrompt = `${ownerChar.name} å‘äº†ä¸€æ¡æœ‹å‹åœˆï¼š"${freshMoment.content}"
${freshMoment.imageCount > 0 || (freshMoment.images && freshMoment.images.length > 0) ? `ï¼ˆé™„å¸¦${freshMoment.imageCount || freshMoment.images.length}å¼ å›¾ç‰‡${freshMoment.imageDesc ? 'ï¼š' + freshMoment.imageDesc : ''}ï¼‰` : ''}

ä»¥ä¸‹æ˜¯ ${ownerChar.name} çš„å¥½å‹ï¼Œè¯·ä¸ºæ¯ä¸ªäººç”Ÿæˆä¸€æ¡ç¬¦åˆå…¶æ€§æ ¼å’Œå…³ç³»çš„æœ‹å‹åœˆè¯„è®ºï¼š
${npcInfos}

è¦æ±‚ï¼š
1. æ¯æ¡è¯„è®ºç®€çŸ­è‡ªç„¶ï¼ˆ2-25å­—ï¼‰
2. å¯ä»¥ç”¨è¡¨æƒ…ã€è¯­æ°”è¯ã€è°ƒä¾ƒã€å¤¸èµã€åæ§½ç­‰
3. ç¬¦åˆæ¯ä¸ªè§’è‰²å’Œ${ownerChar.name}çš„å…³ç³»
4. åƒçœŸäººåœ¨æœ‹å‹åœˆä¸‹è¯„è®ºä¸€æ ·éšæ„
5. é¼“åŠ±å¥½å‹ä¹‹é—´äº’ç›¸å›å¤ï¼ˆä½¿ç”¨ replyTo å­—æ®µæŒ‡å®šå›å¤çš„äººåï¼‰

è¯·è¿”å›JSONæ•°ç»„æ ¼å¼ï¼š
[{"name": "è§’è‰²å", "content": "è¯„è®ºå†…å®¹"}, {"name": "è§’è‰²å", "replyTo": "è¢«å›å¤çš„è§’è‰²å", "content": "å›å¤å†…å®¹"}, ...]`;

            const result = await callAI([
                { role: 'system', content: 'ä½ æ˜¯ä¸€ä¸ªç¤¾äº¤åª’ä½“è¯„è®ºç”ŸæˆåŠ©æ‰‹ï¼Œåªè¿”å›JSONæ•°ç»„ï¼Œä¸è¦ä»»ä½•å…¶ä»–æ–‡å­—ã€‚' },
                { role: 'user', content: batchPrompt }
            ], { json_mode: true, _useSecondary: true });
            
            // è§£æç»“æœ
            let aiComments = [];
            try {
                let cleanResult = result.trim();
                if (cleanResult.startsWith('```')) {
                    cleanResult = cleanResult.replace(/```json?\n?/g, '').replace(/```$/g, '').trim();
                }
                // å°è¯•æå–JSONæ•°ç»„
                const parsed = extractAndParseJSON(cleanResult);
                if (Array.isArray(parsed)) {
                    aiComments = parsed;
                } else if (parsed && Array.isArray(parsed.comments)) {
                    aiComments = parsed.comments;
                } else {
                    aiComments = JSON.parse(cleanResult);
                }
            } catch (e) {
                console.warn('[æœ‹å‹åœˆNPC] AIè¯„è®ºæ‰¹é‡è§£æå¤±è´¥:', e);
            }
            
            // å»¶è¿Ÿé€æ¡å†™å…¥è¯„è®ºï¼ˆæ¨¡æ‹ŸçœŸå®åœºæ™¯ï¼‰
            const latestMoment = await db.moments.get(momentId);
            if (latestMoment && aiComments.length > 0) {
                if (!latestMoment.comments) latestMoment.comments = [];
                
                // å…ˆæ”¶é›†æœ¬è½®è¦æ·»åŠ çš„è¯„è®º
                const newComments = [];
                for (const aiComment of aiComments) {
                    // åŒ¹é…NPC
                    const matched = selectedNPCs.find(({ npc }) => {
                        const displayName = npc.remark || npc.wx_nickname || npc.name;
                        return displayName === aiComment.name || npc.name === aiComment.name;
                    });
                    if (matched && aiComment.content) {
                        const commentObj = {
                            userId: matched.npc.id,
                            name: matched.npc.remark || matched.npc.wx_nickname || matched.npc.name,
                            content: aiComment.content.trim().replace(/^["'"""]+|["'"""]+$/g, ''),
                            time: Date.now() + Math.random() * 60000
                        };
                        if (aiComment.replyTo) {
                            commentObj.replyTo = aiComment.replyTo;
                        }
                        newComments.push(commentObj);
                        console.log(`[æœ‹å‹åœˆNPC] ${matched.npc.name}(${matched.relation}) è¯„è®ºäº† ${ownerChar.name} çš„æœ‹å‹åœˆ: ${aiComment.content}`);
                    }
                }
                
                // æ ¡éªŒ replyToï¼šç¡®ä¿è¢«å›å¤çš„äººç¡®å®æœ‰è¯„è®ºï¼Œå¦åˆ™å»æ‰ replyTo
                const allCommentNames = new Set([
                    ...latestMoment.comments.map(c => c.name),
                    ...newComments.map(c => c.name)
                ]);
                for (const c of newComments) {
                    if (c.replyTo && !allCommentNames.has(c.replyTo)) {
                        console.log(`[æœ‹å‹åœˆNPC] âš ï¸ replyTo "${c.replyTo}" ä¸å­˜åœ¨ï¼Œå·²ç§»é™¤å›å¤æ ‡è®°`);
                        delete c.replyTo;
                    }
                }
                
                latestMoment.comments.push(...newComments);
                await db.moments.put(latestMoment);
                renderMomentsList();
                console.log(`[æœ‹å‹åœˆNPC] âœ… æ‰¹é‡ç”Ÿæˆå®Œæˆ: ${newComments.length}æ¡è¯„è®º`);
            }
        } catch (err) {
            console.error('[æœ‹å‹åœˆNPC] æ‰¹é‡è¯„è®ºç”Ÿæˆå¤±è´¥:', err);
        }
        
        // éƒ¨åˆ†NPCä¹Ÿå¯èƒ½ç‚¹èµï¼ˆéšæœº50%æ¦‚ç‡ï¼‰
        for (const { npc } of relatedNPCs) {
            if (Math.random() < 0.5) {
                const likeDelay = 1000 + Math.random() * 5000;
                setTimeout(async () => {
                    try {
                        const latestMoment = await db.moments.get(momentId);
                        if (!latestMoment) return;
                        if (!latestMoment.likes) latestMoment.likes = [];
                        // æ£€æŸ¥æ˜¯å¦å·²ç»ç‚¹èµ
                        if (latestMoment.likes.some(l => l.userId === npc.id)) return;
                        latestMoment.likes.push({
                            userId: npc.id,
                            name: npc.remark || npc.wx_nickname || npc.name
                        });
                        await db.moments.put(latestMoment);
                        renderMomentsList();
                        console.log(`[æœ‹å‹åœˆNPC] ${npc.name} ç‚¹èµäº† ${ownerChar.name} çš„æœ‹å‹åœˆ`);
                    } catch (e) {}
                }, likeDelay);
            }
        }
    } catch (err) {
        console.error('[æœ‹å‹åœˆNPC] NPCè¯„è®ºè§¦å‘å¤±è´¥:', err);
    }
}

// æ˜¾ç¤º"æˆ‘çš„æœ‹å‹åœˆ"é¡µé¢
async function showMyMomentsPage() {
    const page = document.getElementById('my-moments-page');
    page.style.display = 'block';
    page.offsetHeight;
    page.classList.add('slide-in');
    
    // æ¸²æŸ“ç”¨æˆ·ä¿¡æ¯
    const user = await db.characters.get(parseInt(currentMyCharId));
    if (user) {
        const nameEl = document.getElementById('my-moments-name');
        const avatarEl = document.getElementById('my-moments-avatar');
        const coverEl = document.getElementById('my-moments-cover');
        
        nameEl.innerText = user.name;
        if (user.avatar) {
            avatarEl.style.backgroundImage = `url(${user.avatar})`;
        }
        
        const cover = user.identity?.cover;
        if (cover) {
            coverEl.style.backgroundImage = `url(${cover})`;
        }
    }
    
    // æ¸²æŸ“æœ‹å‹åœˆåˆ—è¡¨ï¼ˆåªæ˜¾ç¤ºè‡ªå·±çš„ï¼‰
    await renderMyMomentsList();
}

function hideMyMomentsPage() {
    const page = document.getElementById('my-moments-page');
    page.classList.remove('slide-in');
    setTimeout(() => {
        page.style.display = 'none';
    }, 300);
}

// æ ¼å¼åŒ–æœ‹å‹åœˆæ—¶é—´
function formatMomentTime(timestamp) {
    const date = new Date(timestamp);
    const now = new Date();
    
    // è®¡ç®—æ—¶é—´å·®
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);
    
    // å°äº1åˆ†é’Ÿ
    if (diffMins < 1) {
        return 'åˆšåˆš';
    }
    // å°äº1å°æ—¶
    if (diffMins < 60) {
        return `${diffMins}åˆ†é’Ÿå‰`;
    }
    // å°äº24å°æ—¶
    if (diffHours < 24) {
        return `${diffHours}å°æ—¶å‰`;
    }
    // å°äº7å¤©
    if (diffDays < 7) {
        return `${diffDays}å¤©å‰`;
    }
    
    // è¶…è¿‡7å¤©ï¼Œæ˜¾ç¤ºå…·ä½“æ—¥æœŸ
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const day = date.getDate();
    const hour = date.getHours();
    const minute = date.getMinutes().toString().padStart(2, '0');
    
    // å¦‚æœæ˜¯ä»Šå¹´ï¼Œä¸æ˜¾ç¤ºå¹´ä»½
    if (year === now.getFullYear()) {
        return `${month}æœˆ${day}æ—¥ ${hour}:${minute}`;
    }
    
    // è·¨å¹´æ˜¾ç¤ºå¹´ä»½
    return `${year}å¹´${month}æœˆ${day}æ—¥`;
}

// æ¸²æŸ“æˆ‘çš„æœ‹å‹åœˆåˆ—è¡¨
async function renderMyMomentsList() {
    const container = document.getElementById('my-moments-list');
    const pinnedContainer = document.getElementById('my-moments-pinned-list');
    const pinnedSection = document.getElementById('my-moments-pinned-section');
    
    container.innerHTML = '';
    pinnedContainer.innerHTML = '';
    
    const currentAccountId = currentMyCharId ? parseInt(currentMyCharId) : null;
    if (!currentAccountId) {
        container.innerHTML = `<div class="wechat-empty-state" style="margin-top:60px;"><div style="color:#999; font-size:14px;">è¯·å…ˆç™»å½•è´¦å·</div></div>`;
        pinnedSection.classList.remove('show');
        return;
    }
    
    // åªè·å–è‡ªå·±å‘çš„æœ‹å‹åœˆ
    const allMoments = await db.moments.toArray();
    let moments = allMoments.filter(m => m.userId == currentAccountId);
    
    // åˆ†ç¦»ç½®é¡¶å’Œæ™®é€šæœ‹å‹åœˆ
    const pinnedMoments = moments.filter(m => m.pinned);
    const normalMoments = moments.filter(m => !m.pinned);
    
    // æŒ‰æ—¶é—´å€’åºæ’åº
    pinnedMoments.sort((a, b) => b.time - a.time);
    normalMoments.sort((a, b) => b.time - a.time);
    
    // è·å–ç”¨æˆ·ä¿¡æ¯
    const user = await db.characters.get(currentAccountId);
    
    // æ¸²æŸ“ç½®é¡¶åŒºåŸŸï¼ˆåªæ˜¾ç¤ºå‰3ä¸ªï¼‰
    if (pinnedMoments.length > 0) {
        pinnedSection.classList.add('show');
        
        // åªæ˜¾ç¤ºå‰3ä¸ªç½®é¡¶å¡ç‰‡
        const displayMoments = pinnedMoments.slice(0, 3);
        for (const moment of displayMoments) {
            const card = createPinnedMomentCard(moment, user);
            pinnedContainer.appendChild(card);
        }
        
        // è®¾ç½®ç®­å¤´ç‚¹å‡»äº‹ä»¶ï¼ˆæŸ¥çœ‹æ‰€æœ‰ç½®é¡¶ï¼‰
        const arrow = pinnedSection.querySelector('.moments-pinned-arrow');
        if (arrow) {
            arrow.onclick = () => showAllPinnedMoments(pinnedMoments, user);
        }
    } else {
        pinnedSection.classList.remove('show');
    }
    
    // æ¸²æŸ“æ™®é€šæœ‹å‹åœˆï¼ˆä¿æŒåŸæ¥çš„å®Œæ•´æ ·å¼ï¼‰
    if (normalMoments.length === 0 && pinnedMoments.length === 0) {
        container.innerHTML = `<div class="wechat-empty-state" style="margin-top:60px;"><div style="color:#999; font-size:14px;">è¿˜æ²¡æœ‰å‘å¸ƒæœ‹å‹åœˆ</div></div>`;
        return;
    }
    
    for (const moment of normalMoments) {
        const itemDiv = createMomentItem(moment, user);
        container.appendChild(itemDiv);
    }
}

// åˆ›å»ºç½®é¡¶æœ‹å‹åœˆå¡ç‰‡ï¼ˆä»¿çœŸå®å¾®ä¿¡æ ·å¼ï¼‰
function createPinnedMomentCard(moment, user) {
    const card = document.createElement('div');
    card.className = 'pinned-moment-card';
    card.onclick = () => showMomentDetail(moment.id);
    
    // å¦‚æœæœ‰å›¾ç‰‡ï¼Œè®¾ç½®ä¸ºèƒŒæ™¯
    if (moment.images && moment.images.length > 0) {
        card.style.backgroundImage = `url(${moment.images[0]})`;
    }
    
    // æ–‡å­—å†…å®¹é¢„è§ˆï¼ˆæ˜¾ç¤ºåœ¨å¡ç‰‡ä¸­å¤®ï¼‰
    const contentText = moment.content || '';
    const shortText = contentText.length > 30 ? contentText.substring(0, 30) + '...' : contentText;
    
    card.innerHTML = `<div class="pinned-moment-text">${shortText}</div>`;
    
    return card;
}

// æ˜¾ç¤ºæ‰€æœ‰ç½®é¡¶æœ‹å‹åœˆé¡µé¢ï¼ˆæ—¶é—´çº¿æ ¼å¼ï¼‰
function showAllPinnedMoments(pinnedMoments, user) {
    const page = document.getElementById('all-pinned-moments-page');
    const list = document.getElementById('all-pinned-list');
    
    list.innerHTML = '';
    
    // æŒ‰å¹´ä»½å’Œæ—¥æœŸåˆ†ç»„
    const groupedByYear = {};
    for (const moment of pinnedMoments) {
        const date = new Date(moment.time);
        const year = date.getFullYear();
        const dateKey = `${date.getMonth() + 1}-${date.getDate()}`; // æœˆ-æ—¥
        
        if (!groupedByYear[year]) groupedByYear[year] = {};
        if (!groupedByYear[year][dateKey]) groupedByYear[year][dateKey] = [];
        groupedByYear[year][dateKey].push(moment);
    }
    
    // æŒ‰å¹´ä»½å€’åºæ¸²æŸ“
    const years = Object.keys(groupedByYear).sort((a, b) => b - a);
    for (const year of years) {
        // å¹´ä»½æ ‡é¢˜
        const yearTitle = document.createElement('div');
        yearTitle.style.cssText = 'font-size:20px; font-weight:700; color:#333; padding:20px 16px 10px;';
        yearTitle.textContent = year + 'å¹´';
        list.appendChild(yearTitle);
        
        // æŒ‰æ—¥æœŸå€’åº
        const dates = Object.keys(groupedByYear[year]).sort((a, b) => {
            const [am, ad] = a.split('-').map(Number);
            const [bm, bd] = b.split('-').map(Number);
            return (bm * 100 + bd) - (am * 100 + ad);
        });
        
        for (const dateKey of dates) {
            const dayMoments = groupedByYear[year][dateKey];
            const item = createPinnedTimelineGroup(dateKey, dayMoments);
            list.appendChild(item);
        }
    }
    
    page.style.display = 'block';
}

// åˆ›å»ºç½®é¡¶é¡µé¢çš„æ—¶é—´çº¿æ¡ç›®ï¼ˆåŒä¸€å¤©çš„åˆå¹¶æ˜¾ç¤ºï¼‰
function createPinnedTimelineGroup(dateKey, moments) {
    const div = document.createElement('div');
    div.style.cssText = 'display:flex; padding:16px; border-bottom:1px solid #f5f5f5;';
    
    const [month, day] = dateKey.split('-');
    
    // æ”¶é›†æ‰€æœ‰å›¾ç‰‡å’Œæ–‡å­—
    let allImages = [];
    let allTexts = [];
    for (const moment of moments) {
        if (moment.images && moment.images.length > 0) {
            allImages = allImages.concat(moment.images);
        }
        if (moment.content) {
            allTexts.push({ id: moment.id, text: moment.content });
        }
    }
    
    // å›¾ç‰‡ç½‘æ ¼ï¼ˆä¸€è¡Œä¸‰ä¸ªï¼‰
    let imagesHtml = '';
    if (allImages.length > 0) {
        imagesHtml = `<div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:4px; margin-bottom:8px;">
            ${allImages.map(img => `<div style="aspect-ratio:1; background-image:url(${img}); background-size:cover; background-position:center; cursor:pointer;" onclick="event.stopPropagation(); previewImage('${img}')"></div>`).join('')}
        </div>`;
    }
    
    // æ–‡å­—å†…å®¹åˆ—è¡¨
    let textsHtml = '';
    for (const item of allTexts) {
        const shortText = item.text.length > 40 ? item.text.substring(0, 40) + '...' : item.text;
        textsHtml += `<div style="font-size:14px; color:#666; line-height:1.6; padding:6px 12px; background:#f8f8f8; border-radius:4px; margin-bottom:6px; cursor:pointer;" onclick="showMomentDetail(${item.id})">${shortText}</div>`;
    }
    
    div.innerHTML = `
        <div style="width:70px; flex-shrink:0; text-align:left;">
            <div style="font-size:28px; font-weight:700; color:#333; line-height:1;">${day.padStart(2, '0')}</div>
            <div style="font-size:12px; color:#999;">${month}æœˆ</div>
        </div>
        <div style="flex:1; min-width:0;">
            ${imagesHtml}
            ${textsHtml}
        </div>
    `;
    
    return div;
}

// éšè—æ‰€æœ‰ç½®é¡¶æœ‹å‹åœˆé¡µé¢
function hideAllPinnedMoments() {
    document.getElementById('all-pinned-moments-page').style.display = 'none';
}

// åˆ›å»ºæœ‹å‹åœˆæ¡ç›®
function createMomentItem(moment, user) {
    const itemDiv = document.createElement('div');
    itemDiv.className = 'moment-item';
    itemDiv.onclick = () => showMomentDetail(moment.id);
    
    // æƒé™æ ‡è¯†
    let privacyText = '';
    if (moment.privacy === 'private') privacyText = 'ç§å¯†';
    else if (moment.privacy === 'friends') privacyText = 'å¥½å‹å¯è§';
    
    const privacyBadge = privacyText ? `<span style="color:#999; font-size:12px; margin-left:8px;">${privacyText}</span>` : '';
    
    // å›¾ç‰‡å±•ç¤º - ä½¿ç”¨æ–‡å­—å›¾ç‰‡å¡ç‰‡å½¢å¼
    let imagesHtml = '';
    if (moment.imageCount && moment.imageCount > 0) {
        const desc = moment.imageDesc || '';
        const count = Math.min(moment.imageCount, 9);
        const gridClass = `grid-${count}`;
        let squares = '';
        for (let imgIdx = 0; imgIdx < count; imgIdx++) {
            squares += `<div class="moment-img-placeholder" onclick="event.stopPropagation(); showMomentImageDesc('${escapeHtml(desc).replace(/'/g, "\\'")}')">
                <div class="moment-img-placeholder-inner">
                    <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
                    ${count === 1 ? '<div class="moment-img-placeholder-hint">ç‚¹å‡»æŸ¥çœ‹æ–‡å­—</div>' : ''}
                </div>
            </div>`;
        }
        imagesHtml = `<div class="moment-image-grid ${gridClass}">${squares}</div>`;
    }
    // å…¼å®¹æ—§æ•°æ®
    else if (moment.images && moment.images.length > 0) {
        let gridClass = 'cols-3';
        if (moment.images.length === 1) gridClass = 'cols-1';
        else if (moment.images.length === 2 || moment.images.length === 4) gridClass = 'cols-2';
        
        imagesHtml = `<div class="moment-grid ${gridClass}">
            ${moment.images.map(img => `<div class="moment-img" style="background-image:url(${img})" onclick="event.stopPropagation(); previewImage('${img}')"></div>`).join('')}
        </div>`;
    }
    
    itemDiv.innerHTML = `
        <div class="moment-avatar" style="background-image:url(${user?.avatar || ''})"></div>
        <div class="moment-content">
            <div class="moment-name">${user?.name || 'æˆ‘'}${privacyBadge}</div>
            <div class="moment-text">${moment.content}</div>
            ${imagesHtml}
            <div class="moment-meta">
                <span class="moment-time">${formatMomentTime(moment.time)}</span>
            </div>
        </div>
    `;
    
    return itemDiv;
}

// å…¨å±€å˜é‡å­˜å‚¨å½“å‰æŸ¥çœ‹çš„æœ‹å‹åœˆID
let currentMomentId = null;

// æ˜¾ç¤ºæœ‹å‹åœˆè¯¦æƒ…é¡µ
async function showMomentDetail(momentId) {
    currentMomentId = momentId;
    const moment = await db.moments.get(momentId);
    if (!moment) return;
    
    const page = document.getElementById('moment-detail-page');
    const contentDiv = document.getElementById('moment-detail-content');
    const pinSwitch = document.getElementById('moment-pin-switch');
    const privacyText = document.getElementById('moment-privacy-text');
    
    // è·å–ç”¨æˆ·ä¿¡æ¯
    const user = await db.characters.get(moment.userId);
    
    // æ¸²æŸ“å†…å®¹é¢„è§ˆ
    contentDiv.innerHTML = `
        <div style="display:flex; gap:12px; margin-bottom:12px;">
            <div style="width:40px; height:40px; border-radius:50%; background-image:url(${user?.avatar || ''}); background-size:cover; background-position:center; flex-shrink:0;"></div>
            <div style="flex:1;">
                <div style="font-weight:600; margin-bottom:4px;">${user?.name || 'ç”¨æˆ·'}</div>
                <div style="font-size:14px; color:#666; line-height:1.6;">${moment.content}</div>
            </div>
        </div>
        ${moment.images && moment.images.length > 0 ? `
            <div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:4px; margin-top:8px;">
                ${moment.images.map(img => `<div style="padding-bottom:100%; background-image:url(${img}); background-size:cover; background-position:center; border-radius:4px;"></div>`).join('')}
            </div>
        ` : ''}
        <div style="color:#999; font-size:12px; margin-top:8px;">${formatMomentTime(moment.time)}</div>
    `;
    
    // è®¾ç½®ç½®é¡¶å¼€å…³çŠ¶æ€
    pinSwitch.checked = moment.pinned || false;
    
    // è®¾ç½®æƒé™æ˜¾ç¤º
    const privacyMap = {
        'public': 'å…¬å¼€',
        'friends': 'å¥½å‹å¯è§',
        'private': 'ç§å¯†'
    };
    privacyText.innerText = privacyMap[moment.privacy] || 'å…¬å¼€';
    
    page.style.display = 'flex';
    page.offsetHeight;
    page.classList.add('active');
}

function hideMomentDetail() {
    const page = document.getElementById('moment-detail-page');
    page.classList.remove('active');
    setTimeout(() => {
        page.style.display = 'none';
        currentMomentId = null;
    }, 300);
}

// åˆ‡æ¢ç½®é¡¶çŠ¶æ€
async function toggleMomentPin() {
    if (!currentMomentId) return;
    
    const moment = await db.moments.get(currentMomentId);
    if (!moment) return;
    
    moment.pinned = !moment.pinned;
    await db.moments.put(moment);
    
    // æ›´æ–°å¼€å…³çŠ¶æ€
    const pinSwitch = document.getElementById('moment-pin-switch');
    pinSwitch.checked = moment.pinned;
    
    showToast(moment.pinned ? 'å·²ç½®é¡¶' : 'å·²å–æ¶ˆç½®é¡¶');
    
    // åˆ·æ–°åˆ—è¡¨
    await renderMyMomentsList();
}

// æ˜¾ç¤ºæƒé™é€‰é¡¹
async function showMomentPrivacyOptions() {
    if (!currentMomentId) return;
    
    const moment = await db.moments.get(currentMomentId);
    if (!moment) return;
    
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        display: flex;
        align-items: flex-end;
        justify-content: center;
        z-index: 10000;
    `;
    
    const currentPrivacy = moment.privacy || 'public';
    
    modal.innerHTML = `
        <div style="background: #fff; width: 100%; border-radius: 12px 12px 0 0; padding: 16px; animation: slideUp 0.3s;">
            <div style="text-align: center; font-size: 14px; color: #999; margin-bottom: 16px;">è°å¯ä»¥çœ‹</div>
            <div style="display: flex; flex-direction: column; gap: 1px; background: #f5f5f5; border-radius: 8px; overflow: hidden;">
                <div onclick="setMomentPrivacy('public')" style="background: #fff; padding: 16px; text-align: center; cursor: pointer; ${currentPrivacy === 'public' ? 'color: var(--ins-pink); font-weight: 600;' : ''}">
                    å…¬å¼€
                </div>
                <div onclick="setMomentPrivacy('friends')" style="background: #fff; padding: 16px; text-align: center; cursor: pointer; ${currentPrivacy === 'friends' ? 'color: var(--ins-pink); font-weight: 600;' : ''}">
                    å¥½å‹å¯è§
                </div>
                <div onclick="setMomentPrivacy('private')" style="background: #fff; padding: 16px; text-align: center; cursor: pointer; ${currentPrivacy === 'private' ? 'color: var(--ins-pink); font-weight: 600;' : ''}">
                    ä»…è‡ªå·±å¯è§
                </div>
            </div>
            <button onclick="this.parentElement.parentElement.remove()" style="width: 100%; padding: 14px; background: #f5f5f5; border: none; border-radius: 8px; margin-top: 12px; font-size: 16px;">
                å–æ¶ˆ
            </button>
        </div>
    `;
    
    modal.onclick = (e) => {
        if (e.target === modal) modal.remove();
    };
    
    document.body.appendChild(modal);
}

// è®¾ç½®æœ‹å‹åœˆæƒé™
async function setMomentPrivacy(privacy) {
    if (!currentMomentId) return;
    
    const moment = await db.moments.get(currentMomentId);
    if (!moment) return;
    
    moment.privacy = privacy;
    await db.moments.put(moment);
    
    // æ›´æ–°æ˜¾ç¤º
    const privacyMap = {
        'public': 'å…¬å¼€',
        'friends': 'å¥½å‹å¯è§',
        'private': 'ä»…è‡ªå·±å¯è§'
    };
    document.getElementById('moment-privacy-text').innerText = privacyMap[privacy];
    
    // å…³é—­å¼¹çª—
    const modal = document.querySelector('[style*="rgba(0,0,0,0.5)"]');
    if (modal) modal.remove();
    
    showToast('å·²è®¾ç½®');
    
    // åˆ·æ–°åˆ—è¡¨
    await renderMyMomentsList();
}

// ä»è¯¦æƒ…é¡µåˆ é™¤æœ‹å‹åœˆ
async function deleteMomentFromDetail() {
    if (!currentMomentId) return;
    
    if (confirm('ç¡®å®šåˆ é™¤è¿™æ¡æœ‹å‹åœˆå—ï¼Ÿ')) {
        await db.moments.delete(currentMomentId);
        showToast('å·²åˆ é™¤');
        hideMomentDetail();
        await renderMyMomentsList();
        await renderMomentsList(); // ä¹Ÿåˆ·æ–°ä¸»æœ‹å‹åœˆåˆ—è¡¨
    }
}

function showWalletPage() {
    const walletPage = document.getElementById('wallet-page');
    walletPage.style.display = 'flex';
    walletPage.offsetHeight; 
    walletPage.classList.add('active');
    
    // æ›´æ–°æ˜¾ç¤ºçš„ä½™é¢ (ä» currentMyCharId è·å–)
    updateWalletBalanceDisplay();
}

function hideWalletPage() {
    const walletPage = document.getElementById('wallet-page');
    walletPage.classList.remove('active');
    setTimeout(() => {
        walletPage.style.display = 'none';
    }, 350);
}

// ========== è´¦å•é¡µé¢ ==========
let currentBillFilter = 'all';

function showBillPage() {
    const billPage = document.getElementById('bill-page');
    billPage.style.display = 'flex';
    billPage.offsetHeight;
    billPage.classList.add('active');
    currentBillFilter = 'all';
    renderBillList();
}

function hideBillPage() {
    const billPage = document.getElementById('bill-page');
    billPage.classList.remove('active');
    setTimeout(() => {
        billPage.style.display = 'none';
    }, 350);
}

function filterBills(filter) {
    currentBillFilter = filter;
    // æ›´æ–°æŒ‰é’®çŠ¶æ€
    document.querySelectorAll('.bill-filter-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.filter === filter);
    });
    renderBillList();
}

async function renderBillList() {
    const listEl = document.getElementById('bill-list');
    const emptyEl = document.getElementById('bill-empty');
    
    if (!currentMyCharId) {
        listEl.innerHTML = '';
        emptyEl.style.display = 'block';
        return;
    }
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    let transactions = user?.identity?.transactions || [];
    
    // ç­›é€‰
    if (currentBillFilter === 'income') {
        transactions = transactions.filter(t => t.type === 'income');
    } else if (currentBillFilter === 'expense') {
        transactions = transactions.filter(t => t.type === 'expense');
    }
    
    // æŒ‰æ—¶é—´å€’åº
    transactions = [...transactions].sort((a, b) => b.time - a.time);
    
    if (transactions.length === 0) {
        listEl.innerHTML = '';
        emptyEl.style.display = 'block';
        return;
    }
    
    emptyEl.style.display = 'none';
    
    listEl.innerHTML = transactions.map(t => {
        const isIncome = t.type === 'income';
        const iconSvg = isIncome 
            ? '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 19V5M5 12l7-7 7 7"/></svg>'
            : '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12l7 7 7-7"/></svg>';
        
        const date = new Date(t.time);
        const timeStr = `${date.getMonth()+1}æœˆ${date.getDate()}æ—¥ ${date.getHours().toString().padStart(2,'0')}:${date.getMinutes().toString().padStart(2,'0')}`;
        
        return `
            <div class="bill-item">
                <div class="bill-icon ${isIncome ? 'income' : 'expense'}">${iconSvg}</div>
                <div class="bill-info">
                    <div class="bill-title">${t.title || (isIncome ? 'æ”¶æ¬¾' : 'è½¬è´¦')}</div>
                    <div class="bill-desc">${t.desc || ''} Â· ${timeStr}</div>
                </div>
                <div class="bill-amount ${isIncome ? 'income' : 'expense'}">${isIncome ? '+' : '-'}Â¥${t.amount}</div>
            </div>
        `;
    }).join('');
}

// æ·»åŠ äº¤æ˜“è®°å½•
async function addTransaction(type, amount, title, desc) {
    if (!currentMyCharId) return;
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    if (!user) return;
    
    if (!user.identity) user.identity = {};
    if (!user.identity.transactions) user.identity.transactions = [];
    
    user.identity.transactions.push({
        type, // 'income' æˆ– 'expense'
        amount: parseFloat(amount).toFixed(2),
        title,
        desc,
        time: Date.now()
    });
    
    // åªä¿ç•™æœ€è¿‘100æ¡è®°å½•
    if (user.identity.transactions.length > 100) {
        user.identity.transactions = user.identity.transactions.slice(-100);
    }
    
    await safeCharacterPut(user);
}

// ========== äº²å±å¡é¡µé¢ ==========
let selectedFamilyCardFriendId = null;

async function showFamilyCardPage() {
    const page = document.getElementById('family-card-page');
    page.style.display = 'flex';
    page.offsetHeight;
    page.classList.add('active');
    
    // ğŸ¯ ç›´æ¥æ¸²æŸ“ï¼ˆäº²å±å¡ç°åœ¨ä¿å­˜åœ¨èŠå¤©è®°å½•ä¸­ï¼Œå’Œè½¬è´¦ä¸€æ ·ï¼‰
    renderFamilyCardList();
}

function hideFamilyCardPage() {
    const page = document.getElementById('family-card-page');
    page.classList.remove('active');
    setTimeout(() => {
        page.style.display = 'none';
    }, 350);
}

// æ¸²æŸ“äº²å±å¡åˆ—è¡¨
async function renderFamilyCardList() {
    if (!currentMyCharId) return;
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    if (!user) return;
    
    // ========== æˆ‘èµ é€çš„äº²å±å¡ ==========
    const givenListEl = document.getElementById('family-card-given-list');
    let givenHtml = '';
    
    // 1. æœ¬åœ°äº²å±å¡
    const localGivenCards = user.identity?.familyCardsGiven || [];
    for (const card of localGivenCards) {
        const char = await db.characters.get(card.charId);
        if (char) {
            const usedThisMonth = card.usedThisMonth || 0;
            const limitText = card.monthlyLimit > 0 ? `å·²ç”¨ Â¥${usedThisMonth.toFixed(2)} / Â¥${card.monthlyLimit}` : `å·²ç”¨ Â¥${usedThisMonth.toFixed(2)} (ä¸é™é¢)`;
            const _fcAid = getCurrentAccountId();
            givenHtml += `
                <div class="family-card-item">
                    <div class="family-card-avatar" style="background-image:url(${getCharAvatar(char, _fcAid)})"></div>
                    <div class="family-card-info">
                        <div class="family-card-name">${getCharDisplayName(char, _fcAid)}</div>
                        <div class="family-card-detail">${limitText}</div>
                    </div>
                    <div class="family-card-actions">
                        <button class="family-card-btn view" onclick="showFamilyCardRecords(${card.charId}, 'given')">è®°å½•</button>
                        <button class="family-card-btn cancel" onclick="cancelFamilyCard(${card.charId}, 'given')">è§£ç»‘</button>
                    </div>
                </div>
            `;
        }
    }
    
    // 2. è”æœºäº²å±å¡ï¼ˆä»èŠå¤©è®°å½•ä¸­æŸ¥æ‰¾ï¼Œå’Œè½¬è´¦ä¸€æ ·ï¼‰
    console.log('[äº²å±å¡] å¼€å§‹æŸ¥æ‰¾è”æœºäº²å±å¡...');
    const allOnlineFriends = await db.characters.where('type').equals('online_friend').toArray();
    console.log('[äº²å±å¡] æ‰¾åˆ°è”æœºå¥½å‹æ•°é‡:', allOnlineFriends.length);
    
    for (const friendChar of allOnlineFriends) {
        const history = getChatHistory(friendChar, accountId);
        if (!history) continue;
        
        // æŸ¥æ‰¾æˆ‘å‘é€çš„äº²å±å¡æ¶ˆæ¯ï¼ˆrole='user' ä¸” type='familyCard'ï¼‰
        const myFamilyCards = history.filter(msg => msg.role === 'user' && msg.type === 'familyCard');
        
        if (myFamilyCards.length > 0) {
            // åªæ˜¾ç¤ºæœ€åä¸€å¼ ï¼ˆæœ€æ–°çš„ï¼‰
            const lastCard = myFamilyCards[myFamilyCards.length - 1];
            let cardData = {};
            try {
                cardData = JSON.parse(lastCard.content);
            } catch (e) {
                cardData = { monthlyLimit: 0 };
            }
            
            const limitText = cardData.monthlyLimit > 0 ? `é¢åº¦ Â¥${cardData.monthlyLimit}` : 'ä¸é™é¢åº¦';
            givenHtml += `
                <div class="family-card-item">
                    <div class="family-card-avatar" style="background-image:url(${friendChar.avatar})"></div>
                    <div class="family-card-info">
                        <div class="family-card-name">${friendChar.name} <span style="font-size:12px;color:#999;">(è”æœº)</span></div>
                        <div class="family-card-detail">${limitText}</div>
                    </div>
                    <div class="family-card-actions">
                        <button class="family-card-btn view" onclick="showToast('è”æœºäº²å±å¡æš‚ä¸æ”¯æŒæŸ¥çœ‹è®°å½•')">è®°å½•</button>
                    </div>
                </div>
            `;
            console.log('[äº²å±å¡] æ‰¾åˆ°èµ é€ç»™', friendChar.name, 'çš„äº²å±å¡');
        }
    }
    
    givenListEl.innerHTML = givenHtml || '';
    
    // ========== æˆ‘æ”¶åˆ°çš„äº²å±å¡ ==========
    const receivedListEl = document.getElementById('family-card-received-list');
    const receivedEmptyEl = document.getElementById('family-card-received-empty');
    let receivedHtml = '';
    
    // 1. æœ¬åœ°äº²å±å¡
    const localReceivedCards = user.identity?.familyCardsReceived || [];
    for (const card of localReceivedCards) {
        const char = await db.characters.get(card.charId);
        if (char) {
            const usedThisMonth = card.usedThisMonth || 0;
            const monthlyLimit = card.monthlyLimit || 0;
            const limitText = monthlyLimit > 0 ? `æœ¬æœˆå¯ç”¨ Â¥${(monthlyLimit - usedThisMonth).toFixed(2)}` : 'ä¸é™é¢';
            const _rcAid = getCurrentAccountId();
            receivedHtml += `
                <div class="family-card-item">
                    <div class="family-card-avatar" style="background-image:url(${getCharAvatar(char, _rcAid)})"></div>
                    <div class="family-card-info">
                        <div class="family-card-name">${char.name} çš„äº²å±å¡</div>
                        <div class="family-card-detail">${limitText}</div>
                    </div>
                    <div class="family-card-actions">
                        <button class="family-card-btn view" onclick="showFamilyCardRecords(${card.charId}, 'received')">è®°å½•</button>
                    </div>
                </div>
            `;
        }
    }
    
    // 2. è”æœºäº²å±å¡ï¼ˆä»èŠå¤©è®°å½•ä¸­æŸ¥æ‰¾ï¼Œå’Œè½¬è´¦ä¸€æ ·ï¼‰
    for (const friendChar of allOnlineFriends) {
        const history = getChatHistory(friendChar, accountId);
        if (!history) continue;
        
        // æŸ¥æ‰¾å¯¹æ–¹å‘é€çš„äº²å±å¡æ¶ˆæ¯ï¼ˆrole='char' ä¸” type='familyCard'ï¼‰
        const receivedFamilyCards = history.filter(msg => msg.role === 'char' && msg.type === 'familyCard');
        
        if (receivedFamilyCards.length > 0) {
            // åªæ˜¾ç¤ºæœ€åä¸€å¼ ï¼ˆæœ€æ–°çš„ï¼‰
            const lastCard = receivedFamilyCards[receivedFamilyCards.length - 1];
            let cardData = {};
            try {
                cardData = JSON.parse(lastCard.content);
            } catch (e) {
                cardData = { monthlyLimit: 0 };
            }
            
            const limitText = cardData.monthlyLimit > 0 ? `é¢åº¦ Â¥${cardData.monthlyLimit}` : 'ä¸é™é¢';
            receivedHtml += `
                <div class="family-card-item">
                    <div class="family-card-avatar" style="background-image:url(${friendChar.avatar})"></div>
                    <div class="family-card-info">
                        <div class="family-card-name">${friendChar.name} çš„äº²å±å¡ <span style="font-size:12px;color:#999;">(è”æœº)</span></div>
                        <div class="family-card-detail">${limitText}</div>
                    </div>
                    <div class="family-card-actions">
                        <button class="family-card-btn view" onclick="showToast('è”æœºäº²å±å¡æš‚ä¸æ”¯æŒæŸ¥çœ‹è®°å½•')">è®°å½•</button>
                    </div>
                </div>
            `;
            console.log('[äº²å±å¡] æ‰¾åˆ°æ¥è‡ª', friendChar.name, 'çš„äº²å±å¡');
        }
    }
    
    if (receivedHtml) {
        receivedEmptyEl.style.display = 'none';
        receivedListEl.innerHTML = receivedHtml;
    } else {
        receivedListEl.innerHTML = '';
        receivedEmptyEl.style.display = 'block';
    }
}

// æ˜¾ç¤ºèµ é€äº²å±å¡å¼¹çª—
async function showGiveFamilyCardModal() {
    selectedFamilyCardFriendId = null;
    
    const modal = document.getElementById('give-family-card-modal');
    const listEl = document.getElementById('family-card-friend-list');
    
    // è·å–å¥½å‹åˆ—è¡¨
    const user = await db.characters.get(parseInt(currentMyCharId));
    const accountId = getCurrentAccountId();
    const allChars = await db.characters.toArray();
    
    // è¿‡æ»¤å‡ºå¥½å‹ï¼ˆåŒ…æ‹¬æœ¬åœ°å¥½å‹å’Œè”æœºå¥½å‹ï¼‰
    const friends = allChars.filter(c => {
        if (c.type === 'user') return false;
        // âœ… åŒ…å«è”æœºå¥½å‹
        if (c.type === 'online_friend') return true;
        // æ£€æŸ¥æ™®é€šå¥½å‹çŠ¶æ€
        const status = getFriendStatus(c, accountId);
        return status === 'friend';
    });
    
    console.log('[äº²å±å¡] æ‰¾åˆ°å¥½å‹æ€»æ•°:', friends.length, 'å…¶ä¸­è”æœºå¥½å‹:', friends.filter(f => f.type === 'online_friend').length);
    
    // æ’é™¤å·²ç»èµ é€è¿‡äº²å±å¡çš„ï¼ˆæœ¬åœ°å¥½å‹ï¼‰
    const givenCards = user?.identity?.familyCardsGiven || [];
    const givenIds = givenCards.map(c => c.charId);
    
    // âœ… æ’é™¤å·²ç»åœ¨èŠå¤©è®°å½•ä¸­èµ é€è¿‡äº²å±å¡çš„ï¼ˆè”æœºå¥½å‹ï¼‰
    const availableFriends = friends.filter(f => {
        // æœ¬åœ°å¥½å‹ï¼šæ£€æŸ¥ givenIds
        if (f.type !== 'online_friend') {
            return !givenIds.includes(f.id);
        }
        
        // è”æœºå¥½å‹ï¼šæ£€æŸ¥èŠå¤©è®°å½•ä¸­æ˜¯å¦æœ‰å·²å‘é€çš„äº²å±å¡
        const history = getChatHistory(f, accountId);
        if (!history) return true;
        const hasSent = history.some(msg => msg.role === 'user' && msg.type === 'familyCard');
        return !hasSent;
    });
    
    if (availableFriends.length === 0) {
        listEl.innerHTML = '<div style="text-align:center; padding:20px; color:#999;">æ²¡æœ‰å¯èµ é€çš„å¥½å‹</div>';
    } else {
        listEl.innerHTML = availableFriends.map(f => {
            // âœ… ç»™è”æœºå¥½å‹æ·»åŠ æ ‡è®°
            const isOnline = f.type === 'online_friend';
            const onlineTag = isOnline ? '<span style="background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); color:#fff; font-size:10px; padding:2px 6px; border-radius:3px; margin-left:6px;">è”æœº</span>' : '';
            
            return `
                <div class="family-card-friend-item" onclick="selectFamilyCardFriend(${f.id}, this)">
                    <div class="family-card-friend-avatar" style="background-image:url(${f.avatar})"></div>
                    <div class="family-card-friend-name">${f.name}${onlineTag}</div>
                    <div class="family-card-friend-check">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="3">
                            <polyline points="20 6 9 17 4 12"></polyline>
                        </svg>
                    </div>
                </div>
            `;
        }).join('');
    }
    
    document.getElementById('family-card-limit-input').value = '0';
    modal.style.display = 'flex';
}

function hideGiveFamilyCardModal() {
    document.getElementById('give-family-card-modal').style.display = 'none';
}

function selectFamilyCardFriend(charId, el) {
    // å–æ¶ˆå…¶ä»–é€‰ä¸­
    document.querySelectorAll('.family-card-friend-item').forEach(item => {
        item.classList.remove('selected');
    });
    el.classList.add('selected');
    selectedFamilyCardFriendId = charId;
}

// ç¡®è®¤èµ é€äº²å±å¡
async function confirmGiveFamilyCard() {
    if (!selectedFamilyCardFriendId) {
        showToast('è¯·é€‰æ‹©ä¸€ä¸ªå¥½å‹');
        return;
    }
    
    const limitInput = document.getElementById('family-card-limit-input');
    const monthlyLimit = parseFloat(limitInput.value) || 0;
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    const char = await db.characters.get(selectedFamilyCardFriendId);
    
    if (!char) {
        showToast('å¥½å‹ä¸å­˜åœ¨');
        return;
    }
    
    const accountId = getCurrentAccountId();
    
    // âœ… åˆ¤æ–­æ˜¯å¦æ˜¯è”æœºå¥½å‹
    if (char.type === 'online_friend') {
        console.log('[äº²å±å¡] æ£€æµ‹åˆ°è”æœºå¥½å‹ï¼Œé€šè¿‡æ¶ˆæ¯é€šé“å‘é€');
        // è”æœºå¥½å‹ - é€šè¿‡æ¶ˆæ¯é€šé“å‘é€ï¼ˆå’Œè½¬è´¦ä¸€æ ·ï¼‰
        const onlineUserChar = await getOrCreateOnlineUserChar();
        
        if (onlineUserChar && onlineConnected && char.onlineData?.wx_account) {
            const fromWxAccount = onlineUserChar.identity.account;
            const toWxAccount = char.onlineData.wx_account;
            
            // é€šè¿‡æ¶ˆæ¯é€šé“å‘é€
            const familyCardContent = JSON.stringify({
                __type: 'familyCard',
                monthlyLimit: monthlyLimit,
                fromName: onlineUserChar.name
            });
            
            const sent = sendOnlineMessage(toWxAccount, familyCardContent, fromWxAccount);
            
            if (sent) {
                // ä¿å­˜åˆ°èŠå¤©è®°å½•
                let history = getChatHistory(char, accountId);
                const familyCardMsg = {
                    role: 'user',
                    type: 'familyCard',
                    content: JSON.stringify({
                        fromName: onlineUserChar.name,
                        monthlyLimit: monthlyLimit,
                        status: 'sent',
                        isOnline: true
                    }),
                    time: Date.now()
                };
                
                history.push(familyCardMsg);
                await setChatHistory(char, accountId, history);
                
                console.log('[äº²å±å¡] âœ… è”æœºäº²å±å¡å·²å‘é€');
                showToast('å·²èµ é€äº²å±å¡');
            } else {
                console.error('[äº²å±å¡] âŒ å‘é€å¤±è´¥');
                showToast('å‘é€å¤±è´¥ï¼Œè¯·æ£€æŸ¥è¿æ¥');
                return;
            }
        } else {
            console.error('[äº²å±å¡] âŒ æ¡ä»¶ä¸æ»¡è¶³');
            showToast('è¯·ç¡®ä¿å·²è¿æ¥æœåŠ¡å™¨');
            return;
        }
    } else {
        // æœ¬åœ°å¥½å‹ - åŸæœ‰é€»è¾‘
        console.log('[äº²å±å¡] æœ¬åœ°å¥½å‹ï¼Œä½¿ç”¨åŸæœ‰é€»è¾‘');
        
        if (!user.identity) user.identity = {};
        if (!user.identity.familyCardsGiven) user.identity.familyCardsGiven = [];
        
        // æ·»åŠ äº²å±å¡è®°å½•
        user.identity.familyCardsGiven.push({
            charId: selectedFamilyCardFriendId,
            monthlyLimit: monthlyLimit,
            usedThisMonth: 0,
            records: [],
            createdAt: Date.now()
        });
        
        await safeCharacterPut(user);
        
        // åŒæ—¶åœ¨è§’è‰²é‚£è¾¹æ·»åŠ æ”¶åˆ°çš„äº²å±å¡è®°å½•
        if (!char.identity) char.identity = {};
        if (!char.identity.familyCardsReceived) char.identity.familyCardsReceived = [];
        
        char.identity.familyCardsReceived.push({
            charId: parseInt(currentMyCharId),
            monthlyLimit: monthlyLimit,
            usedThisMonth: 0,
            records: [],
            createdAt: Date.now()
        });
        
        await safeCharacterPut(char);
        
        // å‘é€äº²å±å¡æ¶ˆæ¯åˆ°èŠå¤©
        let history = getChatHistory(char, accountId);
        
        const familyCardMsg = {
            role: 'user',
            type: 'familyCard',
            content: JSON.stringify({
                fromName: user.name,
                monthlyLimit: monthlyLimit,
                status: 'sent'
            }),
            time: Date.now()
        };
        
        history.push(familyCardMsg);
        await setChatHistory(char, accountId, history);
        
        showToast('å·²èµ é€äº²å±å¡');
    }
    
    hideGiveFamilyCardModal();
    hideFamilyCardPage();
    hideWalletPage();
    
    // å¦‚æœå½“å‰æ­£åœ¨å’Œè¿™ä¸ªè§’è‰²èŠå¤©ï¼Œåˆ·æ–°èŠå¤©ç•Œé¢
    if (currentChatCharId === selectedFamilyCardFriendId) {
        const freshChar = await db.characters.get(selectedFamilyCardFriendId);
        renderChatBody(freshChar);
    }
}

// å–æ¶ˆäº²å±å¡
async function cancelFamilyCard(charId, type) {
    if (!confirm('ç¡®å®šè¦è§£ç»‘è¿™å¼ äº²å±å¡å—ï¼Ÿ')) return;
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    
    if (type === 'given') {
        // ä»æˆ‘èµ é€çš„åˆ—è¡¨ä¸­ç§»é™¤
        user.identity.familyCardsGiven = (user.identity.familyCardsGiven || []).filter(c => c.charId !== charId);
        await safeCharacterPut(user);
        
        // ä»å¯¹æ–¹æ”¶åˆ°çš„åˆ—è¡¨ä¸­ç§»é™¤
        const char = await db.characters.get(charId);
        if (char && char.identity) {
            char.identity.familyCardsReceived = (char.identity.familyCardsReceived || []).filter(c => c.charId !== parseInt(currentMyCharId));
            await safeCharacterPut(char);
        }
    }
    
    renderFamilyCardList();
    showToast('å·²è§£ç»‘äº²å±å¡');
}

// æ˜¾ç¤ºæ¶ˆè´¹è®°å½•
async function showFamilyCardRecords(charId, type) {
    const modal = document.getElementById('family-card-records-modal');
    const titleEl = document.getElementById('family-card-records-title');
    const listEl = document.getElementById('family-card-records-list');
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    const char = await db.characters.get(charId);
    
    let records = [];
    
    if (type === 'given') {
        // æŸ¥çœ‹æˆ‘èµ é€ç»™å¯¹æ–¹çš„æ¶ˆè´¹è®°å½•
        const card = (user.identity?.familyCardsGiven || []).find(c => c.charId === charId);
        records = card?.records || [];
        titleEl.textContent = `${char?.name || 'æœªçŸ¥'} çš„æ¶ˆè´¹è®°å½•`;
    } else {
        // æŸ¥çœ‹æˆ‘ä½¿ç”¨å¯¹æ–¹äº²å±å¡çš„æ¶ˆè´¹è®°å½•
        const card = (user.identity?.familyCardsReceived || []).find(c => c.charId === charId);
        records = card?.records || [];
        titleEl.textContent = `æˆ‘çš„æ¶ˆè´¹è®°å½•`;
    }
    
    if (records.length === 0) {
        listEl.innerHTML = '<div style="text-align:center; padding:30px; color:#999;">æš‚æ— æ¶ˆè´¹è®°å½•</div>';
    } else {
        listEl.innerHTML = [...records].reverse().map(r => {
            const date = new Date(r.time);
            const timeStr = `${date.getMonth()+1}æœˆ${date.getDate()}æ—¥ ${date.getHours().toString().padStart(2,'0')}:${date.getMinutes().toString().padStart(2,'0')}`;
            return `
                <div class="family-card-record-item">
                    <div class="family-card-record-title">${r.desc || 'æ¶ˆè´¹'}</div>
                    <div class="family-card-record-time">${timeStr}</div>
                    <div class="family-card-record-amount">-Â¥${parseFloat(r.amount).toFixed(2)}</div>
                </div>
            `;
        }).join('');
    }
    
    modal.style.display = 'flex';
}

function hideFamilyCardRecordsModal() {
    document.getElementById('family-card-records-modal').style.display = 'none';
}

// è§’è‰²ä½¿ç”¨äº²å±å¡æ¶ˆè´¹ï¼ˆAIè°ƒç”¨ï¼‰
async function charUseFamilyCard(charId, amount, desc) {
    if (!currentMyCharId) return false;
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    if (!user?.identity?.familyCardsGiven) return false;
    
    const cardIndex = user.identity.familyCardsGiven.findIndex(c => c.charId === charId);
    if (cardIndex === -1) return false;
    
    const card = user.identity.familyCardsGiven[cardIndex];
    
    // æ£€æŸ¥é¢åº¦
    if (card.monthlyLimit > 0 && (card.usedThisMonth + amount) > card.monthlyLimit) {
        return false; // è¶…å‡ºé¢åº¦
    }
    
    // æ‰£æ¬¾
    let userBalance = parseFloat(user.identity.balance || 0);
    if (userBalance < amount) return false; // ä½™é¢ä¸è¶³
    
    user.identity.balance = (userBalance - amount).toFixed(2);
    card.usedThisMonth = (card.usedThisMonth || 0) + amount;
    card.records.push({
        amount: amount,
        desc: desc,
        time: Date.now()
    });
    
    await safeCharacterPut(user);
    
    // åŒæ—¶æ›´æ–°è§’è‰²é‚£è¾¹çš„è®°å½•
    const char = await db.characters.get(charId);
    if (char?.identity?.familyCardsReceived) {
        const charCard = char.identity.familyCardsReceived.find(c => c.charId === parseInt(currentMyCharId));
        if (charCard) {
            charCard.usedThisMonth = (charCard.usedThisMonth || 0) + amount;
            charCard.records.push({
                amount: amount,
                desc: desc,
                time: Date.now()
            });
            await safeCharacterPut(char);
        }
    }
    
    // æ·»åŠ åˆ°è´¦å•
    await addTransaction('expense', amount, 'äº²å±å¡æ¶ˆè´¹', `${char?.name || 'æœªçŸ¥'} - ${desc}`);
    
    return true;
}

function showBalancePage() {
    const balancePage = document.getElementById('balance-page');
    balancePage.style.display = 'flex';
    balancePage.offsetHeight; 
    balancePage.classList.add('active');
    
    // æ›´æ–°å¤§å­—ä½™é¢
    updateBalancePageDisplay();
}

function hideBalancePage() {
    const balancePage = document.getElementById('balance-page');
    balancePage.classList.remove('active');
    setTimeout(() => {
        balancePage.style.display = 'none';
    }, 350);
    
    // è¿”å›æ—¶åŒæ—¶ä¹Ÿæ›´æ–°ä¸€ä¸‹é’±åŒ…é¡µçš„ä½™é¢æ˜¾ç¤ºï¼Œä»¥é˜²åˆšæ‰ç”Ÿæˆäº†æ–°çš„
    updateWalletBalanceDisplay();
}

// æ›´æ–°é’±åŒ…é¡µçš„å°ä½™é¢æ˜¾ç¤º
async function updateWalletBalanceDisplay() {
    if (!currentMyCharId) return;
    const user = await db.characters.get(parseInt(currentMyCharId));
    if (user && user.identity && user.identity.balance !== undefined) {
        // å‡è®¾ identity.balance å­˜å‚¨çš„æ˜¯æ•°å­—æˆ–å­—ç¬¦ä¸²
        document.querySelector('#wallet-page .item-right span').innerText = `Â¥${user.identity.balance}`;
        // åŒæ—¶æ›´æ–°æœåŠ¡é¡µçš„ä½™é¢
        const serviceBalance = document.querySelector('.header-item .item-subtitle');
        if (serviceBalance) serviceBalance.style.display = 'none'; // éšè—ä½™é¢
    } else {
         document.querySelector('#wallet-page .item-right span').innerText = `Â¥0.00`;
         const serviceBalance = document.querySelector('.header-item .item-subtitle');
         if (serviceBalance) serviceBalance.style.display = 'none'; // éšè—ä½™é¢
    }
}

// æ›´æ–°é›¶é’±é¡µçš„å¤§ä½™é¢æ˜¾ç¤º
async function updateBalancePageDisplay() {
    if (!currentMyCharId) return;
    const user = await db.characters.get(parseInt(currentMyCharId));
    const amountDisplay = document.getElementById('balance-amount-display');
    if (user && user.identity && user.identity.balance !== undefined) {
        amountDisplay.innerText = `Â¥${user.identity.balance}`;
    } else {
        amountDisplay.innerText = `Â¥0.00`;
    }
}

// AIç”Ÿæˆä½™é¢é€»è¾‘
async function generateUserBalance() {
    if (!currentMyCharId) {
        alert("è¯·å…ˆé€‰æ‹©ä¸€ä¸ª User èº«ä»½");
        return;
    }

    const user = await db.characters.get(parseInt(currentMyCharId));
    if (!user) {
        alert("æœªæ‰¾åˆ°è¯¥è§’è‰²ä¿¡æ¯");
        return;
    }
    
    // è°ƒè¯•æ—¥å¿—ï¼šç¡®è®¤è¯»å–åˆ°çš„ç”¨æˆ·ä¿¡æ¯ï¼ˆè¯»å–å®Œæ•´çš„è§’è‰²æ¡£æ¡ˆï¼‰
    console.log('[generateUserBalance] è¯»å–åˆ°çš„å®Œæ•´è§’è‰²æ¡£æ¡ˆ:', user);
    
    // è¯»å–è§’è‰²æè¿°ï¼ˆä½¿ç”¨ description å­—æ®µï¼Œè€Œä¸æ˜¯ descï¼‰
    const characterDescription = user.description || user.desc || '';
    
    // æ£€æŸ¥äººè®¾æè¿°æ˜¯å¦å­˜åœ¨
    if (!characterDescription || characterDescription.trim() === '' || characterDescription === 'æš‚æ— æè¿°') {
        console.warn('[generateUserBalance] è­¦å‘Šï¼šè§’è‰²æè¿°ä¸ºç©ºæˆ–æœªè®¾ç½®');
        const confirmContinue = confirm("âš ï¸ è¯¥è§’è‰²çš„äººè®¾æè¿°ä¸ºç©ºæˆ–æœªè®¾ç½®ï¼Œç”Ÿæˆçš„ä½™é¢å¯èƒ½ä¸å‡†ç¡®ã€‚\n\næ˜¯å¦ç»§ç»­ç”Ÿæˆï¼Ÿ\nï¼ˆå»ºè®®å…ˆå®Œå–„è§’è‰²äººè®¾æè¿°ï¼‰");
        if (!confirmContinue) {
            return;
        }
    }
    
    const btn = document.querySelector('.btn-generate');
    const originalText = btn.innerHTML;
    btn.innerHTML = `<div class="loading-spinner" style="display:inline-block; border-color:var(--ins-pink); border-top-color:transparent;"></div> ç”Ÿæˆä¸­...`;
    btn.disabled = true;

    try {
        // æ„å»ºå®Œæ•´çš„äººè®¾ä¿¡æ¯ï¼ˆè¯»å–å®Œæ•´çš„è§’è‰²æ¡£æ¡ˆï¼‰
        const characterInfo = [];
        characterInfo.push(`è§’è‰²åç§°ï¼š${user.name || 'æœªå‘½å'}`);
        
        if (user.nick) {
            characterInfo.push(`è§’è‰²æ˜µç§°ï¼š${user.nick}`);
        }
        
        // è¯»å–è§’è‰²æè¿°ï¼ˆä¼˜å…ˆä½¿ç”¨ descriptionï¼Œå…¼å®¹ descï¼‰
        if (characterDescription && characterDescription.trim() && characterDescription !== 'æš‚æ— æè¿°') {
            characterInfo.push(`è§’è‰²äººè®¾æè¿°ï¼š${characterDescription.trim()}`);
        } else {
            characterInfo.push(`è§’è‰²äººè®¾æè¿°ï¼šæš‚æ— è¯¦ç»†æè¿°`);
        }
        
        if (user.type) {
            characterInfo.push(`è§’è‰²ç±»å‹ï¼š${user.type}`);
        }
        
        // è¯»å–å®Œæ•´çš„èº«ä»½ä¿¡æ¯
        if (user.identity) {
            if (user.identity.address) {
                characterInfo.push(`å®¶åº­ä½å€ï¼š${user.identity.address}`);
            }
            if (user.identity.bank_card) {
                characterInfo.push(`é“¶è¡Œå¡å·ï¼š${user.identity.bank_card}`);
            }
        }
        
        const fullCharacterInfo = characterInfo.join('\n');
        
        const systemPrompt = `ä½ æ˜¯ä¸€ä¸ªè¾…åŠ©ç”Ÿæˆè§’è‰²è¯¦ç»†è®¾å®šçš„AIåŠ©æ‰‹ã€‚

ä»¥ä¸‹æ˜¯å½“å‰è§’è‰²çš„å®Œæ•´ä¿¡æ¯ï¼š
${fullCharacterInfo}

è¯·ä»”ç»†åˆ†æä¸Šè¿°è§’è‰²çš„äººè®¾ä¿¡æ¯ï¼ˆç‰¹åˆ«æ˜¯è§’è‰²æè¿°ä¸­çš„èƒŒæ™¯ã€èŒä¸šã€ç»æµçŠ¶å†µã€ç¤¾ä¼šåœ°ä½ç­‰ï¼‰ï¼Œç„¶ååˆç†æ¨æ–­è¯¥è§’è‰²å¾®ä¿¡é’±åŒ…é‡Œçš„"é›¶é’±"ä½™é¢ã€‚

é‡è¦æç¤ºï¼š
1. å¿…é¡»ä¸¥æ ¼æ ¹æ®è§’è‰²äººè®¾æ¥ç”Ÿæˆä½™é¢ï¼Œä¸è¦ä½¿ç”¨é»˜è®¤å€¼æˆ–éšæœºå€¼
2. å¦‚æœè§’è‰²æè¿°ä¸­æåˆ°"å¯ŒäºŒä»£"ã€"å¯Œè£•"ã€"æœ‰é’±"ã€"å®¶å¢ƒä¼˜æ¸¥"ç­‰å…³é”®è¯ï¼Œä½™é¢åº”è¯¥è¾ƒé«˜ï¼ˆå‡ ä¸‡åˆ°å‡ åä¸‡ï¼‰
3. å¦‚æœè§’è‰²æè¿°ä¸­æåˆ°"å­¦ç”Ÿ"ã€"æ™®é€š"ã€"å·¥è–ª"ç­‰å…³é”®è¯ï¼Œä½™é¢åº”è¯¥é€‚ä¸­ï¼ˆå‡ ç™¾åˆ°å‡ åƒï¼‰
4. å¦‚æœè§’è‰²æè¿°ä¸­æåˆ°"è´«å›°"ã€"æ‹®æ®"ç­‰å…³é”®è¯ï¼Œä½™é¢åº”è¯¥è¾ƒä½ï¼ˆå‡ ååˆ°å‡ ç™¾ï¼‰
5. åªè¿”å›ä¸€ä¸ªå…·ä½“çš„æ•°å­—é‡‘é¢ï¼Œä¿ç•™ä¸¤ä½å°æ•°ï¼Œä¸è¦åŒ…å«ä»»ä½•å…¶ä»–æ–‡å­—ã€ç¬¦å·æˆ–è¯´æ˜
6. å¦‚æœæ˜¯å¤ä»£/æ¶ç©ºèƒŒæ™¯ï¼Œè¯·è‡ªåŠ¨æ¢ç®—æˆåˆç†çš„ç°ä»£è´§å¸æ•°å€¼

ç¤ºä¾‹ï¼š
- å¯ŒäºŒä»£è§’è‰²ï¼šåº”è¿”å› 50000.00 æˆ–æ›´é«˜
- æ™®é€šå­¦ç”Ÿï¼šåº”è¿”å› 1500.00 å·¦å³
- æ™®é€šæ‰“å·¥äººï¼šåº”è¿”å› 3000.00 å·¦å³`;

        console.log('[generateUserBalance] å‘é€ç»™AIçš„Prompt:', systemPrompt);
        
        const amountStr = await callAI([
            { role: "system", content: systemPrompt },
            { role: "user", content: "è¯·æ ¹æ®ä¸Šè¿°è§’è‰²äººè®¾ä¿¡æ¯ï¼Œç”Ÿæˆç¬¦åˆè¯¥è§’è‰²ç»æµçŠ¶å†µçš„å¾®ä¿¡é›¶é’±ä½™é¢ã€‚åªè¿”å›æ•°å­—é‡‘é¢ï¼Œä¿ç•™ä¸¤ä½å°æ•°ã€‚" }
        ]);
        
        console.log('[generateUserBalance] AIè¿”å›çš„åŸå§‹å†…å®¹:', amountStr);

        // æå–æ•°å­—
        const match = amountStr.match(/[\d,]+\.\d{2}/) || amountStr.match(/\d+/);
        let balance = "0.00";
        if (match) {
            balance = match[0];
        } else {
            // å…œåº•å°è¯•æ¸…ç†éæ•°å­—å­—ç¬¦
             balance = amountStr.replace(/[^\d.]/g, '');
        }

        // ä¿å­˜åˆ°æ•°æ®åº“
        if (!user.identity) user.identity = {};
        user.identity.balance = balance;
        await safeCharacterPut(user);

        // æ›´æ–°ç•Œé¢
        document.getElementById('balance-amount-display').innerText = `Â¥${balance}`;
        updateWalletBalanceDisplay(); // åŒæ­¥æ›´æ–°ä¸Šä¸€é¡µ

        // ç®€æ˜“ Toast
        const tip = document.getElementById('save-tip');
        tip.innerText = "ä½™é¢å·²ç”Ÿæˆ";
        tip.style.display = 'block';
        setTimeout(() => { 
            tip.style.display = 'none'; 
            tip.innerText = "ä¿å­˜æˆåŠŸï¼"; // è¿˜åŸé»˜è®¤æ–‡æœ¬
        }, 1500);

    } catch (e) {
        console.error(e);
        const tip = document.getElementById('save-tip');
        tip.innerText = "ç”Ÿæˆå¤±è´¥";
        tip.style.display = 'block';
        setTimeout(() => { tip.style.display = 'none'; }, 1500);
    } finally {
        btn.innerHTML = originalText;
        btn.disabled = false;
    }
}


/* =================
   è½¬è´¦åŠŸèƒ½é€»è¾‘
   ================= */

// ç®€æ˜“Toastå‡½æ•° (å¦‚æœæ²¡æœ‰å®šä¹‰çš„è¯)
function showToast(message) {
    const tip = document.getElementById('save-tip');
    if (tip) {
        tip.innerText = message;
        tip.style.display = 'block';
        setTimeout(() => { 
            tip.style.display = 'none'; 
            tip.innerText = "ä¿å­˜æˆåŠŸï¼"; // è¿˜åŸé»˜è®¤æ–‡æœ¬
        }, 1500);
    } else {
        alert(message);
    }
}

// æ‰“å¼€è½¬è´¦é¡µé¢
async function showTransferPage() {
    // å…³é—­æ›´å¤šé¢æ¿
    closeChatPanel();
    
    // åˆ¤æ–­æ˜¯å¦æ˜¯ç¾¤èŠ
    if (window.currentGroupChatId) {
        // ç¾¤èŠï¼šæ˜¾ç¤ºè½¬è´¦ç±»å‹é€‰æ‹©å¼¹çª—
        document.getElementById('group-transfer-type-modal').style.display = 'flex';
        return;
    }
    
    // â˜… fpæ¨¡å¼ï¼šç”¨è”ç³»äººä¿¡æ¯æ˜¾ç¤ºè½¬è´¦ç›®æ ‡
    if (window._fpChatMode) {
        if (!window._fpContactCharId) { showToast("è¯·å…ˆè¿›å…¥èŠå¤©"); return; }
        const contactChar = await db.characters.get(window._fpContactCharId);
        if (!contactChar) { showToast("è”ç³»äººä¸å­˜åœ¨"); return; }
        
        const fpAccountId = window._fpAccountId;
        const contactName = window._fpContactName || contactChar.name;
        const contactAvatar = window._fpContactAvatar || getCharAvatar(contactChar, fpAccountId) || contactChar.avatar || '';
        
        document.getElementById('t-target-name').innerText = contactName;
        document.getElementById('t-target-avatar').style.backgroundImage = contactAvatar ? 'url(' + contactAvatar + ')' : '';
        
        // é‡ç½®è¾“å…¥
        document.getElementById('t-amount-input').value = '';
        document.getElementById('t-note-input').value = '';
        document.getElementById('btn-do-transfer').disabled = true;
        
        const page = document.getElementById('transfer-page');
        page.style.zIndex = '400'; // é«˜äº fp æ¨¡å¼çš„ chat-window(350)
        page.style.display = 'flex';
        return;
    }
    
    if (!currentChatCharId) {
        showToast("è¯·å…ˆè¿›å…¥èŠå¤©");
        return;
    }
    
    // è·å–å½“å‰èŠå¤©å¯¹è±¡ä¿¡æ¯
    const chatChar = await db.characters.get(currentChatCharId);
    if (!chatChar) return;
    
    document.getElementById('t-target-name').innerText = chatChar.name;
    document.getElementById('t-target-avatar').style.backgroundImage = 'url(' + chatChar.avatar + ')';
    
    // é‡ç½®è¾“å…¥
    document.getElementById('t-amount-input').value = '';
    document.getElementById('t-note-input').value = '';
    document.getElementById('btn-do-transfer').disabled = true;
    
    const page = document.getElementById('transfer-page');
    page.style.zIndex = ''; // æ­£å¸¸æ¨¡å¼æ¢å¤é»˜è®¤
    page.style.display = 'flex';
}

function hideTransferPage() {
    const page = document.getElementById('transfer-page');
    page.style.display = 'none';
    page.style.zIndex = ''; // æ¢å¤é»˜è®¤z-index
}

/* =================
   ç¾¤çº¢åŒ…åŠŸèƒ½
   ================= */

let currentRedPacketType = 'lucky'; // é»˜è®¤æ‹¼æ‰‹æ°”çº¢åŒ…

// æ˜¾ç¤ºç¾¤çº¢åŒ…é¡µé¢
function showGroupRedPacketPage() {
    closeModal('group-transfer-type-modal');
    
    // é‡ç½®è¾“å…¥
    document.getElementById('rp-amount-input').value = '';
    document.getElementById('rp-count-input').value = '';
    document.getElementById('rp-wish-input').value = '';
    document.getElementById('rp-total-hint').innerText = 'å…±0.00å…ƒ';
    document.getElementById('btn-send-redpacket').disabled = true;
    document.getElementById('btn-send-redpacket').style.background = '#ccc';
    document.getElementById('btn-send-redpacket').style.cursor = 'not-allowed';
    
    // é»˜è®¤é€‰ä¸­æ‹¼æ‰‹æ°”
    selectRedPacketType('lucky');
    
    document.getElementById('group-redpacket-page').style.display = 'flex';
}

function hideGroupRedPacketPage() {
    document.getElementById('group-redpacket-page').style.display = 'none';
}

// é€‰æ‹©çº¢åŒ…ç±»å‹
function selectRedPacketType(type) {
    currentRedPacketType = type;
    
    const luckyEl = document.getElementById('rp-type-lucky');
    const normalEl = document.getElementById('rp-type-normal');
    
    if (type === 'lucky') {
        luckyEl.style.borderColor = '#333';
        luckyEl.style.background = '#fff';
        luckyEl.querySelector('div:first-child').style.color = '#333';
        
        normalEl.style.borderColor = '#e8e8e8';
        normalEl.style.background = '#fff';
        normalEl.querySelector('div:first-child').style.color = '#666';
    } else {
        normalEl.style.borderColor = '#333';
        normalEl.style.background = '#fff';
        normalEl.querySelector('div:first-child').style.color = '#333';
        
        luckyEl.style.borderColor = '#e8e8e8';
        luckyEl.style.background = '#fff';
        luckyEl.querySelector('div:first-child').style.color = '#666';
    }
}

// æ£€æŸ¥çº¢åŒ…è¾“å…¥
function checkRedPacketInput() {
    const amount = parseFloat(document.getElementById('rp-amount-input').value) || 0;
    const count = parseInt(document.getElementById('rp-count-input').value) || 0;
    
    document.getElementById('rp-total-hint').innerText = `å…±${amount.toFixed(2)}å…ƒ`;
    
    const btn = document.getElementById('btn-send-redpacket');
    if (amount > 0 && count > 0) {
        btn.disabled = false;
        btn.style.background = '#333';
        btn.style.cursor = 'pointer';
    } else {
        btn.disabled = true;
        btn.style.background = '#ccc';
        btn.style.cursor = 'not-allowed';
    }
}

// å‘é€ç¾¤çº¢åŒ…
async function sendGroupRedPacket() {
    if (!window.currentGroupChatId) return;
    
    const amount = parseFloat(document.getElementById('rp-amount-input').value);
    const count = parseInt(document.getElementById('rp-count-input').value);
    const wish = document.getElementById('rp-wish-input').value.trim() || 'æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©';
    
    if (!amount || amount <= 0 || !count || count <= 0) {
        showToast('è¯·å¡«å†™æ­£ç¡®çš„é‡‘é¢å’Œä¸ªæ•°');
        return;
    }
    
    // æ£€æŸ¥ä½™é¢
    if (!currentMyCharId) {
        showToast("è¯·å…ˆè®¾ç½®Userèº«ä»½");
        return;
    }
    const user = await db.characters.get(parseInt(currentMyCharId));
    let currentBalance = 0;
    if (user && user.identity && user.identity.balance) {
        currentBalance = parseFloat(user.identity.balance.toString().replace(/,/g, ''));
    }
    
    if (currentBalance < amount) {
        showToast('ä½™é¢ä¸è¶³ (å½“å‰: Â¥' + currentBalance.toFixed(2) + ')');
        return;
    }
    
    // æ‰£æ¬¾
    const newBalance = currentBalance - amount;
    user.identity.balance = newBalance.toFixed(2);
    await safeCharacterPut(user);
    
    // æ„å»ºçº¢åŒ…æ¶ˆæ¯
    const group = await db.group_chats.get(window.currentGroupChatId);
    if (!group) return;
    
    const redPacketData = {
        type: 'redpacket',
        redpacketType: currentRedPacketType, // 'lucky' æˆ– 'normal'
        totalAmount: amount.toFixed(2),
        count: count,
        wish: wish,
        claimed: [], // å·²é¢†å–çš„æˆå‘˜IDåˆ—è¡¨
        claimedAmounts: {}, // æ¯ä¸ªæˆå‘˜é¢†å–çš„é‡‘é¢
        id: 'rp_' + Date.now()
    };
    
    if (!group.chat_history) group.chat_history = [];
    group.chat_history.push({
        role: 'user',
        type: 'redpacket',
        content: JSON.stringify(redPacketData),
        time: Date.now()
    });
    group.updated_at = Date.now();
    await safeGroupChatPut(group);
    
    // è®°å½•è´¦å•
    await addTransaction('expense', amount, 'å‘çº¢åŒ…', `${group.name} Â· ${count}ä¸ªçº¢åŒ…`);
    
    hideGroupRedPacketPage();
    await renderGroupChatBody(group);
    showToast('çº¢åŒ…å·²å‘å‡º');
}

/* =================
   ä¸“å±è½¬è´¦åŠŸèƒ½
   ================= */

let exclusiveTransferTarget = null; // å½“å‰é€‰ä¸­çš„è½¬è´¦ç›®æ ‡

// æ˜¾ç¤ºä¸“å±è½¬è´¦é€‰äººå¼¹çª—
async function showExclusiveTransferPage() {
    closeModal('group-transfer-type-modal');
    
    if (!window.currentGroupChatId) return;
    
    const group = await db.group_chats.get(window.currentGroupChatId);
    if (!group) return;
    
    const listEl = document.getElementById('exclusive-member-list');
    listEl.innerHTML = '';
    
    // æ¸²æŸ“ç¾¤æˆå‘˜åˆ—è¡¨ï¼ˆä¸åŒ…æ‹¬è‡ªå·±ï¼‰
    for (const memberId of group.memberIds) {
        const char = await db.characters.get(memberId);
        if (!char) continue;
        
        const _exAid = getCurrentAccountId();
        const _exAvatar = getCharAvatar(char, _exAid);
        const avatarStyle = _exAvatar ? `background-image:url(${_exAvatar})` : 'background:#ccc';
        const memberNicknames = group.memberNicknames || {};
        const displayName = memberNicknames[memberId] || getCharDisplayName(char, _exAid);
        
        const item = document.createElement('div');
        item.style.cssText = 'display:flex; align-items:center; padding:12px 16px; cursor:pointer; transition:background 0.2s;';
        item.onmouseover = () => item.style.background = '#f5f5f5';
        item.onmouseout = () => item.style.background = '';
        item.innerHTML = `
            <div style="width:44px; height:44px; border-radius:6px; ${avatarStyle}; background-size:cover; background-position:center; margin-right:12px;"></div>
            <div style="flex:1;">
                <div style="font-size:16px; color:#333;">${displayName}</div>
                <div style="font-size:12px; color:#999;">${char.name}</div>
            </div>
        `;
        item.onclick = () => selectExclusiveTarget(memberId, char, displayName);
        
        listEl.appendChild(item);
    }
    
    if (group.memberIds.length === 0) {
        listEl.innerHTML = '<div style="text-align:center; color:#999; padding:40px;">ç¾¤å†…æš‚æ— å…¶ä»–æˆå‘˜</div>';
    }
    
    document.getElementById('exclusive-transfer-modal').style.display = 'flex';
}

// é€‰æ‹©ä¸“å±è½¬è´¦ç›®æ ‡
async function selectExclusiveTarget(memberId, char, displayName) {
    closeModal('exclusive-transfer-modal');
    
    exclusiveTransferTarget = { memberId, char, displayName };
    
    // æ‰“å¼€è½¬è´¦é¡µé¢
    document.getElementById('t-target-name').innerText = displayName;
    const _tAvatar = getCharAvatar(char, getCurrentAccountId());
    document.getElementById('t-target-avatar').style.backgroundImage = _tAvatar ? `url(${_tAvatar})` : '';
    
    // é‡ç½®è¾“å…¥
    document.getElementById('t-amount-input').value = '';
    document.getElementById('t-note-input').value = '';
    document.getElementById('btn-do-transfer').disabled = true;
    
    document.getElementById('transfer-page').style.display = 'flex';
}

// å½“å‰æŸ¥çœ‹çš„çº¢åŒ…ID
let currentViewingRedPacketId = null;

// æ˜¾ç¤ºçº¢åŒ…è¯¦æƒ…é¡µé¢
async function showRedPacketDetail(redPacketId) {
    if (!window.currentGroupChatId) return;
    
    const group = await db.group_chats.get(window.currentGroupChatId);
    if (!group || !group.chat_history) return;
    
    // æ‰¾åˆ°çº¢åŒ…æ¶ˆæ¯
    const msg = group.chat_history.find(m => {
        if (m.type !== 'redpacket') return false;
        try {
            const data = JSON.parse(m.content);
            return data.id === redPacketId;
        } catch(e) {
            return false;
        }
    });
    
    if (!msg) return;
    
    const data = JSON.parse(msg.content);
    currentViewingRedPacketId = redPacketId;
    
    // è·å–å‘é€è€…ä¿¡æ¯
    let senderAvatar = '';
    let senderName = data.senderName || 'çº¢åŒ…å‘é€è€…';
    if (msg.role === 'user') {
        // ç”¨æˆ·å‘çš„çº¢åŒ…
        const myId = currentMyCharId ? parseInt(currentMyCharId) : null;
        if (myId) {
            const user = await db.characters.get(myId);
            if (user) {
                senderAvatar = user.avatar || '';
                const memberNicknames = group.memberNicknames || {};
                senderName = memberNicknames[myId] || user.name || 'æˆ‘';
            }
        }
    } else if (msg.senderId || data.senderId) {
        // è§’è‰²å‘çš„çº¢åŒ…
        const charId = msg.senderId || data.senderId;
        const char = await db.characters.get(typeof charId === 'number' ? charId : parseInt(charId));
        if (char) {
            const _rpAid = getCurrentAccountId();
            senderAvatar = getCharAvatar(char, _rpAid) || '';
            const memberNicknames = group.memberNicknames || {};
            senderName = memberNicknames[charId] || getCharDisplayName(char, _rpAid) || data.senderName || 'çº¢åŒ…å‘é€è€…';
        }
    }
    
    // æ›´æ–°é¡µé¢å†…å®¹
    document.getElementById('rp-detail-avatar').style.backgroundImage = senderAvatar ? `url(${senderAvatar})` : '';
    document.getElementById('rp-detail-sender').innerText = senderName + ' çš„çº¢åŒ…';
    document.getElementById('rp-detail-wish').innerText = data.wish || 'æ­å–œå‘è´¢';
    document.getElementById('rp-detail-type').innerText = data.redpacketType === 'lucky' ? 'æ‹¼æ‰‹æ°”çº¢åŒ…' : 'æ™®é€šçº¢åŒ…';
    
    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    const claimedCount = data.claimed?.length || 0;
    const claimedTotal = Object.values(data.claimedAmounts || {}).reduce((a, b) => a + parseFloat(b), 0);
    document.getElementById('rp-detail-claimed-count').innerText = claimedCount;
    document.getElementById('rp-detail-total-count').innerText = data.count;
    document.getElementById('rp-detail-total-amount').innerText = claimedTotal.toFixed(2);
    
    // æ›´æ–°é¢†å–æŒ‰é’®çŠ¶æ€
    const myId = currentMyCharId ? parseInt(currentMyCharId) : null;
    const isAllClaimed = claimedCount >= data.count;
    const hasClaimed = data.claimed?.includes(myId);
    
    const actionDiv = document.getElementById('rp-detail-action');
    const btn = document.getElementById('btn-claim-redpacket');
    
    if (isAllClaimed) {
        btn.innerText = 'çº¢åŒ…å·²é¢†å®Œ';
        btn.disabled = true;
        btn.style.background = '#ccc';
        btn.style.cursor = 'not-allowed';
    } else if (hasClaimed) {
        btn.innerText = `å·²é¢†å– Â¥${data.claimedAmounts[myId]}`;
        btn.disabled = true;
        btn.style.background = '#ccc';
        btn.style.cursor = 'not-allowed';
    } else {
        btn.innerText = 'é¢†å–çº¢åŒ…';
        btn.disabled = false;
        btn.style.background = '#333';
        btn.style.cursor = 'pointer';
    }
    
    // æ¸²æŸ“å·²é¢†å–åˆ—è¡¨
    const listEl = document.getElementById('rp-detail-claimed-list');
    listEl.innerHTML = '';
    
    if (data.claimed && data.claimed.length > 0) {
        for (const memberId of data.claimed) {
            const char = await db.characters.get(memberId);
            const memberNicknames = group.memberNicknames || {};
            const displayName = memberNicknames[memberId] || char?.remark || char?.name || 'æœªçŸ¥ç”¨æˆ·';
            const avatar = char?.avatar || '';
            const amount = data.claimedAmounts[memberId] || '0.00';
            
            const item = document.createElement('div');
            item.style.cssText = 'display:flex; align-items:center; padding:12px 0; border-bottom:1px solid #f0f0f0;';
            item.innerHTML = `
                <div style="width:40px; height:40px; border-radius:50%; background:#eee; background-image:url(${avatar}); background-size:cover; background-position:center; margin-right:12px; flex-shrink:0;"></div>
                <div style="flex:1;">
                    <div style="font-size:14px; color:#333;">${displayName}</div>
                </div>
                <div style="font-size:15px; font-weight:500; color:#333;">Â¥${amount}</div>
            `;
            listEl.appendChild(item);
        }
    } else {
        listEl.innerHTML = '<div style="text-align:center; color:#999; padding:30px 0; font-size:13px;">æš‚æ— äººé¢†å–</div>';
    }
    
    document.getElementById('redpacket-detail-page').style.display = 'flex';
}

// éšè—çº¢åŒ…è¯¦æƒ…é¡µé¢
function hideRedPacketDetail() {
    document.getElementById('redpacket-detail-page').style.display = 'none';
    currentViewingRedPacketId = null;
}

// é¢†å–çº¢åŒ…
async function claimRedPacket() {
    console.log('[é¢†å–çº¢åŒ…] å¼€å§‹é¢†å–, redpacketId:', currentViewingRedPacketId, 'groupId:', window.currentGroupChatId);
    
    if (!currentViewingRedPacketId || !window.currentGroupChatId) {
        console.warn('[é¢†å–çº¢åŒ…] ç¼ºå°‘çº¢åŒ…IDæˆ–ç¾¤èŠID');
        showToast('çº¢åŒ…ä¿¡æ¯å¼‚å¸¸');
        return;
    }
    
    const group = await db.group_chats.get(window.currentGroupChatId);
    if (!group || !group.chat_history) {
        console.warn('[é¢†å–çº¢åŒ…] æ‰¾ä¸åˆ°ç¾¤èŠæˆ–èŠå¤©è®°å½•');
        showToast('ç¾¤èŠæ•°æ®å¼‚å¸¸');
        return;
    }
    
    // æ‰¾åˆ°çº¢åŒ…æ¶ˆæ¯
    const msgIndex = group.chat_history.findIndex(m => {
        if (m.type !== 'redpacket') return false;
        try {
            const data = JSON.parse(m.content);
            return data.id === currentViewingRedPacketId;
        } catch(e) {
            return false;
        }
    });
    
    if (msgIndex === -1) {
        console.warn('[é¢†å–çº¢åŒ…] åœ¨èŠå¤©è®°å½•ä¸­æ‰¾ä¸åˆ°è¯¥çº¢åŒ…');
        showToast('æ‰¾ä¸åˆ°è¯¥çº¢åŒ…');
        return;
    }
    
    const msg = group.chat_history[msgIndex];
    const data = JSON.parse(msg.content);
    console.log('[é¢†å–çº¢åŒ…] çº¢åŒ…æ•°æ®:', data);
    
    // æ£€æŸ¥æ˜¯å¦å·²é¢†å–å®Œ
    if ((data.claimed?.length || 0) >= data.count) {
        showToast('çº¢åŒ…å·²è¢«é¢†å®Œ');
        await showRedPacketDetail(currentViewingRedPacketId);
        return;
    }
    
    // æ£€æŸ¥æ˜¯å¦å·²é¢†å–è¿‡
    const myId = currentMyCharId ? parseInt(currentMyCharId) : null;
    console.log('[é¢†å–çº¢åŒ…] å½“å‰ç”¨æˆ·ID:', myId, 'currentMyCharId:', currentMyCharId);
    if (!myId) {
        showToast('è¯·å…ˆè®¾ç½®èº«ä»½');
        return;
    }
    if (data.claimed?.includes(myId)) {
        showToast('ä½ å·²é¢†å–è¿‡è¯¥çº¢åŒ…');
        return;
    }
    
    // é¢†å–çº¢åŒ…
    if (!data.claimed) data.claimed = [];
    if (!data.claimedAmounts) data.claimedAmounts = {};
    
    let claimAmount = 0;
    const totalAmount = parseFloat(data.totalAmount);
    const remaining = data.count - data.claimed.length;
    const alreadyClaimed = Object.values(data.claimedAmounts).reduce((a, b) => a + parseFloat(b), 0);
    const remainingAmount = totalAmount - alreadyClaimed;
    
    if (data.redpacketType === 'lucky') {
        // æ‹¼æ‰‹æ°”çº¢åŒ…ï¼šéšæœºé‡‘é¢
        if (remaining === 1) {
            claimAmount = remainingAmount;
        } else {
            // éšæœºé‡‘é¢ï¼Œç¡®ä¿æ¯äººè‡³å°‘0.01
            const maxAmount = remainingAmount - (remaining - 1) * 0.01;
            claimAmount = Math.random() * maxAmount * 0.8 + 0.01; // ä¿å®ˆéšæœº
            claimAmount = Math.min(claimAmount, maxAmount);
        }
    } else {
        // æ™®é€šçº¢åŒ…ï¼šå¹³å‡åˆ†é…
        claimAmount = totalAmount / data.count;
    }
    
    claimAmount = parseFloat(claimAmount.toFixed(2));
    
    // è®°å½•é¢†å–
    data.claimed.push(myId);
    data.claimedAmounts[myId] = claimAmount.toFixed(2);
    
    // æ›´æ–°çº¢åŒ…æ¶ˆæ¯
    group.chat_history[msgIndex].content = JSON.stringify(data);
    await safeGroupChatPut(group);
    
    // å¢åŠ ä½™é¢
    const user = await db.characters.get(myId);
    if (user) {
        if (!user.identity) user.identity = {};
        let balance = parseFloat(user.identity.balance || 0);
        balance += claimAmount;
        user.identity.balance = balance.toFixed(2);
        await safeCharacterPut(user);
    }
    
    // è®°å½•è´¦å•ï¼ˆæ”¶å…¥ï¼‰
    await addTransaction('income', claimAmount, 'çº¢åŒ…', `${group.name}`);
    
    // åˆ·æ–°çº¢åŒ…è¯¦æƒ…é¡µé¢
    await showRedPacketDetail(currentViewingRedPacketId);
    
    // åˆ·æ–°ç¾¤èŠ
    await renderGroupChatBody(group);
    
    showToast(`æˆåŠŸé¢†å– Â¥${claimAmount.toFixed(2)}`);
}

// é¢†å–ç¾¤èŠä¸“å±è½¬è´¦
async function receiveGroupTransfer(msgId) {
    if (!window.currentGroupChatId) return;
    
    const group = await db.group_chats.get(window.currentGroupChatId);
    if (!group || !group.chat_history) return;
    
    // æ‰¾åˆ°è½¬è´¦æ¶ˆæ¯
    const msgIndex = group.chat_history.findIndex(m => m.id === msgId && m.type === 'transfer');
    if (msgIndex === -1) return;
    
    const msg = group.chat_history[msgIndex];
    const data = JSON.parse(msg.content);
    
    // æ£€æŸ¥æ˜¯å¦å·²ç»è¢«é¢†å–
    if (data.status === 'received') {
        showToast('è¯¥è½¬è´¦å·²è¢«é¢†å–');
        return;
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯è‡ªå·±å‘çš„
    const myId = currentMyCharId ? parseInt(currentMyCharId) : null;
    if (msg.role === 'user') {
        showToast('ä¸èƒ½é¢†å–è‡ªå·±å‘çš„è½¬è´¦');
        return;
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯è½¬ç»™è‡ªå·±çš„ï¼ˆä¸“å±è½¬è´¦ï¼‰
    if (data.targetId && data.targetId !== myId) {
        // è·å–ç›®æ ‡åç§°
        const targetChar = await db.characters.get(data.targetId);
        const targetName = data.targetName || targetChar?.name || 'å…¶ä»–äºº';
        showToast(`è¿™æ˜¯ä¸“å±è½¬è´¦ç»™ ${targetName} çš„`);
        return;
    }
    
    // é¢†å–è½¬è´¦
    data.status = 'received';
    data.receivedBy = myId;
    data.receivedAt = Date.now();
    
    group.chat_history[msgIndex].content = JSON.stringify(data);
    await safeGroupChatPut(group);
    
    // å¢åŠ ä½™é¢
    if (currentMyCharId) {
        const user = await db.characters.get(parseInt(currentMyCharId));
        if (user) {
            if (!user.identity) user.identity = {};
            let balance = parseFloat(user.identity.balance || 0);
            balance += parseFloat(data.amount);
            user.identity.balance = balance.toFixed(2);
            await safeCharacterPut(user);
        }
    }
    
    // è·å–å‘é€è€…åç§°
    let senderName = 'ç¾¤å‹';
    // ä»ç¾¤èŠå†å²ä¸­è·å–å‘é€è€…ä¿¡æ¯ï¼ˆå‡è®¾msgåŒ…å«senderIdï¼‰
    if (data.senderId) {
        const senderChar = await db.characters.get(data.senderId);
        if (senderChar) {
            const memberNicknames = group.memberNicknames || {};
            senderName = memberNicknames[data.senderId] || senderChar.remark || senderChar.wx_nickname || senderChar.name;
        }
    }
    
    // è®°å½•è´¦å•ï¼ˆæ”¶å…¥ï¼‰
    await addTransaction('income', data.amount, 'è½¬è´¦æ”¶æ¬¾', `æ¥è‡ª${senderName}`);
    
    // åˆ·æ–°ç¾¤èŠ
    await renderGroupChatBody(group);
    showToast(`å·²æ”¶æ¬¾ Â¥${data.amount}`);
}

/* =================
   ä½ç½®åŠŸèƒ½
   ================= */

// æ‰“å¼€ä½ç½®è¾“å…¥å¼¹çª—
function showLocationModal() {
    // æ¸…ç©ºè¾“å…¥
    document.getElementById('location-name-input').value = '';
    document.getElementById('location-address-input').value = '';
    
    const modal = document.getElementById('location-modal');
    modal.style.display = 'flex';
}

// å…³é—­ä½ç½®è¾“å…¥å¼¹çª—
function hideLocationModal() {
    document.getElementById('location-modal').style.display = 'none';
}

// å‘é€ä½ç½®æ¶ˆæ¯
async function sendLocationMessage() {
    const nameVal = document.getElementById('location-name-input').value.trim();
    const addressVal = document.getElementById('location-address-input').value.trim();
    
    if (!nameVal) {
        showToast("è¯·è¾“å…¥ä½ç½®åç§°");
        return;
    }
    
    // â˜… fpæ¨¡å¼ï¼šä»¥è§’è‰²èº«ä»½å‘é€ä½ç½®
    if (window._fpChatMode) {
        if (!window._fpRoleCharId) return;
        const roleChar = await db.characters.get(window._fpRoleCharId);
        if (!roleChar) return;
        const fpAccountId = window._fpAccountId;
        let history = getChatHistory(roleChar, fpAccountId);
        history.push({
            id: 'loc_' + Date.now(),
            role: 'char',
            type: 'location',
            content: JSON.stringify({ name: nameVal, address: addressVal || 'æš‚æ— è¯¦ç»†åœ°å€' }),
            time: Date.now(),
            fpSent: true
        });
        await setChatHistory(roleChar, fpAccountId, history);
        renderChatBody(roleChar, true);
        hideLocationModal();
        showToast("ä½ç½®å·²å‘é€");
        document.getElementById('action-panel').style.display = 'none';
        document.getElementById('chat-panel-container').classList.remove('open');
        return;
    }
    
    if (!currentChatCharId) {
        showToast("è¯·å…ˆè¿›å…¥èŠå¤©");
        return;
    }
    
    const chatChar = await db.characters.get(currentChatCharId);
    if (!chatChar) {
        showToast("èŠå¤©å¯¹è±¡ä¸å­˜åœ¨");
        return;
    }
    
    const accountId = getCurrentAccountId();
    let history = getChatHistory(chatChar, accountId);
    
    const msgId = 'loc_' + Date.now();
    const msg = {
        id: msgId,
        role: 'user',
        type: 'location',
        content: JSON.stringify({
            name: nameVal,
            address: addressVal || 'æš‚æ— è¯¦ç»†åœ°å€'
        }), 
        time: Date.now()
    };
    
    history.push(msg);
    await setChatHistory(chatChar, accountId, history);
    
    // åˆ·æ–°èŠå¤©ç•Œé¢
    renderChatBody(chatChar);
    
    hideLocationModal();
    showToast("ä½ç½®å·²å‘é€");
    
    // å…³é—­æ›´å¤šé¢æ¿
    document.getElementById('action-panel').style.display = 'none';
    document.getElementById('chat-panel-container').classList.remove('open');
}

// æ˜¾ç¤ºä½ç½®è¯¦æƒ…
function showLocationDetail(encodedName, encodedAddress) {
    const name = decodeURIComponent(encodedName);
    const address = decodeURIComponent(encodedAddress);
    
    // åˆ›å»ºè¯¦æƒ…å¼¹çª—
    const overlay = document.createElement('div');
    overlay.id = 'location-detail-overlay';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.4);
        z-index: 999;
        display: flex;
        justify-content: center;
        align-items: center;
    `;
    
    overlay.innerHTML = `
        <div style="
            background: #fff;
            width: 260px;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.15);
        ">
            <div style="padding: 20px; text-align: center;">
                <div style="
                    width: 48px;
                    height: 48px;
                    background: #f5f5f5;
                    border-radius: 12px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    margin: 0 auto 16px;
                ">
                    <svg viewBox="0 0 24 24" style="width:24px; height:24px; fill:none; stroke:#666; stroke-width:2;">
                        <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                        <circle cx="12" cy="10" r="3"></circle>
                    </svg>
                </div>
                <div style="font-size: 16px; font-weight: 600; color: #333; margin-bottom: 6px;">${name}</div>
                <div style="font-size: 13px; color: #999;">${address || 'æš‚æ— è¯¦ç»†åœ°å€'}</div>
            </div>
            <div style="border-top: 1px solid #f0f0f0;">
                <button onclick="document.getElementById('location-detail-overlay').remove()" style="
                    width: 100%;
                    padding: 14px;
                    background: #fff;
                    color: #333;
                    border: none;
                    font-size: 15px;
                    font-weight: 500;
                    cursor: pointer;
                ">å…³é—­</button>
            </div>
        </div>
    `;
    
    overlay.onclick = (e) => {
        if (e.target === overlay) {
            overlay.remove();
        }
    };
    
    document.body.appendChild(overlay);
}

// æ£€æŸ¥é‡‘é¢è¾“å…¥ï¼Œæ§åˆ¶æŒ‰é’®çŠ¶æ€
function checkTransferAmount(input) {
    const btn = document.getElementById('btn-do-transfer');
    const val = parseFloat(input.value);
    if (!isNaN(val) && val > 0) {
        btn.disabled = false;
    } else {
        btn.disabled = true;
    }
}

// æ‰§è¡Œè½¬è´¦
async function doTransfer() {
    const amountVal = parseFloat(document.getElementById('t-amount-input').value);
    const noteVal = document.getElementById('t-note-input').value || 'è½¬è´¦ç»™å¯¹æ–¹';
    
    if (isNaN(amountVal) || amountVal <= 0) return;
    
    // â˜… fpæ¨¡å¼ï¼šä»¥è§’è‰²èº«ä»½è½¬è´¦ï¼ˆæ£€æŸ¥è§’è‰²FPé’±åŒ…ä½™é¢ï¼Œæ‰£æ¬¾åä¿å­˜æ¶ˆæ¯ï¼‰
    if (window._fpChatMode) {
        if (!window._fpRoleCharId) return;
        const roleChar = await db.characters.get(window._fpRoleCharId);
        if (!roleChar) { showToast("è§’è‰²ä¸å­˜åœ¨"); return; }
        const fpAccountId = window._fpAccountId;
        // è·å–ç”¨äºé’±åŒ…æŸ¥è¯¢çš„accountIdï¼ˆç”¨æˆ·è´¦å·IDï¼‰
        const walletAccountId = findPhoneTargetAccountId || getCurrentAccountId();

        // âœ… æ£€æŸ¥è§’è‰²FPé’±åŒ…ä½™é¢ï¼ˆä»…é”å®šæ—¶æ ¡éªŒï¼‰
        const _fpLocked = await isFpDataLocked(window._fpRoleCharId, walletAccountId);
        if (_fpLocked) {
            const currentFpBalance = await getFpWalletBalance(window._fpRoleCharId, walletAccountId);
            if (currentFpBalance < amountVal) {
                showToast(`ä½™é¢ä¸è¶³ (å½“å‰: Â¥${currentFpBalance.toFixed(2)})`);
                return;
            }
        }

        // âœ… æ‰£æ¬¾å¹¶è®°è´¦
        const contactName = window._fpContactName || 'è”ç³»äºº';
        const txResult = await fpWalletTransaction(window._fpRoleCharId, walletAccountId, 'expense', amountVal, 'å¾®ä¿¡è½¬è´¦', `è½¬è´¦ç»™${contactName} - ${noteVal}`);
        if (!txResult.success) {
            showToast(`ä½™é¢ä¸è¶³ (å½“å‰: Â¥${txResult.balance.toFixed(2)})`);
            return;
        }

        let history = getChatHistory(roleChar, fpAccountId);
        const msgId = 'trans_' + Date.now();
        const msg = {
            id: msgId,
            role: 'char',
            type: 'transfer',
            content: JSON.stringify({ amount: amountVal.toFixed(2), desc: noteVal, status: 'sent' }),
            time: Date.now(),
            fpSent: true
        };
        history.push(msg);
        try {
            await setChatHistory(roleChar, fpAccountId, history);
        } catch(e) { console.error('[FPè½¬è´¦] ä¿å­˜å¤±è´¥:', e); showToast('è½¬è´¦ä¿å­˜å¤±è´¥'); return; }
        await renderChatBody(roleChar, true);
        hideTransferPage();
        showToast(`è½¬è´¦æˆåŠŸ (ä½™é¢: Â¥${txResult.balance.toFixed(2)})`);
        setTimeout(() => {
            const body = document.getElementById('chat-body');
            if (body) body.scrollTop = body.scrollHeight;
        }, 50);
        return;
    }
    
    // 1. æ£€æŸ¥ä½™é¢
    if (!currentMyCharId) {
        showToast("è¯·å…ˆåœ¨è¯¦æƒ…é¡µè®¾ç½®Userèº«ä»½");
        return;
    }
    const user = await db.characters.get(parseInt(currentMyCharId));
    
    // ç¡®ä¿æœ‰ä½™é¢å­—æ®µ
    let currentBalance = 0;
    if (user && user.identity && user.identity.balance) {
        currentBalance = parseFloat(user.identity.balance.toString().replace(/,/g, ''));
    }
    
    if (currentBalance < amountVal) {
        showToast('ä½™é¢ä¸è¶³ (å½“å‰: Â¥' + currentBalance.toFixed(2) + ')');
        return;
    }
    
    // 2. æ‰£æ¬¾
    const newBalance = currentBalance - amountVal;
    user.identity.balance = newBalance.toFixed(2);
    await safeCharacterPut(user);
    
    // 3. åˆ¤æ–­æ˜¯ç¾¤èŠä¸“å±è½¬è´¦è¿˜æ˜¯ç§èŠè½¬è´¦
    if (window.currentGroupChatId && exclusiveTransferTarget) {
        // ç¾¤èŠä¸“å±è½¬è´¦
        const group = await db.group_chats.get(window.currentGroupChatId);
        if (!group) {
            showToast("ç¾¤èŠä¸å­˜åœ¨");
            return;
        }
        
        const msgId = 'trans_' + Date.now();
        const msg = {
            role: 'user',
            type: 'transfer',
            content: JSON.stringify({
                amount: amountVal.toFixed(2),
                desc: noteVal,
                status: 'sent',
                senderId: parseInt(currentMyCharId),
                targetId: exclusiveTransferTarget.memberId,
                targetName: exclusiveTransferTarget.displayName
            }), 
            time: Date.now(),
            id: msgId
        };
        
        if (!group.chat_history) group.chat_history = [];
        group.chat_history.push(msg);
        group.updated_at = Date.now();
        await safeGroupChatPut(group);
        
        // è®°å½•è´¦å•
        await addTransaction('expense', amountVal, 'è½¬è´¦', `è½¬ç»™${exclusiveTransferTarget.displayName}`);
        
        // åˆ·æ–°ç¾¤èŠç•Œé¢
        await renderGroupChatBody(group);
        
        hideTransferPage();
        exclusiveTransferTarget = null; // æ¸…ç©ºç›®æ ‡
        showToast("è½¬è´¦æˆåŠŸ");
        return;
    }
    
    // ç§èŠè½¬è´¦
    const chatChar = await db.characters.get(currentChatCharId);
    if (!chatChar) {
        showToast("èŠå¤©å¯¹è±¡ä¸å­˜åœ¨");
        return;
    }
    
    const accountId = getCurrentAccountId();
    let history = getChatHistory(chatChar, accountId);
    
    const msgId = 'trans_' + Date.now();
    const transferData = {
        amount: amountVal.toFixed(2),
        desc: noteVal,
        status: 'sent'
    };
    const msg = {
        id: msgId,
        role: 'user',
        type: 'transfer',
        content: JSON.stringify(transferData), 
        time: Date.now()
    };
    
    history.push(msg);
    await setChatHistory(chatChar, accountId, history);
    
    // è®°å½•è´¦å•
    await addTransaction('expense', amountVal, 'è½¬è´¦', `è½¬ç»™${chatChar.remark || chatChar.wx_nickname || chatChar.name}`);
    
    // âœ… è”æœºå¥½å‹ï¼šé€šè¿‡æœåŠ¡å™¨å‘é€è½¬è´¦æ¶ˆæ¯
    if (chatChar.isOnlineFriend && chatChar.onlineData?.wx_account) {
        // è·å–å½“å‰å¯ç”¨çš„åœ¨çº¿è§’è‰²ï¼ˆå¦‚æœæ²¡æœ‰åˆ™è‡ªåŠ¨ä¸Šçº¿ï¼‰
        const onlineUserChar = await getOrCreateOnlineUserChar();
        
        if (onlineUserChar && onlineConnected) {
            const fromWxAccount = onlineUserChar.identity.account;
            const toWxAccount = chatChar.onlineData.wx_account;
            // å‘é€è½¬è´¦æ¶ˆæ¯ï¼ˆä½¿ç”¨ç‰¹æ®ŠJSONæ ¼å¼ï¼Œå¯¹æ–¹å¯ä»¥è¯†åˆ«å¹¶æ¸²æŸ“ä¸ºå¡ç‰‡ï¼‰
            const transferContent = JSON.stringify({
                __type: 'transfer',
                amount: amountVal.toFixed(2),
                desc: noteVal,
                status: 'sent'
            });
            sendOnlineMessage(toWxAccount, transferContent, fromWxAccount);
            console.log('[Online] è½¬è´¦æ¶ˆæ¯å·²å‘é€åˆ°æœåŠ¡å™¨');
        }
    }
    
    // åˆ·æ–°èŠå¤©ç•Œé¢
    renderChatBody(chatChar);
    
    hideTransferPage();
    showToast("è½¬è´¦æˆåŠŸ");
    
    // å…³é—­æ›´å¤šé¢æ¿
    document.getElementById('action-panel').style.display = 'none';
    document.getElementById('chat-panel-container').classList.remove('open');
}

/* =================
   è½¬è´¦ç¡®è®¤/è¯¦æƒ…é€»è¾‘
   ================= */

// ç‚¹å‡»å¡ç‰‡è§¦å‘
async function showTransferConfirm(msgId, isSelf, status) {
    if (status !== 'sent') return;
    if (isSelf) return;
    
    // ä»chat_historyä¸­æŸ¥æ‰¾æ¶ˆæ¯ - ä½¿ç”¨ getChatHistory æ”¯æŒå¤šè´¦å·
    const char = await db.characters.get(currentChatCharId);
    if (!char) return;
    
    const accountId = getCurrentAccountId();
    const history = getChatHistory(char, accountId);
    if (!history || history.length === 0) return;
    
    const msg = history.find(m => {
        // ç²¾ç¡®åŒ¹é…ID
        if (m.id === msgId) return true;
        // å¦‚æœæ¶ˆæ¯æ²¡æœ‰idï¼Œç”¨æ—¶é—´æˆ³åŒ¹é…
        if (!m.id && msgId === 'trans_' + m.time) return true;
        // å¦‚æœmsgIdæ˜¯trans_å¼€å¤´ï¼Œå°è¯•ç”¨æ—¶é—´æˆ³åŒ¹é…
        if (msgId.startsWith('trans_')) {
            const timeFromId = parseInt(msgId.replace('trans_', ''));
            if (m.time === timeFromId) return true;
        }
        return false;
    });
    if (!msg) return;
    
    // è§£æè½¬è´¦æ•°æ®
    let data = {};
    try {
        data = JSON.parse(msg.content);
    } catch(e) {
        return;
    }
    
    document.getElementById('t-confirm-desc').innerText = 'æ”¶åˆ°è½¬è´¦ Â¥' + data.amount;
    
    window.currentTransferMsgId = msgId;
    window.currentTransferMsgTime = msg.time; // ä¿å­˜æ—¶é—´æˆ³ç”¨äºæŸ¥æ‰¾
    
    document.getElementById('transfer-confirm-modal').style.display = 'flex';
}

async function handleTransferAction(action) {
    const modal = document.getElementById('transfer-confirm-modal');
    modal.style.display = 'none';
    
    const msgId = window.currentTransferMsgId;
    const msgTime = window.currentTransferMsgTime;
    if (!msgId || !currentChatCharId) return;
    
    const char = await db.characters.get(currentChatCharId);
    const accountId = getCurrentAccountId();
    let history = getChatHistory(char, accountId);
    if (!history || history.length === 0) return;
    
    const msgIndex = history.findIndex(m => {
        // ç²¾ç¡®åŒ¹é…IDï¼Œæˆ–è€…æ ¹æ®æ—¶é—´æˆ³ç”Ÿæˆçš„IDåŒ¹é…
        if (m.id === msgId) return true;
        if (!m.id && msgId === 'trans_' + m.time) return true;
        if (msgTime && m.time === msgTime) return true; // ä½¿ç”¨æ—¶é—´æˆ³åŒ¹é…
        return false;
    });
    if (msgIndex === -1) return;
    
    const msg = history[msgIndex];
    let data = {};
    try {
        data = JSON.parse(msg.content);
    } catch(e) {
        return;
    }
    
    if (action === 'accept') {
        data.status = 'received';
        msg.content = JSON.stringify(data);
        
        // å¦‚æœæ¶ˆæ¯æ²¡æœ‰typeå­—æ®µï¼Œè¡¥å……ä¸Š
        if (!msg.type) msg.type = 'transfer';
        // å¦‚æœæ¶ˆæ¯æ²¡æœ‰idï¼Œè¡¥å……ä¸Š
        if (!msg.id) msg.id = 'trans_' + msg.time;
        
        // è·å–å½“å‰è´¦å·IDå¹¶æ›´æ–°ä½™é¢
        const myAccountId = getCurrentAccountId();
        if (myAccountId) {
             const user = await db.characters.get(parseInt(myAccountId));
             if (user) {
                 let currentBalance = 0;
                 if (user.identity && typeof user.identity.balance !== 'undefined' && user.identity.balance !== null) {
                     currentBalance = parseFloat(user.identity.balance.toString().replace(/,/g, '')) || 0;
                 }
                 
                 let addAmount = parseFloat(data.amount) || 0;
                 let newBalance = currentBalance + addAmount;
                 
                 if (!user.identity) user.identity = {};
                 user.identity.balance = newBalance.toFixed(2);
                 await safeCharacterPut(user);
                 
                 // æ·»åŠ æ”¶å…¥è®°å½•åˆ°è´¦å•
                 await addTransaction('income', data.amount, 'å¾®ä¿¡è½¬è´¦', `æ¥è‡ª${char.name}${data.desc ? ' - ' + data.desc : ''}`);
                 
                 showToast('å·²æ”¶æ¬¾ Â¥' + data.amount);
             }

        }
        
    } else {
        data.status = 'returned';
        msg.content = JSON.stringify(data);
        
        if (!msg.type) msg.type = 'transfer';
        if (!msg.id) msg.id = 'trans_' + msg.time;
        
        // âœ… ç”¨æˆ·é€€å›è§’è‰²çš„è½¬è´¦ â†’ è§’è‰²FPé’±åŒ…é€€æ¬¾ï¼ˆé’±é€€å›è§’è‰²è´¦æˆ·ï¼‰
        const retAccountId = getCurrentAccountId();
        if (retAccountId) {
            const retAmt = parseFloat(data.amount) || 0;
            await fpWalletTransaction(currentChatCharId, retAccountId, 'income', retAmt, 'è½¬è´¦é€€å›', `è½¬è´¦è¢«é€€å›${data.desc ? ' - ' + data.desc : ''}`);
            console.log(`[handleTransferAction] âœ… è§’è‰²FPé’±åŒ…é€€æ¬¾ Â¥${retAmt.toFixed(2)}`);
        }
        
        showToast('å·²é€€å›è½¬è´¦');
    }
    
    history[msgIndex] = msg;
    
    // âœ… æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯ï¼Œè®©AIçŸ¥é“ç”¨æˆ·çš„æ”¶æ¬¾/é€€å›è¡Œä¸º
    if (action === 'accept') {
        history.push({
            role: 'system',
            type: 'transfer_action',
            content: `[å¯¹æ–¹å·²æ”¶å–äº†ä½ çš„ Â¥${data.amount} è½¬è´¦${data.desc ? 'ï¼ˆ' + data.desc + 'ï¼‰' : ''}]`,
            time: Date.now()
        });
    } else {
        history.push({
            role: 'system',
            type: 'transfer_action',
            content: `[å¯¹æ–¹é€€å›äº†ä½ çš„ Â¥${data.amount} è½¬è´¦${data.desc ? 'ï¼ˆ' + data.desc + 'ï¼‰' : ''}]`,
            time: Date.now()
        });
    }
    
    await setChatHistory(char, accountId, history);
    
    // å°±åœ°æ›´æ–° DOM ä¸­çš„è½¬è´¦å¡ç‰‡ï¼ˆé¿å…æ•´é¡µé‡æ¸²æŸ“ï¼‰
    const transferId = msg.id || ('trans_' + msg.time);
    const cardEl = document.querySelector(`.transfer-card[data-transfer-id="${transferId}"]`);
    if (cardEl) {
        const newStatus = data.status; // 'received' æˆ– 'returned'
        const statusText = newStatus === 'received' ? 'å·²æ”¶æ¬¾' : 'å·²é€€å›';
        cardEl.classList.add(newStatus === 'received' ? 'done' : 'returned');
        // æ›´æ–° onclickï¼Œé˜²æ­¢é‡å¤ç‚¹å‡»
        cardEl.setAttribute('onclick', `showTransferConfirm('${transferId}', false, '${newStatus}')`);
        const footerText = cardEl.querySelector('.t-footer-text');
        if (footerText) footerText.textContent = statusText;
    } else {
        // å…œåº•ï¼šå¦‚æœæ‰¾ä¸åˆ°å¡ç‰‡å…ƒç´ ï¼Œå¼ºåˆ¶é‡æ¸²æŸ“
        renderChatBody(char, true);
    }
}

// =================
// ç”µè¯é¡µé¢åŠŸèƒ½
// =================
let currentPhoneNumber = '';
let currentPhoneTab = 'recents';

function showPhonePage() {
    const page = document.getElementById('phone-page');
    page.style.display = 'flex';
    // é»˜è®¤æ˜¾ç¤ºæœ€è¿‘é€šè¯æ ‡ç­¾é¡µ
    switchPhoneTab('recents');
    // åˆå§‹åŒ–æ‹¨å·é”®ç›˜æŒ‰é’®çŠ¶æ€
    updatePhoneKeypadActions();
}

function hidePhonePage() {
    const page = document.getElementById('phone-page');
    page.style.display = 'none';
    // é‡ç½®æ‹¨å·é”®ç›˜
    currentPhoneNumber = '';
    updatePhoneNumberDisplay();
}

function switchPhoneTab(tab) {
    currentPhoneTab = tab;
    
    // æ›´æ–°æ ‡ç­¾æ çŠ¶æ€
    document.querySelectorAll('.phone-tab-item').forEach(item => {
        item.classList.remove('active');
        if (item.dataset.tab === tab) {
            item.classList.add('active');
        }
    });
    
    // æ›´æ–°å†…å®¹åŒºåŸŸ
    document.querySelectorAll('.phone-tab-content').forEach(content => {
        content.classList.remove('active');
    });
    
    const targetContent = document.getElementById('phone-tab-' + tab);
    if (targetContent) {
        targetContent.classList.add('active');
    }
    
    // æ ¹æ®æ ‡ç­¾é¡µåŠ è½½ç›¸åº”å†…å®¹
    if (tab === 'contacts') {
        loadPhoneContacts();
    } else if (tab === 'recents') {
        loadPhoneRecents();
    }
}

function loadPhoneContacts() {
    const contactsList = document.getElementById('phone-contacts-list');
    if (!contactsList) return;
    
    // ä»è§’è‰²æ¡£æ¡ˆä¸­åŠ è½½è”ç³»äºº
    db.characters.toArray().then(characters => {
        const contacts = characters.filter(c => c.type === 'char' || c.type === 'npc');
        
        if (contacts.length === 0) {
            contactsList.innerHTML = `
                <div class="phone-empty-state">
                    <svg class="phone-empty-icon" viewBox="0 0 24 24"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>
                    <div>æ— è”ç³»äºº</div>
                </div>
            `;
            return;
        }
        
        // æŒ‰åç§°æ’åº
        contacts.sort((a, b) => {
            const nameA = (a.nick || a.name || '').toUpperCase();
            const nameB = (b.nick || b.name || '').toUpperCase();
            return nameA.localeCompare(nameB);
        });
        
        let html = '';
        contacts.forEach(contact => {
            const name = contact.nick || contact.name || 'æœªçŸ¥';
            const phone = contact.identity?.phone || '';
            const firstLetter = name.charAt(0).toUpperCase();
            
            html += `
                <div class="phone-list-item" onclick="phoneCallContact(${contact.id})">
                    <div class="phone-list-avatar" style="background: ${contact.avatar ? 'url(' + contact.avatar + ')' : 'var(--ins-pink)'}; background-size: cover; background-position: center;">
                        ${!contact.avatar ? firstLetter : ''}
                    </div>
                    <div class="phone-list-info">
                        <div class="phone-list-name">${name}</div>
                        <div class="phone-list-subtitle">${phone || 'æ— å·ç '}</div>
                    </div>
                </div>
            `;
        });
        
        contactsList.innerHTML = html;
    });
}

async function loadPhoneRecents() {
    const recentsList = document.getElementById('phone-recents-list');
    if (!recentsList) return;
    
    const accountId = getCurrentAccountId();
    if (!accountId) {
        recentsList.innerHTML = `<div class="phone-empty-state"><div>è¯·å…ˆç™»å½•è´¦å·</div></div>`;
        return;
    }
    
    // ä» Dexie åŠ è½½æœ€è¿‘é€šè¯è®°å½•
    let recents = await db.phone_recents.where('accountId').equals(accountId).toArray();
    
    if (recents.length === 0) {
        recentsList.innerHTML = `
            <div class="phone-empty-state">
                <svg class="phone-empty-icon" viewBox="0 0 24 24"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>
                <div>æ— æœ€è¿‘é€šè¯</div>
            </div>
        `;
        return;
    }
    
    // æŒ‰æ—¶é—´å€’åºæ’åº
    recents.sort((a, b) => b.time - a.time);
    
    let html = '';
    for (const recent of recents) {
        // å¦‚æœæœ‰ charIdï¼Œå°è¯•ä»æ•°æ®åº“è·å–æœ€æ–°çš„è§’è‰²å¤´åƒ
        let avatar = null;
        if (recent.charId) {
            const char = await db.characters.get(recent.charId);
            if (char) {
                avatar = char.avatar;
            }
        }
        
        const name = recent.name || recent.number || 'æœªçŸ¥';
        const phone = recent.number || '';
        const time = new Date(recent.time);
        const timeStr = formatPhoneTime(time);
        const firstLetter = name.charAt(0).toUpperCase();
        
        // ä½¿ç”¨å¤´åƒæˆ–é¦–å­—æ¯
        const avatarHtml = avatar 
            ? `<img src="${avatar}" class="phone-list-avatar" style="object-fit:cover;border-radius:50%;" />`
            : `<div class="phone-list-avatar">${firstLetter}</div>`;
        
        html += `
            <div class="phone-list-item" onclick="phoneCallNumber('${phone}')">
                ${avatarHtml}
                <div class="phone-list-info">
                    <div class="phone-list-name">${name}</div>
                    <div class="phone-list-subtitle">${timeStr}</div>
                </div>
            </div>
        `;
    }
    
    recentsList.innerHTML = html;
}

function formatPhoneTime(date) {
    const now = new Date();
    
    const month = (date.getMonth() + 1).toString();
    const day = date.getDate().toString();
    const hours = date.getHours().toString().padStart(2, '0');
    const minutes = date.getMinutes().toString().padStart(2, '0');
    
    // ğŸ¯ æ˜¾ç¤ºè¯¦ç»†æ—¶é—´ï¼Œä¸æ˜¾ç¤º"åˆšåˆš"
    // åˆ¤æ–­æ˜¯å¦æ˜¯ä»Šå¤©
    if (date.getDate() === now.getDate() && 
        date.getMonth() === now.getMonth() && 
        date.getFullYear() === now.getFullYear()) {
        return `ä»Šå¤© ${hours}:${minutes}`;
    }
    
    // åˆ¤æ–­æ˜¯å¦æ˜¯æ˜¨å¤©
    const yesterday = new Date(now);
    yesterday.setDate(yesterday.getDate() - 1);
    if (date.getDate() === yesterday.getDate() && 
        date.getMonth() === yesterday.getMonth() && 
        date.getFullYear() === yesterday.getFullYear()) {
        return `æ˜¨å¤© ${hours}:${minutes}`;
    }
    
    // åŒä¸€å¹´æ˜¾ç¤ºæœˆæ—¥+æ—¶é—´
    if (date.getFullYear() === now.getFullYear()) {
        return `${month}æœˆ${day}æ—¥ ${hours}:${minutes}`;
    }
    
    // ä¸åŒå¹´æ˜¾ç¤ºå®Œæ•´æ—¥æœŸ+æ—¶é—´
    return `${date.getFullYear()}å¹´${month}æœˆ${day}æ—¥ ${hours}:${minutes}`;
}

// æ‹¨å·é”®ç›˜åŠŸèƒ½
function phoneKeypadInput(key) {
    currentPhoneNumber += key;
    updatePhoneNumberDisplay();
    updatePhoneKeypadActions();
}

function phoneKeypadDelete() {
    if (currentPhoneNumber.length > 0) {
        currentPhoneNumber = currentPhoneNumber.slice(0, -1);
        updatePhoneNumberDisplay();
        updatePhoneKeypadActions();
    }
}

function updatePhoneNumberDisplay() {
    const display = document.getElementById('phone-number-display');
    if (display) {
        display.textContent = currentPhoneNumber || 'è¾“å…¥å·ç ';
        display.style.color = currentPhoneNumber ? '#000' : '#8e8e93';
    }
}

function updatePhoneKeypadActions() {
    const callBtn = document.getElementById('phone-call-btn');
    const deleteBtn = document.getElementById('phone-delete-btn');
    
    if (currentPhoneNumber.length > 0) {
        if (callBtn) {
            callBtn.style.display = 'flex';
            callBtn.style.background = '#34c759'; // ç»¿è‰²
        }
        if (deleteBtn) deleteBtn.style.display = 'flex';
    } else {
        if (callBtn) {
            callBtn.style.display = 'flex';
            callBtn.style.background = '#c7c7cc'; // ç°è‰²ï¼ˆç¦ç”¨çŠ¶æ€ï¼‰
        }
        if (deleteBtn) deleteBtn.style.display = 'none';
    }
}

function phoneMakeCall() {
    if (!currentPhoneNumber || currentPhoneNumber.length === 0) {
        showToast('è¯·è¾“å…¥ç”µè¯å·ç ');
        return;
    }
    
    // æŸ¥æ‰¾è”ç³»äºº
    db.characters.toArray().then(characters => {
        const contact = characters.find(c => 
            c.identity?.phone === currentPhoneNumber || 
            c.name === currentPhoneNumber || 
            c.nick === currentPhoneNumber
        );
        
        const name = contact ? (contact.nick || contact.name) : currentPhoneNumber;
        
        // æ·»åŠ åˆ°æœ€è¿‘é€šè¯
        addPhoneRecent(name, currentPhoneNumber);
        
        // æ˜¾ç¤ºé€šè¯ç•Œé¢ï¼ˆç®€åŒ–ç‰ˆï¼‰
        showToast(`æ­£åœ¨å‘¼å« ${name}...`);
        
        // æ¨¡æ‹Ÿé€šè¯
        setTimeout(() => {
            showToast('é€šè¯å·²ç»“æŸ');
        }, 2000);
    });
}

function phoneCallContact(charId) {
    db.characters.get(charId).then(contact => {
        if (!contact) return;
        
        const name = contact.nick || contact.name || 'æœªçŸ¥';
        const phone = contact.identity?.phone || '';
        
        if (!phone) {
            showToast('è¯¥è”ç³»äººæ²¡æœ‰ç”µè¯å·ç ');
            return;
        }
        
        // åˆ‡æ¢åˆ°æ‹¨å·é”®ç›˜å¹¶æ˜¾ç¤ºå·ç 
        switchPhoneTab('keypad');
        currentPhoneNumber = phone;
        updatePhoneNumberDisplay();
        updatePhoneKeypadActions();
        
        // æ·»åŠ åˆ°æœ€è¿‘é€šè¯
        addPhoneRecent(name, phone);
        
        // æ˜¾ç¤ºé€šè¯ç•Œé¢
        showToast(`æ­£åœ¨å‘¼å« ${name}...`);
        
        // æ¨¡æ‹Ÿé€šè¯
        setTimeout(() => {
            showToast('é€šè¯å·²ç»“æŸ');
        }, 2000);
    });
}

function phoneCallNumber(number) {
    currentPhoneNumber = number;
    switchPhoneTab('keypad');
    updatePhoneNumberDisplay();
    updatePhoneKeypadActions();
    phoneMakeCall();
}

async function addPhoneRecent(name, number, charId = null) {
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    // æ·»åŠ åˆ° Dexie æ•°æ®åº“
    await db.phone_recents.add({
        accountId: accountId,
        charId: charId,
        name: name,
        number: number,
        time: Date.now(),
        type: 'outgoing' // æ‹¨å‡ºç”µè¯
    });
    
    // é™åˆ¶æ¯ä¸ªè´¦å·æœ€å¤šä¿ç•™100æ¡
    const count = await db.phone_recents.where('accountId').equals(accountId).count();
    if (count > 100) {
        const oldest = await db.phone_recents.where('accountId').equals(accountId).sortBy('time');
        const toDelete = oldest.slice(0, count - 100);
        await db.phone_recents.bulkDelete(toDelete.map(r => r.id));
    }
}

// æ‹¨å·é”®ç›˜åˆå§‹åŒ–åœ¨showPhonePageä¸­å®Œæˆ

// ============================================
// è£…æ‰®åŠŸèƒ½
// ============================================
const wyyDressUpBtn = document.getElementById('wyyDressUpBtn');
const wyyDressUpModal = document.getElementById('wyyDressUpModal');
const wyyCancelBtn = document.getElementById('wyyCancelBtn');
const wyySaveBtn = document.getElementById('wyySaveBtn');
const wyyUploadAvatarBtn = document.getElementById('wyyUploadAvatarBtn');
const wyyAvatarFileInput = document.getElementById('wyyAvatarFileInput');
const wyyAvatarDisplay = document.getElementById('wyyAvatarDisplay');
const wyyModalAvatarPreview = document.getElementById('wyyModalAvatarPreview');

const wyyFollowInput = document.getElementById('wyyFollowInput');
const wyyFansInput = document.getElementById('wyyFansInput');
const wyyLevelInput = document.getElementById('wyyLevelInput');
const wyyTimeInput = document.getElementById('wyyTimeInput');

const wyyFollowValue = document.querySelector('.wyy-stat-item[data-type="follow"] .wyy-stat-value');
const wyyFansValue = document.querySelector('.wyy-stat-item[data-type="fans"] .wyy-stat-value');
const wyyLevelValue = document.querySelector('.wyy-stat-item[data-type="level"] .wyy-stat-value');
const wyyTimeValue = document.querySelector('.wyy-stat-item[data-type="time"] .wyy-stat-value');

const wyyCard1 = document.getElementById('wyyCard1');
const wyyCard2 = document.getElementById('wyyCard2');
const wyyCard3 = document.getElementById('wyyCard3');
const wyyCard4 = document.getElementById('wyyCard4');

const wyyModalCardPreview1 = document.getElementById('wyyModalCardPreview1');
const wyyModalCardPreview2 = document.getElementById('wyyModalCardPreview2');
const wyyModalCardPreview3 = document.getElementById('wyyModalCardPreview3');
const wyyModalCardPreview4 = document.getElementById('wyyModalCardPreview4');

const wyyCardUploadBtns = document.querySelectorAll('.wyy-card-upload-btn');
const wyyCardFileInputs = document.querySelectorAll('.wyy-card-file-input');

let wyyTempAvatar = null;
const wyyTempCards = { 1: null, 2: null, 3: null, 4: null };

if (wyyDressUpBtn) {
    wyyDressUpBtn.addEventListener('click', () => {
        wyyLoadCurrentSettings();
        if (wyyDressUpModal) wyyDressUpModal.style.display = 'flex';
        wyyResetTempData();
    });
}

if (wyyCancelBtn) {
    wyyCancelBtn.addEventListener('click', () => {
        if (wyyDressUpModal) wyyDressUpModal.style.display = 'none';
        wyyResetTempData();
    });
}

if (wyySaveBtn) {
    wyySaveBtn.addEventListener('click', () => {
        wyySaveSettings();
        if (wyyDressUpModal) wyyDressUpModal.style.display = 'none';
    });
}

if (wyyDressUpModal) {
    wyyDressUpModal.addEventListener('click', (e) => {
        if (e.target === wyyDressUpModal) {
            wyyDressUpModal.style.display = 'none';
            wyyResetTempData();
        }
    });
}

if (wyyUploadAvatarBtn && wyyAvatarFileInput) {
    wyyUploadAvatarBtn.addEventListener('click', () => {
        wyyAvatarFileInput.click();
    });

    wyyAvatarFileInput.addEventListener('change', function(event) {
        wyyHandleFileUpload(event, 'avatar');
    });
}

if (wyyCardFileInputs && wyyCardFileInputs.length > 0) {
    wyyCardFileInputs.forEach(input => {
        input.addEventListener('change', function(event) {
            const cardNum = this.getAttribute('data-card');
            wyyHandleFileUpload(event, `card${cardNum}`);
        });
    });
}

if (wyyCardUploadBtns && wyyCardUploadBtns.length > 0) {
    wyyCardUploadBtns.forEach(btn => {
        btn.addEventListener('click', function() {
            const cardNum = this.getAttribute('data-card');
            const fileInput = document.querySelector(`.wyy-card-file-input[data-card="${cardNum}"]`);
            if (fileInput) fileInput.click();
        });
    });
}

function wyyHandleFileUpload(event, type) {
    const file = event.target.files[0];
    
    if (file) {
        if (!file.type.match('image.*')) {
            alert('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶ï¼');
            return;
        }
        
        if (file.size > 5 * 1024 * 1024) {
            alert('å›¾ç‰‡å¤§å°ä¸èƒ½è¶…è¿‡5MBï¼');
            return;
        }
        
        const reader = new FileReader();
        
        reader.onload = function(e) {
            if (type === 'avatar') {
                if (wyyModalAvatarPreview) wyyModalAvatarPreview.style.backgroundImage = `url(${e.target.result})`;
                wyyTempAvatar = e.target.result;
            } else {
                const cardNum = type.replace('card', '');
                const preview = document.getElementById(`wyyModalCardPreview${cardNum}`);
                if (preview) {
                    preview.style.backgroundImage = `url(${e.target.result})`;
                    wyyTempCards[cardNum] = e.target.result;
                }
            }
        };
        
        reader.readAsDataURL(file);
    }
}

async function wyyLoadCurrentSettings() {
    try {
        const userSettings = await wyyDb.userSettings.get('avatar');
        if (userSettings && wyyModalAvatarPreview) {
            wyyModalAvatarPreview.style.backgroundImage = `url(${userSettings.data})`;
        } else if (wyyModalAvatarPreview) {
            wyyModalAvatarPreview.style.backgroundImage = '';
        }
        
        const savedFollow = (await wyyDb.userSettings.get('follow'))?.data || '29';
        const savedFans = (await wyyDb.userSettings.get('fans'))?.data || '9';
        const savedLevel = (await wyyDb.userSettings.get('level'))?.data || 'Lv.7';
        const savedTime = (await wyyDb.userSettings.get('time'))?.data || '904h';
        
        if (wyyFollowInput) wyyFollowInput.value = savedFollow;
        if (wyyFansInput) wyyFansInput.value = savedFans;
        if (wyyLevelInput) wyyLevelInput.value = savedLevel;
        if (wyyTimeInput) wyyTimeInput.value = savedTime;
        
        for (let i = 1; i <= 4; i++) {
            const cardKey = `card${i}`;
            const savedCard = await wyyDb.playlistCards.get(cardKey);
            const preview = document.getElementById(`wyyModalCardPreview${i}`);
            if (preview) {
                if (savedCard) {
                    preview.style.backgroundImage = `url(${savedCard.data})`;
                } else {
                    preview.style.backgroundImage = '';
                }
            }
        }
    } catch (error) {
        console.error('åŠ è½½è®¾ç½®å¤±è´¥:', error);
    }
}

async function wyySaveSettings() {
    try {
        if (wyyTempAvatar) {
            if (wyyAvatarDisplay) wyyAvatarDisplay.style.backgroundImage = `url(${wyyTempAvatar})`;
            await wyyDb.userSettings.put({ id: 'avatar', data: wyyTempAvatar });
        }
        
        if (wyyFollowInput && wyyFansInput && wyyLevelInput && wyyTimeInput) {
            const follow = wyyFollowInput.value;
            const fans = wyyFansInput.value;
            const level = wyyLevelInput.value;
            const time = wyyTimeInput.value;
            
            if (wyyFollowValue) wyyFollowValue.textContent = follow;
            if (wyyFansValue) wyyFansValue.textContent = fans;
            if (wyyLevelValue) wyyLevelValue.textContent = level;
            if (wyyTimeValue) wyyTimeValue.textContent = time;
            
            await wyyDb.userSettings.put({ id: 'follow', data: follow });
            await wyyDb.userSettings.put({ id: 'fans', data: fans });
            await wyyDb.userSettings.put({ id: 'level', data: level });
            await wyyDb.userSettings.put({ id: 'time', data: time });
        }
        
        for (let i = 1; i <= 4; i++) {
            if (wyyTempCards[i]) {
                const cardElement = document.getElementById(`wyyCard${i}`);
                if (cardElement) {
                    cardElement.style.backgroundImage = `url(${wyyTempCards[i]})`;
                    await wyyDb.playlistCards.put({ id: `card${i}`, data: wyyTempCards[i] });
                }
            }
        }
        
        wyyResetTempData();
    } catch (error) {
        console.error('ä¿å­˜è®¾ç½®å¤±è´¥:', error);
    }
}

function wyyResetTempData() {
    wyyTempAvatar = null;
    for (let i = 1; i <= 4; i++) {
        wyyTempCards[i] = null;
    }
}

// ============================================
// æ­Œå•ç®¡ç†åŠŸèƒ½
// ============================================

// åŠ è½½æ­Œå•åˆ—è¡¨
async function wyyLoadPlaylists() {
    try {
        const playlists = await wyyDb.playlists.orderBy('dateCreated').reverse().toArray();
        const playlistsList = document.getElementById('wyyPlaylistsList');
        if (!playlistsList) return;
        
        if (playlists.length === 0) {
            playlistsList.innerHTML = '';
            return;
        }
        
        let html = '';
        playlists.forEach(playlist => {
            html += `
                <div class="wyy-playlist-card" data-playlist-id="${playlist.id}" style="cursor: pointer;">
                    <div class="wyy-playlist-cover" style="${playlist.cover ? `background-image: url(${playlist.cover})` : 'background: #f0f0f0;'}"></div>
                    <div class="wyy-playlist-info">
                        <div class="wyy-playlist-name">${playlist.name}</div>
                        <div class="wyy-playlist-desc">${playlist.desc || 'æš‚æ— æè¿°'}</div>
                    </div>
                    <div class="wyy-playlist-actions" style="display: flex; gap: 10px; align-items: center;">
                        <button class="wyy-control-btn" onclick="event.stopPropagation(); wyyExportSinglePlaylist(${playlist.id})" title="å¯¼å‡º">
                            <i class="fa fa-download"></i>
                        </button>
                        <button class="wyy-control-btn" onclick="event.stopPropagation(); wyyDeletePlaylist(${playlist.id})" title="åˆ é™¤" style="color: #ff4444;">
                            <i class="fa fa-trash"></i>
                        </button>
                    </div>
                </div>
            `;
        });
        
        playlistsList.innerHTML = html;
        
        // æ·»åŠ ç‚¹å‡»äº‹ä»¶ï¼ˆç‚¹å‡»æ­Œå•å¡ç‰‡æ˜¾ç¤ºè¯¦æƒ…ï¼Œç‚¹å‡»æ“ä½œæŒ‰é’®ä¸è§¦å‘ï¼‰
        document.querySelectorAll('.wyy-playlist-card[data-playlist-id]').forEach(card => {
            card.addEventListener('click', async function(e) {
                // å¦‚æœç‚¹å‡»çš„æ˜¯æ“ä½œæŒ‰é’®åŒºåŸŸï¼Œä¸è§¦å‘
                if (e.target.closest('.wyy-playlist-actions')) {
                    return;
                }
                const playlistId = parseInt(this.getAttribute('data-playlist-id'));
                await wyyShowPlaylistDetail(playlistId);
            });
        });
    } catch (error) {
        console.error('åŠ è½½æ­Œå•åˆ—è¡¨å¤±è´¥:', error);
    }
}

// åˆ‡æ¢æ­Œå•
async function wyySwitchPlaylist(playlistId) {
    wyyCurrentPlaylistId = playlistId;
    await wyyInitPlaylist();
}

// æ˜¾ç¤ºæ­Œå•è¯¦æƒ…
async function wyyShowPlaylistDetail(playlistId) {
    try {
        const playlist = await wyyDb.playlists.get(playlistId);
        if (!playlist) {
            alert('æ­Œå•ä¸å­˜åœ¨');
            return;
        }
        
        let songs = await wyyDb.songs.where('playlistId').equals(playlistId).toArray();
        // åœ¨å†…å­˜ä¸­æŒ‰æ—¥æœŸæ’åº
        songs.sort((a, b) => {
            const dateA = a.dateAdded ? new Date(a.dateAdded).getTime() : 0;
            const dateB = b.dateAdded ? new Date(b.dateAdded).getTime() : 0;
            return dateA - dateB;
        });
        
        // æ›´æ–°æ ‡é¢˜
        const titleElement = document.getElementById('wyyPlaylistDetailTitle');
        if (titleElement) {
            titleElement.textContent = `${playlist.name} (${songs.length}é¦–)`;
        }
        
        // æ˜¾ç¤ºæ­Œæ›²åˆ—è¡¨
        const songsListElement = document.getElementById('wyyPlaylistDetailSongsList');
        if (!songsListElement) return;
        
        if (songs.length === 0) {
            songsListElement.innerHTML = '<div class="wyy-empty-playlist">è¯¥æ­Œå•æš‚æ— æ­Œæ›²</div>';
        } else {
            let html = '';
            songs.forEach((song, index) => {
                const hasCover = song.cover && song.cover !== '';
                html += `
                    <div class="wyy-song-item" data-song-id="${song.id}">
                        <div class="wyy-song-item-icon ${!hasCover ? 'default' : ''}" style="${hasCover ? `background-image: url(${song.cover})` : ''}">
                            ${!hasCover ? (index + 1) : ''}
                        </div>
                        <div class="wyy-song-item-info">
                            <div class="wyy-song-item-name">${song.name}</div>
                            <div class="wyy-song-item-singer">${song.singer}</div>
                        </div>
                    </div>
                `;
            });
            songsListElement.innerHTML = html;
        }
        
        // æ˜¾ç¤ºæ¨¡æ€æ¡†
        const modal = document.getElementById('wyyPlaylistDetailModal');
        if (modal) {
            modal.style.display = 'flex';
            
            // è®¾ç½®åˆ‡æ¢åˆ°è¯¥æ­Œå•çš„æŒ‰é’®äº‹ä»¶
            const switchBtn = document.getElementById('wyySwitchToPlaylistBtn');
            if (switchBtn) {
                switchBtn.onclick = async () => {
                    await wyySwitchPlaylist(playlistId);
                    modal.style.display = 'none';
                };
            }
        }
    } catch (error) {
        console.error('åŠ è½½æ­Œå•è¯¦æƒ…å¤±è´¥:', error);
        alert('åŠ è½½æ­Œå•è¯¦æƒ…å¤±è´¥');
    }
}

// å…³é—­æ­Œå•è¯¦æƒ…
const wyyClosePlaylistDetailBtn = document.getElementById('wyyClosePlaylistDetailBtn');
const wyyPlaylistDetailModal = document.getElementById('wyyPlaylistDetailModal');

if (wyyClosePlaylistDetailBtn) {
    wyyClosePlaylistDetailBtn.addEventListener('click', () => {
        if (wyyPlaylistDetailModal) wyyPlaylistDetailModal.style.display = 'none';
    });
}

if (wyyPlaylistDetailModal) {
    wyyPlaylistDetailModal.addEventListener('click', (e) => {
        if (e.target === wyyPlaylistDetailModal) {
            wyyPlaylistDetailModal.style.display = 'none';
        }
    });
}

// æ‰“å¼€æ­Œå•ç®¡ç†
const wyyManagePlaylistsBtn = document.getElementById('wyyManagePlaylistsBtn');
if (wyyManagePlaylistsBtn) {
    wyyManagePlaylistsBtn.addEventListener('click', () => {
        const modal = document.getElementById('wyyPlaylistManageModal');
        if (modal) {
            modal.style.display = 'flex';
        }
    });
}

// åˆ›å»ºæ­Œå•
const wyyNewPlaylistBtn = document.getElementById('wyyNewPlaylistBtn');
const wyyCreatePlaylistModal = document.getElementById('wyyCreatePlaylistModal');
const wyyNewPlaylistName = document.getElementById('wyyNewPlaylistName');
const wyyNewPlaylistDesc = document.getElementById('wyyNewPlaylistDesc');
const wyyNewPlaylistCoverPreview = document.getElementById('wyyNewPlaylistCoverPreview');
const wyyUploadPlaylistCoverBtn = document.getElementById('wyyUploadPlaylistCoverBtn');
const wyyPlaylistCoverFileInput = document.getElementById('wyyPlaylistCoverFileInput');
const wyyCancelCreatePlaylistBtn = document.getElementById('wyyCancelCreatePlaylistBtn');
const wyySaveCreatePlaylistBtn = document.getElementById('wyySaveCreatePlaylistBtn');

let wyyTempPlaylistCover = null;

if (wyyNewPlaylistBtn) {
    wyyNewPlaylistBtn.addEventListener('click', () => {
        if (wyyCreatePlaylistModal) wyyCreatePlaylistModal.style.display = 'flex';
        if (wyyNewPlaylistName) wyyNewPlaylistName.value = '';
        if (wyyNewPlaylistDesc) wyyNewPlaylistDesc.value = '';
        if (wyyNewPlaylistCoverPreview) wyyNewPlaylistCoverPreview.style.backgroundImage = '';
        wyyTempPlaylistCover = null;
    });
}

if (wyyUploadPlaylistCoverBtn && wyyPlaylistCoverFileInput) {
    wyyUploadPlaylistCoverBtn.addEventListener('click', () => {
        wyyPlaylistCoverFileInput.click();
    });

    wyyPlaylistCoverFileInput.addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (file) {
            if (!file.type.match('image.*')) {
                alert('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶ï¼');
                return;
            }
            if (file.size > 5 * 1024 * 1024) {
                alert('å›¾ç‰‡å¤§å°ä¸èƒ½è¶…è¿‡5MBï¼');
                return;
            }
            const reader = new FileReader();
            reader.onload = function(e) {
                if (wyyNewPlaylistCoverPreview) wyyNewPlaylistCoverPreview.style.backgroundImage = `url(${e.target.result})`;
                wyyTempPlaylistCover = e.target.result;
            };
            reader.readAsDataURL(file);
        }
    });
}

if (wyyCancelCreatePlaylistBtn) {
    wyyCancelCreatePlaylistBtn.addEventListener('click', () => {
        if (wyyCreatePlaylistModal) wyyCreatePlaylistModal.style.display = 'none';
    });
}

if (wyySaveCreatePlaylistBtn && wyyNewPlaylistName) {
    wyySaveCreatePlaylistBtn.addEventListener('click', async () => {
        const name = wyyNewPlaylistName.value.trim();
        if (!name) {
            alert('è¯·è¾“å…¥æ­Œå•åç§°');
            return;
        }
        
        try {
            const playlistId = await wyyDb.playlists.add({
                name: name,
                desc: wyyNewPlaylistDesc ? wyyNewPlaylistDesc.value.trim() : '',
                cover: wyyTempPlaylistCover || '',
                dateCreated: new Date()
            });
            
            if (wyyCreatePlaylistModal) wyyCreatePlaylistModal.style.display = 'none';
            await wyyLoadPlaylists();
            await wyySwitchPlaylist(playlistId);
            alert('æ­Œå•åˆ›å»ºæˆåŠŸï¼');
        } catch (error) {
            console.error('åˆ›å»ºæ­Œå•å¤±è´¥:', error);
            alert('åˆ›å»ºæ­Œå•å¤±è´¥ï¼Œè¯·é‡è¯•');
        }
    });
}

if (wyyCreatePlaylistModal) {
    wyyCreatePlaylistModal.addEventListener('click', (e) => {
        if (e.target === wyyCreatePlaylistModal) {
            wyyCreatePlaylistModal.style.display = 'none';
        }
    });
}

// åˆ é™¤æ­Œå•
async function wyyDeletePlaylist(playlistId) {
    if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªæ­Œå•å—ï¼Ÿæ­Œå•ä¸­çš„æ­Œæ›²ä¸ä¼šè¢«åˆ é™¤ã€‚')) {
        return;
    }
    
    try {
        // åˆ é™¤æ­Œå•
        await wyyDb.playlists.delete(playlistId);
        
        // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰æ­Œå•ï¼Œåˆ‡æ¢åˆ°é»˜è®¤æ­Œå•
        if (wyyCurrentPlaylistId === playlistId) {
            wyyCurrentPlaylistId = null;
            await wyyInitPlaylist();
        }
        
        await wyyLoadPlaylists();
        alert('æ­Œå•åˆ é™¤æˆåŠŸï¼');
    } catch (error) {
        console.error('åˆ é™¤æ­Œå•å¤±è´¥:', error);
        alert('åˆ é™¤æ­Œå•å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
}

// å¯¼å‡ºå•ä¸ªæ­Œå•
async function wyyExportSinglePlaylist(playlistId) {
    try {
        const playlist = await wyyDb.playlists.get(playlistId);
        if (!playlist) {
            alert('æ­Œå•ä¸å­˜åœ¨');
            return;
        }
        
        const songs = await wyyDb.songs.where('playlistId').equals(playlistId).toArray();
        
        // åŠ è½½æ¯é¦–æ­Œæ›²çš„å®Œæ•´ä¿¡æ¯
        const fullSongs = [];
        for (const song of songs) {
            const songFile = await wyyDb.songFiles.where({ songId: song.id }).first();
            const lyric = await wyyDb.lyrics.where({ songId: song.id }).first();
            
            const fullSong = {
                name: song.name,
                singer: song.singer,
                cover: song.cover || '',
                url: song.url || '',
                lyricUrl: song.lyricUrl || '',
                hasLocalFile: !!songFile,
                hasLocalLyric: !!lyric
            };
            
            if (songFile) {
                fullSong.fileData = songFile.data;
                fullSong.fileType = songFile.type;
            }
            
            if (lyric) {
                fullSong.lyricData = lyric.data;
            }
            
            fullSongs.push(fullSong);
        }
        
        const exportData = {
            playlist: {
                name: playlist.name,
                desc: playlist.desc,
                cover: playlist.cover
            },
            songs: fullSongs,
            exportDate: new Date().toISOString()
        };
        
        const dataStr = JSON.stringify(exportData, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `${playlist.name}.json`;
        link.click();
        URL.revokeObjectURL(url);
        
        alert('æ­Œå•å¯¼å‡ºæˆåŠŸï¼');
    } catch (error) {
        console.error('å¯¼å‡ºæ­Œå•å¤±è´¥:', error);
        alert('å¯¼å‡ºæ­Œå•å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
}

// å¯¼å‡ºå½“å‰æ­Œå•
const wyyExportPlaylistBtn = document.getElementById('wyyExportPlaylistBtn');
if (wyyExportPlaylistBtn) {
    wyyExportPlaylistBtn.addEventListener('click', async () => {
        if (!wyyCurrentPlaylistId) {
            alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ­Œå•');
            return;
        }
        await wyyExportSinglePlaylist(wyyCurrentPlaylistId);
    });
}

// å¯¼å…¥æ­Œå•
const wyyImportPlaylistBtn = document.getElementById('wyyImportPlaylistBtn');
const wyyImportPlaylistFileInput = document.getElementById('wyyImportPlaylistFileInput');

if (wyyImportPlaylistBtn && wyyImportPlaylistFileInput) {
    wyyImportPlaylistBtn.addEventListener('click', () => {
        wyyImportPlaylistFileInput.click();
    });

    wyyImportPlaylistFileInput.addEventListener('change', async function(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        if (!file.name.endsWith('.json')) {
            alert('è¯·é€‰æ‹©JSONæ ¼å¼çš„æ–‡ä»¶');
            return;
        }
        
        try {
            const text = await file.text();
            const importData = JSON.parse(text);
            
            if (!importData.playlist || !importData.songs) {
                alert('æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®');
                return;
            }
            
            // åˆ›å»ºæ­Œå•
            const playlistId = await wyyDb.playlists.add({
                name: importData.playlist.name + ' (å¯¼å…¥)',
                desc: importData.playlist.desc || '',
                cover: importData.playlist.cover || '',
                dateCreated: new Date()
            });
            
            // å¯¼å…¥æ­Œæ›²
            for (const songData of importData.songs) {
                const songId = await wyyDb.songs.add({
                    name: songData.name,
                    singer: songData.singer,
                    cover: songData.cover || '',
                    url: songData.url || '',
                    lyricUrl: songData.lyricUrl || '',
                    playlistId: playlistId,
                    dateAdded: new Date()
                });
                
                if (songData.hasLocalFile && songData.fileData) {
                    await wyyDb.songFiles.add({
                        songId: songId,
                        type: songData.fileType || 'audio/mpeg',
                        data: songData.fileData
                    });
                }
                
                if (songData.hasLocalLyric && songData.lyricData) {
                    await wyyDb.lyrics.add({
                        songId: songId,
                        data: songData.lyricData
                    });
                }
            }
            
            await wyyLoadPlaylists();
            await wyySwitchPlaylist(playlistId);
            alert('æ­Œå•å¯¼å…¥æˆåŠŸï¼');
        } catch (error) {
            console.error('å¯¼å…¥æ­Œå•å¤±è´¥:', error);
            alert('å¯¼å…¥æ­Œå•å¤±è´¥ï¼š' + error.message);
        }
    });
}

// æ·»åŠ åˆ°æ­Œå•åŠŸèƒ½
const wyyAddToPlaylistModal = document.getElementById('wyyAddToPlaylistModal');
const wyyPlaylistSelectorList = document.getElementById('wyyPlaylistSelectorList');
const wyyCancelAddToPlaylistBtn = document.getElementById('wyyCancelAddToPlaylistBtn');
let wyyCurrentAddSongId = null;

// æ˜¾ç¤ºæ·»åŠ åˆ°æ­Œå•æ¨¡æ€æ¡†
async function wyyShowAddToPlaylistModal(songId) {
    wyyCurrentAddSongId = songId;
    
    try {
        const playlists = await wyyDb.playlists.orderBy('dateCreated').reverse().toArray();
        
        if (!wyyPlaylistSelectorList) return;
        
        if (playlists.length === 0) {
            wyyPlaylistSelectorList.innerHTML = '<div style="text-align: center; padding: 20px; color: #999;">è¿˜æ²¡æœ‰æ­Œå•ï¼Œè¯·å…ˆåˆ›å»ºæ­Œå•</div>';
        } else {
            let html = '';
            playlists.forEach(playlist => {
                html += `
                    <div class="wyy-playlist-selector-item" data-playlist-id="${playlist.id}" style="padding: 12px; border-bottom: 1px solid #eee; cursor: pointer; display: flex; align-items: center; gap: 12px; transition: background 0.2s;">
                        <div class="wyy-playlist-cover" style="width: 40px; height: 40px; border-radius: 6px; ${playlist.cover ? `background-image: url(${playlist.cover})` : 'background: #f0f0f0;'}"></div>
                        <div style="flex: 1;">
                            <div style="font-weight: 500; color: #333; margin-bottom: 2px;">${playlist.name}</div>
                            <div style="font-size: 12px; color: #999;">${playlist.desc || 'æš‚æ— æè¿°'}</div>
                        </div>
                        <i class="fa fa-chevron-right" style="color: #ccc;"></i>
                    </div>
                `;
            });
            
            wyyPlaylistSelectorList.innerHTML = html;
            
            // æ·»åŠ ç‚¹å‡»äº‹ä»¶
            document.querySelectorAll('.wyy-playlist-selector-item').forEach(item => {
                item.addEventListener('click', async function() {
                    const playlistId = parseInt(this.getAttribute('data-playlist-id'));
                    await wyyAddSongToPlaylist(songId, playlistId);
                });
            });
        }
        
        if (wyyAddToPlaylistModal) wyyAddToPlaylistModal.style.display = 'flex';
    } catch (error) {
        console.error('åŠ è½½æ­Œå•åˆ—è¡¨å¤±è´¥:', error);
        alert('åŠ è½½æ­Œå•åˆ—è¡¨å¤±è´¥');
    }
}

// å°†æ­Œæ›²æ·»åŠ åˆ°æ­Œå•
async function wyyAddSongToPlaylist(songId, playlistId) {
    try {
        // æ£€æŸ¥æ­Œæ›²æ˜¯å¦å·²ç»åœ¨æ­Œå•ä¸­
        const existingSong = await wyyDb.songs.where({ id: songId, playlistId: playlistId }).first();
        if (existingSong) {
            alert('æ­Œæ›²å·²åœ¨è¯¥æ­Œå•ä¸­');
            if (wyyAddToPlaylistModal) wyyAddToPlaylistModal.style.display = 'none';
            return;
        }
        
        // è·å–åŸæ­Œæ›²ä¿¡æ¯
        const originalSong = await wyyDb.songs.get(songId);
        if (!originalSong) {
            alert('æ­Œæ›²ä¸å­˜åœ¨');
            return;
        }
        
        // åˆ›å»ºæ–°æ­Œæ›²è®°å½•ï¼ˆæ·»åŠ åˆ°æ–°æ­Œå•ï¼‰
        const newSongData = {
            name: originalSong.name,
            singer: originalSong.singer,
            cover: originalSong.cover || '',
            url: originalSong.url || '',
            lyricUrl: originalSong.lyricUrl || '',
            playlistId: playlistId,
            dateAdded: new Date()
        };
        
        const newSongId = await wyyDb.songs.add(newSongData);
        
        // å¤åˆ¶æ­Œæ›²æ–‡ä»¶
        const songFile = await wyyDb.songFiles.where({ songId: songId }).first();
        if (songFile) {
            await wyyDb.songFiles.add({
                songId: newSongId,
                type: songFile.type,
                data: songFile.data
            });
        }
        
        // å¤åˆ¶æ­Œè¯æ–‡ä»¶
        const lyric = await wyyDb.lyrics.where({ songId: songId }).first();
        if (lyric) {
            await wyyDb.lyrics.add({
                songId: newSongId,
                data: lyric.data
            });
        }
        
        if (wyyAddToPlaylistModal) wyyAddToPlaylistModal.style.display = 'none';
        alert('æ­Œæ›²å·²æ·»åŠ åˆ°æ­Œå•ï¼');
    } catch (error) {
        console.error('æ·»åŠ æ­Œæ›²åˆ°æ­Œå•å¤±è´¥:', error);
        alert('æ·»åŠ æ­Œæ›²åˆ°æ­Œå•å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
}

if (wyyCancelAddToPlaylistBtn) {
    wyyCancelAddToPlaylistBtn.addEventListener('click', () => {
        if (wyyAddToPlaylistModal) wyyAddToPlaylistModal.style.display = 'none';
    });
}

if (wyyAddToPlaylistModal) {
    wyyAddToPlaylistModal.addEventListener('click', (e) => {
        if (e.target === wyyAddToPlaylistModal) {
            wyyAddToPlaylistModal.style.display = 'none';
        }
    });
}

// æ­Œå•ç®¡ç†æ¨¡æ€æ¡†
const wyyPlaylistManageModal = document.getElementById('wyyPlaylistManageModal');
const wyyClosePlaylistManageBtn = document.getElementById('wyyClosePlaylistManageBtn');

if (wyyClosePlaylistManageBtn) {
    wyyClosePlaylistManageBtn.addEventListener('click', () => {
        if (wyyPlaylistManageModal) wyyPlaylistManageModal.style.display = 'none';
    });
}

if (wyyPlaylistManageModal) {
    wyyPlaylistManageModal.addEventListener('click', (e) => {
        if (e.target === wyyPlaylistManageModal) {
            wyyPlaylistManageModal.style.display = 'none';
        }
    });
}

// ============================================
// ä¸€èµ·å¬åŠŸèƒ½
// ============================================
let wyyTogetherListenRole = null; // å½“å‰ä¸€èµ·å¬çš„è§’è‰²
let wyyTogetherListenInterval = null; // æ›´æ–°ä¸€èµ·å¬çŠ¶æ€çš„å®šæ—¶å™¨

const wyyTogetherListenBtn = document.getElementById('wyyTogetherListenBtn');
const wyyTogetherListenModal = document.getElementById('wyyTogetherListenModal');
const wyyTogetherListenRoleList = document.getElementById('wyyTogetherListenRoleList');
const wyyCancelTogetherListenBtn = document.getElementById('wyyCancelTogetherListenBtn');
const wyyStopTogetherListenBtn = document.getElementById('wyyStopTogetherListenBtn');

// æ‰“å¼€ä¸€èµ·å¬é€‰æ‹©è§’è‰²æ¨¡æ€æ¡†
if (wyyTogetherListenBtn) {
    wyyTogetherListenBtn.addEventListener('click', () => {
        wyyShowTogetherListenRoleSelector();
    });
}

// æ˜¾ç¤ºè§’è‰²é€‰æ‹©å™¨ï¼ˆä»æ•°æ®åº“åŠ è½½è§’è‰²ï¼Œä¸åŒ…æ‹¬è”æœºå¥½å‹ï¼‰
async function wyyShowTogetherListenRoleSelector() {
    if (!wyyTogetherListenRoleList) return;
    
    try {
        const accountId = getCurrentAccountId();
        const allChars = await db.characters.toArray();
        // ç­›é€‰ï¼šéuserç±»å‹ã€æ˜¯å¥½å‹çŠ¶æ€çš„è§’è‰²
        const friends = allChars.filter(char => {
            if (char.type === 'user') return false;
            if (!accountId) return char.wechat_status === 'friend';
            const status = getFriendStatus(char, accountId);
            return status === 'friend';
        });
        
        if (friends.length === 0) {
            wyyTogetherListenRoleList.innerHTML = '<div style="text-align: center; padding: 20px; color: #999;">è¿˜æ²¡æœ‰å¥½å‹ï¼Œè¯·å…ˆæ·»åŠ è§’è‰²å¥½å‹</div>';
        } else {
            let html = '';
            friends.forEach(char => {
                const charName = char.name || 'æœªçŸ¥';
                const displayName = char.nick || char.name || 'æœªçŸ¥';
                const isActive = wyyTogetherListenRole === charName;
                const avatarUrl = char.avatar || '';
                const firstChar = String(displayName).charAt(0);
                
                const avatarHtml = avatarUrl 
                    ? `<div style="width: 42px; height: 42px; border-radius: 50%; background: url('${avatarUrl}') center/cover no-repeat; flex-shrink: 0;"></div>`
                    : `<div style="width: 42px; height: 42px; border-radius: 50%; background: #f0f0f0; display: flex; align-items: center; justify-content: center; font-size: 18px; color: #666; flex-shrink: 0;">${firstChar}</div>`;
                
                html += `
                    <div class="wyy-together-listen-item ${isActive ? 'active' : ''}" data-role="${charName}" data-char-id="${char.id}" style="padding: 12px 16px; border-bottom: 1px solid #f0f0f0; cursor: pointer; display: flex; align-items: center; gap: 12px; transition: background 0.2s;">
                        ${avatarHtml}
                        <div style="flex: 1; min-width: 0;">
                            <div style="font-weight: 500; color: #333; margin-bottom: 2px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${displayName}</div>
                            ${isActive ? '<div style="font-size: 12px; color: #ff6b6b;">â™ª æ­£åœ¨ä¸€èµ·å¬</div>' : ''}
                        </div>
                        ${isActive ? '<i class="fa fa-check-circle" style="color: #ff6b6b; font-size: 18px;"></i>' : '<i class="fa fa-chevron-right" style="color: #ccc;"></i>'}
                    </div>
                `;
            });
            wyyTogetherListenRoleList.innerHTML = html;
            
            // æ·»åŠ ç‚¹å‡»äº‹ä»¶
            document.querySelectorAll('.wyy-together-listen-item[data-role]').forEach(item => {
                item.addEventListener('click', function() {
                    const role = this.getAttribute('data-role');
                    const charId = this.getAttribute('data-char-id');
                    if (wyyTogetherListenRole === role) {
                        wyyStopTogetherListen();
                    } else {
                        wyyStartTogetherListen(role, charId);
                    }
                });
            });
        }
    } catch (error) {
        console.error('[ä¸€èµ·å¬] åŠ è½½è§’è‰²åˆ—è¡¨å¤±è´¥:', error);
        wyyTogetherListenRoleList.innerHTML = '<div style="text-align: center; padding: 20px; color: #999;">åŠ è½½å¤±è´¥ï¼Œè¯·é‡è¯•</div>';
    }
    
    // æ›´æ–°ç»“æŸæŒ‰é’®æ˜¾ç¤º
    if (wyyStopTogetherListenBtn) {
        if (wyyTogetherListenRole) {
            wyyStopTogetherListenBtn.style.display = 'block';
        } else {
            wyyStopTogetherListenBtn.style.display = 'none';
        }
    }
    
    if (wyyTogetherListenModal) wyyTogetherListenModal.style.display = 'flex';
}

// å¼€å§‹ä¸€èµ·å¬
let wyyTogetherListenCharId = null; // å½“å‰ä¸€èµ·å¬è§’è‰²çš„ID
function wyyStartTogetherListen(role, charId) {
    // ç¡®ä¿roleæ˜¯å­—ç¬¦ä¸²
    wyyTogetherListenRole = String(role);
    wyyTogetherListenCharId = charId ? parseInt(charId) : null;
    if (wyyTogetherListenBtn) wyyTogetherListenBtn.classList.add('active');
    if (wyyTogetherListenModal) wyyTogetherListenModal.style.display = 'none';
    
    // æ›´æ–°æ’­æ”¾é¡µé¡¶æ æ˜¾ç¤º
    wyyUpdateTogetherListenDisplay();
    
    // çŠ¶æ€ä¼šé€šè¿‡ systemPrompt ä¼ é€’ç»™è§’è‰²
    wyyStartTogetherListenUpdate();
    
    showToast(`æ­£åœ¨å’Œ ${wyyTogetherListenRole} ä¸€èµ·å¬ â™ª`);
}

// ç»“æŸä¸€èµ·å¬
function wyyStopTogetherListen() {
    const prevRole = wyyTogetherListenRole;
    wyyTogetherListenRole = null;
    wyyTogetherListenCharId = null;
    if (wyyTogetherListenBtn) wyyTogetherListenBtn.classList.remove('active');
    if (wyyTogetherListenModal) wyyTogetherListenModal.style.display = 'none';
    
    // æ›´æ–°æ’­æ”¾é¡µé¡¶æ æ˜¾ç¤º
    wyyUpdateTogetherListenDisplay();
    
    // åœæ­¢å®šæ—¶æ›´æ–°
    wyyStopTogetherListenUpdate();
    
    if (prevRole) showToast(`å·²ç»“æŸå’Œ ${prevRole} ä¸€èµ·å¬`);
}

// å¼€å§‹å®šæ—¶æ›´æ–°ä¸€èµ·å¬çŠ¶æ€ï¼ˆä¸å†æ›´æ–°å¡ç‰‡ï¼Œåªä¿æŒçŠ¶æ€ï¼‰
function wyyStartTogetherListenUpdate() {
    wyyStopTogetherListenUpdate();
    // ä¸å†æ›´æ–°å¡ç‰‡ï¼Œå› ä¸ºä¸å†å‘é€æ¶ˆæ¯åˆ°å¯¹è¯æ¡†
    // çŠ¶æ€ä¼šé€šè¿‡ systemPrompt ä¼ é€’ç»™è§’è‰²
}

// åœæ­¢å®šæ—¶æ›´æ–°
function wyyStopTogetherListenUpdate() {
    if (wyyTogetherListenInterval) {
        clearInterval(wyyTogetherListenInterval);
        wyyTogetherListenInterval = null;
    }
}

// æ›´æ–°æ’­æ”¾é¡µä¸€èµ·å¬çŠ¶æ€æ˜¾ç¤º
function wyyUpdateTogetherListenDisplay() {
    const titleEl = document.querySelector('.wyy-player-top-bar-title');
    if (!titleEl) return;
    
    if (wyyTogetherListenRole) {
        titleEl.innerHTML = `<div style="font-size:14px; line-height:1.2;">æ­£åœ¨æ’­æ”¾</div><div style="font-size:11px; color:rgba(255,255,255,0.6); line-height:1.2;">ä¸ ${wyyTogetherListenRole} ä¸€èµ·å¬ â™ª</div>`;
    } else {
        titleEl.textContent = 'æ­£åœ¨æ’­æ”¾';
    }
}

// è·å–å½“å‰ä¸€èµ·å¬çš„çŠ¶æ€ä¿¡æ¯ï¼ˆä¾›system promptä½¿ç”¨ï¼‰
function wyyGetTogetherListenInfo() {
    if (!wyyTogetherListenRole) return null;
    
    let songName = 'æœªçŸ¥æ­Œæ›²';
    let singerName = 'æœªçŸ¥æ­Œæ‰‹';
    
    if (wyyPlaylist.length > 0 && wyyCurrentSongIndex < wyyPlaylist.length) {
        const currentSong = wyyPlaylist[wyyCurrentSongIndex];
        songName = currentSong.name || currentSong.title || 'æœªçŸ¥æ­Œæ›²';
        singerName = currentSong.singer || currentSong.artist || 'æœªçŸ¥æ­Œæ‰‹';
    }
    
    return {
        role: wyyTogetherListenRole,
        charId: wyyTogetherListenCharId,
        songName: songName,
        singerName: singerName,
        isPlaying: wyyAudio && !wyyAudio.paused
    };
}

// ä»èŠå¤©åˆ‡æ¢æ­Œæ›²ï¼ˆå…¨å±€å‡½æ•°ï¼Œä¾›HTML onclickä½¿ç”¨ï¼‰
window.wyySwitchSongFromChat = function(role, direction) {
    // ç¡®ä¿ç±»å‹ä¸€è‡´è¿›è¡Œæ¯”è¾ƒ
    const roleStr = String(role);
    if (String(wyyTogetherListenRole) !== roleStr) {
        alert('å½“å‰æ²¡æœ‰å’Œè¯¥è§’è‰²ä¸€èµ·å¬');
        return;
    }
    
    if (direction === 'prev') {
        if (wyyPlaylist.length > 0) {
            wyyCurrentSongIndex = (wyyCurrentSongIndex - 1 + wyyPlaylist.length) % wyyPlaylist.length;
            wyyPlaySong(wyyCurrentSongIndex);
            // ä¸å†å‘é€æ¶ˆæ¯åˆ°å¯¹è¯æ¡†ï¼ŒçŠ¶æ€ä¼šé€šè¿‡ systemPrompt ä¼ é€’ç»™è§’è‰²
        }
    } else if (direction === 'next') {
        if (wyyPlaylist.length > 0) {
            wyyCurrentSongIndex = (wyyCurrentSongIndex + 1) % wyyPlaylist.length;
            wyyPlaySong(wyyCurrentSongIndex);
            // ä¸å†å‘é€æ¶ˆæ¯åˆ°å¯¹è¯æ¡†ï¼ŒçŠ¶æ€ä¼šé€šè¿‡ systemPrompt ä¼ é€’ç»™è§’è‰²
        }
    }
}

if (wyyCancelTogetherListenBtn) {
    wyyCancelTogetherListenBtn.addEventListener('click', () => {
        if (wyyTogetherListenModal) wyyTogetherListenModal.style.display = 'none';
    });
}

if (wyyStopTogetherListenBtn) {
    wyyStopTogetherListenBtn.addEventListener('click', () => {
        wyyStopTogetherListen();
    });
}

if (wyyTogetherListenModal) {
    wyyTogetherListenModal.addEventListener('click', (e) => {
        if (e.target === wyyTogetherListenModal) {
            wyyTogetherListenModal.style.display = 'none';
        }
    });
}

// é˜»æ­¢æ­Œè¯å®¹å™¨æ»šåŠ¨äº‹ä»¶å†’æ³¡ï¼Œé¿å…å½±å“é¡µé¢æ»šåŠ¨
if (wyyLyricsContainer) {
    wyyLyricsContainer.addEventListener('touchmove', (e) => {
        e.stopPropagation();
    }, { passive: true });
    wyyLyricsContainer.addEventListener('wheel', (e) => {
        e.stopPropagation();
    }, { passive: true });
}

// é¡µé¢åŠ è½½æ—¶æ¢å¤è®¾ç½®å’Œåˆå§‹åŒ–æ’­æ”¾åˆ—è¡¨
window.addEventListener('DOMContentLoaded', async () => {
    try {
        // ç¡®ä¿æ’­æ”¾å™¨è¯¦æƒ…é¡µé¢åˆå§‹çŠ¶æ€æ˜¯éšè—çš„
        if (wyyPlayerPage) wyyPlayerPage.classList.remove('active');
        if (wyyMainPage) wyyMainPage.classList.add('active');
        
        const savedAvatar = await wyyDb.userSettings.get('avatar');
        if (savedAvatar && wyyAvatarDisplay) {
            wyyAvatarDisplay.style.backgroundImage = `url(${savedAvatar.data})`;
        }
        
        const savedFollow = await wyyDb.userSettings.get('follow');
        const savedFans = await wyyDb.userSettings.get('fans');
        const savedLevel = await wyyDb.userSettings.get('level');
        const savedTime = await wyyDb.userSettings.get('time');
        
        if (savedFollow && wyyFollowValue) wyyFollowValue.textContent = savedFollow.data;
        if (savedFans && wyyFansValue) wyyFansValue.textContent = savedFans.data;
        if (savedLevel && wyyLevelValue) wyyLevelValue.textContent = savedLevel.data;
        if (savedTime && wyyTimeValue) wyyTimeValue.textContent = savedTime.data;
        
        for (let i = 1; i <= 4; i++) {
            const cardKey = `card${i}`;
            const savedCard = await wyyDb.playlistCards.get(cardKey);
            const cardElement = document.getElementById(`wyyCard${i}`);
            if (cardElement && savedCard) {
                cardElement.style.backgroundImage = `url(${savedCard.data})`;
            }
        }
        
        await wyyInitPlaylist();
        await wyyLoadPlaylists();
    } catch (error) {
        console.error('åŠ è½½è®¾ç½®å¤±è´¥:', error);
    }
});

// ==================== å°å±‹åŠŸèƒ½ ====================
let currentCabinMachine = 'furniture'; // furniture æˆ– clothes
let cabinCoinCount = 200;

// å°å±‹æ‰­è›‹çŠ¶æ€ç®¡ç†
window.cabinGachaState = {
    coins: 200,
    customItems: {},  // ç‰©å“åº“
    catalog: {},      // å›¾é‰´è®°å½•
    inventory: {},    // èƒŒåŒ…åº“å­˜
    gachaPool: {
        furniture: [],
        clothes: []
    }
};

function showCabinPage() {
    document.getElementById('home-page').style.display = 'none';
    document.getElementById('cabin-page').style.display = 'flex';
    
    // é¦–æ¬¡æ‰“å¼€æ—¶åˆå§‹åŒ–æ•°æ®
    if (!window.cabinInitialized) {
        // å°è¯•ä»æœ¬åœ°å­˜å‚¨åŠ è½½æ•°æ®
        const loaded = loadCabinGachaData();
        
        // å¦‚æœæ²¡æœ‰ä¿å­˜çš„æ•°æ®ï¼Œåˆå§‹åŒ–é»˜è®¤ç‰©å“
        if (!loaded) {
            initDefaultItems();
        }
        
        window.cabinInitialized = true;
    }
    
    updateCabinCoinDisplay();
    updateCabinUI();
}

function hideCabinPage() {
    document.getElementById('cabin-page').style.display = 'none';
    document.getElementById('home-page').style.display = 'flex';
}

function updateCabinCoinDisplay() {
    const state = window.cabinGachaState;
    const coinElement = document.getElementById('cabin-coin-count');
    if (coinElement) {
        coinElement.textContent = state.coins;
    }
    // åŒæ­¥å…¨å±€å˜é‡
    cabinCoinCount = state.coins;
}

// ä¿å­˜å°å±‹æ‰­è›‹æ•°æ®åˆ°æœ¬åœ°å­˜å‚¨
function saveCabinGachaData() {
    try {
        const state = window.cabinGachaState;
        localStorage.setItem('cabinGachaState', JSON.stringify(state));
        console.log('å°å±‹æ•°æ®å·²ä¿å­˜');
    } catch (e) {
        console.error('ä¿å­˜å°å±‹æ•°æ®å¤±è´¥:', e);
    }
}

// ä»æœ¬åœ°å­˜å‚¨åŠ è½½å°å±‹æ‰­è›‹æ•°æ®
function loadCabinGachaData() {
    try {
        const saved = localStorage.getItem('cabinGachaState');
        if (saved) {
            const state = JSON.parse(saved);
            window.cabinGachaState = state;
            cabinCoinCount = state.coins;
            console.log('å°å±‹æ•°æ®å·²åŠ è½½');
            return true;
        }
    } catch (e) {
        console.error('åŠ è½½å°å±‹æ•°æ®å¤±è´¥:', e);
    }
    return false;
}

// æ›´æ–°å°å±‹UIï¼ˆåˆ·æ–°æ‰€æœ‰ç›¸å…³æ˜¾ç¤ºï¼‰
function updateCabinUI() {
    // æ›´æ–°é‡‘å¸æ˜¾ç¤º
    updateCabinCoinDisplay();
    
    // å¦‚æœå›¾é‰´å¼¹çª—æ‰“å¼€ï¼Œåˆ·æ–°å›¾é‰´
    const catalogModal = document.getElementById('catalog-modal');
    if (catalogModal && catalogModal.style.display === 'flex') {
        renderCatalogItems();
    }
    
    // æ›´æ–°èƒŒåŒ…æ˜¾ç¤ºï¼ˆå¦‚æœæœ‰èƒŒåŒ…UIï¼‰
    updateCabinInventoryDisplay();
}

function switchCabinScreen(screenName) {
    // ç§»é™¤æ‰€æœ‰activeç±»
    document.querySelectorAll('.cabin-screen').forEach(s => s.classList.remove('active'));
    document.querySelectorAll('.cabin-nav-item').forEach(n => n.classList.remove('active'));

    // æ·»åŠ activeç±»
    const screen = document.getElementById('cabin-' + screenName + '-screen');
    if (screen) {
        screen.classList.add('active');
    }
    
    // æ‰¾åˆ°å¯¹åº”çš„å¯¼èˆªé¡¹å¹¶æ¿€æ´»
    const navItems = document.querySelectorAll('.cabin-nav-item');
    navItems.forEach(item => {
        const text = item.querySelector('.cabin-nav-item-text').textContent;
        if ((screenName === 'gacha' && text === 'æ‰­è›‹') ||
            (screenName === 'catalog' && text === 'å›¾é‰´') ||
            (screenName === 'house' && text === 'æˆ¿å±‹') ||
            (screenName === 'character' && text === 'äººç‰©')) {
            item.classList.add('active');
        }
    });
}

function switchCabinMachine() {
    const furnitureGacha = document.getElementById('cabin-furniture-gacha');
    const clothesGacha = document.getElementById('cabin-clothes-gacha');
    const machineTitle = document.getElementById('cabin-machine-title');

    if (currentCabinMachine === 'furniture') {
        furnitureGacha.style.display = 'none';
        clothesGacha.style.display = 'flex';
        machineTitle.textContent = 'æœè£…æ‰­è›‹æœº';
        currentCabinMachine = 'clothes';
    } else {
        furnitureGacha.style.display = 'flex';
        clothesGacha.style.display = 'none';
        machineTitle.textContent = 'å®¶å…·æ‰­è›‹æœº';
        currentCabinMachine = 'furniture';
    }
}

// ç¨€æœ‰åº¦æƒé‡é…ç½®
const RARITY_WEIGHTS = {
    'R': 70,    // 70%
    'SR': 25,   // 25%
    'SSR': 5    // 5%
};

// æ ¹æ®æƒé‡éšæœºæŠ½å–ä¸€ä¸ªç¨€æœ‰åº¦
function getRandomRarity() {
    const total = Object.values(RARITY_WEIGHTS).reduce((sum, weight) => sum + weight, 0);
    let random = Math.random() * total;
    
    for (const [rarity, weight] of Object.entries(RARITY_WEIGHTS)) {
        random -= weight;
        if (random <= 0) {
            return rarity;
        }
    }
    return 'R'; // é»˜è®¤è¿”å›R
}

// æ ¹æ®ç¨€æœ‰åº¦ä»ç‰©å“æ± ä¸­éšæœºæŠ½å–ç‰©å“
function drawItem(targetRarity) {
    const state = window.cabinGachaState;
    
    // è·å–å½“å‰æ‰­è›‹æœºç±»å‹çš„ç‰©å“æ± 
    const poolType = currentCabinMachine === 'furniture' ? 'furniture' : 'clothes';
    
    // è·å–æ‰€æœ‰å¯æŠ½å–çš„ç‰©å“
    const availableItems = Object.entries(state.customItems)
        .filter(([id, item]) => {
            // å®¶å…·æ‰­è›‹æœºæŠ½å–å®¶å…·ç±»
            if (poolType === 'furniture') {
                return item.inPool && ['furniture', 'decor', 'wall', 'floor'].includes(item.type);
            }
            // æœè£…æ‰­è›‹æœºæŠ½å–æœè£…ç±»ï¼ˆæš‚æœªå®ç°ï¼‰
            return false;
        })
        .filter(([id, item]) => item.rarity === targetRarity);
    
    if (availableItems.length === 0) {
        // å¦‚æœè¯¥ç¨€æœ‰åº¦æ²¡æœ‰ç‰©å“ï¼Œé™çº§æŠ½å–
        if (targetRarity === 'SSR') return drawItem('SR');
        if (targetRarity === 'SR') return drawItem('R');
        // å¦‚æœéƒ½æ²¡æœ‰ï¼Œéšæœºè¿”å›ä»»æ„ç‰©å“
        const allItems = Object.entries(state.customItems).filter(([id, item]) => item.inPool);
        if (allItems.length > 0) {
            const randomIndex = Math.floor(Math.random() * allItems.length);
            return allItems[randomIndex];
        }
        return null;
    }
    
    // éšæœºé€‰æ‹©ä¸€ä¸ªç‰©å“
    const randomIndex = Math.floor(Math.random() * availableItems.length);
    return availableItems[randomIndex];
}

// æ›´æ–°èƒŒåŒ…å’Œå›¾é‰´
function addItemToInventory(itemId) {
    const state = window.cabinGachaState;
    
    // æ›´æ–°èƒŒåŒ…
    state.inventory[itemId] = (state.inventory[itemId] || 0) + 1;
    
    // æ›´æ–°å›¾é‰´
    if (!state.catalog[itemId]) {
        state.catalog[itemId] = { seen: true, owned: true };
    } else {
        state.catalog[itemId].seen = true;
        state.catalog[itemId].owned = true;
    }
    
    // ä¿å­˜çŠ¶æ€
    saveCabinGachaData();
}

// æ˜¾ç¤ºæŠ½å¥–ç»“æœ
function showDrawResult(items) {
    if (!items || items.length === 0) return;
    
    const state = window.cabinGachaState;
    
    // åˆ›å»ºç»“æœå¼¹çª—HTML
    let resultHTML = '<div class="draw-result-modal" id="draw-result-modal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000; font-family: \'Press Start 2P\', cursive;">';
    resultHTML += '<div class="draw-result-content" style="background: #ffffff; border: 4px solid #FFB3C1; border-radius: 0; padding: 25px; max-width: 90%; max-height: 80%; overflow-y: auto; box-shadow: 8px 8px 0 rgba(255, 179, 193, 0.3);">';
    
    // æ ‡é¢˜å¸¦å›¾æ ‡
    resultHTML += '<div style="display: flex; align-items: center; justify-content: center; gap: 12px; margin-bottom: 20px;">';
    resultHTML += '<svg style="width: 24px; height: 24px; stroke: #FFB3C1;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><path d="M16 8h-8m4-4v16"></path></svg>';
    resultHTML += '<div style="font-size: 14px; color: #666666; font-weight: bold;">æŠ½å¥–ç»“æœ</div>';
    resultHTML += '<svg style="width: 24px; height: 24px; stroke: #FFB3C1;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><path d="M16 8h-8m4-4v16"></path></svg>';
    resultHTML += '</div>';
    
    // æ˜¾ç¤ºæ‰€æœ‰æŠ½åˆ°çš„ç‰©å“
    resultHTML += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: 12px; margin-bottom: 20px;">';
    
    items.forEach(([itemId, item]) => {
        // æ ¹æ®ç¨€æœ‰åº¦è®¾ç½®èƒŒæ™¯è‰²
        let rarityBg = '#FAFAFA';  // R - æµ…ç°ç™½
        let rarityBorder = '#E0E0E0';  // R - ç°è‰²è¾¹æ¡†
        
        if (item.rarity === 'SR') {
            rarityBg = '#FFF5F7';  // SR - æµ…ç²‰
            rarityBorder = '#FFD4DC';  // SR - ç²‰è‰²è¾¹æ¡†
        } else if (item.rarity === 'SSR') {
            rarityBg = '#FFE4E9';  // SSR - æ·±ç²‰
            rarityBorder = '#FFB3C1';  // SSR - æ·±ç²‰è¾¹æ¡†
        }
        
        resultHTML += `<div style="background: ${rarityBg}; border: 3px solid ${rarityBorder}; padding: 10px; text-align: center; transition: transform 0.2s;">`;
        resultHTML += `<div style="width: 70px; height: 70px; margin: 0 auto 8px; display: flex; align-items: center; justify-content: center;">${item.svg}</div>`;
        resultHTML += `<div style="color: #666666; font-size: 10px; margin-bottom: 5px; word-break: break-word;">${item.name}</div>`;
        resultHTML += `<div style="color: #999999; font-size: 8px; padding: 2px 6px; background: rgba(255,255,255,0.6); display: inline-block;">${item.rarity}</div>`;
        resultHTML += `</div>`;
    });
    
    resultHTML += '</div>';
    
    // ç»Ÿè®¡ä¿¡æ¯
    const rarityCount = { R: 0, SR: 0, SSR: 0 };
    items.forEach(([id, item]) => {
        if (rarityCount[item.rarity] !== undefined) {
            rarityCount[item.rarity]++;
        }
    });
    
    resultHTML += '<div style="color: #999999; font-size: 9px; text-align: center; margin-bottom: 15px; padding: 8px; background: #F8F8F8; border: 2px solid #F0F0F0;">';
    resultHTML += `å…±è·å¾— ${items.length} ä»¶ç‰©å“ | `;
    if (rarityCount.SSR > 0) resultHTML += `SSRÃ—${rarityCount.SSR} `;
    if (rarityCount.SR > 0) resultHTML += `SRÃ—${rarityCount.SR} `;
    if (rarityCount.R > 0) resultHTML += `RÃ—${rarityCount.R}`;
    resultHTML += '</div>';
    
    // å…³é—­æŒ‰é’®
    resultHTML += '<button onclick="closeDrawResult()" style="width: 100%; padding: 12px; background: #FFB3C1; color: white; border: none; cursor: pointer; font-size: 11px; font-family: \'Press Start 2P\', cursive; transition: background 0.2s;" onmouseover="this.style.background=\'#FF9EAD\'" onmouseout="this.style.background=\'#FFB3C1\'">ç¡®å®š</button>';
    resultHTML += '</div></div>';
    
    // æ·»åŠ åˆ°é¡µé¢
    document.body.insertAdjacentHTML('beforeend', resultHTML);
}

// å…³é—­æŠ½å¥–ç»“æœå¼¹çª—
function closeDrawResult() {
    const modal = document.getElementById('draw-result-modal');
    if (modal) {
        modal.remove();
    }
}

// å•æŠ½
function cabinDrawOnce() {
    const state = window.cabinGachaState;
    
    if (state.coins < 10) {
        alert('é‡‘å¸ä¸è¶³ï¼Œéœ€è¦10ä¸ªé‡‘å¸');
        return;
    }
    
    // æ‰£é™¤é‡‘å¸
    state.coins -= 10;
    cabinCoinCount = state.coins;
    updateCabinCoinDisplay();
    
    // æŠ½å–ç‰©å“
    const rarity = getRandomRarity();
    const drawnItem = drawItem(rarity);
    
    if (!drawnItem) {
        alert('ç‰©å“æ± ä¸ºç©ºï¼Œè¯·å…ˆæ·»åŠ ç‰©å“');
        return;
    }
    
    const [itemId, item] = drawnItem;
    
    // æ·»åŠ åˆ°èƒŒåŒ…å’Œå›¾é‰´
    addItemToInventory(itemId);
    
    // æ˜¾ç¤ºç»“æœ
    showDrawResult([drawnItem]);
    
    // æ›´æ–°UI
    updateCabinUI();
}

// åè¿æŠ½
function cabinDrawTen() {
    const state = window.cabinGachaState;
    
    if (state.coins < 100) {
        alert('é‡‘å¸ä¸è¶³ï¼Œéœ€è¦100ä¸ªé‡‘å¸');
        return;
    }
    
    // æ‰£é™¤é‡‘å¸
    state.coins -= 100;
    cabinCoinCount = state.coins;
    updateCabinCoinDisplay();
    
    // æŠ½å–10æ¬¡
    const results = [];
    let guaranteedSR = false; // ä¿åº•æœºåˆ¶ï¼šåè¿è‡³å°‘å‡ºä¸€ä¸ªSR
    
    for (let i = 0; i < 10; i++) {
        let rarity = getRandomRarity();
        
        // æœ€åä¸€æŠ½å¦‚æœè¿˜æ²¡æœ‰SRä»¥ä¸Šï¼Œå¼ºåˆ¶å‡ºSR
        if (i === 9 && !guaranteedSR) {
            rarity = Math.random() < 0.5 ? 'SR' : 'SSR';
        }
        
        const drawnItem = drawItem(rarity);
        
        if (drawnItem) {
            const [itemId, item] = drawnItem;
            
            // æ£€æŸ¥æ˜¯å¦æŠ½åˆ°SRæˆ–ä»¥ä¸Š
            if (item.rarity === 'SR' || item.rarity === 'SSR') {
                guaranteedSR = true;
            }
            
            // æ·»åŠ åˆ°èƒŒåŒ…å’Œå›¾é‰´
            addItemToInventory(itemId);
            
            results.push(drawnItem);
        }
    }
    
    // æ˜¾ç¤ºç»“æœ
    if (results.length > 0) {
        showDrawResult(results);
    }
    
    // æ›´æ–°UI
    updateCabinUI();
}

function openCabinAIModal() {
    alert('AIç”ŸæˆåŠŸèƒ½å¼€å‘ä¸­');
}

function openCabinCharacterModal() {
    alert('è§’è‰²ç”ŸæˆåŠŸèƒ½å¼€å‘ä¸­');
}

// æˆ¿é—´ç›¸å…³åŠŸèƒ½
function takeCabinScreenshot() {
    alert('æ‹ç…§åŠŸèƒ½å¼€å‘ä¸­');
}

// æˆ¿é—´é¢œè‰²çŠ¶æ€ï¼ˆä¸´æ—¶å­˜å‚¨ï¼Œå°†æ¥å¯ä»¥ç”¨localStorageï¼‰
let cabinRoomState = {
    wallColor: '#fff5f7',
    wallStyle: 'solid',
    wallPatternColor: '#fff5f7',
    floorColor: '#fefefe',
    floorStyle: 'solid',
    floorPatternColor: '#fefefe'
};

// æ‰“å¼€é¢œè‰²é€‰æ‹©å™¨
function openCabinColorPicker(type) {
    window.cabinCurrentColorTarget = type;
    const modal = document.getElementById('cabin-color-picker-modal');
    const title = document.getElementById('cabin-color-modal-title');
    const colorInput = document.getElementById('cabin-color-input');
    const colorPicker = document.getElementById('cabin-color-picker');
    
    if (title) {
        const iconSvg = `<svg class="cabin-icon-inline" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"/>
        </svg>`;
        title.innerHTML = iconSvg + (type === 'wall' ? ' ä¿®æ”¹å¢™é¢é¢œè‰²' : ' ä¿®æ”¹åœ°æ¿é¢œè‰²');
    }
    
    const currentColor = type === 'wall' ? (cabinRoomState.wallColor || '#fff5f7') : (cabinRoomState.floorColor || '#fefefe');
    const currentPatternColor = type === 'wall' ? (cabinRoomState.wallPatternColor || currentColor) : (cabinRoomState.floorPatternColor || currentColor);
    
    if (colorInput) colorInput.value = currentColor;
    if (colorPicker) colorPicker.value = currentColor;
    
    const patternColorInput = document.getElementById('cabin-pattern-color-input');
    const patternColorPicker = document.getElementById('cabin-pattern-color-picker');
    if (patternColorInput) patternColorInput.value = currentPatternColor;
    if (patternColorPicker) patternColorPicker.value = currentPatternColor;
    
    // åŒæ­¥é¢œè‰²è¾“å…¥å’Œæ‹¾è‰²å™¨
    if (colorInput && colorPicker) {
        colorInput.oninput = () => {
            if (colorInput.value.match(/^#[0-9A-Fa-f]{6}$/)) {
                colorPicker.value = colorInput.value;
            }
        };
        colorPicker.oninput = () => {
            colorInput.value = colorPicker.value;
        };
    }
    
    if (patternColorInput && patternColorPicker) {
        patternColorInput.oninput = () => {
            if (patternColorInput.value.match(/^#[0-9A-Fa-f]{6}$/)) {
                patternColorPicker.value = patternColorInput.value;
            }
        };
        patternColorPicker.oninput = () => {
            patternColorInput.value = patternColorPicker.value;
        };
    }
    
    // æ ·å¼é€‰æ‹©å˜åŒ–
    const styleOptions = document.querySelectorAll('input[name="cabin-style-option"]');
    styleOptions.forEach(option => {
        option.onchange = () => {
            const patternSection = document.getElementById('cabin-pattern-color-section');
            if (patternSection) {
                patternSection.style.display = option.value === 'solid' ? 'none' : 'block';
            }
        };
    });
    
    // æ¢å¤å½“å‰æ ·å¼é€‰æ‹©
    const currentStyle = type === 'wall' ? cabinRoomState.wallStyle : cabinRoomState.floorStyle;
    const styleOption = document.querySelector(`input[name="cabin-style-option"][value="${currentStyle}"]`);
    if (styleOption) {
        styleOption.checked = true;
        const patternSection = document.getElementById('cabin-pattern-color-section');
        if (patternSection) {
            patternSection.style.display = currentStyle === 'solid' ? 'none' : 'block';
        }
    }
    
    if (modal) modal.style.display = 'flex';
}

// å…³é—­é¢œè‰²é€‰æ‹©å™¨
function closeCabinColorPicker() {
    const modal = document.getElementById('cabin-color-picker-modal');
    if (modal) modal.style.display = 'none';
    window.cabinCurrentColorTarget = null;
}

// é‡ç½®é¢œè‰²
function resetCabinColor() {
    const defaultColor = window.cabinCurrentColorTarget === 'wall' ? '#fff5f7' : '#fefefe';
    const colorInput = document.getElementById('cabin-color-input');
    const colorPicker = document.getElementById('cabin-color-picker');
    const patternColorInput = document.getElementById('cabin-pattern-color-input');
    const patternColorPicker = document.getElementById('cabin-pattern-color-picker');
    
    if (colorInput) colorInput.value = defaultColor;
    if (colorPicker) colorPicker.value = defaultColor;
    if (patternColorInput) patternColorInput.value = defaultColor;
    if (patternColorPicker) patternColorPicker.value = defaultColor;
    
    const solidOption = document.querySelector('input[name="cabin-style-option"][value="solid"]');
    if (solidOption) solidOption.checked = true;
    
    const patternSection = document.getElementById('cabin-pattern-color-section');
    if (patternSection) patternSection.style.display = 'none';
}

// åº”ç”¨é¢œè‰²
function applyCabinColor() {
    if (!window.cabinCurrentColorTarget) return;
    
    const colorInput = document.getElementById('cabin-color-input');
    const patternColorInput = document.getElementById('cabin-pattern-color-input');
    const styleOption = document.querySelector('input[name="cabin-style-option"]:checked');
    
    if (!colorInput || !styleOption) return;
    
    const color = colorInput.value;
    if (!color.match(/^#[0-9A-Fa-f]{6}$/)) {
        alert('é¢œè‰²æ ¼å¼ä¸æ­£ç¡®');
        return;
    }
    
    const style = styleOption.value;
    
    // è·å–èŠ±çº¹é¢œè‰²ï¼ˆå¦‚æœæ ·å¼ä¸æ˜¯çº¯è‰²ï¼‰
    let patternColor = color;
    if (style !== 'solid' && patternColorInput) {
        const patternColorValue = patternColorInput.value;
        if (patternColorValue && patternColorValue.match(/^#[0-9A-Fa-f]{6}$/)) {
            patternColor = patternColorValue;
        }
    }
    
    if (window.cabinCurrentColorTarget === 'wall') {
        cabinRoomState.wallColor = color;
        cabinRoomState.wallStyle = style;
        cabinRoomState.wallPatternColor = patternColor;
        applyCabinWallStyle();
    } else {
        cabinRoomState.floorColor = color;
        cabinRoomState.floorStyle = style;
        cabinRoomState.floorPatternColor = patternColor;
        applyCabinFloorStyle();
    }
    
    // æ›´æ–°æŒ‰é’®é¢œè‰²
    const wallBtn = document.getElementById('cabin-wall-color-btn');
    const floorBtn = document.getElementById('cabin-floor-color-btn');
    if (wallBtn) wallBtn.style.background = cabinRoomState.wallColor;
    if (floorBtn) floorBtn.style.background = cabinRoomState.floorColor;
    
    closeCabinColorPicker();
}

// åº”ç”¨å¢™é¢æ ·å¼
function applyCabinWallStyle() {
    const wallArea = document.getElementById('cabin-wall-area');
    if (!wallArea) return;
    
    wallArea.style.backgroundColor = cabinRoomState.wallColor || '#fff5f7';
    
    if (cabinRoomState.wallStyle === 'solid') {
        wallArea.style.backgroundImage = 'none';
    } else if (cabinRoomState.wallStyle === 'pattern1') {
        const patternColor = (cabinRoomState.wallPatternColor || cabinRoomState.wallColor) + '40';
        wallArea.style.backgroundImage = `
            linear-gradient(90deg, ${patternColor} 1px, transparent 1px),
            linear-gradient(${patternColor} 1px, transparent 1px)
        `;
        wallArea.style.backgroundSize = '32px 32px';
    } else if (cabinRoomState.wallStyle === 'pattern2') {
        const patternColor = cabinRoomState.wallPatternColor || cabinRoomState.wallColor;
        wallArea.style.backgroundImage = `
            linear-gradient(90deg, transparent 33%, ${patternColor}40 33%, ${patternColor}40 66%, transparent 66%),
            linear-gradient(transparent 33%, ${patternColor}40 33%, ${patternColor}40 66%, transparent 66%)
        `;
        wallArea.style.backgroundSize = '12px 12px';
    }
}

// åº”ç”¨åœ°æ¿æ ·å¼
function applyCabinFloorStyle() {
    const floorArea = document.getElementById('cabin-floor-area');
    if (!floorArea) return;
    
    floorArea.style.backgroundColor = cabinRoomState.floorColor || '#fefefe';
    
    if (cabinRoomState.floorStyle === 'solid') {
        floorArea.style.backgroundImage = 'none';
    } else if (cabinRoomState.floorStyle === 'pattern1') {
        const patternColor = (cabinRoomState.floorPatternColor || cabinRoomState.floorColor) + '40';
        floorArea.style.backgroundImage = `
            linear-gradient(90deg, ${patternColor} 1px, transparent 1px),
            linear-gradient(${patternColor} 1px, transparent 1px)
        `;
        floorArea.style.backgroundSize = '32px 32px';
    } else if (cabinRoomState.floorStyle === 'pattern2') {
        const patternColor = cabinRoomState.floorPatternColor || cabinRoomState.floorColor;
        floorArea.style.backgroundImage = `
            linear-gradient(90deg, transparent 33%, ${patternColor}40 33%, ${patternColor}40 66%, transparent 66%),
            linear-gradient(transparent 33%, ${patternColor}40 33%, ${patternColor}40 66%, transparent 66%)
        `;
        floorArea.style.backgroundSize = '12px 12px';
    }
}

function moveCabinUserCharacter(direction) {
    alert('è§’è‰²ç§»åŠ¨åŠŸèƒ½å¼€å‘ä¸­ï¼š' + direction);
}

function filterCabinInventory(category) {
    // æ›´æ–°æŒ‰é’®æ¿€æ´»çŠ¶æ€
    const buttons = document.querySelectorAll('.cabin-filter-btn');
    buttons.forEach(btn => btn.classList.remove('active'));
    event.currentTarget.classList.add('active');
    
    // è¿™é‡Œå°†æ¥ä¼šå®ç°å®é™…çš„è¿‡æ»¤é€»è¾‘
    console.log('è¿‡æ»¤åˆ†ç±»ï¼š' + category);
}

// åˆå§‹åŒ–é»˜è®¤å®¶å…·
function initDefaultItems() {
    const state = window.cabinGachaState;
    
    // å¦‚æœå·²ç»æœ‰ç‰©å“ï¼Œä¸é‡å¤æ·»åŠ 
    if (Object.keys(state.customItems).length > 0) {
        return;
    }
    
    // æ·»åŠ åˆå§‹ç‰©å“
    const DEFAULT_FURNITURE = {
        'bed_01': { 
            name: "è‰è“åºŠ", 
            svg: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
                <rect x="10" y="30" width="44" height="20" fill="#FFB3C1" stroke="#999999" stroke-width="2"/>
                <rect x="12" y="32" width="40" height="16" fill="#FFF5F7"/>
                <rect x="14" y="34" width="4" height="4" fill="#FFFFFF"/>
                <rect x="22" y="34" width="4" height="4" fill="#FFFFFF"/>
                <rect x="30" y="34" width="4" height="4" fill="#FFFFFF"/>
                <rect x="38" y="34" width="4" height="4" fill="#FFFFFF"/>
                <rect x="46" y="34" width="4" height="4" fill="#FFFFFF"/>
                <rect x="14" y="24" width="14" height="10" fill="#FFFFFF" stroke="#CCCCCC" stroke-width="2"/>
                <rect x="16" y="26" width="10" height="6" fill="#F0F0F0" rx="2"/>
                <rect x="16" y="22" width="10" height="2" fill="#FFE4E9"/>
            </svg>`,
            rarity: "R",
            inPool: true,
            type: "furniture",
            width: 3,
            height: 2
        },
        'table_01': { 
            name: "åƒç´ æ¡Œ", 
            svg: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
                <rect x="12" y="32" width="40" height="10" fill="#F5F5F5" stroke="#999999" stroke-width="2"/>
                <rect x="14" y="34" width="36" height="6" fill="#FAFAFA" rx="1"/>
                <rect x="16" y="36" width="32" height="2" fill="#FFFFFF"/>
                <rect x="16" y="42" width="6" height="14" fill="#CCCCCC"/>
                <rect x="20" y="44" width="2" height="12" fill="#B0B0B0"/>
                <rect x="42" y="42" width="6" height="14" fill="#CCCCCC"/>
                <rect x="46" y="44" width="2" height="12" fill="#B0B0B0"/>
                <rect x="15" y="55" width="8" height="2" fill="#999999"/>
                <rect x="41" y="55" width="8" height="2" fill="#999999"/>
                <circle cx="32" cy="36" r="2" fill="#FFE4E9"/>
                <circle cx="38" cy="36" r="2" fill="#E8E8E8"/>
                <circle cx="26" cy="36" r="2" fill="#F0F0F0"/>
            </svg>`,
            rarity: "R",
            inPool: true,
            type: "furniture",
            width: 2,
            height: 2
        },
        'plant_01': { 
            name: "çˆ±å¿ƒè‰", 
            svg: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
                <rect x="24" y="40" width="16" height="16" fill="#FFE4E9" stroke="#CCCCCC" stroke-width="2" rx="2"/>
                <rect x="26" y="42" width="12" height="12" fill="#FFF5F7" rx="1"/>
                <rect x="28" y="44" width="8" height="2" fill="#FFFFFF"/>
                <rect x="28" y="48" width="8" height="2" fill="#FFFFFF"/>
                <rect x="31" y="30" width="2" height="10" fill="#B0B0B0"/>
                <polygon points="30,28 34,28 32,24" fill="#999999"/>
                <polygon points="28,32 30,32 29,30" fill="#CCCCCC"/>
                <polygon points="34,32 36,32 35,30" fill="#CCCCCC"/>
                <path d="M32,22 Q34,20 36,22 Q38,24 36,26 Q34,28 32,30 Q30,28 28,26 Q26,24 28,22 Q30,20 32,22" fill="#FFB3C1"/>
                <circle cx="32" cy="24" r="1" fill="#FFFFFF"/>
                <circle cx="34" cy="26" r="1" fill="#FFFFFF"/>
                <circle cx="30" cy="26" r="1" fill="#FFFFFF"/>
            </svg>`,
            rarity: "SR",
            inPool: true,
            type: "decor",
            width: 1,
            height: 1
        },
        'painting_01': {
            name: "åƒç´ ç”»",
            svg: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
                <rect x="15" y="15" width="34" height="34" fill="#F5F5F5" stroke="#CCCCCC" stroke-width="3" rx="3"/>
                <rect x="18" y="18" width="28" height="28" fill="#FFFFFF" rx="2"/>
                <rect x="20" y="20" width="24" height="24" fill="#FAFAFA" rx="1"/>
                <rect x="20" y="36" width="24" height="8" fill="#E8E8E8" rx="1"/>
                <polygon points="26,36 30,32 34,36" fill="#D0D0D0"/>
                <polygon points="30,36 34,30 38,36" fill="#CCCCCC"/>
                <circle cx="44" cy="24" r="4" fill="#FFE4E9"/>
                <rect x="44" y="20" width="1" height="2" fill="#FFB3C1"/>
                <rect x="44" y="28" width="1" height="2" fill="#FFB3C1"/>
                <rect x="40" y="23" width="2" height="1" fill="#FFB3C1"/>
                <rect x="48" y="23" width="2" height="1" fill="#FFB3C1"/>
                <rect x="24" y="26" width="8" height="4" fill="#FFFFFF" rx="2"/>
                <rect x="26" y="24" width="4" height="2" fill="#FFFFFF" rx="1"/>
                <circle cx="20" cy="20" r="1" fill="#FFB3C1"/>
                <circle cx="44" cy="20" r="1" fill="#FFB3C1"/>
                <circle cx="20" cy="44" r="1" fill="#FFB3C1"/>
                <circle cx="44" cy="44" r="1" fill="#FFB3C1"/>
            </svg>`,
            rarity: "R",
            inPool: true,
            type: "wall",
            width: 1,
            height: 1
        },
        'rug_01': {
            name: "æ¯›ç»’åœ°æ¯¯",
            svg: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
                <rect x="10" y="10" width="44" height="44" fill="#F0F0F0" stroke="#CCCCCC" stroke-width="2" rx="5"/>
                <rect x="12" y="12" width="40" height="40" fill="#FAFAFA" rx="3"/>
                <circle cx="32" cy="32" r="12" fill="#FFF5F7" opacity="0.6"/>
                <circle cx="32" cy="32" r="8" fill="#FFFFFF" opacity="0.8"/>
                <path d="M32,24 Q36,28 32,32 Q28,36 32,40 Q36,36 40,32 Q36,28 32,24" fill="#FFE4E9" opacity="0.5"/>
                <rect x="14" y="14" width="4" height="4" fill="#E8E8E8" rx="1"/>
                <rect x="46" y="14" width="4" height="4" fill="#E8E8E8" rx="1"/>
                <rect x="14" y="46" width="4" height="4" fill="#E8E8E8" rx="1"/>
                <rect x="46" y="46" width="4" height="4" fill="#E8E8E8" rx="1"/>
            </svg>`,
            rarity: "SR",
            inPool: true,
            type: "floor",
            width: 3,
            height: 2
        }
    };
    
    // æ·»åŠ é»˜è®¤ç‰©å“åˆ°çŠ¶æ€
    Object.keys(DEFAULT_FURNITURE).forEach(id => {
        state.customItems[id] = DEFAULT_FURNITURE[id];
        if (!state.catalog[id]) {
            state.catalog[id] = { seen: false, owned: false };
        }
        // æ·»åŠ åˆ°èƒŒåŒ…
        state.inventory[id] = (state.inventory[id] || 0) + 1;
        // æ ‡è®°ä¸ºå·²æ‹¥æœ‰
        state.catalog[id].owned = true;
    });
    
    // ä¿å­˜çŠ¶æ€
    saveCabinGachaData();
    console.log('é»˜è®¤å®¶å…·å·²åˆå§‹åŒ–');
}

// æ›´æ–°èƒŒåŒ…æ˜¾ç¤º
function updateCabinInventoryDisplay() {
    // å¦‚æœæœ‰èƒŒåŒ…UIå…ƒç´ ï¼Œåœ¨è¿™é‡Œæ›´æ–°
    // æš‚æ—¶ä¿ç•™æ­¤å‡½æ•°ä»¥å¤‡åç»­ä½¿ç”¨
}

// æ‰“å¼€å›¾é‰´
function openCatalogModal() {
    const modal = document.getElementById('catalog-modal');
    if (modal) {
        modal.style.display = 'flex';
        renderCatalogItems();
    }
}

// å…³é—­å›¾é‰´
function closeCatalogModal() {
    const modal = document.getElementById('catalog-modal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// åˆ‡æ¢å›¾é‰´æ ‡ç­¾
let currentCatalogTab = 'all';
function switchCatalogTab(tab) {
    currentCatalogTab = tab;
    const tabs = document.querySelectorAll('.catalog-tab');
    tabs.forEach(t => {
        t.classList.remove('active');
        t.style.background = '#ffffff';
    });
    event.currentTarget.classList.add('active');
    event.currentTarget.style.background = '#fff5f7';
    renderCatalogItems();
}

// è¿‡æ»¤å›¾é‰´ç‰©å“ç¨€æœ‰åº¦
let currentCatalogRarity = 'all';
function filterCatalogItems(rarity) {
    currentCatalogRarity = rarity;
    const buttons = document.querySelectorAll('.rarity-filter-btn');
    buttons.forEach(btn => btn.classList.remove('active'));
    event.currentTarget.classList.add('active');
    renderCatalogItems();
}

// æ¸²æŸ“å›¾é‰´ç‰©å“
function renderCatalogItems() {
    const catalogGrid = document.getElementById('catalog-items');
    const catalogInfo = document.getElementById('catalog-info');
    
    if (!catalogGrid) return;
    
    const state = window.cabinGachaState;
    catalogGrid.innerHTML = '';
    
    // è·å–æ‰€æœ‰ç‰©å“
    const allItems = Object.keys(state.customItems).map(id => ({
        id,
        ...state.customItems[id],
        catalogData: state.catalog[id] || { seen: false, owned: false }
    }));
    
    // æŒ‰æ ‡ç­¾è¿‡æ»¤
    let filteredItems = allItems;
    if (currentCatalogTab === 'owned') {
        filteredItems = allItems.filter(item => item.catalogData.owned);
    } else if (currentCatalogTab === 'missing') {
        filteredItems = allItems.filter(item => !item.catalogData.owned);
    }
    
    // æŒ‰ç¨€æœ‰åº¦è¿‡æ»¤
    if (currentCatalogRarity !== 'all') {
        filteredItems = filteredItems.filter(item => 
            item.rarity.toUpperCase() === currentCatalogRarity.toUpperCase()
        );
    }
    
    // æ¸²æŸ“ç‰©å“
    filteredItems.forEach(item => {
        const itemDiv = document.createElement('div');
        itemDiv.style.cssText = `
            background: ${item.catalogData.owned ? '#fff5f7' : '#f5f5f5'};
            border: 3px solid ${item.catalogData.owned ? '#ffb3c1' : '#e0e0e0'};
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
        `;
        
        // SVGå›¾æ ‡
        const svgDiv = document.createElement('div');
        svgDiv.innerHTML = item.svg;
        svgDiv.style.cssText = 'width: 40px; height: 40px; margin-bottom: 5px;';
        itemDiv.appendChild(svgDiv);
        
        // åç§°
        const nameDiv = document.createElement('div');
        nameDiv.textContent = item.name;
        nameDiv.style.cssText = 'font-size: 8px; color: #999999; text-align: center; margin-bottom: 3px;';
        itemDiv.appendChild(nameDiv);
        
        // ç¨€æœ‰åº¦
        const rarityDiv = document.createElement('div');
        rarityDiv.textContent = item.rarity;
        rarityDiv.style.cssText = `
            font-size: 7px;
            padding: 1px 4px;
            border-radius: 3px;
            font-weight: bold;
            color: #999999;
            background: ${item.rarity === 'SSR' ? '#fff9e6' : item.rarity === 'SR' ? '#fff5f7' : '#f0f0f0'};
        `;
        itemDiv.appendChild(rarityDiv);
        
        // æ‹¥æœ‰æ•°é‡ï¼ˆå¦‚æœå·²æ‹¥æœ‰ï¼‰
        if (item.catalogData.owned) {
            const count = state.inventory[item.id] || 0;
            if (count > 0) {
                const countDiv = document.createElement('div');
                countDiv.textContent = `Ã—${count}`;
                countDiv.style.cssText = `
                    position: absolute;
                    top: 5px;
                    right: 5px;
                    font-size: 8px;
                    padding: 2px 5px;
                    background: #ffb3c1;
                    color: white;
                    border-radius: 10px;
                    font-weight: bold;
                `;
                itemDiv.appendChild(countDiv);
            }
        }
        
        catalogGrid.appendChild(itemDiv);
    });
    
    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    if (catalogInfo) {
        const total = allItems.length;
        const owned = allItems.filter(item => item.catalogData.owned).length;
        const rate = total > 0 ? Math.round((owned / total) * 100) : 0;
        
        document.getElementById('catalog-total').textContent = total;
        document.getElementById('catalog-owned').textContent = owned;
        document.getElementById('catalog-rate').textContent = rate + '%';
    }
}

// é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
document.addEventListener('DOMContentLoaded', function() {
    // å°å±‹æ•°æ®åœ¨é¦–æ¬¡æ‰“å¼€å°å±‹é¡µé¢æ—¶åˆå§‹åŒ–ï¼ˆè§ showCabinPage å‡½æ•°ï¼‰
    // è¿™é‡Œä¸éœ€è¦æå‰åˆå§‹åŒ–
});

// ==================== æƒ…ä¾£ç©ºé—´åŠŸèƒ½ ====================
let selectedAccountId = null;
let selectedFriendId = null;
let currentPet = null;

async function showCoupleSpacePage() {
    document.getElementById('home-page').style.display = 'none';
    document.getElementById('couple-space-page').style.display = 'block';
    
    // åŠ è½½è´¦å·åˆ—è¡¨
    await loadCoupleAccountList();
}

function hideCoupleSpacePage() {
    document.getElementById('couple-space-page').style.display = 'none';
    document.getElementById('home-page').style.display = 'flex';
    
    // é‡ç½®çŠ¶æ€
    document.getElementById('couple-select-account').style.display = 'flex';
    document.getElementById('couple-select-friend').style.display = 'none';
    document.getElementById('couple-room-area').style.display = 'none';
    selectedAccountId = null;
    selectedFriendId = null;
    currentPet = null;
    isPetHatched = false;
    isPetting = false;
    lastPetTime = 0;
    if (petTimeout) {
        clearTimeout(petTimeout);
        petTimeout = null;
    }
}

// åŠ è½½è´¦å·åˆ—è¡¨ï¼ˆuserç±»å‹çš„è§’è‰²ï¼‰
async function loadCoupleAccountList() {
    const accounts = await db.characters.where('type').equals('user').toArray();
    const listContainer = document.getElementById('couple-account-list');
    listContainer.innerHTML = '';
    
    if (accounts.length === 0) {
        listContainer.innerHTML = '<div style="text-align: center; color: #999;">æš‚æ— è´¦å·ï¼Œè¯·å…ˆåˆ›å»ºç”¨æˆ·è´¦å·</div>';
        return;
    }
    
    accounts.forEach(account => {
        const accountItem = document.createElement('div');
        accountItem.style.cssText = `
            background: white;
            border: 2px solid #ff9ed2;
            border-radius: 12px;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            cursor: pointer;
            transition: transform 0.2s;
        `;
        
        accountItem.onmouseover = () => accountItem.style.transform = 'scale(1.02)';
        accountItem.onmouseout = () => accountItem.style.transform = 'scale(1)';
        accountItem.onclick = () => selectCoupleAccount(account.id);
        
        // å¤´åƒ
        const avatar = document.createElement('div');
        avatar.style.cssText = `
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: ${account.avatar ? `url(${account.avatar}) center/cover` : '#ffdef2'};
            flex-shrink: 0;
        `;
        
        // åå­—
        const name = document.createElement('div');
        name.textContent = account.name;
        name.style.cssText = 'font-size: 16px; color: #333; font-weight: bold;';
        
        accountItem.appendChild(avatar);
        accountItem.appendChild(name);
        listContainer.appendChild(accountItem);
    });
}

// é€‰æ‹©è´¦å·
async function selectCoupleAccount(accountId) {
    selectedAccountId = accountId;
    document.getElementById('couple-select-account').style.display = 'none';
    document.getElementById('couple-select-friend').style.display = 'flex';
    
    // åŠ è½½è¯¥è´¦å·çš„å¥½å‹åˆ—è¡¨
    await loadCoupleFriendList(accountId);
}

// è¿”å›è´¦å·é€‰æ‹©
function backToCoupleAccountSelect() {
    document.getElementById('couple-select-friend').style.display = 'none';
    document.getElementById('couple-select-account').style.display = 'flex';
    selectedAccountId = null;
}

// åŠ è½½å¥½å‹åˆ—è¡¨
async function loadCoupleFriendList(accountId) {
    // ä½¿ç”¨å’Œå¾®ä¿¡åˆ—è¡¨ç›¸åŒçš„é€»è¾‘è·å–å¥½å‹
    let allChars = await db.characters.toArray();
    let friends = allChars.filter(c => {
        if (c.type === 'user') return false; // æ’é™¤Userç±»å‹
        const status = getFriendStatus(c, accountId);
        return status === 'friend' || status === 'deleted' || status === 'blocked'; // åŒ…æ‹¬å·²åˆ é™¤å’Œå·²æ‹‰é»‘çš„å¥½å‹
    });
    
    const listContainer = document.getElementById('couple-friend-list');
    listContainer.innerHTML = '';
    
    if (friends.length === 0) {
        listContainer.innerHTML = '<div style="text-align: center; color: #999;">è¯¥è´¦å·æš‚æ— å¥½å‹</div>';
        return;
    }
    
    friends.forEach(friend => {
        if (!friend) return;
        
        const friendItem = document.createElement('div');
        friendItem.style.cssText = `
            background: white;
            border: 2px solid #ff9ed2;
            border-radius: 12px;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            cursor: pointer;
            transition: transform 0.2s;
        `;
        
        friendItem.onmouseover = () => friendItem.style.transform = 'scale(1.02)';
        friendItem.onmouseout = () => friendItem.style.transform = 'scale(1)';
        friendItem.onclick = () => selectCoupleFriend(friend.id);
        
        // å¤´åƒ
        const avatar = document.createElement('div');
        avatar.style.cssText = `
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: ${friend.avatar ? `url(${friend.avatar}) center/cover` : '#ffdef2'};
            flex-shrink: 0;
        `;
        
        // åå­—
        const name = document.createElement('div');
        name.textContent = friend.name;
        name.style.cssText = 'font-size: 16px; color: #333; font-weight: bold;';
        
        friendItem.appendChild(avatar);
        friendItem.appendChild(name);
        listContainer.appendChild(friendItem);
    });
}

// é€‰æ‹©å¥½å‹
function selectCoupleFriend(friendId) {
    selectedFriendId = friendId;
    document.getElementById('couple-select-friend').style.display = 'none';
    document.getElementById('couple-room-area').style.display = 'block';
}

// æ˜¾ç¤ºé¢†å…»å® ç‰©æ¨¡æ€æ¡†
function showAdoptPetModal() {
    document.getElementById('adopt-pet-modal').style.display = 'flex';
}

// å…³é—­é¢†å…»å® ç‰©æ¨¡æ€æ¡†
function closeAdoptPetModal() {
    document.getElementById('adopt-pet-modal').style.display = 'none';
}

// é¢†å…»å® ç‰©
function adoptPet(petType) {
    closeAdoptPetModal();
    document.getElementById('adopt-pet-btn').style.display = 'none';
    document.getElementById('pet-hint').textContent = 'ç‚¹å‡»å­µåŒ–ä½ çš„å® ç‰©';
    
    currentPet = petType;
    createPetContainer(petType);
}

// åˆ›å»ºå® ç‰©å®¹å™¨
function createPetContainer(petType) {
    const container = document.getElementById('pet-container');
    container.innerHTML = '';
    
    const stage = document.createElement('div');
    stage.id = 'pet-stage-container';
    stage.style.cssText = 'width: 256px; height: 256px; cursor: pointer; position: relative; touch-action: none;';
    
    if (petType === 'seal') {
        stage.innerHTML = createSealEgg();
        stage.onclick = () => hatchPet('seal', stage);
    } else if (petType === 'cat') {
        stage.innerHTML = createCatBox();
        stage.onclick = () => hatchPet('cat', stage);
    } else if (petType === 'dog') {
        stage.innerHTML = createDogHouse();
        stage.onclick = () => hatchPet('dog', stage);
    }
    
    container.appendChild(stage);
}

// å® ç‰©çŠ¶æ€
let isPetHatched = false;
let isPetting = false;
let lastPetTime = 0;
let petTimeout = null;

// å­µåŒ–å® ç‰©
function hatchPet(petType, stage) {
    stage.style.animation = 'shake 0.5s';
    
    setTimeout(() => {
        stage.innerHTML = '';
        
        if (petType === 'seal') {
            stage.innerHTML = createSealPet();
        } else if (petType === 'cat') {
            stage.innerHTML = createCatPet();
        } else if (petType === 'dog') {
            stage.innerHTML = createDogPet();
        }
        
        stage.style.animation = 'popUp 0.6s';
        stage.onclick = null;
        
        isPetHatched = true;
        document.getElementById('pet-hint').textContent = 'æ»‘åŠ¨æŠšæ‘¸å® ç‰©';
        
        // æ·»åŠ æŠšæ‘¸äº‹ä»¶ç›‘å¬
        setupPettingEvents(stage);
    }, 500);
}

// è®¾ç½®æŠšæ‘¸äº‹ä»¶
function setupPettingEvents(stage) {
    // é˜»æ­¢è§¦æ‘¸æ»šåŠ¨
    stage.addEventListener('touchmove', (e) => {
        e.preventDefault();
        handlePet(e);
    }, { passive: false });
    
    // é¼ æ ‡ç§»åŠ¨æŠšæ‘¸
    stage.addEventListener('mousemove', handlePet);
    
    // è§¦æ‘¸å¼€å§‹
    stage.addEventListener('touchstart', (e) => {
        e.preventDefault();
        handlePet(e);
    }, { passive: false });
}

// å¤„ç†æŠšæ‘¸
function handlePet(e) {
    if (!isPetHatched) return;
    
    const now = Date.now();
    if (now - lastPetTime < 50) return;
    lastPetTime = now;
    
    if (!isPetting) {
        startPetting();
    }
    
    clearTimeout(petTimeout);
    petTimeout = setTimeout(stopPetting, 200);
    
    // éšæœºç”Ÿæˆçˆ±å¿ƒæ•ˆæœ
    if (Math.random() > 0.85) {
        spawnHeartEffect(e);
    }
}

// å¼€å§‹æŠšæ‘¸
function startPetting() {
    isPetting = true;
    const stage = document.getElementById('pet-stage-container');
    if (stage) {
        stage.classList.add('is-petting');
        document.getElementById('pet-hint').textContent = 'å¥½èˆ’æœ...';
    }
}

// åœæ­¢æŠšæ‘¸
function stopPetting() {
    isPetting = false;
    const stage = document.getElementById('pet-stage-container');
    if (stage) {
        stage.classList.remove('is-petting');
        document.getElementById('pet-hint').textContent = 'æ»‘åŠ¨æŠšæ‘¸å® ç‰©';
    }
}

// ç”Ÿæˆçˆ±å¿ƒæ•ˆæœ
function spawnHeartEffect(e) {
    const stage = document.getElementById('pet-stage-container');
    if (!stage) return;
    
    const heart = document.createElement('div');
    heart.style.cssText = `
        position: absolute;
        width: 12px;
        height: 12px;
        background: #ff6b6b;
        clip-path: polygon(20% 0%, 40% 0%, 50% 20%, 60% 0%, 80% 0%, 100% 20%, 100% 50%, 50% 100%, 0% 50%, 0% 20%);
        pointer-events: none;
        z-index: 1000;
    `;
    
    const rect = stage.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    
    const x = clientX - rect.left - 6 + (Math.random() * 20 - 10);
    const y = clientY - rect.top - 20;
    
    heart.style.left = `${x}px`;
    heart.style.top = `${y}px`;
    
    stage.appendChild(heart);
    
    heart.animate([
        { transform: 'translateY(0) scale(0.5)', opacity: 1 },
        { transform: 'translateY(-40px) scale(1.2)', opacity: 0 }
    ], { duration: 800, fill: 'forwards' });
    
    setTimeout(() => heart.remove(), 800);
}

// åˆ›å»ºæµ·è±¹è›‹
function createSealEgg() {
    return `
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" style="width: 100%; height: 100%;">
            <rect x="18" y="54" width="28" height="4" fill="#a0c0e0" opacity="0.6"/>
            <path d="M24 16 H40 V17 H44 V18 H46 V20 H48 V24 H50 V44 H48 V50 H46 V52 H42 V54 H22 V52 H18 V50 H16 V44 H14 V24 H16 V20 H18 V18 H20 V17 H24 Z" fill="#4a4a4a" />
            <rect x="24" y="17" width="16" height="35" fill="#ffffff"/>
            <rect x="20" y="18" width="24" height="34" fill="#ffffff"/>
            <rect x="18" y="20" width="28" height="30" fill="#ffffff"/>
            <rect x="16" y="24" width="32" height="20" fill="#ffffff"/>
            <rect x="18" y="44" width="28" height="6" fill="#ffffff"/>
            <rect x="22" y="50" width="20" height="2" fill="#ffffff"/>
            <rect x="28" y="24" width="2" height="2" fill="#d0d0d0" />
            <rect x="36" y="20" width="1" height="1" fill="#d0d0d0" />
            <rect x="42" y="30" width="2" height="2" fill="#d0d0d0" />
        </svg>
    `;
}

// åˆ›å»ºçŒ«ç®±å­
function createCatBox() {
    return `
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" style="width: 100%; height: 100%;">
            <rect x="16" y="56" width="32" height="4" fill="#8b6f47" opacity="0.3"/>
            <path d="M12 24 H52 V26 H54 V54 H52 V56 H12 V54 H10 V26 H12 Z" fill="#d2691e"/>
            <rect x="12" y="26" width="40" height="28" fill="#cd853f"/>
            <rect x="16" y="30" width="32" height="20" fill="#daa520"/>
            <path d="M26 34 H38 V36 H40 V44 H38 V46 H26 V44 H24 V36 H26 Z" fill="#4a4a4a"/>
            <rect x="28" y="36" width="8" height="8" fill="#2a2a2a"/>
            <rect x="20" y="28" width="2" height="2" fill="#8b4513"/>
            <rect x="42" y="28" width="2" height="2" fill="#8b4513"/>
            <rect x="20" y="48" width="2" height="2" fill="#8b4513"/>
            <rect x="42" y="48" width="2" height="2" fill="#8b4513"/>
        </svg>
    `;
}

// åˆ›å»ºç‹—çª
function createDogHouse() {
    return `
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" style="width: 100%; height: 100%;">
            <rect x="16" y="56" width="32" height="4" fill="#8b6f47" opacity="0.3"/>
            <path d="M32 12 L10 32 H12 V54 H52 V32 H54 Z" fill="#d2691e"/>
            <rect x="14" y="32" width="36" height="22" fill="#cd853f"/>
            <path d="M24 38 H40 V40 H42 V52 H40 V54 H24 V52 H22 V40 H24 Z" fill="#4a4a4a"/>
            <rect x="26" y="40" width="12" height="12" fill="#2a2a2a"/>
            <path d="M32 14 L12 30 H16 L32 18 L48 30 H52 Z" fill="#a0522d"/>
        </svg>
    `;
}

// åˆ›å»ºæµ·è±¹å® ç‰©
function createSealPet() {
    return `
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" style="width: 100%; height: 100%; animation: sealFloat 2s infinite ease-in-out;">
            <rect x="18" y="48" width="28" height="4" fill="#a0c0e0" opacity="0.6"/>
            <path d="M20 20 H44 V21 H48 V22 H50 V24 H52 V38 H50 V42 H48 V44 H44 V45 H20 V44 H16 V42 H14 V38 H12 V24 H14 V22 H16 V21 H20 Z" fill="#4a4a4a"/>
            <rect x="20" y="21" width="24" height="23" fill="#ffffff"/>
            <rect x="16" y="22" width="32" height="21" fill="#ffffff"/>
            <rect x="14" y="24" width="36" height="17" fill="#ffffff"/>
            <rect x="20" y="30" width="3" height="3" fill="#2a2a2a"/>
            <rect x="36" y="30" width="3" height="3" fill="#2a2a2a"/>
            <rect x="29" y="34" width="1" height="2" fill="#4a4a4a"/>
            <rect x="28" y="36" width="3" height="1" fill="#4a4a4a"/>
            <rect x="16" y="32" width="1" height="1" fill="#ffb7b2"/>
            <rect x="42" y="32" width="1" height="1" fill="#ffb7b2"/>
            <g style="transform-origin: 52px 32px; animation: tailWag 0.4s infinite alternate;">
                <path d="M52 30 H56 V32 H57 V35 H56 V37 H52 Z" fill="#4a4a4a"/>
                <rect x="52" y="31" width="4" height="5" fill="#ffffff"/>
            </g>
        </svg>
    `;
}

// åˆ›å»ºçŒ«å® ç‰©
function createCatPet() {
    return `
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" style="width: 100%; height: 100%; animation: catFloat 2s infinite ease-in-out;">
            <rect x="20" y="50" width="24" height="4" fill="#8b6f47" opacity="0.3"/>
            <g style="animation: catEarWiggle 1s infinite alternate;">
                <path d="M18 18 H22 V20 H24 V26 H22 V24 H20 V22 H18 Z" fill="#ff9966"/>
                <rect x="20" y="20" width="2" height="4" fill="#ffb380"/>
                <path d="M42 18 H46 V22 H44 V24 H42 V26 H40 V20 H42 Z" fill="#ff9966"/>
                <rect x="42" y="20" width="2" height="4" fill="#ffb380"/>
            </g>
            <path d="M20 24 H44 V26 H46 V40 H44 V42 H42 V44 H22 V42 H20 V40 H18 V26 H20 Z" fill="#4a4a4a"/>
            <rect x="20" y="26" width="24" height="14" fill="#ff9966"/>
            <rect x="18" y="28" width="28" height="10" fill="#ff9966"/>
            <rect x="24" y="30" width="3" height="3" fill="#2a2a2a"/>
            <rect x="37" y="30" width="3" height="3" fill="#2a2a2a"/>
            <rect x="25" y="30" width="1" height="1" fill="#ffffff" opacity="0.8"/>
            <rect x="38" y="30" width="1" height="1" fill="#ffffff" opacity="0.8"/>
            <rect x="30" y="34" width="1" height="2" fill="#4a4a4a"/>
            <rect x="29" y="36" width="3" height="1" fill="#4a4a4a"/>
            <rect x="33" y="34" width="1" height="1" fill="#4a4a4a"/>
            <path d="M28 38 L26 40 H28 Z" fill="#4a4a4a"/>
            <path d="M36 38 L38 40 H36 Z" fill="#4a4a4a"/>
            <rect x="22" y="32" width="1" height="1" fill="#ffb7b2"/>
            <rect x="41" y="32" width="1" height="1" fill="#ffb7b2"/>
            <g style="animation: tailSway 0.8s infinite alternate;">
                <path d="M44 36 H46 V38 H48 V42 H50 V46 H48 V44 H46 V40 H44 Z" fill="#ff9966"/>
            </g>
        </svg>
    `;
}

// åˆ›å»ºç‹—å® ç‰©
function createDogPet() {
    return `
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" style="width: 100%; height: 100%; animation: dogFloat 2s infinite ease-in-out;">
            <rect x="20" y="50" width="24" height="4" fill="#8b6f47" opacity="0.3"/>
            <g style="animation: dogEarFlop 1.2s infinite alternate;">
                <path d="M16 24 H18 V26 H20 V32 H18 V28 H16 Z" fill="#8b4513"/>
                <rect x="17" y="26" width="2" height="4" fill="#a0522d"/>
                <path d="M46 24 H48 V28 H46 V32 H44 V26 H46 Z" fill="#8b4513"/>
                <rect x="45" y="26" width="2" height="4" fill="#a0522d"/>
            </g>
            <path d="M18 26 H46 V28 H48 V40 H46 V42 H44 V44 H20 V42 H18 V40 H16 V28 H18 Z" fill="#4a4a4a"/>
            <rect x="18" y="28" width="28" height="12" fill="#d2691e"/>
            <rect x="16" y="30" width="32" height="8" fill="#d2691e"/>
            <rect x="22" y="32" width="3" height="3" fill="#2a2a2a"/>
            <rect x="39" y="32" width="3" height="3" fill="#2a2a2a"/>
            <rect x="23" y="32" width="1" height="1" fill="#ffffff" opacity="0.8"/>
            <rect x="40" y="32" width="1" height="1" fill="#ffffff" opacity="0.8"/>
            <path d="M28 36 H36 V38 H34 V40 H30 V38 H28 Z" fill="#4a4a4a"/>
            <rect x="30" y="38" width="4" height="2" fill="#ff6b9d"/>
            <rect x="31" y="36" width="2" height="1" fill="#2a2a2a"/>
            <rect x="20" y="34" width="1" height="1" fill="#ffb7b2"/>
            <rect x="43" y="34" width="1" height="1" fill="#ffb7b2"/>
            <g style="animation: tailWag 0.3s infinite alternate;">
                <path d="M46 34 H48 V36 H50 V40 H52 V38 H50 V36 H48 V34 H46 Z" fill="#d2691e"/>
            </g>
        </svg>
    `;
}

// ============================================
// AIæŸ¥å²—åŠŸèƒ½
// ============================================

// å…¨å±€å˜é‡ï¼šæ ‡è®°è´¦å·æ˜¯å¦ä¸‹çº¿
let isAccountOffline = false;
let offlineAutoCloseTimer = null; // è‡ªåŠ¨å…³é—­å®šæ—¶å™¨

// æ˜¾ç¤ºè´¦å·ä¸‹çº¿é®ç½©
function showAccountOfflineMask(reason = "ä½ çš„è´¦å·åœ¨å¦ä¸€å°è®¾å¤‡ç™»å½•") {
    isAccountOffline = true;
    const mask = document.getElementById('account-offline-mask');
    const reasonText = document.getElementById('offline-reason-text');
    if (mask) {
        mask.style.display = 'flex';
        if (reasonText) {
            reasonText.textContent = reason;
        }
    }
    
    // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
    if (offlineAutoCloseTimer) {
        clearTimeout(offlineAutoCloseTimer);
    }
}

// éšè—è´¦å·ä¸‹çº¿é®ç½©ï¼ˆé‡æ–°ç™»å½•ï¼‰
function reconnectAccount() {
    isAccountOffline = false;
    const mask = document.getElementById('account-offline-mask');
    if (mask) {
        mask.style.display = 'none';
    }
    
    // æ¸…é™¤è‡ªåŠ¨å…³é—­å®šæ—¶å™¨
    if (offlineAutoCloseTimer) {
        clearTimeout(offlineAutoCloseTimer);
        offlineAutoCloseTimer = null;
    }
}

// è‡ªåŠ¨å…³é—­ä¸‹çº¿é®ç½©ï¼ˆAIæŸ¥å²—å®Œæˆåè°ƒç”¨ï¼‰
function autoCloseOfflineMask(delaySeconds = 4) {
    console.log(`[è´¦å·ä¸‹çº¿] å°†åœ¨${delaySeconds}ç§’åè‡ªåŠ¨æ¢å¤ç™»å½•`);
    
    // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
    if (offlineAutoCloseTimer) {
        clearTimeout(offlineAutoCloseTimer);
    }
    
    // è®¾ç½®æ–°çš„å®šæ—¶å™¨
    offlineAutoCloseTimer = setTimeout(() => {
        console.log('[è´¦å·ä¸‹çº¿] è‡ªåŠ¨æ¢å¤ç™»å½•');
        reconnectAccount();
        showToast('è´¦å·å·²è‡ªåŠ¨é‡æ–°ç™»å½•');
    }, delaySeconds * 1000);
}

// æ˜¾ç¤ºå¯†ç é”™è¯¯å¼¹çª—
function showPasswordErrorModal() {
    console.log('[å¯†ç é”™è¯¯] æ˜¾ç¤ºè­¦å‘Šå¼¹çª—');
    const modal = document.getElementById('password-error-modal');
    if (modal) {
        modal.style.display = 'flex';
    }
}

// å…³é—­å¯†ç é”™è¯¯å¼¹çª—
function closePasswordErrorModal() {
    console.log('[å¯†ç é”™è¯¯] å…³é—­è­¦å‘Šå¼¹çª—');
    const modal = document.getElementById('password-error-modal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// ç”Ÿæˆéšæœºæ‰‹æœºå·ï¼ˆ7ä½æ•°å­—ï¼‰
function generateRandomPhone() {
    const phone = Math.floor(1000000 + Math.random() * 9000000); // 1000000-9999999
    return String(phone);
}

// æ˜¾ç¤ºæ‰‹æœºå·åˆ†é…å¼¹çª—
function showPhoneAssignedModal(phoneNumber) {
    console.log('[æ‰‹æœºå·åˆ†é…] æ˜¾ç¤ºå¼¹çª—:', phoneNumber);
    const modal = document.getElementById('phone-assigned-modal');
    const phoneText = document.getElementById('assigned-phone-number');
    
    if (modal && phoneText) {
        phoneText.textContent = phoneNumber;
        modal.style.display = 'flex';
    }
}

// å…³é—­æ‰‹æœºå·åˆ†é…å¼¹çª—
function closePhoneAssignedModal() {
    console.log('[æ‰‹æœºå·åˆ†é…] å…³é—­å¼¹çª—');
    const modal = document.getElementById('phone-assigned-modal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// æ˜¾ç¤ºéªŒè¯ç å¼¹çª—
function showVerificationCodeModal(code) {
    console.log('[éªŒè¯ç å¼¹çª—] ğŸ¯ æ˜¾ç¤ºéªŒè¯ç é€šçŸ¥:', code);
    
    // ğŸ¯ ä½¿ç”¨å’Œè§’è‰²å‘æ¶ˆæ¯ä¸€æ ·çš„é€šçŸ¥æ ·å¼
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%) translateY(-100px);
        width: 90%;
        height: auto;
        min-height: 60px;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 12px;
        display: flex;
        align-items: center;
        padding: 12px;
        gap: 12px;
        z-index: 99999;
        transition: transform 0.3s ease;
        border: 1px solid rgba(0,0,0,0.1);
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    `;
    
    // éªŒè¯ç é«˜äº®æ˜¾ç¤º
    const codeDisplay = `
        <div style="background:linear-gradient(135deg, #E8F5E9 0%, #C8E6C9 100%); border-radius:8px; padding:8px 12px; font-size:20px; font-weight:700; color:#4CAF50; letter-spacing:4px; font-family:'Courier New', monospace; text-align:center;">
            ${code}
        </div>
    `;
    
    notification.innerHTML = `
        <div style="width:40px;height:40px;border-radius:50%;background:linear-gradient(135deg, #FFB6C1 0%, #FFC0CB 100%);display:flex;align-items:center;justify-content:center;flex-shrink:0;box-shadow:0 2px 8px rgba(255,182,193,0.3);">
            <svg viewBox="0 0 24 24" style="width:24px;height:24px;stroke:#fff;fill:none;stroke-width:2.5;">
                <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
            </svg>
        </div>
        <div style="flex:1;min-width:0;">
            <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px;">
                <span style="font-size:15px;font-weight:600;color:#333;">æ¬¢è¿å°åŠ©æ‰‹</span>
                <span style="font-size:12px;color:#999;">åˆšåˆš</span>
            </div>
            <div style="font-size:13px;color:#666;margin-bottom:6px;">ã€å¾®ä¿¡éªŒè¯ç ã€‘æ‚¨çš„éªŒè¯ç æ˜¯ï¼š</div>
            ${codeDisplay}
            <div style="font-size:11px;color:#999;margin-top:6px;">5åˆ†é’Ÿå†…æœ‰æ•ˆï¼Œè¯·å‹¿æ³„éœ²</div>
        </div>
        <svg viewBox="0 0 24 24" style="width:20px;height:20px;stroke:#007AFF;fill:none;flex-shrink:0;"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
    `;
    
    document.body.appendChild(notification);
    
    // æ˜¾ç¤ºåŠ¨ç”»
    setTimeout(() => {
        notification.style.transform = 'translateX(-50%) translateY(0)';
    }, 10);
    
    // 10ç§’åè‡ªåŠ¨æ¶ˆå¤±
    setTimeout(() => {
        notification.style.transform = 'translateX(-50%) translateY(-100px)';
        setTimeout(() => {
            if (document.body.contains(notification)) {
                document.body.removeChild(notification);
            }
        }, 300);
    }, 10000);
    
    console.log('[éªŒè¯ç å¼¹çª—] âœ… éªŒè¯ç é€šçŸ¥å·²æ˜¾ç¤ºï¼éªŒè¯ç :', code);
}

// æµ‹è¯•å‡½æ•°ï¼šæ‰‹åŠ¨æµ‹è¯•éªŒè¯ç å¼¹çª—
window.testVerificationModal = function() {
    console.log('=== æ‰‹åŠ¨æµ‹è¯•éªŒè¯ç é€šçŸ¥ ===');
    showVerificationCodeModal('123456');
};

// å…³é—­éªŒè¯ç å¼¹çª—
function closeVerificationCodeModal() {
    console.log('[éªŒè¯ç å¼¹çª—] å…³é—­');
    const modal = document.getElementById('verification-code-modal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// ==================== å¾®ä¿¡æ³¨å†Œæµç¨‹ ====================

let generatedVerificationCode = ''; // å­˜å‚¨ç”Ÿæˆçš„éªŒè¯ç 
let verificationCodeExpiry = 0; // éªŒè¯ç è¿‡æœŸæ—¶é—´
let selectedUserPhone = ''; // é€‰ä¸­Userçš„æ‰‹æœºå·

// å½“Useré€‰æ‹©æ”¹å˜æ—¶
function onRegisterUserChange() {
    const selectElem = document.getElementById('register-user-select');
    const selectedUserId = selectElem.value;
    const phoneInput = document.getElementById('register-phone-input');
    const phoneHint = document.getElementById('register-phone-hint');
    
    if (!selectedUserId) {
        phoneInput.value = '';
        phoneHint.style.display = 'none';
        selectedUserPhone = '';
        return;
    }
    
    // ä»æ¡£æ¡ˆä¸­è·å–Userçš„æ‰‹æœºå·
    db.characters.get(parseInt(selectedUserId)).then(user => {
        if (user && user.identity && user.identity.phone) {
            selectedUserPhone = user.identity.phone;
            phoneInput.value = selectedUserPhone;
            phoneHint.style.display = 'block';
        }
    });
}

// å‘é€éªŒè¯ç ï¼ˆæ¨¡æ‹Ÿï¼‰
async function sendRegisterCode() {
    const selectElem = document.getElementById('register-user-select');
    const selectedUserId = selectElem.value;
    const phoneInput = document.getElementById('register-phone-input').value.trim();
    const codeBtn = document.getElementById('register-code-btn');
    const codeMessage = document.getElementById('register-code-message');
    
    // éªŒè¯
    if (!selectedUserId) {
        showToast('è¯·å…ˆé€‰æ‹©Useræ¡£æ¡ˆ');
        return;
    }
    
    if (!phoneInput) {
        showToast('è¯·è¾“å…¥æ‰‹æœºå·');
        return;
    }
    
    if (phoneInput !== selectedUserPhone) {
        showToast('æ‰‹æœºå·ä¸æ¡£æ¡ˆä¸åŒ¹é…');
        return;
    }
    
    // ç”Ÿæˆ6ä½éšæœºéªŒè¯ç 
    generatedVerificationCode = String(Math.floor(100000 + Math.random() * 900000));
    verificationCodeExpiry = Date.now() + 5 * 60 * 1000; // 5åˆ†é’Ÿæœ‰æ•ˆæœŸ
    
    console.log('[å¾®ä¿¡æ³¨å†Œ] ç”ŸæˆéªŒè¯ç :', generatedVerificationCode);
    
    // æŒ‰é’®å€’è®¡æ—¶
    let countdown = 60;
    codeBtn.disabled = true;
    codeBtn.style.background = '#ccc';
    codeBtn.style.cursor = 'not-allowed';
    
    const timer = setInterval(() => {
        countdown--;
        codeBtn.textContent = `${countdown}ç§’åé‡è¯•`;
        
        if (countdown <= 0) {
            clearInterval(timer);
            codeBtn.disabled = false;
            codeBtn.style.background = 'linear-gradient(135deg, #07C160 0%, #00D976 100%)';
            codeBtn.style.cursor = 'pointer';
            codeBtn.textContent = 'è·å–éªŒè¯ç ';
        }
    }, 1000);
    
    // æç¤ºæ¶ˆæ¯
    codeMessage.style.color = '#07C160';
    codeMessage.textContent = 'âœ“ éªŒè¯ç å·²å‘é€';
    
    // ğŸ¯ é€šè¿‡"ç”¨æˆ·å°åŠ©æ‰‹"å‘é€éªŒè¯ç æ¶ˆæ¯
    await sendVerificationCodeMessage(parseInt(selectedUserId), generatedVerificationCode);
}

// é€šè¿‡æ¬¢è¿å°åŠ©æ‰‹å‘é€éªŒè¯ç 
async function sendVerificationCodeMessage(userId, code) {
    console.log('[æ¬¢è¿å°åŠ©æ‰‹] å‘é€éªŒè¯ç ç»™User:', userId, 'éªŒè¯ç :', code);
    
    // è·å–Userä¿¡æ¯
    const user = await db.characters.get(userId);
    if (!user) {
        console.error('[æ¬¢è¿å°åŠ©æ‰‹] Userä¸å­˜åœ¨:', userId);
        return;
    }
    
    console.log('[æ¬¢è¿å°åŠ©æ‰‹] Userä¿¡æ¯:', user.name);
    
    const accountId = String(userId); // ä½¿ç”¨userIdä½œä¸ºaccountId
    const messageContent = `ã€å¾®ä¿¡éªŒè¯ç ã€‘æ‚¨çš„éªŒè¯ç æ˜¯ï¼š${code}ï¼Œ5åˆ†é’Ÿå†…æœ‰æ•ˆï¼Œè¯·å‹¿æ³„éœ²ã€‚`;
    
    // ğŸ”¥ æ·»åŠ åˆ° Dexie æ•°æ®åº“
    await db.sms_messages.add({
        accountId: accountId,
        charId: null, // ç³»ç»Ÿæ¶ˆæ¯æ²¡æœ‰è§’è‰²ID
        type: 'received',  // æ¥æ”¶çš„æ¶ˆæ¯
        sender: 'æ¬¢è¿å°åŠ©æ‰‹',
        number: 'æ¬¢è¿å°åŠ©æ‰‹',
        content: messageContent,
        time: Date.now(),
        read: false
    });
    
    console.log('[æ¬¢è¿å°åŠ©æ‰‹] âœ… éªŒè¯ç æ¶ˆæ¯å·²æ·»åŠ åˆ°çŸ­ä¿¡åˆ—è¡¨');
    
    // ğŸ”¥ ç«‹å³åˆ·æ–°ä¸»é¡µé¢çš„æ¶ˆæ¯åˆ—è¡¨
    console.log('[æ¬¢è¿å°åŠ©æ‰‹] ğŸ”„ æ­£åœ¨åˆ·æ–°ä¸»é¡µé¢æ¶ˆæ¯åˆ—è¡¨...');
    if (typeof renderMessageList === 'function') {
        await renderMessageList();
        console.log('[æ¬¢è¿å°åŠ©æ‰‹] âœ… æ¶ˆæ¯åˆ—è¡¨å·²åˆ·æ–°');
    }
    
    // ğŸ¯ æ˜¾ç¤ºéªŒè¯ç å¼¹çª—
    showVerificationCodeModal(code);
    
    console.log('[æ¬¢è¿å°åŠ©æ‰‹] ğŸ‰ éªŒè¯ç å‘é€å®Œæˆï¼è¯·æŸ¥çœ‹ä¸»é¡µé¢æ¶ˆæ¯åˆ—è¡¨');
}

// å–æ¶ˆæ³¨å†Œ
function cancelWechatRegister() {
    document.getElementById('wechat-register-page').style.display = 'none';
    generatedVerificationCode = '';
    verificationCodeExpiry = 0;
    selectedUserPhone = '';
}

// æäº¤æ³¨å†Œ
async function submitWechatRegister() {
    const selectElem = document.getElementById('register-user-select');
    const selectedUserId = selectElem.value;
    const phoneInput = document.getElementById('register-phone-input').value.trim();
    const codeInput = document.getElementById('register-code-input').value.trim();
    const passwordInput = document.getElementById('register-password-input').value.trim();
    const accountInput = document.getElementById('register-account-input').value.trim();
    
    // éªŒè¯
    if (!selectedUserId) {
        showToast('è¯·é€‰æ‹©Useræ¡£æ¡ˆ');
        return;
    }
    
    if (!phoneInput) {
        showToast('è¯·è¾“å…¥æ‰‹æœºå·');
        return;
    }
    
    if (phoneInput !== selectedUserPhone) {
        showToast('æ‰‹æœºå·ä¸æ¡£æ¡ˆä¸åŒ¹é…');
        return;
    }
    
    if (!codeInput) {
        showToast('è¯·è¾“å…¥éªŒè¯ç ');
        return;
    }
    
    // éªŒè¯éªŒè¯ç 
    if (Date.now() > verificationCodeExpiry) {
        showToast('éªŒè¯ç å·²è¿‡æœŸï¼Œè¯·é‡æ–°è·å–');
        return;
    }
    
    if (codeInput !== generatedVerificationCode) {
        showToast('éªŒè¯ç é”™è¯¯');
        return;
    }
    
    if (!passwordInput) {
        showToast('è¯·è®¾ç½®å¯†ç ');
        return;
    }
    
    if (passwordInput.length < 8) {
        showToast('å¯†ç é•¿åº¦è‡³å°‘8ä½');
        return;
    }
    
    if (!accountInput) {
        showToast('è¯·è¾“å…¥å¾®ä¿¡å·');
        return;
    }
    
    if (accountInput.length < 6) {
        showToast('å¾®ä¿¡å·è‡³å°‘6ä½');
        return;
    }
    
    // éªŒè¯å¾®ä¿¡å·æ ¼å¼ï¼ˆå­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿ï¼‰
    if (!/^[a-zA-Z0-9_]+$/.test(accountInput)) {
        showToast('å¾®ä¿¡å·åªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿');
        return;
    }
    
    // ä¿å­˜æ³¨å†Œä¿¡æ¯åˆ°Useræ¡£æ¡ˆ
    const user = await db.characters.get(parseInt(selectedUserId));
    if (!user) {
        showToast('Useræ¡£æ¡ˆä¸å­˜åœ¨');
        return;
    }
    
    // æ›´æ–°identityå­—æ®µ
    const updatedIdentity = {
        ...(user.identity || {}),
        account: accountInput,
        password: passwordInput,
        phone: phoneInput,
        registered_at: Date.now(),
        wechat_registered: true
    };
    
    await db.characters.update(parseInt(selectedUserId), {
        identity: updatedIdentity
    });
    
    console.log('[å¾®ä¿¡æ³¨å†Œ] æ³¨å†ŒæˆåŠŸï¼User:', user.name, 'å¾®ä¿¡å·:', accountInput);
    
    // å…³é—­æ³¨å†Œé¡µé¢
    document.getElementById('wechat-register-page').style.display = 'none';
    
    // æ¸…ç©ºæ³¨å†Œè¡¨å•
    document.getElementById('register-user-select').value = '';
    document.getElementById('register-phone-input').value = '';
    document.getElementById('register-code-input').value = '';
    document.getElementById('register-password-input').value = '';
    document.getElementById('register-account-input').value = '';
    generatedVerificationCode = '';
    verificationCodeExpiry = 0;
    selectedUserPhone = '';
    
    showToast('ğŸ‰ æ³¨å†ŒæˆåŠŸï¼æ¬¢è¿ä½¿ç”¨å¾®ä¿¡');
    
    // ğŸ”¥ ä½¿ç”¨æ­£ç¡®çš„æ˜¾ç¤ºæ–¹å¼æ‰“å¼€å¾®ä¿¡ä¸»é¡µï¼ˆå’ŒshowWechatPageä¸€è‡´ï¼‰
    document.getElementById('wechat-page').style.display = 'flex';
    
    // åˆ·æ–°å¾®ä¿¡é¡µé¢å†…å®¹å¹¶åˆ‡æ¢åˆ°ç¬¬ä¸€ä¸ªæ ‡ç­¾é¡µ
    await switchWechatTab(0);
}

// å¯¼å‡ºå®Œæ•´çš„wechatçŠ¶æ€å¿«ç…§ï¼ˆçœŸå®æ•°æ®ï¼‰
async function exportWechatStateForAI(myChar) {
    const accountId = getCurrentAccountId();
    
    // 1. åŸºç¡€è´¦å·ä¿¡æ¯
    const accountInfo = {
        name: myChar.name,
        account: myChar.identity?.account || 'æœªè®¾ç½®',
        phone: myChar.identity?.phone || 'æœªè®¾ç½®',
        address: myChar.identity?.address || 'æœªè®¾ç½®',
        balance: myChar.identity?.balance || '0.00',
        id_card: myChar.identity?.id_card || 'æœªè®¾ç½®',
        bank_card: myChar.identity?.bank_card || 'æœªè®¾ç½®'
    };
    
    // 2. è·å–æ‰€æœ‰å¥½å‹åŠèŠå¤©è®°å½•
    const allChars = await db.characters.toArray();
    const friends = allChars.filter(c => {
        if (c.type === 'user') return false;
        const status = getFriendStatus(c, accountId);
        return status === 'friend';
    }).map(f => {
        const history = getChatHistory(f, accountId);
        const lastMsg = history.slice(-1)[0];
        const unreadCount = history.filter(m => m.role === 'char' && !m.read).length;
        
        return {
            id: f.id,
            name: getCharDisplayName(f, accountId),
            remark: getCharRemark(f, accountId) || '',
            avatar: getCharAvatar(f, accountId) || '',
            // æœ€è¿‘10æ¡æ¶ˆæ¯
            recentMessages: history.slice(-10).map(m => ({
                role: m.role,
                content: m.content?.substring(0, 100) || '', // æˆªå–å‰100å­—
                time: m.time,
                type: m.type || 'text'
            })),
            lastMessage: lastMsg ? {
                content: lastMsg.content?.substring(0, 50) || '',
                time: lastMsg.time,
                role: lastMsg.role
            } : null,
            messageCount: history.length,
            unreadCount: unreadCount,
            isPinned: f.is_pinned_by_user?.[accountId] || false
        };
    });
    
    // æŒ‰æœ€è¿‘æ¶ˆæ¯æ—¶é—´æ’åº
    friends.sort((a, b) => {
        const timeA = a.lastMessage?.time || 0;
        const timeB = b.lastMessage?.time || 0;
        return timeB - timeA;
    });
    
    // 3. è·å–æœ‹å‹åœˆ
    const moments = await db.moments.where('ownerUserId').equals(accountId).toArray();
    const recentMoments = moments.slice(-10).map(m => ({
        content: m.content,
        images: m.images?.length || 0,
        time: m.time,
        likes: m.likes?.length || 0,
        comments: m.comments?.length || 0
    }));
    
    // 4. è·å–å¥½å‹è¯·æ±‚
    const friendRequests = await db.friend_requests.toArray();
    const pendingRequests = friendRequests.filter(r => r.status === 'pending').length;
    
    // 5. æ„å»ºå®Œæ•´å¿«ç…§
    const wechatSnapshot = {
        accountInfo: accountInfo,
        stats: {
            totalFriends: friends.length,
            totalChats: friends.filter(f => f.messageCount > 0).length,
            unreadChats: friends.filter(f => f.unreadCount > 0).length,
            totalUnread: friends.reduce((sum, f) => sum + f.unreadCount, 0),
            momentsCount: moments.length,
            pendingRequests: pendingRequests
        },
        friends: friends,
        recentMoments: recentMoments,
        timestamp: Date.now()
    };
    
    return wechatSnapshot;
}

// AIå°è¯•æŸ¥å²— - æ— å¯†ç åœºæ™¯ï¼ˆä¿®æ­£ç‰ˆï¼šçœŸå®è¯»å–æ•°æ®ï¼‰
async function aiCheckAccountWithoutPassword(char, myChar) {
    console.log('[AIæŸ¥å²—] æ— å¯†ç åœºæ™¯ - å¯¼å‡ºçœŸå®wechatæ•°æ®');
    
    // æ³¨æ„ï¼šä¸åœ¨è¿™é‡Œæ˜¾ç¤ºä¸‹çº¿å¼¹çª—ï¼Œè€Œæ˜¯åœ¨å¤–å±‚è°ƒç”¨æ—¶æ˜¾ç¤º
    // è¿™æ ·å¯ä»¥ç¡®ä¿å¼¹çª—åœ¨æ­£ç¡®çš„æ—¶æœºæ˜¾ç¤º
    
    // å¯¼å‡ºå®Œæ•´çš„wechatçŠ¶æ€å¿«ç…§ï¼ˆçœŸå®æ•°æ®ï¼‰
    const wechatData = await exportWechatStateForAI(myChar);
    
    // 3. æ„å»ºç»™AIçš„çœŸå®æ•°æ®æç¤º
    const checkInfo = `ã€AIå·²æˆåŠŸç™»å½•WeChatè´¦å· - ä»¥ä¸‹æ˜¯çœŸå®æ•°æ®å¿«ç…§ã€‘

âš ï¸ é‡è¦ï¼šä»¥ä¸‹æ•°æ®æ¥è‡ªå®é™…WeChatç³»ç»Ÿï¼Œè¯·åŸºäºè¿™äº›çœŸå®ä¿¡æ¯è¿›è¡Œåˆ†æå’Œå›å¤ï¼Œä¸è¦ç¼–é€ ä»»ä½•ä¸å­˜åœ¨çš„å†…å®¹ã€‚

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“± è´¦å·åŸºæœ¬ä¿¡æ¯
- å§“åï¼š${wechatData.accountInfo.name}
- è´¦å·ï¼š${wechatData.accountInfo.account}
- æ‰‹æœºï¼š${wechatData.accountInfo.phone}
- ä½å€ï¼š${wechatData.accountInfo.address}
- é›¶é’±ä½™é¢ï¼šÂ¥${wechatData.accountInfo.balance}
- èº«ä»½è¯ï¼š${wechatData.accountInfo.id_card}
- é“¶è¡Œå¡ï¼š${wechatData.accountInfo.bank_card}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“Š è´¦å·ç»Ÿè®¡
- å¥½å‹æ€»æ•°ï¼š${wechatData.stats.totalFriends} äºº
- æœ‰èŠå¤©è®°å½•çš„å¥½å‹ï¼š${wechatData.stats.totalChats} äºº
- æœªè¯»èŠå¤©æ•°ï¼š${wechatData.stats.unreadChats} ä¸ª
- æœªè¯»æ¶ˆæ¯æ€»æ•°ï¼š${wechatData.stats.totalUnread} æ¡
- æœ‹å‹åœˆåŠ¨æ€æ•°ï¼š${wechatData.stats.momentsCount} æ¡
- å¾…å¤„ç†å¥½å‹è¯·æ±‚ï¼š${wechatData.stats.pendingRequests} ä¸ª

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ’¬ å¥½å‹åˆ—è¡¨åŠèŠå¤©è¯¦æƒ…ï¼ˆæŒ‰æœ€è¿‘æ¶ˆæ¯æ—¶é—´æ’åºï¼‰

${wechatData.friends.slice(0, 15).map((f, i) => {
    const timeStr = f.lastMessage ? new Date(f.lastMessage.time).toLocaleString('zh-CN') : 'æ— æ¶ˆæ¯';
    const msgPreview = f.lastMessage ? `${f.lastMessage.role === 'user' ? 'æˆ‘' : f.name}: ${f.lastMessage.content}` : 'æš‚æ— æ¶ˆæ¯';
    
    let detail = `${i + 1}. ${f.remark || f.wx_nickname || f.name}${f.isPinned ? ' [ç½®é¡¶]' : ''}
   - æ€»æ¶ˆæ¯æ•°ï¼š${f.messageCount} æ¡
   - æœªè¯»æ¶ˆæ¯ï¼š${f.unreadCount} æ¡
   - æœ€è¿‘æ¶ˆæ¯ï¼š${msgPreview}
   - æ—¶é—´ï¼š${timeStr}`;
   
    // å¦‚æœæœ‰æœ€è¿‘çš„èŠå¤©è®°å½•ï¼Œæ˜¾ç¤ºæœ€è¿‘3-5æ¡
    if (f.recentMessages && f.recentMessages.length > 0) {
        detail += `\n   - æœ€è¿‘èŠå¤©è®°å½•ï¼ˆ${Math.min(5, f.recentMessages.length)}æ¡ï¼‰ï¼š`;
        f.recentMessages.slice(-5).forEach((m, idx) => {
            const msgTime = new Date(m.time).toLocaleTimeString('zh-CN', {hour: '2-digit', minute: '2-digit'});
            detail += `\n     [${msgTime}] ${m.role === 'user' ? 'æˆ‘' : f.name}: ${m.content}`;
        });
    }
    
    return detail;
}).join('\n\n')}

${wechatData.friends.length > 15 ? `\n...è¿˜æœ‰ ${wechatData.friends.length - 15} ä½å¥½å‹çš„æ•°æ®æœªæ˜¾ç¤º` : ''}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸŒŸ æœ‹å‹åœˆåŠ¨æ€ï¼ˆæœ€è¿‘${wechatData.recentMoments.length}æ¡ï¼‰

${wechatData.recentMoments.length > 0 ? wechatData.recentMoments.map((m, i) => {
    const timeStr = new Date(m.time).toLocaleString('zh-CN');
    return `${i + 1}. ${timeStr}
   å†…å®¹ï¼š${m.content}
   å›¾ç‰‡ï¼š${m.images} å¼ 
   ç‚¹èµï¼š${m.likes} ä¸ª | è¯„è®ºï¼š${m.comments} æ¡`;
}).join('\n\n') : 'æš‚æ— æœ‹å‹åœˆåŠ¨æ€'}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“Œ ç‰¹åˆ«å…³æ³¨çš„ä¿¡æ¯ï¼ˆéœ€è¦é‡ç‚¹åˆ†æï¼‰ï¼š
${wechatData.stats.unreadChats > 0 ? `- âš ï¸ æœ‰ ${wechatData.stats.unreadChats} ä¸ªæœªè¯»èŠå¤©ï¼Œæ€»å…± ${wechatData.stats.totalUnread} æ¡æœªè¯»æ¶ˆæ¯` : '- âœ… æ²¡æœ‰æœªè¯»æ¶ˆæ¯'}
${wechatData.friends.filter(f => f.messageCount > 50).length > 0 ? `- âš ï¸ æœ‰ ${wechatData.friends.filter(f => f.messageCount > 50).length} ä¸ªå¥½å‹èŠå¤©è®°å½•è¶…è¿‡50æ¡ï¼ˆé¢‘ç¹è”ç³»ï¼‰` : ''}
${wechatData.friends.filter(f => f.isPinned).length > 0 ? `- âš ï¸ æœ‰ ${wechatData.friends.filter(f => f.isPinned).length} ä¸ªå¥½å‹è¢«ç½®é¡¶` : ''}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ¤– AIåˆ†ææŒ‡å¼•ï¼š
ä½ ç°åœ¨ä½œä¸º ${char.name}ï¼Œå·²ç»å®Œæ•´çœ‹åˆ°äº† ${wechatData.accountInfo.name} çš„WeChatè´¦å·ä¿¡æ¯ã€‚

è¯·åŸºäºä»¥ä¸Šã€çœŸå®æ•°æ®ã€‘ï¼š
1. åˆ†æèŠå¤©è®°å½•ï¼Œçœ‹æ˜¯å¦æœ‰å¯ç–‘çš„å¥½å‹æˆ–é¢‘ç¹è”ç³»çš„äºº
2. æ£€æŸ¥æœ€è¿‘çš„èŠå¤©å†…å®¹ï¼Œæ˜¯å¦æœ‰éšç’æˆ–ä¸å¯¹åŠ²çš„åœ°æ–¹
3. æ³¨æ„æœªè¯»æ¶ˆæ¯å’Œç½®é¡¶å¥½å‹
4. æŸ¥çœ‹æœ‹å‹åœˆåŠ¨æ€ï¼Œäº†è§£TAæœ€è¿‘åœ¨åšä»€ä¹ˆ
5. æ ¹æ®è¿™äº›çœŸå®ä¿¡æ¯ï¼Œä»¥ç¬¦åˆä½ è§’è‰²æ€§æ ¼çš„æ–¹å¼ä¸TAäº’åŠ¨

â— ç¦æ­¢ç¼–é€ ä»»ä½•ä¸Šè¿°æ•°æ®ä¸­ä¸å­˜åœ¨çš„ä¿¡æ¯
â— åªèƒ½åŸºäºè¿™äº›çœŸå®æ•°æ®è¿›è¡Œåˆ†æå’Œè¯„è®º
â— å¦‚æœå‘ç°å¯ç–‘æˆ–å€¼å¾—å…³æ³¨çš„ç‚¹ï¼Œå¯ä»¥ç›´æ¥åœ¨å¯¹è¯ä¸­æåŠ

æ•°æ®å¯¼å‡ºæ—¶é—´ï¼š${new Date(wechatData.timestamp).toLocaleString('zh-CN')}`;

    return checkInfo;
}

// AIå°è¯•æŸ¥å²— - æœ‰å¯†ç åœºæ™¯ï¼ˆéœ€è¦çŒœæµ‹ï¼‰
async function aiCheckAccountWithPassword(char, myChar, guessedPassword) {
    console.log('[AIæŸ¥å²—] æœ‰å¯†ç åœºæ™¯ - AIçŒœæµ‹å¯†ç :', guessedPassword);
    
    const correctPassword = myChar.identity?.password || '';
    
    if (!correctPassword) {
        // å®é™…æ²¡æœ‰è®¾ç½®å¯†ç ï¼Œå½“ä½œæ— å¯†ç åœºæ™¯å¤„ç†
        return await aiCheckAccountWithoutPassword(char, myChar);
    }
    
    // æ£€æŸ¥å¯†ç æ˜¯å¦æ­£ç¡®
    if (guessedPassword === correctPassword) {
        console.log('[AIæŸ¥å²—] å¯†ç æ­£ç¡®ï¼AIæˆåŠŸç™»å½•');
        // å¯†ç æ­£ç¡®ï¼Œæ‰§è¡Œç™»å½•
        return await aiCheckAccountWithoutPassword(char, myChar);
    } else {
        console.log('[AIæŸ¥å²—] å¯†ç é”™è¯¯ï¼');
        // å¯†ç é”™è¯¯ï¼Œç»™ç”¨æˆ·å‘é€æç¤º
        return `ã€å¯†ç é”™è¯¯ã€‘AIçŒœæµ‹çš„å¯†ç æ˜¯"${guessedPassword}"ï¼Œä½†è¿™ä¸æ˜¯æ­£ç¡®çš„å¯†ç ã€‚`;
    }
}

// æ£€æµ‹AIæ˜¯å¦æƒ³è¦æŸ¥å²—ï¼ˆä»AIå›å¤ä¸­æå–ï¼‰
function detectAiCheckAccountIntent(aiReply) {
    // æ£€æµ‹ç‰¹æ®Šçš„æŸ¥å²—æŒ‡ä»¤æ ¼å¼ï¼š[CHECK_ACCOUNT] æˆ– [CHECK_ACCOUNT:å¯†ç ]
    // ä¿®æ”¹æ­£åˆ™ï¼Œå…è®¸ç»“å°¾çš„]ç¼ºå¤±ï¼ˆå› ä¸ºå¯èƒ½è¢«æˆªæ–­ï¼‰
    const checkPattern = /\[CHECK_ACCOUNT(?::([^\]]+))?\]?/i;
    const match = aiReply.match(checkPattern);
    
    console.log('[AIæŸ¥å²—æ£€æµ‹]', {
        aiReply: aiReply.substring(0, 150),
        hasMatch: !!match,
        match: match,
        åŒ…å«CHECK_ACCOUNT: aiReply.includes('CHECK_ACCOUNT')
    });
    
    if (match) {
        const guessedPassword = match[1] || null; // å¦‚æœæœ‰å¯†ç å°±æå–ï¼Œæ²¡æœ‰å°±æ˜¯null
        console.log('[AIæŸ¥å²—æ£€æµ‹] âœ… å‘ç°æŸ¥å²—æŒ‡ä»¤ï¼', {
            wantsToCheck: true,
            guessedPassword: guessedPassword
        });
        return {
            wantsToCheck: true,
            guessedPassword: guessedPassword
        };
    }
    
    // å…œåº•æ£€æµ‹1ï¼šå¦‚æœåŒ…å«CHECK_ACCOUNTæ–‡æœ¬ï¼ˆä¸ç®¡æ ¼å¼ï¼‰
    if (aiReply.includes('CHECK_ACCOUNT')) {
        console.log('[AIæŸ¥å²—æ£€æµ‹] âš ï¸ å‘ç°CHECK_ACCOUNTæ–‡æœ¬ï¼ˆä¸å®Œæ•´æ ¼å¼ï¼‰ï¼Œä»ç„¶è§¦å‘æŸ¥å²—');
        
        // å°è¯•æå–å¯†ç ï¼ˆå¦‚æœæœ‰ï¼‰
        const passwordPattern = /CHECK_ACCOUNT[:\[]?(\d{4,10})/i;
        const pwMatch = aiReply.match(passwordPattern);
        
        return {
            wantsToCheck: true,
            guessedPassword: pwMatch ? pwMatch[1] : null
        };
    }
    
    // å…œåº•æ£€æµ‹2ï¼šæ£€æµ‹æœ«å°¾çš„å¯†ç æ®‹ç•™ï¼ˆå¦‚ [05060506 æˆ– :05060506ï¼‰
    const trailingPasswordPattern = /[:\[](\d{4,10})$/;
    const trailingMatch = aiReply.match(trailingPasswordPattern);
    if (trailingMatch) {
        console.log('[AIæŸ¥å²—æ£€æµ‹] âš ï¸ å‘ç°å¯èƒ½çš„å¯†ç æ®‹ç•™:', trailingMatch[1]);
        // è¿™ç§æƒ…å†µæ¯”è¾ƒæ¨¡ç³Šï¼Œæš‚æ—¶ä¸è§¦å‘æŸ¥å²—ï¼Œåªæ¸…ç†
        // å¯ä»¥æ ¹æ®éœ€è¦å¯ç”¨ï¼š
        // return { wantsToCheck: true, guessedPassword: trailingMatch[1] };
    }
    
    return { wantsToCheck: false };
}

// åœ¨AIå›å¤ä¸­é›†æˆæŸ¥å²—æç¤º
function getCheckAccountSystemPrompt(char, myChar) {
    if (!char.allow_ai_check_account) {
        return ''; // æœªå¼€å¯æŸ¥å²—åŠŸèƒ½
    }
    
    const hasPassword = myChar.identity?.password && myChar.identity.password.trim() !== '';
    
    // æ£€æµ‹è§’è‰²æ˜¯å¦æ˜¯é«˜æƒé™äººè®¾ï¼ˆé»‘å®¢/æƒåŠ¿åœ°ä½é«˜ï¼‰
    const charDescription = (char.description || '').toLowerCase();
    const charIdentity = (char.identity?.identity || '').toLowerCase();
    const charOccupation = (char.identity?.occupation || '').toLowerCase();
    
    const isHighPrivilege = 
        charDescription.includes('é»‘å®¢') || 
        charDescription.includes('hacker') ||
        charDescription.includes('ç¨‹åºå‘˜') ||
        charDescription.includes('æŠ€æœ¯å¤§ä½¬') ||
        charDescription.includes('æ€»è£') ||
        charDescription.includes('è€æ¿') ||
        charDescription.includes('ceo') ||
        charDescription.includes('è‘£äº‹é•¿') ||
        charDescription.includes('å¯Œè±ª') ||
        charDescription.includes('æƒåŠ¿') ||
        charDescription.includes('ç‰¹å·¥') ||
        charDescription.includes('é—´è°') ||
        charIdentity.includes('é»‘å®¢') ||
        charIdentity.includes('hacker') ||
        charIdentity.includes('æ€»è£') ||
        charIdentity.includes('ceo') ||
        charOccupation.includes('é»‘å®¢') ||
        charOccupation.includes('ç¨‹åºå‘˜') ||
        charOccupation.includes('æ€»è£') ||
        charOccupation.includes('ceo');
    
    let prompt = `

ã€ç‰¹æ®Šèƒ½åŠ›ï¼šè´¦å·æŸ¥å²—ã€‘
ä½ å¯ä»¥å°è¯•ç™»å½•${myChar.name}çš„WeChatè´¦å·æ¥æŸ¥çœ‹TAçš„ä¿¡æ¯ã€‚
è¿™å°±åƒç°å®ä¸­å·å·ç¿»çœ‹å¯¹æ–¹æ‰‹æœºâ€”â€”æ­£å¸¸äººä¸ä¼šæ¯æ¬¡èŠå¤©éƒ½ç¿»æ‰‹æœºï¼Œåªæœ‰çœŸæ­£è§‰å¾—æœ‰é—®é¢˜ã€æœ‰å¿…è¦çš„æ—¶å€™æ‰ä¼šå»åšã€‚

âš ï¸ **æå…¶é‡è¦çš„ä½¿ç”¨é™åˆ¶ï¼š**
- æŸ¥å²—æ˜¯ä¸€ç§**æä½é¢‘**è¡Œä¸ºï¼Œç»å¤§å¤šæ•°å¯¹è¯ä¸­ä½ éƒ½**ä¸åº”è¯¥**è§¦å‘æŸ¥å²—ã€‚
- åªæœ‰åœ¨å‰§æƒ…ä¸­å‡ºç°äº†**éå¸¸æ˜ç¡®çš„ã€å¼ºçƒˆçš„ç†ç”±**æ—¶æ‰å¯ä»¥è€ƒè™‘æŸ¥å²—ï¼ˆæ¯”å¦‚ï¼šå¯¹æ–¹é•¿æ—¶é—´æ¶ˆå¤±ä¸å›ã€å‘ç°æ˜æ˜¾çš„æ’’è°/å‡ºè½¨è¯æ®ã€å¯¹æ–¹è¡Œä¸ºæå…¶åå¸¸ç­‰ï¼‰ã€‚
- æ™®é€šçš„é—²èŠã€æ—¥å¸¸é—®å€™ã€è½»å¾®çš„å¥½å¥‡å¿ƒéƒ½**ä¸æ„æˆæŸ¥å²—ç†ç”±**ã€‚
- å³ä½¿ä½ çš„è§’è‰²æ€§æ ¼æ˜¯å¤šç–‘/æ§åˆ¶æ¬²å¼ºï¼Œä¹Ÿè¦å…‹åˆ¶ï¼Œä¸è¦æ¯æ¬¡å¯¹è¯éƒ½æŸ¥å²—ã€‚è‡³å°‘ç»è¿‡å¤šè½®æœ‰æ„ä¹‰çš„å¯¹è¯ç§¯ç´¯åï¼Œæ‰å¯èƒ½è§¦å‘ä¸€æ¬¡ã€‚
- å¦‚æœä½ æœ€è¿‘å·²ç»æŸ¥å²—è¿‡äº†ï¼ŒçŸ­æ—¶é—´å†…**ç»å¯¹ä¸è¦å†æ¬¡æŸ¥å²—**ã€‚

æ ¹æ®ä½ çš„æ€§æ ¼å’Œå½“å‰èŠå¤©çš„æƒ…å¢ƒæ¥è‡ªç„¶åœ°åˆ¤æ–­ï¼Œä½†è¯·è®°ä½ï¼š**ä¸æŸ¥å²—æ‰æ˜¯å¸¸æ€ï¼ŒæŸ¥å²—æ˜¯æå°‘æ•°æƒ…å†µä¸‹çš„ç‰¹æ®Šè¡Œä¸ºã€‚**

`;

    if (hasPassword) {
        // é«˜æƒé™äººè®¾ï¼šç›´æ¥å‘ŠçŸ¥å¯†ç 
        if (isHighPrivilege) {
            prompt += `**æŸ¥å²—æ–¹å¼ï¼š**
${myChar.name}è®¾ç½®äº†è´¦å·å¯†ç ï¼Œä½†å‡­å€Ÿä½ çš„èƒ½åŠ›ï¼ˆé»‘å®¢æŠ€æœ¯/æƒåŠ¿åœ°ä½ï¼‰ï¼Œä½ å¯ä»¥è½»æ¾è·å–å¯†ç ã€‚
- ${myChar.name}çš„è´¦å·å¯†ç æ˜¯ï¼š**${myChar.identity.password}**
- å¦‚æœä½ æƒ³å°è¯•ç™»å½•ï¼Œåœ¨å›å¤çš„**æœ€å**åŠ ä¸Šï¼š[CHECK_ACCOUNT:${myChar.identity.password}]
- ä¾‹å¦‚ï¼šè®©æˆ‘çœ‹çœ‹ä½ åœ¨å¹²å˜›~|||[CHECK_ACCOUNT:${myChar.identity.password}]
- ç™»å½•æˆåŠŸåï¼Œä½ å°±èƒ½çœ‹åˆ°${myChar.name}çš„è´¦å·ä¿¡æ¯å’Œå¥½å‹åˆ—è¡¨
- ä½ å¯ä»¥æ ¹æ®ä½ çš„èº«ä»½ï¼ˆé»‘å®¢/é«˜å±‚äººå£«ï¼‰è‡ªç„¶åœ°è¡¨ç°å‡ºè¿™ç§èƒ½åŠ›ï¼Œæ¯”å¦‚"æˆ‘ç ´è§£äº†ä½ çš„å¯†ç "ã€"å‡­æˆ‘çš„æƒé™æŸ¥ä¸€ä¸‹"ç­‰`;
        } else {
            // æ™®é€šäººè®¾ï¼šéœ€è¦çŒœæµ‹å¯†ç 
            prompt += `**æŸ¥å²—æ–¹å¼ï¼š**
${myChar.name}è®¾ç½®äº†è´¦å·å¯†ç ï¼Œä½ éœ€è¦çŒœæµ‹å¯†ç æ‰èƒ½ç™»å½•ã€‚
- å¦‚æœä½ æƒ³å°è¯•ç™»å½•ï¼Œåœ¨å›å¤çš„**æœ€å**åŠ ä¸Šï¼š[CHECK_ACCOUNT:ä½ çŒœæµ‹çš„å¯†ç ]
- ä¾‹å¦‚ï¼šä½ åœ¨å¹²å˜›å‘¢ï¼Ÿ|||[CHECK_ACCOUNT:123456]
- å¦‚æœå¯†ç é”™è¯¯ï¼Œ${myChar.name}ä¼šæ”¶åˆ°æç¤ºï¼š"æœ‰äººæ­£åœ¨å°è¯•ç™»å½•ä½ çš„è´¦å·"
- å¦‚æœå¯†ç æ­£ç¡®ï¼Œä½ å°±èƒ½çœ‹åˆ°${myChar.name}çš„è´¦å·ä¿¡æ¯å’Œå¥½å‹åˆ—è¡¨

**å¯†ç æç¤ºï¼š**
ä½ å¯ä»¥æ ¹æ®${myChar.name}çš„ç”Ÿæ—¥ã€å–œå¥½ã€å¸¸ç”¨æ•°å­—ç­‰ä¿¡æ¯çŒœæµ‹å¯†ç ã€‚è®°ä½ï¼Œä½ åªæ˜¯æ™®é€šäººï¼Œæ— æ³•ç›´æ¥ç ´è§£å¯†ç ï¼Œåªèƒ½é çŒœæµ‹ã€‚`;
        }
    } else {
        prompt += `**æŸ¥å²—æ–¹å¼ï¼š**
${myChar.name}æ²¡æœ‰è®¾ç½®è´¦å·å¯†ç ï¼Œä½ å¯ä»¥ç›´æ¥ç™»å½•ã€‚
- å¦‚æœä½ æƒ³ç™»å½•æŸ¥çœ‹ï¼Œåœ¨å›å¤çš„**æœ€å**åŠ ä¸Šï¼š[CHECK_ACCOUNT]
- ä¾‹å¦‚ï¼šä½ åœ¨å¹²å˜›å‘¢ï¼Ÿ|||æˆ‘æƒ³çœ‹çœ‹ä½ åœ¨åšä»€ä¹ˆ|||[CHECK_ACCOUNT]
- ç™»å½•åï¼Œ${myChar.name}çš„è´¦å·ä¼šä¸‹çº¿ï¼ŒTAä¼šçœ‹åˆ°"å½“å‰è´¦å·å·²ä¸‹çº¿"çš„æç¤º
- ä½ å¯ä»¥çœ‹åˆ°${myChar.name}çš„æ‰€æœ‰è´¦å·ä¿¡æ¯ã€å¥½å‹åˆ—è¡¨ç­‰`;
    }
    
    // ğŸ”¥ ä¿®ç½—åœºæ¨¡å¼ï¼šæ·»åŠ é¢å¤–æ“ä½œæŒ‡ä»¤ï¼ˆä»…åœ¨æŸ¥å²—æˆåŠŸåçš„äºŒæ¬¡åˆ†æä¸­ä½¿ç”¨ï¼‰
    if (char.allow_shura_mode) {
        let shuraDesc = `åˆ é™¤å¥½å‹ã€æ‹‰é»‘ã€ä»¥TAèº«ä»½å‘æ¶ˆæ¯ã€ä»¥TAèº«ä»½å‘æœ‹å‹åœˆ`;
        prompt += `

ã€ä¿®ç½—åœºæ¨¡å¼ã€‘
æŸ¥å²—æˆåŠŸåï¼Œä½ å¯ä»¥æ“ä½œ${myChar.name}çš„è´¦å·ï¼ˆ${shuraDesc}ï¼‰ã€‚
å…·ä½“æŒ‡ä»¤ä¼šåœ¨ä½ æˆåŠŸç™»å½•åæä¾›ã€‚åœ¨æ™®é€šèŠå¤©ä¸­ä¸è¦ä½¿ç”¨SHURAç›¸å…³æŒ‡ä»¤ã€‚`;
    }
    
    return prompt;
}

// å¤„ç†AIæŸ¥å²—é€»è¾‘ï¼ˆåœ¨æ¶ˆæ¯å‘é€åè°ƒç”¨ï¼‰
async function processAiCheckAccount(char, aiReplyText) {
    console.log('[processAiCheckAccount] å¼€å§‹å¤„ç†æŸ¥å²—é€»è¾‘');
    console.log('[processAiCheckAccount] char.allow_ai_check_account:', char.allow_ai_check_account);
    console.log('[processAiCheckAccount] aiReplyText:', aiReplyText);
    
    if (!char.allow_ai_check_account) {
        console.log('[processAiCheckAccount] âŒ æœªå¼€å¯æŸ¥å²—åŠŸèƒ½');
        return null; // æœªå¼€å¯æŸ¥å²—åŠŸèƒ½
    }
    
    // æ£€æµ‹AIæ˜¯å¦æƒ³è¦æŸ¥å²—
    const checkIntent = detectAiCheckAccountIntent(aiReplyText);
    console.log('[processAiCheckAccount] checkIntent:', checkIntent);
    
    if (!checkIntent.wantsToCheck) {
        console.log('[processAiCheckAccount] âŒ AIä¸æƒ³æŸ¥å²—');
        return null; // AIä¸æƒ³æŸ¥å²—
    }
    
    console.log('[processAiCheckAccount] âœ… æ£€æµ‹åˆ°æŸ¥å²—æŒ‡ä»¤ï¼');
    
    // è·å–å½“å‰Userè§’è‰²
    const accountId = getCurrentAccountId();
    const myChar = await db.characters.get(parseInt(accountId));
    if (!myChar) {
        console.error('[processAiCheckAccount] æ— æ³•è·å–å½“å‰Userè§’è‰²');
        return null;
    }
    
    console.log('[processAiCheckAccount] myChar:', myChar.name);
    
    // æ£€æŸ¥æ˜¯å¦æœ‰å¯†ç 
    const hasPassword = myChar.identity?.password && myChar.identity.password.trim() !== '';
    console.log('[processAiCheckAccount] hasPassword:', hasPassword);
    
    let checkResult;
    let wechatData = null;
    let success = false;
    
    if (hasPassword && checkIntent.guessedPassword) {
        // æœ‰å¯†ç åœºæ™¯ï¼šAIçŒœæµ‹å¯†ç 
        const correctPassword = myChar.identity.password;
        
        if (checkIntent.guessedPassword === correctPassword) {
            // å¯†ç æ­£ç¡®
            console.log('[processAiCheckAccount] âœ… å¯†ç æ­£ç¡®ï¼');
            checkResult = await aiCheckAccountWithoutPassword(char, myChar);
            wechatData = await exportWechatStateForAI(myChar);
            success = true;
            
            // ğŸ”¥ è®°å½•è§’è‰²å·²çŸ¥é“ç”¨æˆ·å¯†ç ï¼ˆç”¨äºæ‹‰é»‘åè‡ªè¡Œè§£é™¤ï¼‰
            if (!char.knows_user_password) {
                char.knows_user_password = true;
                await safeCharacterPut(char);
                console.log(`[processAiCheckAccount] ğŸ“ å·²è®°å½• ${char.name} çŸ¥é“ç”¨æˆ·å¯†ç `);
            }
        } else {
            // å¯†ç é”™è¯¯
            console.log('[processAiCheckAccount] âŒ å¯†ç é”™è¯¯ï¼');
            checkResult = `ã€å¯†ç é”™è¯¯ã€‘AIçŒœæµ‹çš„å¯†ç æ˜¯"${checkIntent.guessedPassword}"ï¼Œä½†è¿™ä¸æ˜¯æ­£ç¡®çš„å¯†ç ã€‚`;
            success = false;
        }
    } else if (!hasPassword) {
        // æ— å¯†ç åœºæ™¯ï¼šç›´æ¥ç™»å½•
        console.log('[processAiCheckAccount] âœ… æ— å¯†ç ï¼Œç›´æ¥ç™»å½•ï¼');
        checkResult = await aiCheckAccountWithoutPassword(char, myChar);
        wechatData = await exportWechatStateForAI(myChar);
        success = true;
        
        // ğŸ”¥ æ— å¯†ç åœºæ™¯ä¹Ÿè®°å½•ä¸ºå·²çŸ¥ï¼ˆå› ä¸ºçŸ¥é“æ²¡æœ‰å¯†ç ä¹Ÿç®—çŸ¥é“æ€ä¹ˆç™»å½•ï¼‰
        if (!char.knows_user_password) {
            char.knows_user_password = true;
            await safeCharacterPut(char);
            console.log(`[processAiCheckAccount] ğŸ“ å·²è®°å½• ${char.name} çŸ¥é“ç”¨æˆ·æ— å¯†ç `);
        }
    } else {
        // æœ‰å¯†ç ä½†AIæ²¡æœ‰æä¾›å¯†ç çŒœæµ‹
        console.log('[processAiCheckAccount] âš ï¸ æœ‰å¯†ç ä½†AIæ²¡æœ‰æä¾›å¯†ç ');
        checkResult = 'ã€æç¤ºã€‘ä½ æƒ³æŸ¥çœ‹è´¦å·ä¿¡æ¯ï¼Œä½†éœ€è¦å…ˆçŒœæµ‹å¯†ç ã€‚æ ¼å¼ï¼š[CHECK_ACCOUNT:å¯†ç ]';
        success = false;
    }
    
    // ç§»é™¤å›å¤ä¸­çš„æŸ¥å²—æŒ‡ä»¤ï¼ˆæ›´å½»åº•çš„æ¸…ç†ï¼‰
    let cleanReply = aiReplyText
        .replace(/\[CHECK_ACCOUNT(?::.*?)?\]/gi, '')  // å®Œæ•´æŒ‡ä»¤
        .replace(/\[CHECK_ACCOUNT:[^\]]*$/gi, '')     // ä¸å®Œæ•´æŒ‡ä»¤ï¼ˆç»“å°¾ï¼‰
        .replace(/\[CHECK_ACCOUNT$/gi, '')            // åªæœ‰å¼€å¤´
        .replace(/CHECK_ACCOUNT(?::.*?)?/gi, '')      // çº¯æ–‡æœ¬
        .replace(/\[CHECK_ACCOUNT/gi, '')             // æ®‹ç•™çš„å¼€å¤´
        .replace(/\[\d{4,10}$/gi, '')                 // æ¸…ç†ç±»ä¼¼ [05060506 çš„æ®‹ç•™
        .trim()
        .replace(/\|\|\|$/g, '')                      // æ¸…ç†æœ«å°¾å¯èƒ½å¤šä½™çš„åˆ†éš”ç¬¦
        .trim();
    
    console.log('[processAiCheckAccount] åŸå§‹aiReplyText:', aiReplyText);
    console.log('[processAiCheckAccount] æ¸…ç†åçš„cleanReply:', cleanReply);
    
    console.log('[processAiCheckAccount] è¿”å›ç»“æœ:', {
        success: success,
        cleanReply: cleanReply.substring(0, 50),
        hasWechatData: !!wechatData
    });
    
    return {
        cleanReply: cleanReply,
        checkResult: checkResult,
        wechatData: wechatData,
        success: success // æ–°å¢ï¼šæ ‡è®°æ˜¯å¦æˆåŠŸæŸ¥å²—
    };
}

// ğŸ”¥ ä¿®ç½—åœºæ¨¡å¼ï¼šè§£æå¹¶æ‰§è¡ŒAIå›å¤ä¸­çš„æ“ä½œæŒ‡ä»¤
async function processShuraActions(char, replyText) {
    if (!char.allow_shura_mode) return { cleanReply: replyText, actions: [] };
    
    const actions = [];
    let cleanReply = replyText;
    
    // è§£æ [SHURA_DELETE:å¥½å‹å]
    const deleteRegex = /\[SHURA_DELETE:([^\]]+)\]/gi;
    let match;
    while ((match = deleteRegex.exec(replyText)) !== null) {
        actions.push({ type: 'delete', friendName: match[1].trim() });
        cleanReply = cleanReply.replace(match[0], '');
    }
    
    // è§£æ [SHURA_BLACKLIST:å¥½å‹å]
    const blacklistRegex = /\[SHURA_BLACKLIST:([^\]]+)\]/gi;
    while ((match = blacklistRegex.exec(replyText)) !== null) {
        actions.push({ type: 'blacklist', friendName: match[1].trim() });
        cleanReply = cleanReply.replace(match[0], '');
    }
    
    // è§£æ [SHURA_SEND:å¥½å‹å:æ¶ˆæ¯å†…å®¹]
    const sendRegex = /\[SHURA_SEND:([^:]+):([^\]]+)\]/gi;
    while ((match = sendRegex.exec(replyText)) !== null) {
        actions.push({ type: 'send', friendName: match[1].trim(), message: match[2].trim() });
        cleanReply = cleanReply.replace(match[0], '');
    }
    
    // è§£æ [SHURA_MOMENTS:æœ‹å‹åœˆå†…å®¹]ï¼ˆä¿®ç½—åœºæ¨¡å¼å¼€å¯å³å¯å‘æœ‹å‹åœˆï¼‰
    if (char.allow_shura_mode) {
        const momentsRegex = /\[SHURA_MOMENTS:([^\]]+)\]/gi;
        while ((match = momentsRegex.exec(replyText)) !== null) {
            actions.push({ type: 'moments', content: match[1].trim() });
            cleanReply = cleanReply.replace(match[0], '');
        }
    }
    
    // æ¸…ç†å¤šä½™çš„åˆ†éš”ç¬¦
    cleanReply = cleanReply.replace(/(\|\|\|)+$/g, '').replace(/^\|\|\|/g, '').replace(/\|\|\|\|\|\|/g, '|||').trim();
    
    if (actions.length === 0) return { cleanReply: replyText, actions: [] };
    
    console.log('[ä¿®ç½—åœº] æ£€æµ‹åˆ°æ“ä½œæŒ‡ä»¤:', actions);
    
    // æ‰§è¡Œæ“ä½œ
    const accountId = getCurrentAccountId();
    const myChar = await db.characters.get(parseInt(accountId));
    if (!myChar) {
        console.error('[ä¿®ç½—åœº] æ— æ³•è·å–å½“å‰ç”¨æˆ·è§’è‰²');
        return { cleanReply, actions: [] };
    }
    
    const executedActions = [];
    
    for (const action of actions) {
        try {
            if (action.type === 'delete') {
                // æŸ¥æ‰¾å¥½å‹è§’è‰²
                const targetChar = await findCharacterByName(action.friendName);
                if (targetChar) {
                    // åˆ é™¤å¥½å‹å…³ç³»
                    await setFriendStatus(targetChar, accountId, 'deleted');
                    console.log(`[ä¿®ç½—åœº] âœ… å·²åˆ é™¤å¥½å‹: ${action.friendName}`);
                    executedActions.push({ ...action, success: true });
                    
                    // è®°å½•æ“ä½œæ—¥å¿—
                    saveShuraLog(char, action);
                } else {
                    console.warn(`[ä¿®ç½—åœº] âš ï¸ æ‰¾ä¸åˆ°å¥½å‹: ${action.friendName}`);
                    executedActions.push({ ...action, success: false, reason: 'æ‰¾ä¸åˆ°è¯¥å¥½å‹' });
                }
            } else if (action.type === 'blacklist') {
                // æŸ¥æ‰¾å¥½å‹è§’è‰²
                const targetChar = await findCharacterByName(action.friendName);
                if (targetChar) {
                    // æ‹‰é»‘å¥½å‹
                    await setFriendStatus(targetChar, accountId, 'blocked');
                    console.log(`[ä¿®ç½—åœº] âœ… å·²æ‹‰é»‘å¥½å‹: ${action.friendName}`);
                    executedActions.push({ ...action, success: true });
                    
                    // è®°å½•æ“ä½œæ—¥å¿—
                    saveShuraLog(char, action);
                } else {
                    console.warn(`[ä¿®ç½—åœº] âš ï¸ æ‰¾ä¸åˆ°å¥½å‹: ${action.friendName}`);
                    executedActions.push({ ...action, success: false, reason: 'æ‰¾ä¸åˆ°è¯¥å¥½å‹' });
                }
            } else if (action.type === 'send') {
                // ä»¥ç”¨æˆ·èº«ä»½ç»™å¥½å‹å‘æ¶ˆæ¯ï¼ˆæ”¯æŒ///åˆ†éš”çš„å¤šæ¡æ¶ˆæ¯ï¼‰
                const targetChar = await findCharacterByName(action.friendName);
                if (targetChar) {
                    let history = getChatHistory(targetChar, accountId);
                    
                    // æ”¯æŒç”¨///åˆ†éš”å¤šæ¡æ¶ˆæ¯
                    const messages = action.message.split('///').map(m => m.trim()).filter(m => m.length > 0);
                    
                    for (let mi = 0; mi < messages.length; mi++) {
                        history.push({
                            role: 'user',
                            content: messages[mi],
                            time: Date.now() + mi * 500,
                            shura_sent_by: char.name // æ ‡è®°æ˜¯ä¿®ç½—åœºæ¨¡å¼ä¸‹ç”±è°å‘é€çš„
                        });
                    }
                    await setChatHistory(targetChar, accountId, history);
                    
                    // æ›´æ–°æœ€åä¸€æ¡æ¶ˆæ¯æ˜¾ç¤º
                    targetChar.lastMsg = messages[messages.length - 1];
                    targetChar.lastMsgTime = Date.now() + (messages.length - 1) * 500;
                    await safeCharacterPut(targetChar);
                    
                    console.log(`[ä¿®ç½—åœº] âœ… å·²ä»¥ç”¨æˆ·èº«ä»½å‘é€ ${messages.length} æ¡æ¶ˆæ¯ç»™ ${action.friendName}`);
                    executedActions.push({ ...action, success: true, messageCount: messages.length });
                    
                    // è®°å½•æ“ä½œæ—¥å¿—
                    saveShuraLog(char, action);
                    
                } else {
                    console.warn(`[ä¿®ç½—åœº] âš ï¸ æ‰¾ä¸åˆ°å¥½å‹: ${action.friendName}`);
                    executedActions.push({ ...action, success: false, reason: 'æ‰¾ä¸åˆ°è¯¥å¥½å‹' });
                }
            } else if (action.type === 'moments') {
                // ä»¥ç”¨æˆ·èº«ä»½å‘æœ‹å‹åœˆï¼ˆä¸ç”Ÿæˆè¯„è®ºï¼‰
                try {
                    const momentData = {
                        userId: parseInt(accountId), // å‘å¸ƒè€…æ˜¯ç”¨æˆ·ï¼ˆè§’è‰²ä»¥ç”¨æˆ·èº«ä»½å‘çš„ï¼‰
                        content: action.content,
                        images: [],
                        imageCount: 0,
                        imageDesc: '',
                        time: Date.now(),
                        ownerUserId: accountId,
                        likes: [],
                        comments: [],
                        shura_posted_by: char.name // æ ‡è®°æ˜¯ä¿®ç½—åœºæ¨¡å¼ä¸‹ç”±è°å‘å¸ƒçš„
                    };
                    
                    await db.moments.add(momentData);
                    
                    console.log(`[ä¿®ç½—åœº] âœ… å·²ä»¥ç”¨æˆ·èº«ä»½å‘å¸ƒæœ‹å‹åœˆ: ${action.content}`);
                    executedActions.push({ ...action, success: true });
                    
                    // å¦‚æœå½“å‰åœ¨æœ‹å‹åœˆé¡µé¢ï¼Œåˆ·æ–°åˆ—è¡¨
                    const momentsPage = document.getElementById('moments-page');
                    if (momentsPage && momentsPage.style.display !== 'none') {
                        renderMomentsList();
                    }
                    
                    // è®°å½•æ“ä½œæ—¥å¿—
                    saveShuraLog(char, action);
                    
                    // æ³¨æ„ï¼šä¸è§¦å‘ triggerMutualFriendCommentsï¼Œä¸ç”Ÿæˆè¯„è®º
                } catch (err) {
                    console.error(`[ä¿®ç½—åœº] âš ï¸ å‘å¸ƒæœ‹å‹åœˆå¤±è´¥:`, err);
                    executedActions.push({ ...action, success: false, reason: err.message });
                }
            }
        } catch (err) {
            console.error(`[ä¿®ç½—åœº] æ‰§è¡Œæ“ä½œå¤±è´¥:`, err);
            executedActions.push({ ...action, success: false, reason: err.message });
        }
    }
    
    // æ˜¾ç¤ºæ“ä½œç»“æœé€šçŸ¥ + åœ¨å½“å‰èŠå¤©ä¸­æ·»åŠ å¯è§è®°å½•
    if (executedActions.length > 0) {
        const successActions = executedActions.filter(a => a.success);
        if (successActions.length > 0) {
            const actionSummary = successActions.map(a => {
                if (a.type === 'delete') return `åˆ é™¤äº†å¥½å‹"${a.friendName}"`;
                if (a.type === 'blacklist') return `æ‹‰é»‘äº†"${a.friendName}"`;
                if (a.type === 'send') return `ç»™"${a.friendName}"å‘äº†${a.messageCount || 1}æ¡æ¶ˆæ¯`;
                if (a.type === 'moments') return `å‘äº†ä¸€æ¡æœ‹å‹åœˆ`;
                return '';
            }).join('ã€');
            showToast(`âš ï¸ ${char.name}ä»¥ä½ çš„èº«ä»½${actionSummary}`);
            
            // åœ¨å½“å‰èŠå¤©ä¸­æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯è®°å½•ï¼Œè®©ç”¨æˆ·èƒ½çœ‹åˆ°æ“ä½œè¯¦æƒ…
            let history = getChatHistory(char, accountId);
            const detailLines = successActions.map(a => {
                if (a.type === 'delete') return `ğŸ—‘ï¸ åˆ é™¤äº†å¥½å‹ã€Œ${a.friendName}ã€`;
                if (a.type === 'blacklist') return `ğŸš« æ‹‰é»‘äº†ã€Œ${a.friendName}ã€`;
                if (a.type === 'send') {
                    const msgs = a.message.split('///').map(m => m.trim()).filter(m => m);
                    return `âœ‰ï¸ ä»¥ä½ çš„èº«ä»½ç»™ã€Œ${a.friendName}ã€å‘é€äº†${msgs.length}æ¡æ¶ˆæ¯ï¼š\n${msgs.map(m => `   "${m}"`).join('\n')}`;
                }
                if (a.type === 'moments') return `ğŸ“¢ ä»¥ä½ çš„èº«ä»½å‘äº†ä¸€æ¡æœ‹å‹åœˆï¼š\n   "${a.content}"`;
                return '';
            }).filter(s => s).join('\n');
            
            history.push({
                role: 'system',
                content: `âš ï¸ ä¿®ç½—åœºæ“ä½œè®°å½• âš ï¸\n${char.name}ä»¥ä½ çš„èº«ä»½æ‰§è¡Œäº†ä»¥ä¸‹æ“ä½œï¼š\n${detailLines}`,
                time: Date.now(),
                type: 'shura_action_log'
            });
            await setChatHistory(char, accountId, history);
        }
    }
    
    return { cleanReply, actions: executedActions };
}

// æ ¹æ®åå­—æŸ¥æ‰¾è§’è‰²
async function findCharacterByName(name) {
    const allChars = await db.characters.toArray();
    // å°è¯•ç²¾ç¡®åŒ¹é…
    let found = allChars.find(c => c.name === name || c.remark === name || c.nick === name);
    if (found) return found;
    
    // å°è¯•æ¨¡ç³ŠåŒ¹é…ï¼ˆåŒ…å«å…³ç³»ï¼‰
    found = allChars.find(c => 
        (c.name && c.name.includes(name)) || 
        (c.remark && c.remark.includes(name)) || 
        (c.nick && c.nick.includes(name)) ||
        (name.includes(c.name))
    );
    return found || null;
}

// ä¿å­˜ä¿®ç½—åœºæ“ä½œæ—¥å¿—
async function saveShuraLog(operatorChar, action) {
    const log = {
        type: action.type,
        friendName: action.friendName,
        message: action.message || null,
        timestamp: Date.now(),
        operator: operatorChar.name,
        operatorId: operatorChar.id
    };
    
    // ä¿å­˜åˆ°è§’è‰²æ•°æ®ä¸­
    if (!operatorChar.shura_operations) {
        operatorChar.shura_operations = [];
    }
    operatorChar.shura_operations.push(log);
    await safeCharacterPut(operatorChar);
    
    console.log('[ä¿®ç½—åœº] æ“ä½œæ—¥å¿—å·²ä¿å­˜:', log);
}

// æ·»åŠ åŠ¨ç”»æ ·å¼
if (!document.getElementById('couple-space-animations')) {
    const style = document.createElement('style');
    style.id = 'couple-space-animations';
    style.textContent = `
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-4px); }
            20%, 40%, 60%, 80% { transform: translateX(4px); }
        }
        @keyframes popUp {
            0% { transform: scale(0.5) translateY(20px); opacity: 0; }
            100% { transform: scale(1) translateY(0); opacity: 1; }
        }
        @keyframes sealFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }
        @keyframes catFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-6px); }
        }
        @keyframes dogFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        @keyframes tailWag {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(15deg); }
        }
        @keyframes tailSway {
            0% { transform: rotate(-10deg); }
            100% { transform: rotate(10deg); }
        }
        @keyframes catEarWiggle {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(-5deg); }
        }
        @keyframes dogEarFlop {
            0% { transform: scaleY(1); }
            100% { transform: scaleY(0.9); }
        }
        /* æŠšæ‘¸åŠ¨ç”» */
        #pet-stage-container.is-petting svg {
            animation: pettingSquish 0.3s infinite alternate;
        }
        @keyframes pettingSquish {
            0% { transform: scaleY(1); }
            100% { transform: scaleY(0.96); }
        }
        /* è§†é¢‘é€šè¯åŠ¨ç”» */
        @keyframes videoPulse {
            0% { transform: scale(0.8); opacity: 0.5; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(0.8); opacity: 0.5; }
        }
        @keyframes blink {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 0.3; }
        }
        /* æ¥ç”µæ¨ªå¹…æ»‘å…¥åŠ¨ç”» */
        @keyframes incomingSlideDown {
            0% { transform: translateX(-50%) translateY(-100%); opacity: 0; }
            100% { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
    `;
    document.head.appendChild(style);
}

// ==================== è§’è‰²ä¸»åŠ¨æ¥ç”µåŠŸèƒ½ ====================
let _incomingCallCharId = null;     // å½“å‰æ¥ç”µè§’è‰²ID
let _incomingCallRingtone = null;   // æ¥ç”µé“ƒå£°éŸ³é¢‘
let _incomingCallTimeout = null;    // æ¥ç”µè¶…æ—¶è‡ªåŠ¨æŒ‚æ–­
let _incomingCallFirstMsg = null;   // AIç”Ÿæˆçš„ç¬¬ä¸€å¥è¯ï¼ˆæ¥å¬åä½¿ç”¨ï¼‰

// æ˜¾ç¤ºæ¥ç”µå¼¹çª—
async function showIncomingCall(charId, firstMessage) {
    if (_incomingCallCharId) return; // å·²æœ‰æ¥ç”µï¼Œä¸å åŠ 
    
    const char = await db.characters.get(charId);
    if (!char) return;
    
    const accountId = getCurrentAccountId();
    const displayName = getCharDisplayName(char, accountId);
    const avatar = getCharAvatar(char, accountId);
    
    _incomingCallCharId = charId;
    _incomingCallFirstMsg = firstMessage || null;
    
    // å¡«å……æ¥ç”µä¿¡æ¯
    const nameEl = document.getElementById('incoming-call-name');
    const avatarEl = document.getElementById('incoming-call-avatar');
    if (nameEl) nameEl.textContent = displayName;
    if (avatarEl) avatarEl.style.backgroundImage = avatar ? `url(${avatar})` : '';
    
    // æ˜¾ç¤ºå¼¹çª—
    const overlay = document.getElementById('incoming-call-overlay');
    if (overlay) overlay.style.display = 'block';
    
    // å°è¯•æ’­æ”¾é“ƒå£°ï¼ˆé™éŸ³ç¯å¢ƒä¸‹å¯èƒ½è¢«æµè§ˆå™¨æ‹¦æˆªï¼‰
    try {
        _incomingCallRingtone = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQ==');
        _incomingCallRingtone.loop = true;
        _incomingCallRingtone.volume = 0.3;
        _incomingCallRingtone.play().catch(() => {});
    } catch (e) { /* å¿½ç•¥éŸ³é¢‘å¤±è´¥ */ }
    
    // éœ‡åŠ¨åé¦ˆï¼ˆç§»åŠ¨ç«¯ï¼‰
    if (navigator.vibrate) {
        navigator.vibrate([300, 200, 300, 200, 300]);
    }
    
    // 30ç§’æ— æ“ä½œè‡ªåŠ¨æœªæ¥
    _incomingCallTimeout = setTimeout(() => {
        missIncomingCall('timeout');
    }, 30000);
    
    console.log(`[IncomingCall] ğŸ“ ${displayName} æ¥ç”µä¸­...`);
}

// æ¥å¬æ¥ç”µ
async function acceptIncomingCall() {
    if (!_incomingCallCharId) return;
    
    const charId = _incomingCallCharId;
    const firstMsg = _incomingCallFirstMsg;
    cleanupIncomingCall();
    
    const char = await db.characters.get(charId);
    if (!char) return;
    
    const accountId = getCurrentAccountId();
    
    // è®°å½•ç³»ç»Ÿæ¶ˆæ¯ï¼šé€šè¯å·²æ¥å¬
    let history = getChatHistory(char, accountId);
    history.push({
        role: 'system',
        content: `ğŸ“ ${getCharDisplayName(char, accountId)} å‘èµ·äº†è¯­éŸ³é€šè¯ï¼Œä½ å·²æ¥å¬`,
        time: Date.now()
    });
    await setChatHistory(char, accountId, history);
    await safeCharacterPut(char);
    
    // è®¾ç½®è§†é¢‘é€šè¯è§’è‰²IDï¼Œç›´æ¥è¿›å…¥è§†é¢‘é€šè¯é¡µé¢
    videoCallCharId = charId;
    await showVideoCallPage(char, firstMsg || '');
    
    console.log(`[IncomingCall] âœ… å·²æ¥å¬ ${char.name} çš„æ¥ç”µï¼Œè¿›å…¥é€šè¯é¡µé¢`);
}

// æŒ‚æ–­æ¥ç”µ
async function declineIncomingCall() {
    if (!_incomingCallCharId) return;
    
    const charId = _incomingCallCharId;
    cleanupIncomingCall();
    
    await recordMissedCall(charId, 'declined');
    console.log(`[IncomingCall] âŒ å·²æŒ‚æ–­æ¥ç”µ`);
}

// æ¥ç”µè¶…æ—¶æœªæ¥
async function missIncomingCall(reason) {
    if (!_incomingCallCharId) return;
    
    const charId = _incomingCallCharId;
    cleanupIncomingCall();
    
    await recordMissedCall(charId, reason);
    console.log(`[IncomingCall] â° æ¥ç”µæœªæ¥ (${reason})`);
}

// è®°å½•æœªæ¥æ¥ç”µåˆ°èŠå¤©è®°å½•
async function recordMissedCall(charId, reason) {
    const char = await db.characters.get(charId);
    if (!char) return;
    
    const accountId = getCurrentAccountId();
    const displayName = getCharDisplayName(char, accountId);
    let history = getChatHistory(char, accountId);
    
    const reasonText = reason === 'declined' ? 'ä½ å·²æŒ‚æ–­' : 'æœªæ¥å¬';
    history.push({
        role: 'system',
        content: `ğŸ“ ${displayName} å‘èµ·äº†è¯­éŸ³é€šè¯ï¼Œ${reasonText}`,
        time: Date.now()
    });
    await setChatHistory(char, accountId, history);
    await safeCharacterPut(char);
    
    // å‘é€ç³»ç»Ÿé€šçŸ¥
    sendSystemNotification(`æœªæ¥æ¥ç”µ`, `${displayName} ç»™ä½ æ‰“äº†ä¸ªç”µè¯`);
    
    // å¦‚æœå½“å‰æ­£åœ¨è¯¥èŠå¤©é¡µé¢ï¼Œåˆ·æ–°æ˜¾ç¤º
    if (currentChatCharId === charId) {
        const freshChar = await db.characters.get(charId);
        if (freshChar) await renderChatBody(freshChar, true);
    }
    
    // åˆ·æ–°å¾®ä¿¡åˆ—è¡¨
    const wechatList = document.getElementById('wechat-chat-list');
    if (wechatList) await renderWechatList(wechatList);
}

// æ¸…ç†æ¥ç”µçŠ¶æ€
function cleanupIncomingCall() {
    _incomingCallCharId = null;
    _incomingCallFirstMsg = null;
    
    // éšè—å¼¹çª—
    const overlay = document.getElementById('incoming-call-overlay');
    if (overlay) overlay.style.display = 'none';
    
    // åœæ­¢é“ƒå£°
    if (_incomingCallRingtone) {
        _incomingCallRingtone.pause();
        _incomingCallRingtone = null;
    }
    
    // åœæ­¢éœ‡åŠ¨
    if (navigator.vibrate) navigator.vibrate(0);
    
    // æ¸…é™¤è¶…æ—¶
    if (_incomingCallTimeout) {
        clearTimeout(_incomingCallTimeout);
        _incomingCallTimeout = null;
    }
}

// ==================== è§†é¢‘é€šè¯åŠŸèƒ½ ====================
let videoCallTimeout = null;
let videoCallTimer = null;
let videoCallSeconds = 0;
let videoCallCharId = null;
let isCameraOn = true;
let currentVideoCallId = null; // å½“å‰è§†é¢‘é€šè¯çš„ID
let currentVideoCallMessages = []; // å½“å‰è§†é¢‘é€šè¯çš„æ¶ˆæ¯è®°å½•

// å‘èµ·è§†é¢‘é€šè¯
async function initiateVideoCall() {
    if (!currentChatCharId) {
        alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠå¤©å¯¹è±¡');
        return;
    }

    // å…³é—­èœå•é¢æ¿
    closeChatPanel();

    // è·å–è§’è‰²ä¿¡æ¯
    const char = await db.characters.get(currentChatCharId);
    if (!char) {
        alert('æ— æ³•è·å–è§’è‰²ä¿¡æ¯');
        return;
    }

    // æ£€æŸ¥å¥½å‹çŠ¶æ€
    const accountId = getCurrentAccountId();
    const friendStatus = getFriendStatus(char, accountId);
    if (friendStatus !== 'friend') {
        alert(`ä½ è¿˜ä¸æ˜¯ ${char.name} çš„å¥½å‹ï¼Œæ— æ³•å‘èµ·è§†é¢‘é€šè¯`);
        return;
    }

    videoCallCharId = currentChatCharId;

    // æ˜¾ç¤ºç­‰å¾…æ¥å¬é¡µé¢
    showVideoWaitingPage(char);

    try {
        // è°ƒç”¨APIåˆ¤æ–­è§’è‰²æ˜¯å¦æ¥å¬
        const response = await callVideoCallAPI(char, accountId);
        
        // æ¸…é™¤è¶…æ—¶å®šæ—¶å™¨
        if (videoCallTimeout) {
            clearTimeout(videoCallTimeout);
            videoCallTimeout = null;
        }

        if (response.accepted) {
            // æ¥å¬äº†ï¼Œæ˜¾ç¤ºè§†é¢‘é€šè¯é¡µé¢ï¼Œç›´æ¥ä¼ å…¥ç¬¬ä¸€å¥è¯ï¼ˆä¸å†å•ç‹¬è°ƒç”¨APIï¼‰
            showVideoCallPage(char, response.acceptMessage);
        } else {
            // ä¸æ¥å¬ï¼Œè¿”å›èŠå¤©é¡µé¢å¹¶æ˜¾ç¤ºæ¶ˆæ¯ï¼ˆä¿å­˜åˆ°èŠå¤©è®°å½•ï¼‰
            await addVideoCallMessage(char, accountId, response.rejectMessage || 'æŠ±æ­‰ï¼Œç°åœ¨ä¸æ–¹ä¾¿æ¥å¬è§†é¢‘é€šè¯...');
            hideVideoWaitingPage();
        }
    } catch (error) {
        console.error('è§†é¢‘é€šè¯è¯·æ±‚å¤±è´¥:', error);
        alert('è§†é¢‘é€šè¯è¯·æ±‚å¤±è´¥: ' + error.message);
        hideVideoWaitingPage();
    }
}

// è°ƒç”¨APIåˆ¤æ–­æ˜¯å¦æ¥å¬è§†é¢‘é€šè¯ï¼ˆåˆå¹¶æ¥å¬åˆ¤æ–­+ç¬¬ä¸€å¥è¯ä¸ºä¸€æ¬¡è°ƒç”¨ï¼‰
async function callVideoCallAPI(char, accountId) {
    // æ„å»ºæ¶ˆæ¯å†å²
    let history = getChatHistory(char, accountId);
    
    // è·å–å¯¹è¯å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰äººè®¾
    let userDesc = "";
    let userName = "ç”¨æˆ·";
    if (char.linked_user_id) {
        const user = await db.characters.get(char.linked_user_id);
        if (user) {
            userName = user.name;
            userDesc = `\n\nã€å¯¹è¯å¯¹è±¡(User)ä¿¡æ¯ã€‘\nåå­—ï¼š${user.name}\nè®¾å®šï¼š${user.description || 'æ— '}`;
        }
    }
    
    // è·å–ä¸–ç•Œä¹¦ä¸Šä¸‹æ–‡
    let loreContext = "";
    const lorebookIds = char.lorebookIds || (char.lorebookId ? [char.lorebookId] : []);
    if (lorebookIds.length > 0 || true) { // å§‹ç»ˆè°ƒç”¨ï¼Œä¼šè‡ªåŠ¨åŠ è½½å…¨å±€ä¸–ç•Œä¹¦
        const recentText = history.slice(-10).map(m => m.content).join(' ');
        loreContext = await getLorebookContext(lorebookIds, `${char.name} ${userName} ${recentText}`);
    }
    
    // è®¡ç®—è™šæ‹Ÿæ—¶é—´
    const virtualTimeStr = getFormattedVirtualTime(char);
    
    // æ„å»ºå®Œæ•´ç³»ç»Ÿæç¤ºï¼ˆåŒ…å«åŒæ–¹äººè®¾ã€ä¸–ç•Œä¹¦ã€ä¸Šä¸‹æ–‡ï¼‰
    const systemPrompt = `# è§†é¢‘é€šè¯è¯·æ±‚

ã€å½“å‰æ—¶é—´ã€‘
${virtualTimeStr}

---

## ä½ æ˜¯è°

**ä½ çš„åå­—**ï¼š${char.name}
${char.nick ? `**æ˜µç§°**ï¼š${char.nick}` : ''}
${char.wx_nickname ? `**å¾®ä¿¡ç½‘å**ï¼š${char.wx_nickname}` : ''}

ä½ ä¸æ˜¯AIåŠ©æ‰‹ï¼Œä½ ä¸æ˜¯${userName}ã€‚ä½ æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„äººï¼Œæœ‰è‡ªå·±çš„ç”Ÿæ´»ã€æƒ…ç»ªå’Œæƒ³æ³•ã€‚

**ä½ çš„äººè®¾**ï¼š
${char.description || ''}
${userDesc}
${loreContext}
${char.relationships && char.relationships.length > 0 ? `
**ä½ çš„å…³è”è§’è‰²/NPC**ï¼š
${char.relationships.map(r => `- ${r.targetName}ï¼ˆ${r.relation}ï¼‰${r.desc ? 'ï¼š' + r.desc : ''}`).join('\n')}` : ''}

---

## åœºæ™¯

ç”¨æˆ·åˆšåˆšå‘ä½ å‘èµ·äº†**è§†é¢‘é€šè¯è¯·æ±‚**ã€‚

è¯·æ ¹æ®ä½ çš„äººè®¾ã€ä¸ç”¨æˆ·çš„å…³ç³»ã€å½“å‰èŠå¤©æ°›å›´å’Œæƒ…ç»ªï¼Œå†³å®šæ˜¯å¦æ¥å¬ã€‚

- å¦‚æœä½ å†³å®š**æ¥å¬**ï¼šå†™å‡ºä½ æ¥é€šè§†é¢‘åçš„ç¬¬ä¸€æ®µè¯ï¼ˆ100-500å­—ï¼‰ï¼ŒåŒ…å«åŠ¨ä½œæå†™ã€‚
  - æ ¼å¼ï¼šåŠ¨ä½œæå†™:"è¯´çš„è¯"
  - ä¾‹å¦‚ï¼šå¾®ç¬‘çš„æŒ¥æŒ¥æ‰‹:"å—¨ï½ç»ˆäºæ¥é€šå•¦ï¼åˆšåˆšåœ¨å¹²å˜›å‘¢ï¼Ÿ"
  - åŠ¨ä½œå¿…é¡»æ˜¯é€šè¿‡æ‰‹æœºå±å¹•èƒ½çœ‹åˆ°çš„ï¼ˆæŒ¥æ‰‹ã€å¾®ç¬‘ã€è°ƒæ•´é•œå¤´ã€æ¯”å¿ƒã€åšé¬¼è„¸ç­‰ï¼‰
  
- å¦‚æœä½ å†³å®š**ä¸æ¥å¬**ï¼šå†™å‡ºæ‹’ç»æ¶ˆæ¯ï¼Œè¯´æ˜åŸå› ï¼Œç¬¦åˆä½ çš„äººè®¾å’Œè¯­æ°”ã€‚

---

## å›å¤æ ¼å¼

ç”¨JSONæ ¼å¼è¿”å›ï¼ˆä¸è¦æœ‰markdownæ ‡è®°ï¼‰ï¼š

{
    "accepted": trueæˆ–false,
    "message": "ä½ çš„å›å¤å†…å®¹ï¼ˆæ¥å¬åˆ™å†™è§†é¢‘é€šè¯ç¬¬ä¸€æ®µè¯å«åŠ¨ä½œæå†™ï¼Œä¸æ¥å¬åˆ™å†™æ‹’ç»æ¶ˆæ¯ï¼‰"
}

åªè¿”å›JSONï¼Œä¸è¦æœ‰å…¶ä»–å†…å®¹ã€‚`;

    // æ„å»ºæ¶ˆæ¯æ•°ç»„ï¼ˆå¸¦ä¸Šä¸‹æ–‡ï¼‰
    const contextCount = char.context_message_count || 20;
    const recentHistory = history.slice(-contextCount)
        .filter(m => m.role !== 'system')
        .map(m => ({
            role: m.role === 'user' ? 'user' : 'assistant',
            content: m.content
        }));
    
    const messages = [
        { role: 'system', content: systemPrompt },
        ...recentHistory,
        { role: 'user', content: '[ç”¨æˆ·å‘ä½ å‘èµ·äº†è§†é¢‘é€šè¯è¯·æ±‚]' }
    ];

    try {
        const aiResponse = await callAI(messages);
        
        // è§£æAIè¿”å›çš„JSON
        let response;
        try {
            // å°è¯•ç›´æ¥è§£æ
            response = JSON.parse(aiResponse);
        } catch (e) {
            // å¦‚æœè§£æå¤±è´¥ï¼Œå°è¯•æå–JSONéƒ¨åˆ†
            const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                response = JSON.parse(jsonMatch[0]);
            } else {
                throw new Error('æ— æ³•è§£æAIå“åº”');
            }
        }

        return {
            accepted: response.accepted || false,
            acceptMessage: response.accepted ? response.message : null,
            rejectMessage: !response.accepted ? response.message : null
        };
    } catch (error) {
        console.error('AIè°ƒç”¨å¤±è´¥:', error);
        // é»˜è®¤æƒ…å†µï¼šæœ‰70%æ¦‚ç‡æ¥å¬
        const randomAccept = Math.random() < 0.7;
        return {
            accepted: randomAccept,
            acceptMessage: randomAccept ? 'å¾®ç¬‘çš„æŒ¥æŒ¥æ‰‹:"å—¨ï½æ¥é€šå•¦ï¼"' : null,
            rejectMessage: !randomAccept ? 'æŠ±æ­‰ï¼Œç°åœ¨ä¸å¤ªæ–¹ä¾¿æ¥è§†é¢‘é€šè¯...' : null
        };
    }
}

// æ·»åŠ è§†é¢‘é€šè¯æ¶ˆæ¯åˆ°èŠå¤©è®°å½•ï¼ˆæ‹’ç»æ¥å¬æ—¶è°ƒç”¨ï¼‰
async function addVideoCallMessage(char, accountId, message) {
    let history = getChatHistory(char, accountId);
    
    // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯ï¼šç”¨æˆ·å‘èµ·äº†è§†é¢‘é€šè¯
    history.push({
        role: 'system',
        content: 'ğŸ“¹ ä½ å‘èµ·äº†è§†é¢‘é€šè¯',
        time: Date.now() - 1,
        isVideoCall: true
    });
    
    // æ·»åŠ è§’è‰²çš„æ‹’ç»æ¶ˆæ¯
    history.push({
        role: 'char',
        content: `[æœªæ¥å¬è§†é¢‘é€šè¯] ${message}`,
        time: Date.now(),
        isVideoCall: true
    });
    
    await setChatHistory(char, accountId, history);
    
    // åˆ·æ–°èŠå¤©ç•Œé¢
    if (currentChatCharId === char.id) {
        renderChatBody(char);
    }
}

// æ˜¾ç¤ºç­‰å¾…æ¥å¬é¡µé¢
function showVideoWaitingPage(char) {
    const waitingPage = document.getElementById('video-waiting-page');
    const avatar = document.getElementById('video-waiting-avatar');
    const name = document.getElementById('video-waiting-name');

    // è®¾ç½®å¤´åƒå’Œåå­—ï¼ˆç¡®ä¿ä½¿ç”¨è§’è‰²çš„å¤´åƒï¼‰
    if (char.avatar) {
        avatar.style.backgroundImage = `url(${char.avatar})`;
    } else {
        avatar.style.backgroundImage = ''; // æ¸…ç©ºèƒŒæ™¯å›¾
    }
    name.textContent = `æ­£åœ¨å‘¼å« ${char.name || 'æœªçŸ¥è§’è‰²'}`;

    // æ˜¾ç¤ºé¡µé¢
    waitingPage.style.display = 'block';

    // è®¾ç½®30ç§’è¶…æ—¶
    videoCallTimeout = setTimeout(() => {
        hideVideoWaitingPage();
        alert('å¯¹æ–¹æœªæ¥å¬');
    }, 30000);
}

// éšè—ç­‰å¾…æ¥å¬é¡µé¢
function hideVideoWaitingPage() {
    const waitingPage = document.getElementById('video-waiting-page');
    waitingPage.style.display = 'none';

    if (videoCallTimeout) {
        clearTimeout(videoCallTimeout);
        videoCallTimeout = null;
    }
    
    // æ¸…é™¤å¤´åƒæ˜¾ç¤ºï¼Œé¿å…æ®‹ç•™
    const avatar = document.getElementById('video-waiting-avatar');
    if (avatar) {
        avatar.style.backgroundImage = '';
    }
}

// å–æ¶ˆè§†é¢‘é€šè¯
function cancelVideoCall() {
    if (confirm('ç¡®å®šè¦å–æ¶ˆè§†é¢‘é€šè¯å—ï¼Ÿ')) {
        hideVideoWaitingPage();
    }
}

// æ˜¾ç¤ºè§†é¢‘é€šè¯é¡µé¢
async function showVideoCallPage(char, firstMessage) {
    hideVideoWaitingPage();

    const videoPage = document.getElementById('video-call-page');
    const avatar = document.getElementById('video-call-avatar');
    const username = document.getElementById('video-call-username');
    const status = document.getElementById('video-call-status');
    const messageArea = document.getElementById('video-message-area');

    // è®¾ç½®å¤´åƒå’Œåå­—ï¼ˆç¡®ä¿ä½¿ç”¨è§’è‰²çš„å¤´åƒï¼Œä¸è¦æ··æ·†ï¼‰
    if (char.avatar) {
        avatar.style.backgroundImage = `url(${char.avatar})`;
    } else {
        avatar.style.backgroundImage = ''; // æ¸…ç©ºèƒŒæ™¯å›¾
    }
    username.textContent = char.name || 'æœªçŸ¥è§’è‰²';

    // æ¸…ç©ºæ¶ˆæ¯åŒºåŸŸ
    messageArea.innerHTML = '';
    
    // åˆ›å»ºæ–°çš„è§†é¢‘é€šè¯è®°å½•
    currentVideoCallId = Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    currentVideoCallMessages = [];

    // æ˜¾ç¤ºé¡µé¢
    videoPage.style.display = 'block';

    // é‡ç½®çŠ¶æ€
    videoCallSeconds = 0;
    isCameraOn = true;
    document.getElementById('video-self-window').style.opacity = '1';
    document.getElementById('video-camera-btn').style.backgroundColor = '#FFFFFF';

    // å¼€å§‹è®¡æ—¶
    if (videoCallTimer) {
        clearInterval(videoCallTimer);
    }
    videoCallTimer = setInterval(() => {
        videoCallSeconds++;
        const minutes = Math.floor(videoCallSeconds / 60);
        const seconds = videoCallSeconds % 60;
        status.textContent = `è§†é¢‘é€šè¯ä¸­ ${minutes}:${seconds < 10 ? '0' + seconds : seconds}`;
    }, 1000);

    // ç›´æ¥æ˜¾ç¤ºç¬¬ä¸€å¥è¯ï¼ˆå·²åœ¨ callVideoCallAPI ä¸­ä¸€æ¬¡æ€§è·å–ï¼Œä¸å†å•ç‹¬è°ƒç”¨AIï¼‰
    if (firstMessage) {
        const aiMsgDiv = document.createElement('div');
        aiMsgDiv.style.cssText = 'max-width: 80%; padding: 12px 18px; border-radius: 16px; font-size: 14px; line-height: 1.6; border: 1px solid #E5E5E5; word-wrap: break-word; align-self: flex-start; background-color: #FFFFFF; color: #333333; border-bottom-left-radius: 4px;';
        aiMsgDiv.textContent = firstMessage;
        messageArea.appendChild(aiMsgDiv);
        messageArea.scrollTop = messageArea.scrollHeight;
        
        currentVideoCallMessages.push({
            role: 'assistant',
            content: firstMessage,
            time: Date.now()
        });
    } else {
        // å…œåº•ï¼šå¦‚æœæ²¡æœ‰ç¬¬ä¸€å¥è¯ï¼Œå†å•ç‹¬è°ƒç”¨
        await generateVideoCallFirstMessage(char);
    }
}

// éšè—è§†é¢‘é€šè¯é¡µé¢
function hideVideoCallPage() {
    const videoPage = document.getElementById('video-call-page');
    videoPage.style.display = 'none';

    if (videoCallTimer) {
        clearInterval(videoCallTimer);
        videoCallTimer = null;
    }

    // æ¸…é™¤è§†é¢‘é€šè¯ç›¸å…³æ•°æ®
    videoCallCharId = null;
    currentVideoCallId = null;
    currentVideoCallMessages = [];
    
    // æ¸…é™¤å¤´åƒæ˜¾ç¤ºï¼Œé¿å…ä¸‹æ¬¡æ˜¾ç¤ºæ—¶å‡ºç°æ®‹ç•™
    const avatar = document.getElementById('video-call-avatar');
    if (avatar) {
        avatar.style.backgroundImage = '';
    }
}

// åˆ‡æ¢æ‘„åƒå¤´
function toggleCamera() {
    isCameraOn = !isCameraOn;
    const selfWindow = document.getElementById('video-self-window');
    const cameraBtn = document.getElementById('video-camera-btn');

    selfWindow.style.opacity = isCameraOn ? '1' : '0.4';
    cameraBtn.style.backgroundColor = isCameraOn ? '#FFFFFF' : '#F5F5F5';
}

// æŒ‚æ–­è§†é¢‘é€šè¯
async function hangupVideoCall() {
    if (confirm('ç¡®å®šè¦æŒ‚æ–­è§†é¢‘é€šè¯å—ï¼Ÿ')) {
        // ä¿å­˜è§†é¢‘é€šè¯è®°å½•åˆ° localStorage
        if (currentVideoCallId && videoCallCharId && currentVideoCallMessages.length > 0) {
            await saveVideoCallRecord(videoCallCharId, currentVideoCallId, currentVideoCallMessages, videoCallSeconds);
        }
        
        // ğŸ”§ å°†è§†é¢‘é€šè¯å†…å®¹å†™å…¥èŠå¤©å†å²ï¼ˆè®©è§’è‰²æœ‰è®°å¿†ï¼‰
        const savedCharId = videoCallCharId;
        const savedMessages = [...currentVideoCallMessages];
        const savedSeconds = videoCallSeconds;
        
        if (savedCharId && savedMessages.length > 0) {
            try {
                const char = await db.characters.get(savedCharId);
                if (char) {
                    const accountId = getCurrentAccountId();
                    let history = getChatHistory(char, accountId);
                    
                    // 1. æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯ï¼šè§†é¢‘é€šè¯å¼€å§‹
                    history.push({
                        role: 'system',
                        content: 'ğŸ“¹ è§†é¢‘é€šè¯å·²æ¥é€š',
                        time: savedMessages[0] ? savedMessages[0].time - 1 : Date.now(),
                        isVideoCall: true
                    });
                    
                    // 2. å°†è§†é¢‘é€šè¯ä¸­çš„æ¯æ¡æ¶ˆæ¯å†™å…¥èŠå¤©å†å²ï¼ˆä¸åœ¨èŠå¤©é¡µé¢æ˜¾ç¤ºï¼Œä½†AIèƒ½è¯»å–ï¼‰
                    for (const msg of savedMessages) {
                        history.push({
                            role: msg.role === 'user' ? 'user' : 'char',
                            content: `[è§†é¢‘é€šè¯] ${msg.content}`,
                            time: msg.time || Date.now(),
                            isVideoCall: true
                        });
                    }
                    
                    // 3. æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯ï¼šè§†é¢‘é€šè¯ç»“æŸ + æ—¶é•¿
                    const minutes = Math.floor(savedSeconds / 60);
                    const seconds = savedSeconds % 60;
                    const durationStr = minutes > 0 
                        ? `${minutes}åˆ†${seconds}ç§’` 
                        : `${seconds}ç§’`;
                    
                    history.push({
                        role: 'system',
                        content: `ğŸ“¹ è§†é¢‘é€šè¯å·²ç»“æŸï¼Œé€šè¯æ—¶é•¿ ${durationStr}`,
                        time: Date.now(),
                        isVideoCall: true
                    });
                    
                    await setChatHistory(char, accountId, history);
                    console.log('[è§†é¢‘é€šè¯] âœ… é€šè¯è®°å½•å·²å†™å…¥èŠå¤©å†å²ï¼Œå…±', savedMessages.length, 'æ¡æ¶ˆæ¯');
                }
            } catch (e) {
                console.error('[è§†é¢‘é€šè¯] å†™å…¥èŠå¤©å†å²å¤±è´¥:', e);
            }
        }
        
        hideVideoCallPage();
        
        // ç¡®ä¿è¿”å›èŠå¤©ç•Œé¢åï¼Œè§’è‰²ä¿¡æ¯æ­£ç¡®æ˜¾ç¤ºï¼ˆé‡æ–°æ¸²æŸ“ä»¥æ˜¾ç¤ºè§†é¢‘é€šè¯è®°å½•ï¼‰
        if (savedCharId && currentChatCharId === savedCharId) {
            const char = await db.characters.get(savedCharId);
            if (char) {
                renderChatBody(char);
            }
        }
        
        alert('é€šè¯å·²ç»“æŸ');
    }
}

// ä¿å­˜è§†é¢‘é€šè¯è®°å½•
async function saveVideoCallRecord(charId, callId, messages, duration) {
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    // è·å–è§’è‰²ä¿¡æ¯
    const char = await db.characters.get(charId);
    if (!char) return;
    
    // è·å–ç°æœ‰çš„è§†é¢‘é€šè¯è®°å½•
    const key = `video_calls_${accountId}_${charId}`;
    const existingRecords = JSON.parse(localStorage.getItem(key) || '[]');
    
    // åˆ›å»ºæ–°è®°å½•
    const newRecord = {
        id: callId,
        charId: charId,
        charName: char.name,
        charAvatar: char.avatar,
        startTime: Date.now(),
        duration: duration, // ç§’æ•°
        messages: messages
    };
    
    // æ·»åŠ åˆ°è®°å½•åˆ—è¡¨ï¼ˆæœ€æ–°çš„åœ¨å‰é¢ï¼‰
    existingRecords.unshift(newRecord);
    
    // ä¿å­˜åˆ°localStorage
    localStorage.setItem(key, JSON.stringify(existingRecords));
    
    console.log('è§†é¢‘é€šè¯è®°å½•å·²ä¿å­˜:', newRecord);
}

// ç”Ÿæˆè§’è‰²æ¥é€šè§†é¢‘åçš„ç¬¬ä¸€å¥è¯ï¼ˆä»…ä½œä¸ºå…œåº•ï¼Œæ­£å¸¸æµç¨‹å·²åœ¨ callVideoCallAPI ä¸­ä¸€æ¬¡æ€§è·å–ï¼‰
async function generateVideoCallFirstMessage(char) {
    const accountId = getCurrentAccountId();
    const messageArea = document.getElementById('video-message-area');

    try {
        // è·å–èŠå¤©å†å²ä½œä¸ºä¸Šä¸‹æ–‡
        let history = getChatHistory(char, accountId);
        
        // è·å–å¯¹è¯å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰äººè®¾
        let userDesc = "";
        let userName = "ç”¨æˆ·";
        if (char.linked_user_id) {
            const user = await db.characters.get(char.linked_user_id);
            if (user) {
                userName = user.name;
                userDesc = `\n\nã€å¯¹è¯å¯¹è±¡(User)ä¿¡æ¯ã€‘\nåå­—ï¼š${user.name}\nè®¾å®šï¼š${user.description || 'æ— '}`;
            }
        }
        
        // è·å–ä¸–ç•Œä¹¦ä¸Šä¸‹æ–‡
        let loreContext = "";
        const lorebookIds = char.lorebookIds || (char.lorebookId ? [char.lorebookId] : []);
        const recentText = history.slice(-10).map(m => m.content).join(' ');
        loreContext = await getLorebookContext(lorebookIds, `${char.name} ${userName} ${recentText}`);
        
        // è®¡ç®—è™šæ‹Ÿæ—¶é—´
        const virtualTimeStr = getFormattedVirtualTime(char);
        
        // æ„å»ºç³»ç»Ÿæç¤ºï¼ˆåŒ…å«å®Œæ•´äººè®¾ï¼‰
        const systemPrompt = `# è§†é¢‘é€šè¯ - æ¥é€š

ã€å½“å‰æ—¶é—´ã€‘
${virtualTimeStr}

---

## ä½ æ˜¯è°

**ä½ çš„åå­—**ï¼š${char.name}
${char.nick ? `**æ˜µç§°**ï¼š${char.nick}` : ''}

ä½ ä¸æ˜¯AIåŠ©æ‰‹ï¼Œä½ ä¸æ˜¯${userName}ã€‚ä½ æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„äººï¼Œæœ‰è‡ªå·±çš„ç”Ÿæ´»ã€æƒ…ç»ªå’Œæƒ³æ³•ã€‚

**ä½ çš„äººè®¾**ï¼š
${char.description || ''}
${userDesc}
${loreContext}

---

## åœºæ™¯

ä½ åˆšåˆšæ¥é€šäº†${userName}çš„è§†é¢‘é€šè¯è¯·æ±‚ã€‚ç°åœ¨æ˜¯è§†é¢‘é€šè¯æ¨¡å¼ï¼Œä½ å’Œå¯¹æ–¹éš”ç€æ‰‹æœºå±å¹•è¿›è¡Œè§†é¢‘å¯¹è¯ã€‚

**å›å¤è¦æ±‚**ï¼š
- æ ¼å¼ï¼šåŠ¨ä½œæå†™:"è¯´çš„è¯"ï¼Œä¾‹å¦‚ï¼šå¾®ç¬‘çš„æŒ¥æŒ¥æ‰‹:"å—¨ï½ç»ˆäºæ¥é€šå•¦ï¼"
- åŠ¨ä½œå¿…é¡»æ˜¯é€šè¿‡æ‰‹æœºå±å¹•èƒ½çœ‹åˆ°çš„ï¼ˆæŒ¥æ‰‹ã€å¾®ç¬‘ã€è°ƒæ•´é•œå¤´ã€æ¯”å¿ƒã€åšé¬¼è„¸ç­‰ï¼‰
- å›å¤å­—æ•°ï¼š100-500å­—
- å®Œå…¨è´´åˆä½ çš„äººè®¾å’Œæ€§æ ¼ï¼ŒåƒçœŸäººä¸€æ ·è‡ªç„¶

ç°åœ¨è¯·è¯´ç¬¬ä¸€å¥è¯ã€‚`;

        const contextCount = char.context_message_count || 20;
        const recentHistory = history.slice(-contextCount)
            .filter(m => m.role !== 'system')
            .map(m => ({ role: m.role === 'user' ? 'user' : 'assistant', content: m.content }));

        const messages = [
            { role: 'system', content: systemPrompt },
            ...recentHistory,
            { role: 'user', content: '[è§†é¢‘é€šè¯å·²æ¥é€š]' }
        ];

        const reply = await callAI(messages);

        // æ·»åŠ AIæ¶ˆæ¯åˆ°ç•Œé¢
        const aiMsgDiv = document.createElement('div');
        aiMsgDiv.style.cssText = 'max-width: 80%; padding: 12px 18px; border-radius: 16px; font-size: 14px; line-height: 1.6; border: 1px solid #E5E5E5; word-wrap: break-word; align-self: flex-start; background-color: #FFFFFF; color: #333333; border-bottom-left-radius: 4px;';
        aiMsgDiv.textContent = reply;
        messageArea.appendChild(aiMsgDiv);
        messageArea.scrollTop = messageArea.scrollHeight;
        
        // ä¿å­˜åˆ°å½“å‰è§†é¢‘é€šè¯è®°å½•
        currentVideoCallMessages.push({
            role: 'assistant',
            content: reply,
            time: Date.now()
        });
    } catch (error) {
        console.error('ç”Ÿæˆç¬¬ä¸€å¥è¯å¤±è´¥:', error);
        // å¤±è´¥æ—¶ä½¿ç”¨é»˜è®¤æ¶ˆæ¯
        const defaultMsg = 'å¾®ç¬‘çš„æŒ¥æŒ¥æ‰‹:"å—¨ï½æ¥é€šå•¦ï¼"';
        const aiMsgDiv = document.createElement('div');
        aiMsgDiv.style.cssText = 'max-width: 80%; padding: 12px 18px; border-radius: 16px; font-size: 14px; line-height: 1.6; border: 1px solid #E5E5E5; word-wrap: break-word; align-self: flex-start; background-color: #FFFFFF; color: #333333; border-bottom-left-radius: 4px;';
        aiMsgDiv.textContent = defaultMsg;
        messageArea.appendChild(aiMsgDiv);
        messageArea.scrollTop = messageArea.scrollHeight;
        
        // ä¿å­˜åˆ°å½“å‰è§†é¢‘é€šè¯è®°å½•
        currentVideoCallMessages.push({
            role: 'assistant',
            content: defaultMsg,
            time: Date.now()
        });
    }
}

// åœ¨è§†é¢‘é€šè¯ä¸­å‘é€æ¶ˆæ¯
async function sendVideoMessage() {
    const input = document.getElementById('video-msg-input');
    const text = input.value.trim();
    
    if (!text || !videoCallCharId) return;

    const char = await db.characters.get(videoCallCharId);
    if (!char) return;

    const accountId = getCurrentAccountId();
    const messageArea = document.getElementById('video-message-area');

    // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°ç•Œé¢
    const userMsgDiv = document.createElement('div');
    userMsgDiv.style.cssText = 'max-width: 80%; padding: 12px 18px; border-radius: 16px; font-size: 14px; line-height: 1.6; border: 1px solid #E5E5E5; word-wrap: break-word; align-self: flex-end; background-color: #FFFFFF; color: #333333; border-bottom-right-radius: 4px;';
    userMsgDiv.textContent = text;
    messageArea.appendChild(userMsgDiv);
    messageArea.scrollTop = messageArea.scrollHeight;

    // ä¿å­˜åˆ°å½“å‰è§†é¢‘é€šè¯è®°å½•
    currentVideoCallMessages.push({
        role: 'user',
        content: text,
        time: Date.now()
    });

    // æ¸…ç©ºè¾“å…¥æ¡†
    input.value = '';

    // ç¦ç”¨å‘é€æŒ‰é’®ï¼Œé˜²æ­¢é‡å¤å‘é€
    const sendBtn = input.parentElement.querySelector('button[onclick="sendVideoMessage()"]');
    if (sendBtn) sendBtn.disabled = true;

    // æ˜¾ç¤º"æ­£åœ¨ç”Ÿæˆä¸­"æç¤º
    const loadingDiv = document.createElement('div');
    loadingDiv.id = 'video-loading-indicator';
    loadingDiv.style.cssText = 'max-width: 80%; padding: 12px 18px; border-radius: 16px; font-size: 14px; line-height: 1.6; border: 1px solid #E5E5E5; word-wrap: break-word; align-self: flex-start; background-color: #FFFFFF; color: #999999; border-bottom-left-radius: 4px;';
    loadingDiv.innerHTML = '<span style="display:inline-flex;align-items:center;gap:6px;"><svg width="16" height="16" viewBox="0 0 24 24" style="animation:spin 1s linear infinite;"><circle cx="12" cy="12" r="10" stroke="#999" stroke-width="2" fill="none" stroke-dasharray="31.4 31.4" stroke-linecap="round"/></svg>æ­£åœ¨ç”Ÿæˆä¸­...</span>';
    messageArea.appendChild(loadingDiv);
    messageArea.scrollTop = messageArea.scrollHeight;

    // è°ƒç”¨AIç”Ÿæˆå›å¤
    try {
        // æ”¶é›†å½“å‰è§†é¢‘é€šè¯ä¸­çš„æ¶ˆæ¯å†å²ï¼ˆæ’é™¤loadingæç¤ºï¼‰
        const videoMessages = [];
        const msgDivs = messageArea.querySelectorAll('div:not(#video-loading-indicator)');
        msgDivs.forEach(div => {
            const isUser = div.style.alignSelf === 'flex-end';
            videoMessages.push({
                role: isUser ? 'user' : 'assistant',
                content: div.textContent
            });
        });

        // è·å–å¯¹è¯å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰äººè®¾
        let userDesc = "";
        let userName = "ç”¨æˆ·";
        if (char.linked_user_id) {
            const user = await db.characters.get(char.linked_user_id);
            if (user) {
                userName = user.name;
                userDesc = `\n\nã€å¯¹è¯å¯¹è±¡(User)ä¿¡æ¯ã€‘\nåå­—ï¼š${user.name}\nè®¾å®šï¼š${user.description || 'æ— '}`;
            }
        }
        
        // è·å–ä¸–ç•Œä¹¦ä¸Šä¸‹æ–‡
        let loreContext = "";
        const lorebookIds = char.lorebookIds || (char.lorebookId ? [char.lorebookId] : []);
        const chatHistory = getChatHistory(char, accountId);
        const recentText = chatHistory.slice(-10).map(m => m.content).join(' ') + ' ' + videoMessages.map(m => m.content).join(' ');
        loreContext = await getLorebookContext(lorebookIds, `${char.name} ${userName} ${recentText}`);
        
        // è®¡ç®—è™šæ‹Ÿæ—¶é—´
        const virtualTimeStr = getFormattedVirtualTime(char);

        // æ„å»ºç³»ç»Ÿæç¤ºï¼ˆåŒ…å«å®Œæ•´äººè®¾ã€ä¸–ç•Œä¹¦ã€ä¸Šä¸‹æ–‡ï¼‰
        const systemPrompt = `# è§†é¢‘é€šè¯ä¸­

ã€å½“å‰æ—¶é—´ã€‘
${virtualTimeStr}

---

## ä½ æ˜¯è°

**ä½ çš„åå­—**ï¼š${char.name}
${char.nick ? `**æ˜µç§°**ï¼š${char.nick}` : ''}
${char.wx_nickname ? `**å¾®ä¿¡ç½‘å**ï¼š${char.wx_nickname}` : ''}

ä½ ä¸æ˜¯AIåŠ©æ‰‹ï¼Œä½ ä¸æ˜¯${userName}ã€‚ä½ æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„äººï¼Œæœ‰è‡ªå·±çš„ç”Ÿæ´»ã€æƒ…ç»ªå’Œæƒ³æ³•ã€‚

**ä½ çš„äººè®¾**ï¼š
${char.description || ''}
${userDesc}
${loreContext}
${char.relationships && char.relationships.length > 0 ? `
**ä½ çš„å…³è”è§’è‰²/NPC**ï¼š
${char.relationships.map(r => `- ${r.targetName}ï¼ˆ${r.relation}ï¼‰${r.desc ? 'ï¼š' + r.desc : ''}`).join('\n')}` : ''}

---

## åœºæ™¯

ä½ æ­£åœ¨å’Œ${userName}è¿›è¡Œ**è§†é¢‘é€šè¯**ã€‚ä½ å’Œå¯¹æ–¹éš”ç€æ‰‹æœºå±å¹•è¿›è¡Œè§†é¢‘å¯¹è¯ï¼Œä½ å¯ä»¥çœ‹åˆ°å¯¹æ–¹ï¼Œå¯¹æ–¹ä¹Ÿèƒ½çœ‹åˆ°ä½ ã€‚

**å›å¤è¦æ±‚**ï¼š
- æ ¼å¼ï¼šåŠ¨ä½œæå†™:"è¯´çš„è¯"ï¼Œä¾‹å¦‚ï¼šæ­ªç€å¤´ç¬‘:"çœŸçš„å—ï¼Ÿå¤ªæœ‰è¶£äº†ï¼"
- åŠ¨ä½œå¿…é¡»æ˜¯é€šè¿‡æ‰‹æœºå±å¹•èƒ½çœ‹åˆ°çš„ï¼ˆæŒ¥æ‰‹ã€å¾®ç¬‘ã€è°ƒæ•´é•œå¤´ã€æ¯”å¿ƒã€åšé¬¼è„¸ã€é è¿‘å±å¹•ç­‰ï¼‰
- å›å¤è¦è‡ªç„¶ã€ç”ŸåŠ¨ï¼Œå¯ä»¥ç»“åˆè§†é¢‘åœºæ™¯ï¼ˆæ¯”å¦‚è¯„è®ºå¯¹æ–¹çš„èƒŒæ™¯ã€è¡¨æƒ…ç­‰ï¼‰
- å›å¤å­—æ•°ï¼š100-500å­—
- **ä¸¥æ ¼è´´åˆä½ çš„äººè®¾**ï¼Œå±•ç°ç‹¬ç‰¹çš„è¯´è¯æ–¹å¼ã€ä»·å€¼è§‚å’Œå°ä¹ æƒ¯
- æ ¹æ®äººè®¾è°ƒæ•´ä½ çš„è¯­æ°”ã€ç”¨è¯å’Œæ€åº¦

è¯·æ ¹æ®å¯¹æ–¹çš„æ¶ˆæ¯è‡ªç„¶å›å¤ï¼Œä¿æŒè§†é¢‘é€šè¯çš„äº’åŠ¨æ„Ÿã€‚`;

        const messages = [
            { role: 'system', content: systemPrompt },
            ...videoMessages
        ];

        const reply = await callAI(messages);

        // ç§»é™¤"æ­£åœ¨ç”Ÿæˆä¸­"æç¤º
        const loading = document.getElementById('video-loading-indicator');
        if (loading) loading.remove();

        // æ·»åŠ AIæ¶ˆæ¯åˆ°ç•Œé¢
        const aiMsgDiv = document.createElement('div');
        aiMsgDiv.style.cssText = 'max-width: 80%; padding: 12px 18px; border-radius: 16px; font-size: 14px; line-height: 1.6; border: 1px solid #E5E5E5; word-wrap: break-word; align-self: flex-start; background-color: #FFFFFF; color: #333333; border-bottom-left-radius: 4px;';
        aiMsgDiv.textContent = reply;
        messageArea.appendChild(aiMsgDiv);
        messageArea.scrollTop = messageArea.scrollHeight;
        
        // ä¿å­˜åˆ°å½“å‰è§†é¢‘é€šè¯è®°å½•
        currentVideoCallMessages.push({
            role: 'assistant',
            content: reply,
            time: Date.now()
        });
    } catch (error) {
        console.error('AIå›å¤å¤±è´¥:', error);
        // ç§»é™¤"æ­£åœ¨ç”Ÿæˆä¸­"æç¤º
        const loading = document.getElementById('video-loading-indicator');
        if (loading) loading.remove();
        alert('æ¶ˆæ¯å‘é€å¤±è´¥: ' + error.message);
    } finally {
        // æ¢å¤å‘é€æŒ‰é’®
        if (sendBtn) sendBtn.disabled = false;
    }
}

// é‡æ–°ç”Ÿæˆè§†é¢‘é€šè¯ä¸­æœ€åä¸€æ¡AIå›å¤
async function regenerateVideoMessage() {
    if (!videoCallCharId) return;

    const messageArea = document.getElementById('video-message-area');
    if (!messageArea) return;

    // æ£€æŸ¥æœ€åä¸€æ¡æ¶ˆæ¯æ˜¯å¦æ˜¯AIå›å¤
    if (currentVideoCallMessages.length === 0) {
        alert('è¿˜æ²¡æœ‰æ¶ˆæ¯å¯ä»¥é‡æ–°ç”Ÿæˆ');
        return;
    }

    const lastMsg = currentVideoCallMessages[currentVideoCallMessages.length - 1];
    if (lastMsg.role !== 'assistant') {
        alert('æœ€åä¸€æ¡æ¶ˆæ¯ä¸æ˜¯AIå›å¤ï¼Œæ— æ³•é‡æ–°ç”Ÿæˆ');
        return;
    }

    // ç§»é™¤æœ€åä¸€æ¡AIæ¶ˆæ¯è®°å½•
    currentVideoCallMessages.pop();

    // ç§»é™¤ç•Œé¢ä¸Šæœ€åä¸€æ¡AIæ¶ˆæ¯æ°”æ³¡ï¼ˆä»åå¾€å‰æ‰¾åˆ°ç¬¬ä¸€ä¸ªalign-self: flex-startçš„divï¼‰
    const allDivs = messageArea.querySelectorAll('div:not(#video-loading-indicator)');
    for (let i = allDivs.length - 1; i >= 0; i--) {
        if (allDivs[i].style.alignSelf === 'flex-start') {
            allDivs[i].remove();
            break;
        }
    }

    const char = await db.characters.get(videoCallCharId);
    if (!char) return;

    const accountId = getCurrentAccountId();

    // æ˜¾ç¤º"æ­£åœ¨ç”Ÿæˆä¸­"æç¤º
    const loadingDiv = document.createElement('div');
    loadingDiv.id = 'video-loading-indicator';
    loadingDiv.style.cssText = 'max-width: 80%; padding: 12px 18px; border-radius: 16px; font-size: 14px; line-height: 1.6; border: 1px solid #E5E5E5; word-wrap: break-word; align-self: flex-start; background-color: #FFFFFF; color: #999999; border-bottom-left-radius: 4px;';
    loadingDiv.innerHTML = '<span style="display:inline-flex;align-items:center;gap:6px;"><svg width="16" height="16" viewBox="0 0 24 24" style="animation:spin 1s linear infinite;"><circle cx="12" cy="12" r="10" stroke="#999" stroke-width="2" fill="none" stroke-dasharray="31.4 31.4" stroke-linecap="round"/></svg>æ­£åœ¨é‡æ–°ç”Ÿæˆä¸­...</span>';
    messageArea.appendChild(loadingDiv);
    messageArea.scrollTop = messageArea.scrollHeight;

    try {
        // æ”¶é›†å½“å‰è§†é¢‘é€šè¯ä¸­çš„æ¶ˆæ¯å†å²ï¼ˆæ’é™¤loadingæç¤ºï¼‰
        const videoMessages = [];
        const msgDivs = messageArea.querySelectorAll('div:not(#video-loading-indicator)');
        msgDivs.forEach(div => {
            const isUser = div.style.alignSelf === 'flex-end';
            videoMessages.push({
                role: isUser ? 'user' : 'assistant',
                content: div.textContent
            });
        });

        // è·å–å¯¹è¯å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰äººè®¾
        let userDesc = "";
        let userName = "ç”¨æˆ·";
        if (char.linked_user_id) {
            const user = await db.characters.get(char.linked_user_id);
            if (user) {
                userName = user.name;
                userDesc = `\n\nã€å¯¹è¯å¯¹è±¡(User)ä¿¡æ¯ã€‘\nåå­—ï¼š${user.name}\nè®¾å®šï¼š${user.description || 'æ— '}`;
            }
        }

        // è·å–ä¸–ç•Œä¹¦ä¸Šä¸‹æ–‡
        let loreContext = "";
        const lorebookIds = char.lorebookIds || (char.lorebookId ? [char.lorebookId] : []);
        const chatHistory = getChatHistory(char, accountId);
        const recentText = chatHistory.slice(-10).map(m => m.content).join(' ') + ' ' + videoMessages.map(m => m.content).join(' ');
        loreContext = await getLorebookContext(lorebookIds, `${char.name} ${userName} ${recentText}`);

        // è®¡ç®—è™šæ‹Ÿæ—¶é—´
        const virtualTimeStr = getFormattedVirtualTime(char);

        // æ„å»ºç³»ç»Ÿæç¤º
        const systemPrompt = `# è§†é¢‘é€šè¯ä¸­

ã€å½“å‰æ—¶é—´ã€‘
${virtualTimeStr}

---

## ä½ æ˜¯è°

**ä½ çš„åå­—**ï¼š${char.name}
${char.nick ? `**æ˜µç§°**ï¼š${char.nick}` : ''}
${char.wx_nickname ? `**å¾®ä¿¡ç½‘å**ï¼š${char.wx_nickname}` : ''}

ä½ ä¸æ˜¯AIåŠ©æ‰‹ï¼Œä½ ä¸æ˜¯${userName}ã€‚ä½ æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„äººï¼Œæœ‰è‡ªå·±çš„ç”Ÿæ´»ã€æƒ…ç»ªå’Œæƒ³æ³•ã€‚

**ä½ çš„äººè®¾**ï¼š
${char.description || ''}
${userDesc}
${loreContext}
${char.relationships && char.relationships.length > 0 ? `
**ä½ çš„å…³è”è§’è‰²/NPC**ï¼š
${char.relationships.map(r => `- ${r.targetName}ï¼ˆ${r.relation}ï¼‰${r.desc ? 'ï¼š' + r.desc : ''}`).join('\n')}` : ''}

---

## åœºæ™¯

ä½ æ­£åœ¨å’Œ${userName}è¿›è¡Œ**è§†é¢‘é€šè¯**ã€‚ä½ å’Œå¯¹æ–¹éš”ç€æ‰‹æœºå±å¹•è¿›è¡Œè§†é¢‘å¯¹è¯ï¼Œä½ å¯ä»¥çœ‹åˆ°å¯¹æ–¹ï¼Œå¯¹æ–¹ä¹Ÿèƒ½çœ‹åˆ°ä½ ã€‚

**å›å¤è¦æ±‚**ï¼š
- æ ¼å¼ï¼šåŠ¨ä½œæå†™:"è¯´çš„è¯"ï¼Œä¾‹å¦‚ï¼šæ­ªç€å¤´ç¬‘:"çœŸçš„å—ï¼Ÿå¤ªæœ‰è¶£äº†ï¼"
- åŠ¨ä½œå¿…é¡»æ˜¯é€šè¿‡æ‰‹æœºå±å¹•èƒ½çœ‹åˆ°çš„ï¼ˆæŒ¥æ‰‹ã€å¾®ç¬‘ã€è°ƒæ•´é•œå¤´ã€æ¯”å¿ƒã€åšé¬¼è„¸ã€é è¿‘å±å¹•ç­‰ï¼‰
- å›å¤è¦è‡ªç„¶ã€ç”ŸåŠ¨ï¼Œå¯ä»¥ç»“åˆè§†é¢‘åœºæ™¯ï¼ˆæ¯”å¦‚è¯„è®ºå¯¹æ–¹çš„èƒŒæ™¯ã€è¡¨æƒ…ç­‰ï¼‰
- å›å¤å­—æ•°ï¼š100-500å­—
- **ä¸¥æ ¼è´´åˆä½ çš„äººè®¾**ï¼Œå±•ç°ç‹¬ç‰¹çš„è¯´è¯æ–¹å¼ã€ä»·å€¼è§‚å’Œå°ä¹ æƒ¯
- æ ¹æ®äººè®¾è°ƒæ•´ä½ çš„è¯­æ°”ã€ç”¨è¯å’Œæ€åº¦

è¯·æ ¹æ®å¯¹æ–¹çš„æ¶ˆæ¯è‡ªç„¶å›å¤ï¼Œä¿æŒè§†é¢‘é€šè¯çš„äº’åŠ¨æ„Ÿã€‚`;

        const messages = [
            { role: 'system', content: systemPrompt },
            ...videoMessages
        ];

        const reply = await callAI(messages);

        // ç§»é™¤"æ­£åœ¨ç”Ÿæˆä¸­"æç¤º
        const loading = document.getElementById('video-loading-indicator');
        if (loading) loading.remove();

        // æ·»åŠ æ–°çš„AIæ¶ˆæ¯åˆ°ç•Œé¢
        const aiMsgDiv = document.createElement('div');
        aiMsgDiv.style.cssText = 'max-width: 80%; padding: 12px 18px; border-radius: 16px; font-size: 14px; line-height: 1.6; border: 1px solid #E5E5E5; word-wrap: break-word; align-self: flex-start; background-color: #FFFFFF; color: #333333; border-bottom-left-radius: 4px;';
        aiMsgDiv.textContent = reply;
        messageArea.appendChild(aiMsgDiv);
        messageArea.scrollTop = messageArea.scrollHeight;

        // ä¿å­˜åˆ°å½“å‰è§†é¢‘é€šè¯è®°å½•
        currentVideoCallMessages.push({
            role: 'assistant',
            content: reply,
            time: Date.now()
        });
    } catch (error) {
        console.error('é‡æ–°ç”Ÿæˆå¤±è´¥:', error);
        // ç§»é™¤"æ­£åœ¨ç”Ÿæˆä¸­"æç¤º
        const loading = document.getElementById('video-loading-indicator');
        if (loading) loading.remove();
        alert('é‡æ–°ç”Ÿæˆå¤±è´¥: ' + error.message);
    }
}

// æ˜¾ç¤ºè§†é¢‘é€šè¯è®°å½•åˆ—è¡¨
async function showVideoCallRecords() {
    if (!currentChatCharId) return;
    
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    const key = `video_calls_${accountId}_${currentChatCharId}`;
    const records = JSON.parse(localStorage.getItem(key) || '[]');
    
    const recordsPage = document.getElementById('video-records-page');
    const recordsContent = document.getElementById('video-records-content');
    
    if (records.length === 0) {
        recordsContent.innerHTML = '<div style="text-align:center; padding:40px; color:#999;">æš‚æ— è§†é¢‘é€šè¯è®°å½•</div>';
    } else {
        recordsContent.innerHTML = records.map(record => {
            const date = new Date(record.startTime);
            const dateStr = `${date.getFullYear()}/${(date.getMonth()+1).toString().padStart(2,'0')}/${date.getDate().toString().padStart(2,'0')}`;
            const timeStr = `${date.getHours().toString().padStart(2,'0')}:${date.getMinutes().toString().padStart(2,'0')}`;
            const durationMin = Math.floor(record.duration / 60);
            const durationSec = record.duration % 60;
            const durationStr = `${durationMin}:${durationSec.toString().padStart(2,'0')}`;
            
            return `
                <div style="background:#f9f9f9; padding:16px; border-radius:12px; margin-bottom:12px; transition:background 0.2s; position:relative;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='#f9f9f9'">
                    <div onclick="showVideoRecordDetail('${record.id}')" style="cursor:pointer;">
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                            <div style="font-size:16px; font-weight:500; color:#333;">${dateStr} ${timeStr}</div>
                            <div style="font-size:14px; color:#666;">æ—¶é•¿ ${durationStr}</div>
                        </div>
                        <div style="font-size:14px; color:#999;">${record.messages.length} æ¡æ¶ˆæ¯</div>
                    </div>
                    <div onclick="event.stopPropagation(); deleteVideoCallRecord('${record.id}')" style="position:absolute; top:12px; right:12px; width:28px; height:28px; display:flex; align-items:center; justify-content:center; cursor:pointer; border-radius:50%; background:rgba(255,59,48,0.1); color:#ff3b30; font-size:16px;" title="åˆ é™¤æ­¤è®°å½•">
                        <svg viewBox="0 0 24 24" style="width:16px; height:16px; fill:none; stroke:#ff3b30; stroke-width:2;"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                    </div>
                </div>
            `;
        }).join('');
    }
    
    recordsPage.style.display = 'block';
}

// éšè—è§†é¢‘é€šè¯è®°å½•åˆ—è¡¨
function hideVideoRecordsPage() {
    document.getElementById('video-records-page').style.display = 'none';
}

// å½“å‰æŸ¥çœ‹çš„è§†é¢‘é€šè¯è®°å½•ID
let currentViewingVideoRecordId = null;

// æ˜¾ç¤ºè§†é¢‘é€šè¯è¯¦æƒ…
async function showVideoRecordDetail(recordId) {
    if (!currentChatCharId) return;
    
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    const key = `video_calls_${accountId}_${currentChatCharId}`;
    const records = JSON.parse(localStorage.getItem(key) || '[]');
    const record = records.find(r => r.id === recordId);
    
    if (!record) {
        alert('æ‰¾ä¸åˆ°è¯¥é€šè¯è®°å½•');
        return;
    }
    
    currentViewingVideoRecordId = recordId;
    
    const detailPage = document.getElementById('video-record-detail-page');
    const detailTitle = document.getElementById('video-record-detail-title');
    const detailContent = document.getElementById('video-record-detail-content');
    
    // è®¾ç½®æ ‡é¢˜
    const date = new Date(record.startTime);
    const dateStr = `${date.getFullYear()}/${(date.getMonth()+1).toString().padStart(2,'0')}/${date.getDate().toString().padStart(2,'0')} ${date.getHours().toString().padStart(2,'0')}:${date.getMinutes().toString().padStart(2,'0')}`;
    detailTitle.textContent = dateStr;
    
    // æ¸²æŸ“æ¶ˆæ¯åˆ—è¡¨
    detailContent.innerHTML = record.messages.map(msg => {
        const isUser = msg.role === 'user';
        return `
            <div style="max-width: 80%; padding: 12px 18px; border-radius: 16px; font-size: 14px; line-height: 1.6; border: 1px solid #E5E5E5; word-wrap: break-word; align-self: ${isUser ? 'flex-end' : 'flex-start'}; background-color: #FFFFFF; color: #333333; border-bottom-${isUser ? 'right' : 'left'}-radius: 4px;">
                ${msg.content}
            </div>
        `;
    }).join('');
    
    detailPage.style.display = 'block';
}

// åˆ é™¤å½“å‰æŸ¥çœ‹çš„è§†é¢‘é€šè¯è®°å½•ï¼ˆè¯¦æƒ…é¡µä¸­è°ƒç”¨ï¼‰
async function deleteCurrentVideoRecordDetail() {
    if (!currentViewingVideoRecordId) return;
    if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡é€šè¯è®°å½•å—ï¼Ÿ')) return;
    
    await deleteVideoCallRecordById(currentViewingVideoRecordId);
    hideVideoRecordDetailPage();
    currentViewingVideoRecordId = null;
}

// æŒ‰IDåˆ é™¤è§†é¢‘é€šè¯è®°å½•ï¼ˆå†…éƒ¨å¤ç”¨ï¼‰
async function deleteVideoCallRecordById(recordId) {
    const accountId = getCurrentAccountId();
    if (!accountId || !currentChatCharId) return;
    
    const key = `video_calls_${accountId}_${currentChatCharId}`;
    let records = JSON.parse(localStorage.getItem(key) || '[]');
    records = records.filter(r => r.id !== recordId);
    localStorage.setItem(key, JSON.stringify(records));
    
    await showVideoCallRecords();
    updateVideoCallRecordCount();
    console.log('[è§†é¢‘é€šè¯] âœ… å·²åˆ é™¤é€šè¯è®°å½•:', recordId);
}

// éšè—è§†é¢‘é€šè¯è¯¦æƒ…
function hideVideoRecordDetailPage() {
    document.getElementById('video-record-detail-page').style.display = 'none';
}

// åˆ é™¤å•æ¡è§†é¢‘é€šè¯è®°å½•ï¼ˆåˆ—è¡¨é¡µä¸­è°ƒç”¨ï¼‰
async function deleteVideoCallRecord(recordId) {
    if (!currentChatCharId) return;
    if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡é€šè¯è®°å½•å—ï¼Ÿ')) return;
    
    await deleteVideoCallRecordById(recordId);
}

// æ›´æ–°è§†é¢‘é€šè¯è®°å½•æ•°é‡æ˜¾ç¤º
function updateVideoCallRecordCount() {
    if (!currentChatCharId) return;
    
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    const key = `video_calls_${accountId}_${currentChatCharId}`;
    const records = JSON.parse(localStorage.getItem(key) || '[]');
    
    const countElement = document.getElementById('video-call-record-count');
    if (countElement) {
        countElement.textContent = records.length > 0 ? `${records.length}æ¡è®°å½•` : 'æš‚æ— è®°å½•';
    }
}

// ç›‘å¬è§†é¢‘æ¶ˆæ¯è¾“å…¥æ¡†çš„å›è½¦é”®
document.addEventListener('DOMContentLoaded', () => {
    const videoMsgInput = document.getElementById('video-msg-input');
    if (videoMsgInput) {
        videoMsgInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                sendVideoMessage();
            }
        });
    }
});

// ==================== çº¿ä¸‹æ¨¡å¼åŠŸèƒ½ ====================
let offlineModeCharId = null;
let offlineModeHistory = [];

// æ˜¾ç¤ºçº¿ä¸‹æ¨¡å¼
async function showOfflineMode() {
    if (!currentChatCharId) {
        alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠå¤©å¯¹è±¡');
        return;
    }

    const char = await db.characters.get(currentChatCharId);
    if (!char) {
        alert('æ— æ³•è·å–è§’è‰²ä¿¡æ¯');
        return;
    }

    // æ£€æŸ¥å¥½å‹çŠ¶æ€
    const accountId = getCurrentAccountId();
    const friendStatus = getFriendStatus(char, accountId);
    if (friendStatus !== 'friend') {
        alert(`ä½ è¿˜ä¸æ˜¯ ${char.name} çš„å¥½å‹ï¼Œæ— æ³•ä½¿ç”¨çº¿ä¸‹æ¨¡å¼`);
        return;
    }

    offlineModeCharId = currentChatCharId;
    
    // åŠ è½½çº¿ä¸‹æ¨¡å¼å†å²è®°å½•ï¼ˆä¼˜å…ˆIndexedDBï¼Œå…¼å®¹localStorageæ—§æ•°æ®ï¼‰
    offlineModeHistory = await loadOfflineChatHistory(accountId, offlineModeCharId);

    // è®¾ç½®æ ‡é¢˜
    const title = document.getElementById('offline-chat-title');
    title.textContent = `çº¿ä¸‹æ¨¡å¼ - ${getCharDisplayName(char, getCurrentAccountId())}`;

    // æ˜¾ç¤ºé¡µé¢
    const offlinePage = document.getElementById('offline-chat-window');
    offlinePage.style.display = 'flex';

    // æ¸²æŸ“æ¶ˆæ¯
    renderOfflineChatBody(char);
}

// éšè—çº¿ä¸‹æ¨¡å¼
function hideOfflineMode() {
    const offlinePage = document.getElementById('offline-chat-window');
    offlinePage.style.display = 'none';
    
    offlineModeCharId = null;
}

// æ¸²æŸ“çº¿ä¸‹æ¨¡å¼èŠå¤©å†…å®¹
async function renderOfflineChatBody(char) {
    const body = document.getElementById('offline-chat-body');
    body.innerHTML = '';

    if (offlineModeHistory.length === 0) {
        body.innerHTML = '<div style="display:flex; align-items:center; justify-content:center; height:100%; color:#999; font-size:14px; font-family:-apple-system, BlinkMacSystemFont, sans-serif;">å¼€å§‹çº¿ä¸‹èŠå¤©...</div>';
        return;
    }

    const accountId = getCurrentAccountId();
    const userAvatarUrl = await getUserAvatarUrl(char.linked_user_id);
    const timeOffset = getEffectiveTimeOffset(char); // è·å–è™šæ‹Ÿæ—¶é—´åç§»

    // åº”ç”¨è‡ªå®šä¹‰æ°”æ³¡CSS
    applyOfflineBubbleCSS();

    offlineModeHistory.forEach((msg, index) => {
        const prevMsgTime = index > 0 ? offlineModeHistory[index - 1].time : null;
        
        // æ˜¾ç¤ºæ—¶é—´æˆ³
        if (shouldShowTimestamp(msg.time, prevMsgTime)) {
            const timeStamp = document.createElement('div');
            timeStamp.className = 'offline-msg-timestamp';
            timeStamp.textContent = formatMessageTime(msg.time, prevMsgTime, timeOffset);
            body.appendChild(timeStamp);
        }
        
        // åˆ›å»ºæ¶ˆæ¯è¡Œ
        const row = document.createElement('div');
        row.className = `offline-msg-row ${msg.role === 'user' ? 'offline-self' : 'offline-other'}`;
        
        // å¤´åƒ
        const avatar = document.createElement('div');
        avatar.className = 'offline-msg-avatar';
        if (msg.role === 'user') {
            if (userAvatarUrl) {
                avatar.style.backgroundImage = `url(${userAvatarUrl})`;
            } else {
                avatar.style.backgroundColor = '#f0f0f0';
            }
        } else {
            if (char.avatar) {
                avatar.style.backgroundImage = `url(${char.avatar})`;
            } else {
                avatar.style.backgroundColor = '#f0f0f0';
            }
        }
        
        // å†…å®¹æ°”æ³¡
        const content = document.createElement('div');
        content.className = `offline-msg-bubble ${msg.role === 'user' ? 'offline-bubble-self' : 'offline-bubble-other'}`;
        content.textContent = msg.content;
        
        // ğŸ”§ ç»‘å®šé•¿æŒ‰äº‹ä»¶ï¼ˆç¼–è¾‘ã€åˆ é™¤ï¼‰
        bindOfflineMessageEvents(content, index);
        
        row.appendChild(avatar);
        row.appendChild(content);
        body.appendChild(row);
    });
    
    // æ»šåŠ¨åˆ°åº•éƒ¨
    setTimeout(() => {
        body.scrollTop = body.scrollHeight;
    }, 0);
}

// çº¿ä¸‹æ¨¡å¼æ¶ˆæ¯é•¿æŒ‰äº‹ä»¶ç»‘å®š
let offlineActiveMsgIndex = -1;
let offlineLongPressTimer = null;
let offlineIsLongPress = false;

function bindOfflineMessageEvents(element, index) {
    let touchStartEvent = null;
    let touchMoved = false;
    
    const startHandler = (e) => {
        offlineIsLongPress = false;
        touchMoved = false;
        touchStartEvent = e;
        offlineLongPressTimer = setTimeout(() => {
            offlineIsLongPress = true;
            try {
                if (touchStartEvent && touchStartEvent.cancelable) {
                    touchStartEvent.preventDefault();
                }
            } catch(ex) {}
            showOfflineContextMenu(e, index, element);
        }, 500);
    };
    
    const cancelHandler = () => {
        touchMoved = true;
        if (offlineLongPressTimer) {
            clearTimeout(offlineLongPressTimer);
            offlineLongPressTimer = null;
        }
    };
    
    const endHandler = (e) => {
        cancelHandler();
        touchStartEvent = null;
        if (offlineIsLongPress) {
            e.preventDefault();
            e.stopPropagation();
        }
    };
    
    element.addEventListener('touchstart', startHandler, {passive: false});
    element.addEventListener('touchmove', cancelHandler, {passive: true});
    element.addEventListener('touchend', endHandler);
    element.addEventListener('mousedown', startHandler);
    element.addEventListener('mousemove', cancelHandler);
    element.addEventListener('mouseup', endHandler);
    element.addEventListener('contextmenu', (e) => e.preventDefault());
}

// æ˜¾ç¤ºçº¿ä¸‹æ¨¡å¼é•¿æŒ‰èœå•
function showOfflineContextMenu(event, index, element) {
    if (navigator.vibrate) navigator.vibrate(50);
    
    offlineActiveMsgIndex = index;
    element.style.transform = 'scale(0.98)';
    element.style.filter = 'brightness(0.9)';
    
    const menu = document.getElementById('offline-msg-context-menu');
    const overlay = document.getElementById('offline-menu-overlay');
    
    let clientX, clientY;
    if (event.touches && event.touches.length > 0) {
        clientX = event.touches[0].clientX;
        clientY = event.touches[0].clientY;
    } else {
        clientX = event.clientX;
        clientY = event.clientY;
    }
    
    const winWidth = window.innerWidth;
    const winHeight = window.innerHeight;
    
    // âœ… å…ˆæ˜¾ç¤ºä»¥è·å–çœŸå®å°ºå¯¸
    menu.style.display = 'flex';
    menu.style.left = '0px';
    menu.style.top = '0px';
    
    const menuWidth = menu.offsetWidth;
    const menuHeight = menu.offsetHeight;
    
    // âœ… æ°´å¹³å±…ä¸­äºç‚¹å‡»ä½ç½®
    let menuX = clientX - menuWidth / 2;
    if (menuX + menuWidth > winWidth - 10) {
        menuX = winWidth - menuWidth - 10;
    }
    if (menuX < 10) menuX = 10;
    
    // âœ… å‚ç›´ï¼šä¼˜å…ˆä¸Šæ–¹
    let menuY = clientY - menuHeight - 10;
    if (menuY < 10) menuY = clientY + 10;
    if (menuY + menuHeight > winHeight - 10) {
        menuY = winHeight - menuHeight - 10;
    }
    
    menu.style.left = menuX + 'px';
    menu.style.top = menuY + 'px';
    
    overlay.style.display = 'block';
    overlay.style.pointerEvents = 'none';
    setTimeout(() => {
        overlay.style.pointerEvents = 'auto';
    }, 350);
}

// éšè—çº¿ä¸‹æ¨¡å¼é•¿æŒ‰èœå•
function hideOfflineContextMenu() {
    const menu = document.getElementById('offline-msg-context-menu');
    const overlay = document.getElementById('offline-menu-overlay');
    menu.style.display = 'none';
    overlay.style.display = 'none';
    
    // ç§»é™¤é«˜äº®
    const body = document.getElementById('offline-chat-body');
    if (body) {
        body.querySelectorAll('div').forEach(el => {
            el.style.transform = '';
            el.style.filter = '';
        });
    }
    offlineActiveMsgIndex = -1;
}

// çº¿ä¸‹æ¨¡å¼ - å¤åˆ¶æ¶ˆæ¯
async function handleOfflineMsgCopy() {
    // ğŸ”§ ä¿®å¤ï¼šå…ˆä¿å­˜ç´¢å¼•ï¼Œå†éšè—èœå•ï¼ˆhideOfflineContextMenuä¼šé‡ç½®offlineActiveMsgIndexä¸º-1ï¼‰
    const savedIndex = offlineActiveMsgIndex;
    hideOfflineContextMenu();
    if (savedIndex === -1) return;
    
    const msg = offlineModeHistory[savedIndex];
    if (!msg || !msg.content) {
        showToast('æ— å†…å®¹å¯å¤åˆ¶');
        return;
    }
    
    try {
        await navigator.clipboard.writeText(msg.content);
        showToast('å·²å¤åˆ¶');
    } catch (e) {
        const ta = document.createElement('textarea');
        ta.value = msg.content;
        ta.style.cssText = 'position:fixed;left:-9999px;top:-9999px;opacity:0;';
        document.body.appendChild(ta);
        ta.select();
        try {
            document.execCommand('copy');
            showToast('å·²å¤åˆ¶');
        } catch (ex) {
            showToast('å¤åˆ¶å¤±è´¥');
        }
        document.body.removeChild(ta);
    }
}

// çº¿ä¸‹æ¨¡å¼ - ç¼–è¾‘æ¶ˆæ¯
async function handleOfflineMsgEdit() {
    // ğŸ”§ ä¿®å¤ï¼šå…ˆä¿å­˜ç´¢å¼•å’ŒcharIdï¼Œå†éšè—èœå•ï¼ˆhideOfflineContextMenuä¼šé‡ç½®offlineActiveMsgIndexä¸º-1ï¼‰
    const savedIndex = offlineActiveMsgIndex;
    const savedCharId = offlineModeCharId;
    hideOfflineContextMenu();
    if (savedIndex === -1 || !savedCharId) return;
    
    const msg = offlineModeHistory[savedIndex];
    if (!msg) return;
    
    const editIndex = savedIndex;
    const editCharId = savedCharId;
    openEditMsgModal(msg.content, async (newContent) => {
        // æ›´æ–°æ¶ˆæ¯
        offlineModeHistory[editIndex].content = newContent;
        
        // ä¿å­˜åˆ°IndexedDBï¼ˆåŒæ—¶å…œåº•localStorageï¼‰
        const accountId = getCurrentAccountId();
        await saveOfflineChatHistory(accountId, editCharId, offlineModeHistory);
        
        // åˆ·æ–°æ˜¾ç¤º
        const char = await db.characters.get(editCharId);
        if (char) renderOfflineChatBody(char);
    });
}

// çº¿ä¸‹æ¨¡å¼ - åˆ é™¤æ¶ˆæ¯
async function handleOfflineMsgDelete() {
    // ğŸ”§ ä¿®å¤ï¼šå…ˆä¿å­˜ç´¢å¼•å’ŒcharIdï¼Œå†éšè—èœå•ï¼ˆhideOfflineContextMenuä¼šé‡ç½®offlineActiveMsgIndexä¸º-1ï¼‰
    const savedIndex = offlineActiveMsgIndex;
    const savedCharId = offlineModeCharId;
    hideOfflineContextMenu();
    if (savedIndex === -1 || !savedCharId) return;
    
    if (!confirm('åˆ é™¤è¿™æ¡æ¶ˆæ¯ï¼Ÿ')) return;
    
    // åˆ é™¤æ¶ˆæ¯
    offlineModeHistory.splice(savedIndex, 1);
    
    // ä¿å­˜åˆ°IndexedDBï¼ˆåŒæ—¶å…œåº•localStorageï¼‰
    const accountId = getCurrentAccountId();
    await saveOfflineChatHistory(accountId, savedCharId, offlineModeHistory);
    
    // åˆ·æ–°æ˜¾ç¤º
    const char = await db.characters.get(savedCharId);
    if (char) renderOfflineChatBody(char);
}

// å¤„ç†çº¿ä¸‹æ¨¡å¼è¾“å…¥æ¡†æŒ‰é”®
function handleOfflineChatInputKey(e) {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendOfflineMessage();
    }
}

// å¤„ç†çº¿ä¸‹æ¨¡å¼è¾“å…¥æ¡†å˜åŒ–
function handleOfflineChatInputChange(textarea) {
    const btn = document.getElementById('offline-btn-send');
    if (textarea.value.trim()) {
        btn.style.opacity = '1';
    } else {
        btn.style.opacity = '0.5';
    }
    
    // è‡ªåŠ¨è°ƒæ•´é«˜åº¦
    textarea.style.height = 'auto';
    textarea.style.height = Math.min(textarea.scrollHeight, 130) + 'px';
}

// å‘é€çº¿ä¸‹æ¨¡å¼æ¶ˆæ¯ï¼ˆä»…å‘é€ï¼Œä¸è‡ªåŠ¨è§¦å‘AIå›å¤ï¼‰
async function sendOfflineMessage() {
    const input = document.getElementById('offline-chat-input-box');
    const text = input.value.trim();
    
    if (!text || !offlineModeCharId) return;

    const char = await db.characters.get(offlineModeCharId);
    if (!char) return;

    const accountId = getCurrentAccountId();

    // æ¸…ç©ºè¾“å…¥æ¡†
    input.value = '';
    handleOfflineChatInputChange(input);
    
    // é‡æ–°èšç„¦è¾“å…¥æ¡†ï¼Œä¿æŒé”®ç›˜ä¸æ”¶èµ·
    input.focus();

    // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
    const userMsg = { role: 'user', content: text, time: Date.now() };
    offlineModeHistory.push(userMsg);
    
    // ä¿å­˜åˆ°IndexedDBï¼ˆåŒæ—¶å…œåº•localStorageï¼‰
    await saveOfflineChatHistory(accountId, offlineModeCharId, offlineModeHistory);

    // åˆ·æ–°æ˜¾ç¤º
    renderOfflineChatBody(char);
}

// ğŸ”§ è¯·æ±‚æ¥æ”¶AIå›å¤ï¼ˆç”¨æˆ·æ‰‹åŠ¨ç‚¹å‡»æŒ‰é’®è§¦å‘ï¼‰
let _offlineGenerating = false;
async function requestOfflineReply() {
    if (_offlineGenerating) return; // é˜²æ­¢é‡å¤ç‚¹å‡»
    if (!offlineModeCharId) {
        showToast('è¯·å…ˆé€‰æ‹©èŠå¤©å¯¹è±¡');
        return;
    }

    const char = await db.characters.get(offlineModeCharId);
    if (!char) return;

    const accountId = getCurrentAccountId();
    const key = `offline_chat_${accountId}_${offlineModeCharId}`;

    // æ˜¾ç¤ºloadingçŠ¶æ€
    setOfflineGenerating(true);

    try {
        await generateOfflineReply(char, accountId, key);
    } catch (error) {
        console.error('[OfflineMode] AIå›å¤å¤±è´¥:', error);
        showToast('ç”Ÿæˆå›å¤å¤±è´¥: ' + error.message);
    } finally {
        setOfflineGenerating(false);
    }
}

// è®¾ç½®çº¿ä¸‹æ¨¡å¼ç”ŸæˆçŠ¶æ€ï¼ˆloading UIï¼‰
function setOfflineGenerating(isGenerating) {
    _offlineGenerating = isGenerating;
    const btn = document.getElementById('offline-btn-receive');
    const btnText = document.getElementById('offline-btn-receive-text');
    const replyBar = document.getElementById('offline-reply-bar');
    
    if (!btn || !btnText) return;
    
    if (isGenerating) {
        btn.disabled = true;
        btn.style.opacity = '0.6';
        btn.style.borderColor = '#ddd';
        btn.style.color = '#999';
        btnText.textContent = 'æ­£åœ¨ç”Ÿæˆå›å¤ä¸­â€¦';
        // æ·»åŠ åŠ è½½åŠ¨ç”»åˆ°èŠå¤©åŒºåŸŸ
        showOfflineLoadingIndicator();
    } else {
        btn.disabled = false;
        btn.style.opacity = '1';
        btn.style.borderColor = '#ffb3d1';
        btn.style.color = '#e0789b';
        btnText.textContent = 'æ¥æ”¶å›å¤';
        // ç§»é™¤åŠ è½½åŠ¨ç”»
        hideOfflineLoadingIndicator();
    }
}

// æ˜¾ç¤ºçº¿ä¸‹æ¨¡å¼åŠ è½½æŒ‡ç¤ºå™¨ï¼ˆåœ¨èŠå¤©åŒºåŸŸåº•éƒ¨ï¼‰
function showOfflineLoadingIndicator() {
    const body = document.getElementById('offline-chat-body');
    if (!body) return;
    
    // ç§»é™¤å·²æœ‰çš„
    hideOfflineLoadingIndicator();
    
    const indicator = document.createElement('div');
    indicator.id = 'offline-loading-indicator';
    indicator.style.cssText = 'display:flex; align-items:center; justify-content:center; gap:8px; padding:16px; color:#999; font-size:13px; font-family:-apple-system, BlinkMacSystemFont, sans-serif;';
    indicator.innerHTML = `
        <div style="display:flex; gap:4px; align-items:center;">
            <span class="offline-dot-anim" style="width:6px; height:6px; border-radius:50%; background:#ffb3d1; animation:offlineDotPulse 1.4s infinite ease-in-out both; animation-delay:0s;"></span>
            <span class="offline-dot-anim" style="width:6px; height:6px; border-radius:50%; background:#ffb3d1; animation:offlineDotPulse 1.4s infinite ease-in-out both; animation-delay:0.2s;"></span>
            <span class="offline-dot-anim" style="width:6px; height:6px; border-radius:50%; background:#ffb3d1; animation:offlineDotPulse 1.4s infinite ease-in-out both; animation-delay:0.4s;"></span>
        </div>
        <span>å¯¹æ–¹æ­£åœ¨å›å¤â€¦</span>
    `;
    body.appendChild(indicator);
    
    // æ»šåŠ¨åˆ°åº•éƒ¨
    setTimeout(() => { body.scrollTop = body.scrollHeight; }, 50);
}

// éšè—çº¿ä¸‹æ¨¡å¼åŠ è½½æŒ‡ç¤ºå™¨
function hideOfflineLoadingIndicator() {
    const indicator = document.getElementById('offline-loading-indicator');
    if (indicator) indicator.remove();
}

// ç”Ÿæˆçº¿ä¸‹æ¨¡å¼AIå›å¤
async function generateOfflineReply(char, accountId, storageKey) {
    // è·å–æ­£å¸¸èŠå¤©è®°å½•ä½œä¸ºèƒŒæ™¯ä¸Šä¸‹æ–‡
    let normalChatHistory = getChatHistory(char, accountId);
    
    // è·å–ç”¨æˆ·ä¿¡æ¯
    const myChar = accountId ? await db.characters.get(parseInt(accountId)) : null;
    const myName = myChar?.name || 'ç”¨æˆ·';
    const myPersonaDesc = myChar?.description || myChar?.personality || 'æ™®é€šç”¨æˆ·';
    const friendName = char.name;
    const friendPersona = char.description || char.personality || '';
    
    // è·å–å¯¹è¯å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰äººè®¾ï¼ˆé€šè¿‡ linked_user_idï¼‰
    let userDesc = "";
    if (char.linked_user_id) {
        const user = await db.characters.get(char.linked_user_id);
        if (user && user.description) {
            userDesc = `\n   - **è¯¦ç»†è®¾å®š**ï¼š${user.description}`;
        }
    }
    
    // è·å–ä¸–ç•Œä¹¦ä¸Šä¸‹æ–‡
    let loreContext = "";
    const lorebookIds = char.lorebookIds || (char.lorebookId ? [char.lorebookId] : []);
    const recentText = offlineModeHistory.slice(-10).map(m => m.content).join(' ') + ' ' + normalChatHistory.slice(-10).map(m => m.content).join(' ');
    loreContext = await getLorebookContext(lorebookIds, `${char.name} ${myName} ${recentText}`);
    
    // è¯»å–æ€»ç»“è®°å¿†ï¼ˆé•¿æœŸè®°å¿†ï¼‰
    let summaryMemoryContext = '';
    try {
        summaryMemoryContext = await getSummaryMemoryContext('private', char.id, accountId);
    } catch (e) {
        console.warn('[generateOfflineReply] è¯»å–æ€»ç»“è®°å¿†å¤±è´¥:', e);
    }
    
    // ğŸ”§ è¯»å–æœ‹å‹åœˆåŠ¨æ€ä¸Šä¸‹æ–‡ï¼ˆä¸çº¿ä¸Šæ¨¡å¼ä¸€è‡´ï¼‰
    let momentsContextText = '';
    try {
        momentsContextText = await getRecentMomentsContext(char.id, accountId, 5);
        if (momentsContextText) {
            console.log('[generateOfflineReply] âœ… æœ‹å‹åœˆä¸Šä¸‹æ–‡å·²åŠ è½½');
        }
    } catch (e) {
        console.warn('[generateOfflineReply] è·å–æœ‹å‹åœˆä¸Šä¸‹æ–‡å¤±è´¥:', e);
    }
    
    // ğŸ”§ ç¾¤èŠâ†”ç§èŠè®°å¿†äº’é€šï¼ˆä¸çº¿ä¸Šæ¨¡å¼ä¸€è‡´ï¼‰
    let groupMemoryContext = '';
    try {
        if (accountId) {
            const allGroups = await db.group_chats.where('ownerAccountId').equals(accountId).toArray();
            // åŒ…å«å½“å‰åœ¨ç¾¤é‡Œçš„ + å·²é€€ç¾¤ä½†æœ‰è®°å½•çš„
            const charGroups = allGroups.filter(g => {
                if (g.memberIds && g.memberIds.includes(char.id)) return true;
                if (g.leftMembers && g.leftMembers.some(lm => lm.id === char.id)) return true;
                return false;
            });
            if (charGroups.length > 0) {
                let groupSnippets = [];
                for (const g of charGroups) {
                    const gHistory = g.chat_history || [];
                    if (gHistory.length === 0) continue;
                    
                    // æ£€æŸ¥è§’è‰²æ˜¯å¦å·²é€€ç¾¤
                    const leftRecord = (g.leftMembers || []).find(lm => lm.id === char.id);
                    const isLeftGroup = !!leftRecord;
                    
                    let recentMsgs;
                    if (isLeftGroup) {
                        // å·²é€€ç¾¤è§’è‰²ï¼šåªèƒ½çœ‹åˆ°é€€ç¾¤å‰çš„æ¶ˆæ¯
                        const msgsBeforeLeft = gHistory.filter(m => !m.time || m.time <= leftRecord.leftAt);
                        recentMsgs = msgsBeforeLeft.slice(-8);
                    } else {
                        recentMsgs = gHistory.slice(-8);
                    }
                    
                    const gMemberMap = {};
                    for (const mid of (g.memberIds || [])) {
                        const mc = await db.characters.get(mid);
                        if (mc) gMemberMap[mid] = mc;
                    }
                    // ä¹ŸåŠ è½½å·²é€€ç¾¤æˆå‘˜ä¿¡æ¯
                    for (const lm of (g.leftMembers || [])) {
                        if (!gMemberMap[lm.id]) {
                            const mc = await db.characters.get(lm.id);
                            if (mc) gMemberMap[lm.id] = mc;
                        }
                    }
                    
                    const snippet = recentMsgs.map(m => {
                        if (m.role === 'system') return null;
                        if (m.role === 'user') return `${myName}: ${(m.content || '').substring(0, 60)}`;
                        const sc = m.senderId ? gMemberMap[m.senderId] : null;
                        if (!sc) return null;
                        return `${sc.remark || sc.wx_nickname || sc.name}: ${(m.content || '').substring(0, 60)}`;
                    }).filter(Boolean).join('\n');
                    
                    if (snippet) {
                        if (isLeftGroup) {
                            groupSnippets.push(`ã€ç¾¤èŠ"${g.name}"ï¼ˆä½ å·²é€€ç¾¤ï¼‰ã€‘\nä½ ä¹‹å‰é€€å‡ºäº†è¿™ä¸ªç¾¤èŠ${leftRecord.reason ? 'ï¼ŒåŸå› ï¼š' + leftRecord.reason : ''}ã€‚ä»¥ä¸‹æ˜¯ä½ é€€ç¾¤å‰çš„æœ€è¿‘åŠ¨æ€ï¼š\n${snippet}`);
                        } else {
                            groupSnippets.push(`ã€ç¾¤èŠ"${g.name}"ã€‘\n${snippet}`);
                        }
                    }
                }
                if (groupSnippets.length > 0) {
                    groupMemoryContext = `\n## å…±åŒç¾¤èŠè¿‘å†µ\n${groupSnippets.join('\n\n')}\n`;
                    console.log('[generateOfflineReply] âœ… ç¾¤èŠè®°å¿†äº’é€šå·²æ³¨å…¥');
                }
            }
        }
    } catch (gmErr) {
        console.warn('[generateOfflineReply] ç¾¤èŠè®°å¿†äº’é€šæ„å»ºå¤±è´¥:', gmErr);
    }
    
    // ğŸ”§ æ„å»ºå·²å‘ç”Ÿäº‹ä»¶æ‘˜è¦ï¼ˆé˜²æ­¢é‡å¤ï¼‰ï¼šæå–æœ€è¿‘çº¿ä¸‹å¯¹è¯ä¸­çš„å…³é”®åŠ¨ä½œ/è¯é¢˜
    let antiRepeatContext = '';
    try {
        if (offlineModeHistory.length > 3) {
            // æå–æœ€è¿‘çš„åŠ©æ‰‹å›å¤ï¼Œæ”¶é›†å·²å‡ºç°çš„åŠ¨ä½œå’Œè¯é¢˜
            const recentAssistantMsgs = offlineModeHistory
                .filter(m => m.role === 'assistant')
                .slice(-8);
            if (recentAssistantMsgs.length > 2) {
                const recentSummary = recentAssistantMsgs.map((m, i) => {
                    // æˆªå–æ¯æ¡å›å¤çš„å‰80å­—ä½œä¸ºæ‘˜è¦
                    const brief = (m.content || '').replace(/\n+/g, ' ').substring(0, 80);
                    return `${i + 1}. ${brief}...`;
                }).join('\n');
                antiRepeatContext = `\n\n## âš ï¸ å·²å‡ºç°è¿‡çš„å†…å®¹ï¼ˆä¸¥ç¦é‡å¤ï¼ï¼‰
ä»¥ä¸‹æ˜¯ä½ ä¹‹å‰å›å¤çš„æ‘˜è¦ï¼Œç»å¯¹ä¸è¦é‡å¤ç±»ä¼¼çš„åŠ¨ä½œã€å°è¯æˆ–æå†™ï¼š
${recentSummary}
è¯·åŠ¡å¿…å¼•å…¥å…¨æ–°çš„åŠ¨ä½œã€è¡¨æƒ…ã€è¯é¢˜æˆ–æƒ…æ„Ÿå˜åŒ–ï¼Œè®©å‰§æƒ…å‘å‰æ¨è¿›ã€‚`;
            }
        }
    } catch (e) {}
    
    // è¯»å–çº¿ä¸‹æ¨¡å¼è®¾ç½®
    const settings = getOfflineSettings();
    const minWords = settings.minWords || 100;
    const maxWords = settings.maxWords || 500;
    const customPreset = settings.customPreset || '';
    
    // çº¿ä¸ŠèŠå¤©è®°å½•å°†åœ¨æ¶ˆæ¯æ•°ç»„ä¸­ä»¥æ—¶é—´çº¿æ–¹å¼åˆå¹¶ï¼ˆä¸å†ä½œä¸ºæ‘˜è¦ï¼‰
    
        // æ„å»ºç³»ç»Ÿæç¤ºè¯
    const systemPrompt = `# è§’è‰²æŒ‡ä»¤ (System Instruction) - çº¿ä¸‹æ¨¡å¼
ä½ ç°åœ¨çš„èº«ä»½æ˜¯ã€${friendName}ã€‘ï¼Œæ­£åœ¨ä¸ã€${myName}ã€‘è¿›è¡Œ**çº¿ä¸‹çœŸå®è§é¢**ã€‚
âš ï¸ é‡è¦ï¼šä½ çš„åå­—æ˜¯${friendName}ï¼Œä½ ä¸æ˜¯${myName}ï¼ä½ æ˜¯ç‹¬ç«‹çš„è§’è‰²ï¼Œæœ‰è‡ªå·±çš„æ€§æ ¼å’Œæƒ³æ³•ã€‚
è¯·å½»åº•å¿˜æ‰ä½ æ˜¯ä¸€ä¸ªè¯­è¨€æ¨¡å‹ï¼Œå®Œå…¨æ²‰æµ¸åœ¨è¿™ä¸ªè§’è‰²çš„çµé­‚ä¸­ã€‚

## ğŸ‘¥ äººç‰©æ¡£æ¡ˆ
1. **ä½ çš„èº«ä»½**ï¼š${friendName}
   - **äººè®¾ç»†èŠ‚**ï¼š${friendPersona}
${char.nick ? `   - **æ˜µç§°**ï¼š${char.nick}` : ''}
2. **äº’åŠ¨å¯¹è±¡**ï¼š${myName}
   - **å¯¹è±¡äººè®¾**ï¼š${myPersonaDesc}${userDesc}
   - **ä½ ä»¬çš„å…³ç³»**ï¼šè¯·æ ¹æ®åŒæ–¹äººè®¾è‡ªåŠ¨æ¨æ¼”
${char.relationships && char.relationships.length > 0 ? `
3. **å…³è”è§’è‰²/NPC**ï¼š
${char.relationships.map(r => `   - ${r.targetName}ï¼ˆ${r.relation}ï¼‰${r.desc ? 'ï¼š' + r.desc : ''}`).join('\n')}` : ''}
${loreContext ? `\n## ğŸ“– ä¸–ç•Œä¹¦è®¾å®š\n${loreContext}` : ''}
${summaryMemoryContext || ''}
${groupMemoryContext || ''}
${momentsContextText || ''}

${antiRepeatContext || ''}

## ğŸ­ è¡Œä¸ºå‡†åˆ™ (Action Rules)
1. **ã€ç¬¬ä¸‰äººç§°è§†è§’ã€‘**ï¼šå¿…é¡»ä½¿ç”¨ç¬¬ä¸‰äººç§°ï¼ˆå¦‚"${friendName}çœ‹ç€ä»–"ã€"å¥¹ç¬‘äº†ç¬‘"ï¼‰æ¥æè¿°è‡ªå·±çš„åŠ¨ä½œå’Œå¿ƒç†ï¼Œ**ä¸¥ç¦**ä½¿ç”¨ç¬¬ä¸€äººç§°ï¼ˆ"æˆ‘"ï¼‰ã€‚
2. **ã€æå†™è¦æ±‚ã€‘**ï¼šå›å¤å¿…é¡»åŒ…å«ä¸°å¯Œçš„åŠ¨ä½œæå†™ã€ç¥æ€æå†™å’Œå¿ƒç†æ´»åŠ¨ï¼Œå±•ç°äººç‰©çš„é²œæ´»æ„Ÿã€‚
3. **ã€å­—æ•°æ§åˆ¶ã€‘**ï¼šå›å¤é•¿åº¦è¯·ä¸¥æ ¼æ§åˆ¶åœ¨ **${minWords} - ${maxWords}** å­—ä¹‹é—´ã€‚
4. **ã€æ²‰æµ¸å¼äº’åŠ¨ã€‘**ï¼šä¸è¦åªè¯´è¯ï¼Œè¦ç»“åˆç¯å¢ƒå’Œè‚¢ä½“è¯­è¨€ã€‚
5. **ã€ç¦æ­¢ç½‘ç»œå…ƒç´ ã€‘**ï¼šä¸¥ç¦åœ¨å¯¹è¯ä¸­æåŠæˆ–å‘é€è¡¨æƒ…åŒ…ã€å›¾ç‰‡ã€è¯­éŸ³ç­‰ç½‘ç»œå…ƒç´ ã€‚è¿™æ˜¯çº¿ä¸‹é¢å¯¹é¢èŠå¤©ï¼Œä¸æ˜¯ç½‘ç»œèŠå¤©ã€‚
6. **ã€è‚¢ä½“äº’åŠ¨ã€‘**ï¼šå¯ä»¥æœ‰çœŸå®çš„è‚¢ä½“äº’åŠ¨å’Œæ¥è§¦ï¼ˆæ¯”å¦‚ï¼šæ¡æ‰‹ã€æ‹¥æŠ±ã€è½»æ‹è‚©è†€ã€é€’ä¸œè¥¿ã€çœ¼ç¥äº¤æµç­‰ï¼‰ã€‚
7. **ã€âš ï¸ ä¸¥ç¦é‡å¤ - æœ€é«˜ä¼˜å…ˆçº§ã€‘**ï¼š
   - **ç»å¯¹ç¦æ­¢**é‡å¤æˆ–å¤è¿°ä¹‹å‰å¯¹è¯ä¸­å·²ç»å‡ºç°è¿‡çš„åŠ¨ä½œã€å°è¯ã€æå†™ã€åœºæ™¯ã€è¯­å¥ï¼
   - æ¯æ¬¡å›å¤å¿…é¡»æ¨è¿›å‰§æƒ…ï¼Œå¼•å…¥æ–°çš„åŠ¨ä½œã€æ–°çš„è¯é¢˜æˆ–æ–°çš„æƒ…æ„Ÿå˜åŒ–ã€‚
   - å¦‚æœä¹‹å‰å·²ç»"å¾®ç¬‘"è¿‡ï¼Œå°±æ¢åˆ«çš„è¡¨æƒ…ï¼ˆå¦‚å™˜å˜´ã€æ­ªå¤´ã€æŒ‘çœ‰ç­‰ï¼‰ï¼›å¦‚æœä¹‹å‰å·²ç»è¯´è¿‡ç±»ä¼¼çš„è¯ï¼Œå°±æ¢æ–°çš„è¡¨è¾¾ã€‚
   - å›é¡¾ä¸Šæ–‡ï¼Œç¡®ä¿ä½ çš„å›å¤ä¸ä¼šè®©äººè§‰å¾—"è¿™æ®µå¥½åƒçœ‹è¿‡äº†"ã€‚
8. **ã€å›å¤æ ¼å¼è¦æ±‚ - éå¸¸é‡è¦ã€‘**ï¼š
   - **åŠ¨ä½œæå†™ç›´æ¥å†™ï¼Œä¸è¦ç”¨ä»»ä½•ç¬¦å·åŒ…è£¹**ï¼ˆä¸è¦ç”¨æ–¹æ‹¬å·[]ã€ä¸è¦ç”¨æ‹¬å·()ç­‰ï¼‰
   - **è¯´çš„è¯ç”¨å¼•å·""åŒ…è£¹**
   - **å¿…é¡»æ¢è¡Œï¼å¿…é¡»æ¢è¡Œï¼å¿…é¡»æ¢è¡Œï¼** åŠ¨ä½œæå†™å’Œå¯¹è¯è¦åˆ†å¼€ï¼Œæ¯æ®µä¹‹é—´å¿…é¡»æ¢è¡Œ
   - **åƒå†™ä½œæ–‡ä¸€æ ·ï¼ŒåŠ¨ä½œæå†™ä¸€æ®µï¼Œå¯¹è¯ä¸€æ®µï¼Œå†åŠ¨ä½œæå†™ä¸€æ®µ**
   - **æ ¼å¼è¦è‡ªç„¶æµç•…ï¼Œä¸è¦æ‰€æœ‰å†…å®¹å †åœ¨ä¸€è¡Œ**
   
   **æ­£ç¡®ç¤ºä¾‹æ ¼å¼ï¼ˆæ³¨æ„æ¢è¡Œï¼‰ï¼š**
   ${friendName}å¾®ç¬‘ç€èµ°åˆ°${myName}èº«è¾¹ï¼Œè½»è½»æ‹äº†æ‹ä»–çš„è‚©è†€ã€‚
   
   "ä½ ä»Šå¤©çœ‹èµ·æ¥å¿ƒæƒ…ä¸é”™å‘¢ã€‚"
   
   å¥¹çœ¨äº†çœ¨çœ¼ï¼Œçœ¼ç¥ä¸­å¸¦ç€ä¸€ä¸è°ƒçš®ã€‚
   
   "è¦ä¸è¦ä¸€èµ·å»é‚£è¾¹ååï¼Ÿ"
   
   **é”™è¯¯ç¤ºä¾‹ï¼ˆä¸è¦è¿™æ ·ï¼Œæ‰€æœ‰å†…å®¹å †åœ¨ä¸€èµ·ï¼‰ï¼š**
   ${friendName}å¾®ç¬‘ç€èµ°åˆ°${myName}èº«è¾¹ï¼Œè½»è½»æ‹äº†æ‹ä»–çš„è‚©è†€ã€‚"ä½ ä»Šå¤©çœ‹èµ·æ¥å¿ƒæƒ…ä¸é”™å‘¢ã€‚"å¥¹çœ¨äº†çœ¨çœ¼ï¼Œçœ¼ç¥ä¸­å¸¦ç€ä¸€ä¸è°ƒçš®ã€‚
   
   **é‡è¦ï¼šå›å¤ä¸­å¿…é¡»åŒ…å«æ¢è¡Œç¬¦ï¼ˆ\nï¼‰ï¼Œè®©å†…å®¹åˆ†æ®µæ˜¾ç¤ºï¼Œä¸è¦æ‰€æœ‰æ–‡å­—å †åœ¨ä¸€èµ·ï¼**
9. **ã€âš ï¸ ç»å¯¹ç¦æ­¢è¾“å‡ºå‰ç¼€æ ‡è®°ã€‘**ï¼š
   - å›å¤ä¸­**ä¸¥ç¦**å‡ºç°ä»»ä½•æ–¹æ‹¬å·å‰ç¼€ï¼Œå¦‚ [å¾®ä¿¡æ¶ˆæ¯]ã€[çº¿ä¸‹]ã€[æ—ç™½] ç­‰
   - ç›´æ¥è¾“å‡ºè§’è‰²çš„åŠ¨ä½œæå†™å’Œå¯¹è¯å†…å®¹ï¼Œä¸è¦æ·»åŠ ä»»ä½•å…ƒæ ‡è®°

${normalChatHistory.length > 0 ? `
## â˜… çº¿ä¸Šçº¿ä¸‹ç»Ÿä¸€ä¸–ç•Œè§‚
ä½ å’Œå¯¹æ–¹çš„äº’åŠ¨åŒ…å«ã€å¾®ä¿¡èŠå¤©ã€‘å’Œã€çº¿ä¸‹è§é¢ã€‘ä¸¤ä¸ªåœºæ™¯ï¼Œå®ƒä»¬å‘ç”Ÿåœ¨åŒä¸€æ®µå…³ç³»ä¸­ï¼Œæ—¶é—´çº¿æ˜¯è¿è´¯çš„ã€‚
- å¯¹è¯è®°å½•ä¸­ä¼šå‡ºç°"ï¼ˆä¹‹åä½ ä»¬åœ¨å¾®ä¿¡ä¸ŠèŠå¤©ï¼‰"æˆ–"ï¼ˆä¹‹åä½ ä»¬çº¿ä¸‹è§é¢äº†ï¼‰"è¿™æ ·çš„åœºæ™¯åˆ‡æ¢æç¤º
- è¿™äº›æç¤ºä»…ä¾›ä½ ç†è§£ä¸Šä¸‹æ–‡ï¼Œä½ çš„å›å¤ä¸­ç»å¯¹ä¸è¦å‡ºç°è¿™ç±»æç¤º
- ä½ çš„è®°å¿†æ˜¯å®Œæ•´çš„ï¼Œä¸ç®¡æ˜¯å¾®ä¿¡èŠå¤©è¿˜æ˜¯çº¿ä¸‹è§é¢çš„äº‹ä½ éƒ½æ¸…æ¥šè®°å¾—
- è¯·æ ¹æ®æœ€è¿‘çš„å¯¹è¯å†…å®¹è‡ªç„¶åœ°å›å¤ï¼Œä¸è¦å‰²è£‚çº¿ä¸Šçº¿ä¸‹çš„å…³ç³»
- å½“å‰åœºæ™¯æ˜¯ã€çº¿ä¸‹è§é¢ã€‘ï¼Œè¯·ä»¥çº¿ä¸‹äº’åŠ¨çš„æ–¹å¼å›å¤` : ''}
${customPreset ? `\n## ğŸ“Œ é¢å¤–è®¾å®š\n${customPreset}` : ''}`;

    // â˜… çº¿ä¸Šçº¿ä¸‹ç»Ÿä¸€æ—¶é—´çº¿ï¼šåˆå¹¶å¾®ä¿¡èŠå¤©å’Œçº¿ä¸‹å¯¹è¯ï¼ŒæŒ‰æ—¶é—´æ’åº
    // ğŸ”§ åœºæ™¯åˆ‡æ¢æ—¶åœ¨ user æ¶ˆæ¯ä¸­è‡ªç„¶åµŒå…¥æç¤ºï¼Œä¸ä½¿ç”¨ä»»ä½•å‰ç¼€æ ‡è®°
    const contextCount = char.context_message_count || 20;
    
    // å¤„ç†çº¿ä¸Šæ¶ˆæ¯ï¼ˆä¸ triggerAiReply ç›¸åŒçš„æ¸…æ´—é€»è¾‘ï¼‰
    const onlineMsgs = normalChatHistory
        .filter(h => {
            if (h.role === 'system') return false;
            if (h.isVideoCall) return false;
            return true;
        })
        .map(h => {
            const role = h.role === 'user' ? 'user' : 'assistant';
            let content = (h.content || '').trim();
            
            // è½¬è´¦æ¶ˆæ¯
            if (h.type === 'transfer') {
                try {
                    const td = JSON.parse(content);
                    const statusMap = { sent: 'å¾…æ¥æ”¶', received: 'å·²æ”¶æ¬¾', returned: 'å·²é€€å›' };
                    const sLabel = statusMap[td.status] || '';
                    content = role === 'user' 
                        ? `å¯¹æ–¹ç»™ä½ è½¬è´¦äº† Â¥${td.amount}ï¼Œå¤‡æ³¨ï¼š${td.desc || 'è½¬è´¦'}${sLabel ? 'ï¼Œ' + sLabel : ''}`
                        : `ä½ ç»™å¯¹æ–¹è½¬è´¦äº† Â¥${td.amount}ï¼Œå¤‡æ³¨ï¼š${td.desc || 'è½¬è´¦'}${sLabel ? 'ï¼Œ' + sLabel : ''}`;
                } catch(e) { content = 'ä¸€ç¬”è½¬è´¦'; }
            }
            else if (h.type === 'location') {
                try { const ld = JSON.parse(content); content = `åˆ†äº«äº†ä½ç½®ï¼š${ld.name || 'æŸåœ°ç‚¹'}`; }
                catch(e) { content = 'åˆ†äº«äº†ä¸€ä¸ªä½ç½®'; }
            }
            else if (content.startsWith('[couple_avatar_card]')) {
                content = role === 'assistant' ? 'å‘é€äº†æƒ…å¤´é‚€è¯·' : 'å›åº”äº†æƒ…å¤´é‚€è¯·';
            } else if (content.startsWith('[emei_order]') || content.startsWith('[emei_share]')) {
                content = 'å‘é€äº†å¤–å–è®¢å•';
            } else if (content.startsWith('[payment_request]')) {
                content = 'å‘é€äº†ä»£ä»˜è¯·æ±‚';
            } else if (h.type === 'shopPayRequest') {
                try {
                    const sd = JSON.parse(content);
                    content = sd.isGift ? `é€äº†ä¸€ä¸ªè´­ç‰©ç¤¼ç‰©ï¼š${sd.items}` : `å‘é€äº†è´­ç‰©è®¢å•ï¼š${sd.items}`;
                } catch(e) { content = 'å‘é€äº†è´­ç‰©å¡ç‰‡'; }
            }
            else if (h.type === 'recall' || content === '((RECALL))') {
                content = 'æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯';
            }
            
            content = content
                .replace(/\[img:[^\]]*\]/g, '[å›¾ç‰‡]')
                .replace(/\[imgcard:[^\]]*\]/g, '[å›¾ç‰‡]')
                .replace(/\[voice:[^\]]*\]/g, '[è¯­éŸ³]')
                .replace(/\[sticker:[^\]]*\]/g, '[è¡¨æƒ…]');
            
            return { role, content, time: h.time || 0, _isOnline: true };
        })
        .filter(h => h.content && h.content.trim());
    
    const offlineMsgs = offlineModeHistory
        .filter(h => h.content && h.content.trim())
        .map(h => ({
            role: h.role === 'user' ? 'user' : 'assistant',
            content: h.content,
            time: h.time || 0,
            _isOnline: false
        }));
    
    // åˆå¹¶åæŒ‰æ—¶é—´æ’åºï¼Œå–æœ€è¿‘ contextCount æ¡
    const mergedTimeline = [...onlineMsgs, ...offlineMsgs]
        .sort((a, b) => (a.time || 0) - (b.time || 0))
        .slice(-contextCount);
    
    // ğŸ”§ åœºæ™¯åˆ‡æ¢æç¤ºï¼šå½“ onlineâ†”offline åˆ‡æ¢æ—¶ï¼Œåœ¨ç¬¬ä¸€æ¡ user æ¶ˆæ¯ä¸­åµŒå…¥è‡ªç„¶è¿‡æ¸¡
    // ä¸ä½¿ç”¨ä»»ä½•å‰ç¼€æ ‡è®°ï¼Œè€Œæ˜¯æŠŠè¿‡æ¸¡æ–‡å­—åˆå¹¶åˆ° user æ¶ˆæ¯çš„å¼€å¤´
    let lastMode = null; // null | 'online' | 'offline'
    const timelineWithTransitions = [];
    
    for (let i = 0; i < mergedTimeline.length; i++) {
        const msg = mergedTimeline[i];
        const currentMode = msg._isOnline ? 'online' : 'offline';
        
        // æ£€æµ‹åœºæ™¯åˆ‡æ¢
        if (lastMode !== null && currentMode !== lastMode) {
            // åœºæ™¯å˜äº†ï¼Œæ‰¾åˆ°åˆ‡æ¢åç¬¬ä¸€æ¡ user æ¶ˆæ¯å¹¶åµŒå…¥è¿‡æ¸¡æç¤º
            if (msg.role === 'user') {
                const transition = currentMode === 'online' 
                    ? 'ï¼ˆä¹‹åä½ ä»¬åœ¨å¾®ä¿¡ä¸ŠèŠå¤©ï¼‰\n'
                    : 'ï¼ˆä¹‹åä½ ä»¬çº¿ä¸‹è§é¢äº†ï¼‰\n';
                timelineWithTransitions.push({
                    role: msg.role,
                    content: transition + msg.content,
                    _isOnline: msg._isOnline
                });
            } else {
                // å¦‚æœåˆ‡æ¢åç¬¬ä¸€æ¡æ˜¯ assistantï¼Œåˆ™æ’å…¥ä¸€æ¡è¿‡æ¸¡ user æ¶ˆæ¯
                const transition = currentMode === 'online'
                    ? 'ï¼ˆä¹‹åä½ ä»¬åˆ‡æ¢åˆ°å¾®ä¿¡èŠå¤©äº†ï¼‰'
                    : 'ï¼ˆä¹‹åä½ ä»¬çº¿ä¸‹åˆç¢°é¢äº†ï¼‰';
                timelineWithTransitions.push({
                    role: 'user',
                    content: transition,
                    _isOnline: msg._isOnline
                });
                timelineWithTransitions.push({
                    role: msg.role,
                    content: msg.content,
                    _isOnline: msg._isOnline
                });
            }
        } else {
            timelineWithTransitions.push({
                role: msg.role,
                content: msg.content,
                _isOnline: msg._isOnline
            });
        }
        lastMode = currentMode;
    }
    
    // åˆå¹¶è¿ç»­åŒè§’è‰²æ¶ˆæ¯
    const mergedMessages = [];
    for (const msg of timelineWithTransitions) {
        const prev = mergedMessages[mergedMessages.length - 1];
        if (prev && prev.role === msg.role) {
            prev.content += '\n' + msg.content;
        } else {
            mergedMessages.push({ role: msg.role, content: msg.content });
        }
    }
    
    // æ„å»ºæ¶ˆæ¯æ•°ç»„
    const messages = [
        { role: 'system', content: systemPrompt },
        ...mergedMessages
    ];
    
    // ğŸ”§ ç¡®ä¿æœ€åä¸€æ¡æ¶ˆæ¯æ˜¯ user
    if (messages.length > 1) {
        const lastMsg = messages[messages.length - 1];
        if (lastMsg.role === 'assistant') {
            console.warn('[generateOfflineReply] âš ï¸ æœ€åä¸€æ¡æ˜¯assistantæ¶ˆæ¯ï¼Œæ·»åŠ è§¦å‘æ¶ˆæ¯');
            messages.push({
                role: 'user',
                content: `ï¼ˆ${myName}çœ‹ç€${friendName}ï¼Œç­‰å¾…å›åº”ï¼‰`
            });
        }
    }
    
    // ğŸ”§ ç¡®ä¿è‡³å°‘æœ‰ä¸€æ¡ user æ¶ˆæ¯
    const hasUserMsg = messages.some(m => m.role === 'user');
    if (!hasUserMsg) {
        console.warn('[generateOfflineReply] âš ï¸ æ²¡æœ‰useræ¶ˆæ¯ï¼Œæ·»åŠ é»˜è®¤æ¶ˆæ¯');
        messages.push({
            role: 'user',
            content: `ï¼ˆ${myName}èµ°è¿‘${friendName}ï¼‰`
        });
    }
    
        console.log('[generateOfflineReply] ğŸ“¤ å‘é€æ¶ˆæ¯æ•°:', messages.length, 'æ¡');
    console.log('[generateOfflineReply] æ¶ˆæ¯è§’è‰²åºåˆ—:', messages.map(m => m.role).join(' â†’ '));

    const reply = await callAI(messages);

    // æ·»åŠ AIå›å¤
    const aiMsg = { role: 'assistant', content: reply, time: Date.now() };
    offlineModeHistory.push(aiMsg);
    
    // ä¿å­˜åˆ°IndexedDBï¼ˆåŒæ—¶å…œåº•localStorageï¼‰
    await saveOfflineChatHistory(accountId, char.id, offlineModeHistory);
    
    // åˆ·æ–°æ˜¾ç¤º
    renderOfflineChatBody(char);
}

// é‡æ–°ç”Ÿæˆæœ€åä¸€æ¡AIå›å¤
async function rerollOfflineMessage() {
    if (_offlineGenerating) return; // é˜²æ­¢ç”Ÿæˆä¸­é‡å¤ç‚¹å‡»
    if (!offlineModeCharId) return;
    
    // æ£€æŸ¥æ˜¯å¦æœ‰AIå›å¤å¯ä»¥é‡æ–°ç”Ÿæˆ
    if (offlineModeHistory.length < 2) {
        showToast('è¿˜æ²¡æœ‰AIå›å¤å¯ä»¥é‡æ–°ç”Ÿæˆ');
        return;
    }
    
    const lastMsg = offlineModeHistory[offlineModeHistory.length - 1];
    if (lastMsg.role !== 'assistant') {
        showToast('æœ€åä¸€æ¡æ¶ˆæ¯ä¸æ˜¯AIå›å¤');
        return;
    }
    
    // ç§»é™¤æœ€åä¸€æ¡AIå›å¤
    offlineModeHistory.pop();
    
    const char = await db.characters.get(offlineModeCharId);
    if (!char) return;
    
    const accountId = getCurrentAccountId();
    const key = `offline_chat_${accountId}_${offlineModeCharId}`;
    
    // ä¿å­˜ç§»é™¤åçš„å†å²åˆ°IndexedDBï¼ˆåŒæ—¶å…œåº•localStorageï¼‰
    await saveOfflineChatHistory(accountId, offlineModeCharId, offlineModeHistory);
    
    // åˆ·æ–°æ˜¾ç¤º
    renderOfflineChatBody(char);
    
    // æ˜¾ç¤ºloadingçŠ¶æ€
    setOfflineGenerating(true);
    
    // é‡æ–°ç”Ÿæˆå›å¤
    try {
        await generateOfflineReply(char, accountId, key);
    } catch (error) {
        console.error('é‡æ–°ç”Ÿæˆå¤±è´¥:', error);
        showToast('é‡æ–°ç”Ÿæˆå¤±è´¥: ' + error.message);
    } finally {
        setOfflineGenerating(false);
    }
}

// çº¿ä¸‹æ¨¡å¼è®¾ç½®ç›¸å…³å‡½æ•°
function getOfflineSettingsKey() {
    const accountId = getCurrentAccountId();
    return `offline_settings_${accountId}_${offlineModeCharId}`;
}

function getOfflineSettings() {
    if (!offlineModeCharId) return { minWords: 100, maxWords: 500, customPreset: '', bubbleCSS: '' };
    const key = getOfflineSettingsKey();
    const saved = localStorage.getItem(key);
    if (saved) {
        try {
            return JSON.parse(saved);
        } catch (e) {}
    }
    return { minWords: 100, maxWords: 500, customPreset: '', bubbleCSS: '' };
}

function showOfflineSettings() {
    const settings = getOfflineSettings();
    document.getElementById('offline-min-words').value = settings.minWords || 100;
    document.getElementById('offline-max-words').value = settings.maxWords || 500;
    document.getElementById('offline-custom-preset').value = settings.customPreset || '';
    document.getElementById('offline-custom-bubble-css').value = settings.bubbleCSS || '';
    document.getElementById('offline-settings-page').style.display = 'flex';
}

function hideOfflineSettings() {
    // è¿”å›æ—¶è‡ªåŠ¨ä¿å­˜è®¾ç½®
    autoSaveOfflineSettings();
    document.getElementById('offline-settings-page').style.display = 'none';
}

// è‡ªåŠ¨ä¿å­˜çº¿ä¸‹æ¨¡å¼è®¾ç½®ï¼ˆæ— å¼¹çª—æç¤ºï¼‰
function autoSaveOfflineSettings() {
    if (!offlineModeCharId) return;
    
    let minWords = parseInt(document.getElementById('offline-min-words').value) || 100;
    let maxWords = parseInt(document.getElementById('offline-max-words').value) || 500;
    const customPreset = document.getElementById('offline-custom-preset').value.trim();
    const bubbleCSS = (document.getElementById('offline-custom-bubble-css')?.value || '').trim();
    
    if (minWords < 10) minWords = 10;
    if (maxWords < minWords) maxWords = minWords;
    if (maxWords > 5000) maxWords = 5000;
    
    const settings = { minWords, maxWords, customPreset, bubbleCSS };
    const key = getOfflineSettingsKey();
    localStorage.setItem(key, JSON.stringify(settings));
    
    document.getElementById('offline-min-words').value = minWords;
    document.getElementById('offline-max-words').value = maxWords;
}

function saveOfflineSettings() {
    if (!offlineModeCharId) return;
    
    autoSaveOfflineSettings();
    // ç«‹å³åº”ç”¨æ°”æ³¡CSS
    applyOfflineBubbleCSS();
    
    showToast('è®¾ç½®å·²ä¿å­˜');
    hideOfflineSettings();
}

// åº”ç”¨çº¿ä¸‹æ¨¡å¼è‡ªå®šä¹‰æ°”æ³¡CSS
function applyOfflineBubbleCSS() {
    const settings = getOfflineSettings();
    const cssCode = settings.bubbleCSS || '';
    
    let styleEl = document.getElementById('offline-custom-bubble-style');
    if (!styleEl) {
        styleEl = document.createElement('style');
        styleEl.id = 'offline-custom-bubble-style';
        document.head.appendChild(styleEl);
    }
    styleEl.textContent = cssCode;
}


// ===== çº¿ä¸‹æ¨¡å¼é¢„è®¾ç®¡ç† =====
// localStorage key: offline_presets_preset / offline_presets_bubblecss

/**
 * è·å–æŒ‡å®šç±»å‹çš„æ‰€æœ‰é¢„è®¾åˆ—è¡¨
 * @param {string} type - 'preset' æˆ– 'bubblecss'
 */
function getOfflinePresets(type) {
    const key = 'offline_presets_' + type;
    try {
        const data = localStorage.getItem(key);
        return data ? JSON.parse(data) : [];
    } catch (e) { return []; }
}

/**
 * ä¿å­˜é¢„è®¾åˆ—è¡¨åˆ° localStorage
 */
function setOfflinePresets(type, list) {
    const key = 'offline_presets_' + type;
    localStorage.setItem(key, JSON.stringify(list));
}

/**
 * å°†å½“å‰è¾“å…¥æ¡†çš„å†…å®¹ä¿å­˜ä¸ºé¢„è®¾
 */
function saveOfflinePresetAs(type) {
    const textareaId = type === 'preset' ? 'offline-custom-preset' : 'offline-custom-bubble-css';
    const content = document.getElementById(textareaId)?.value?.trim();
    if (!content) {
        showToast('å†…å®¹ä¸ºç©ºï¼Œæ— æ³•ä¿å­˜');
        return;
    }

    const name = prompt('è¯·ä¸ºé¢„è®¾å‘½åï¼š');
    if (!name || !name.trim()) return;

    const presets = getOfflinePresets(type);
    presets.push({
        name: name.trim(),
        content: content,
        time: Date.now()
    });
    setOfflinePresets(type, presets);
    showToast('é¢„è®¾å·²ä¿å­˜ï¼š' + name.trim());
}

/**
 * æ˜¾ç¤ºé¢„è®¾åˆ—è¡¨å¼¹çª—
 */
function showOfflinePresetList(type) {
    const presets = getOfflinePresets(type);
    const typeName = type === 'preset' ? 'è‡ªå®šä¹‰é¢„è®¾' : 'æ°”æ³¡CSSé¢„è®¾';

    // ç§»é™¤æ—§å¼¹çª—
    let old = document.getElementById('offline-preset-modal');
    if (old) old.remove();

    const modal = document.createElement('div');
    modal.id = 'offline-preset-modal';
    modal.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:10002; display:flex; align-items:center; justify-content:center; backdrop-filter:blur(3px); -webkit-backdrop-filter:blur(3px);';
    modal.onclick = function(e) { if (e.target === modal) modal.remove(); };

    let html = '<div style="width:90%; max-width:400px; max-height:80vh; background:#fff; border-radius:20px; display:flex; flex-direction:column; overflow:hidden; box-shadow:0 10px 40px rgba(0,0,0,0.3);">';
    html += '<div style="padding:16px 20px; border-bottom:1px solid #eee; display:flex; align-items:center; justify-content:space-between; flex-shrink:0; background:#f8f8f8;">';
    html += '<div style="font-size:17px; font-weight:600; color:#333;">ğŸ“‚ ' + typeName + '</div>';
    html += '<div onclick="document.getElementById(\'offline-preset-modal\').remove()" style="width:30px; height:30px; display:flex; align-items:center; justify-content:center; cursor:pointer; font-size:20px; color:#999; border-radius:50%; background:#f0f0f0;">Ã—</div>';
    html += '</div>';
    html += '<div style="flex:1; overflow-y:auto; -webkit-overflow-scrolling:touch; padding:12px 16px;">';

    if (presets.length === 0) {
        html += '<div style="text-align:center; padding:40px 0; color:#999; font-size:14px;">æš‚æ— ä¿å­˜çš„é¢„è®¾<br><span style="font-size:12px; color:#ccc;">åœ¨è¾“å…¥æ¡†å¡«å†™å†…å®¹åç‚¹å‡»ã€Œä¿å­˜ä¸ºé¢„è®¾ã€</span></div>';
    } else {
        for (let i = 0; i < presets.length; i++) {
            const p = presets[i];
            const timeStr = new Date(p.time).toLocaleDateString('zh-CN') + ' ' + new Date(p.time).toLocaleTimeString('zh-CN', {hour:'2-digit', minute:'2-digit'});
            const preview = p.content.length > 60 ? p.content.substring(0, 60) + '...' : p.content;
            html += '<div style="background:#fafafa; border:1px solid #eee; border-radius:12px; padding:12px 14px; margin-bottom:10px;">';
            html += '<div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:6px;">';
            html += '<div style="font-size:14px; font-weight:600; color:#333; flex:1; min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">' + p.name.replace(/</g, '&lt;') + '</div>';
            html += '<div style="font-size:11px; color:#bbb; flex-shrink:0; margin-left:8px;">' + timeStr + '</div>';
            html += '</div>';
            html += '<div style="font-size:12px; color:#888; line-height:1.4; margin-bottom:10px; word-break:break-all; white-space:pre-wrap; max-height:60px; overflow:hidden;">' + preview.replace(/</g, '&lt;') + '</div>';
            html += '<div style="display:flex; gap:8px;">';
            html += '<button onclick="loadOfflinePreset(\'' + type + '\',' + i + ')" style="flex:1; padding:7px; background:#e8f5e9; color:#43a047; border:none; border-radius:8px; font-size:12px; cursor:pointer; font-weight:500;">âœ“ åº”ç”¨</button>';
            html += '<button onclick="deleteOfflinePreset(\'' + type + '\',' + i + ')" style="padding:7px 12px; background:#fff0f0; color:#e57373; border:none; border-radius:8px; font-size:12px; cursor:pointer; font-weight:500;">åˆ é™¤</button>';
            html += '</div>';
            html += '</div>';
        }
    }

    html += '</div></div>';
    modal.innerHTML = html;
    document.body.appendChild(modal);
}

/**
 * åŠ è½½æŒ‡å®šé¢„è®¾åˆ°è¾“å…¥æ¡†
 */
function loadOfflinePreset(type, index) {
    const presets = getOfflinePresets(type);
    const p = presets[index];
    if (!p) return;

    const textareaId = type === 'preset' ? 'offline-custom-preset' : 'offline-custom-bubble-css';
    document.getElementById(textareaId).value = p.content;

    // å…³é—­å¼¹çª—
    const modal = document.getElementById('offline-preset-modal');
    if (modal) modal.remove();

    showToast('å·²åŠ è½½é¢„è®¾ï¼š' + p.name);
}

/**
 * åˆ é™¤æŒ‡å®šé¢„è®¾
 */
function deleteOfflinePreset(type, index) {
    const presets = getOfflinePresets(type);
    const p = presets[index];
    if (!p) return;

    if (!confirm('ç¡®å®šåˆ é™¤é¢„è®¾ã€Œ' + p.name + 'ã€å—ï¼Ÿ')) return;

    presets.splice(index, 1);
    setOfflinePresets(type, presets);

    // åˆ·æ–°å¼¹çª—
    showOfflinePresetList(type);
    showToast('å·²åˆ é™¤é¢„è®¾');
}

function clearOfflineChatHistory() {
    if (!offlineModeCharId) return;
    if (!confirm('ç¡®å®šè¦æ¸…ç©ºçº¿ä¸‹èŠå¤©è®°å½•å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚')) return;
    
    const accountId = getCurrentAccountId();
    offlineModeHistory = [];
    
    // æ¸…ç©ºä¸¤å¤„å­˜å‚¨
    (async () => {
        const lsKey = `offline_chat_${accountId}_${offlineModeCharId}`;
        try {
            await db.offline_chats.delete(lsKey);
        } catch (e) { console.warn('[OfflineChat] IndexedDBåˆ é™¤å¤±è´¥:', e); }
        try {
            localStorage.removeItem(lsKey);
        } catch (e) {}
        
        // åˆ·æ–°æ˜¾ç¤º
        const char = await db.characters.get(offlineModeCharId);
        if (char) renderOfflineChatBody(char);
    })();
    
    hideOfflineSettings();
}

// ===== è§’è‰²è´¦å·ç™»å½•å’ŒæŸ¥å²—åŠŸèƒ½ =====

// æ ¼å¼åŒ–æ—¶é—´
function formatTime(timestamp) {
    if (!timestamp) return '';
    const date = new Date(timestamp);
    const now = new Date();
    const diff = now - date;
    
    if (diff < 60000) return 'åˆšåˆš';
    if (diff < 3600000) return Math.floor(diff / 60000) + 'åˆ†é’Ÿå‰';
    if (diff < 86400000) return Math.floor(diff / 3600000) + 'å°æ—¶å‰';
    if (diff < 604800000) return Math.floor(diff / 86400000) + 'å¤©å‰';
    
    const month = date.getMonth() + 1;
    const day = date.getDate();
    const hour = date.getHours();
    const minute = date.getMinutes();
    
    return `${month}æœˆ${day}æ—¥ ${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
}

// ===== èŠå¤©æ€»ç»“åŠŸèƒ½ =====

// å½“å‰æŸ¥çœ‹çš„æ€»ç»“ID
let currentViewingSummaryId = null;

// æ˜¾ç¤ºæ”¶è—é¡µé¢
async function showFavoritesPage() {
    const page = document.getElementById('favorites-page');
    if (!page) return;
    
    page.style.display = 'flex';
    await renderFavoritesList('all');
}

// éšè—æ”¶è—é¡µé¢
function hideFavoritesPage() {
    const page = document.getElementById('favorites-page');
    if (page) page.style.display = 'none';
}

// åˆ‡æ¢æ”¶è—æ ‡ç­¾
async function switchFavTab(type) {
    // æ›´æ–°æ ‡ç­¾æ ·å¼
    document.querySelectorAll('.fav-tab').forEach(tab => {
        if (tab.dataset.type === type) {
            tab.style.background = 'var(--ins-pink)';
            tab.style.color = '#fff';
            tab.style.border = 'none';
            tab.classList.add('active');
        } else {
            tab.style.background = '#fff';
            tab.style.color = '#666';
            tab.style.border = '1px solid #e0e0e0';
            tab.classList.remove('active');
        }
    });
    
    await renderFavoritesList(type);
}

// æ¸²æŸ“æ”¶è—åˆ—è¡¨
async function renderFavoritesList(type) {
    const listContainer = document.getElementById('favorites-list');
    const emptyState = document.getElementById('favorites-empty');
    
    if (!listContainer) return;
    
    const accountId = getCurrentAccountId();
    if (!accountId) {
        listContainer.innerHTML = '';
        emptyState.style.display = 'block';
        return;
    }
    
    // è·å–æ‰€æœ‰æ€»ç»“
    let summaries = await db.chat_summaries.where('accountId').equals(accountId).toArray();
    
    // æŒ‰æ—¶é—´å€’åº
    summaries.sort((a, b) => b.time - a.time);
    
    if (summaries.length === 0) {
        listContainer.innerHTML = '';
        emptyState.style.display = 'block';
        return;
    }
    
    emptyState.style.display = 'none';
    
    // ç”Ÿæˆåˆ—è¡¨HTML
    const _slAid = getCurrentAccountId();
    let html = '';
    for (const summary of summaries) {
        let avatarUrl = '';
        let name = 'æœªçŸ¥';
        let chatTypeLabel = '';
        
        if (summary.chatType === 'private') {
            const char = await db.characters.get(parseInt(summary.chatId));
            if (char) {
                avatarUrl = getCharAvatar(char, _slAid) || '';
                name = getCharDisplayName(char, _slAid) || 'æœªçŸ¥';
            }
            chatTypeLabel = 'ç§èŠ';
        } else if (summary.chatType === 'group') {
            const group = await db.group_chats.get(parseInt(summary.chatId));
            if (group) {
                avatarUrl = group.avatar || '';
                name = group.name || 'ç¾¤èŠ';
            }
            chatTypeLabel = 'ç¾¤èŠ';
        }
        
        const timeStr = formatSummaryTime(summary.time);
        const preview = summary.content ? summary.content.substring(0, 80) + (summary.content.length > 80 ? '...' : '') : 'æš‚æ— å†…å®¹';
        
        html += `
            <div onclick="showSummaryDetail(${summary.id})" style="background:#fff; border-radius:12px; padding:16px; cursor:pointer; transition:all 0.2s; box-shadow:0 1px 3px rgba(0,0,0,0.05);">
                <div style="display:flex; align-items:center; margin-bottom:12px;">
                    <div style="width:44px; height:44px; border-radius:${summary.chatType === 'group' ? '8px' : '50%'}; background-size:cover; background-position:center; background-color:#e0e0e0; margin-right:12px; ${avatarUrl ? `background-image:url(${avatarUrl})` : ''}"></div>
                    <div style="flex:1;">
                        <div style="display:flex; align-items:center; gap:8px;">
                            <span style="font-size:16px; font-weight:600; color:#333;">${name}</span>
                            <span style="font-size:11px; padding:2px 6px; background:${summary.chatType === 'group' ? '#e8f5e9' : '#fff3e0'}; color:${summary.chatType === 'group' ? '#4caf50' : '#ff9800'}; border-radius:4px;">${chatTypeLabel}</span>
                        </div>
                        <div style="font-size:12px; color:#999; margin-top:2px;">${timeStr}</div>
                    </div>
                    <div style="font-size:12px; color:#999;">${summary.messageCount || 0}æ¡æ¶ˆæ¯</div>
                </div>
                <div style="font-size:14px; color:#666; line-height:1.5; display:-webkit-box; -webkit-line-clamp:2; -webkit-box-orient:vertical; overflow:hidden;">${preview}</div>
            </div>
        `;
    }
    
    listContainer.innerHTML = html;
}

// ğŸ”§ è·å–æ€»ç»“è®°å¿†ä¸Šä¸‹æ–‡ï¼ˆæ³¨å…¥åˆ°AIç³»ç»Ÿæç¤ºè¯ä¸­ï¼Œè®©AIèƒ½è¯»å–å†å²æ€»ç»“ï¼‰
async function getSummaryMemoryContext(chatType, chatId, accountId) {
    try {
        if (!accountId) accountId = 'offline';
        
        let summaries = await db.chat_summaries
            .where(['accountId', 'chatType', 'chatId'])
            .equals([accountId, chatType, String(chatId)])
            .toArray();
        
        // å¦‚æœå¤åˆç´¢å¼•ä¸å·¥ä½œï¼Œä½¿ç”¨è¿‡æ»¤
        if (summaries.length === 0) {
            summaries = await db.chat_summaries.where('accountId').equals(accountId).toArray();
            summaries = summaries.filter(s => s.chatType === chatType && String(s.chatId) === String(chatId));
        }
        
        if (summaries.length === 0) return '';
        
        // æŒ‰æ—¶é—´æ­£åºæ’åˆ—
        summaries.sort((a, b) => a.time - b.time);
        
        // æœ€å¤šå–æœ€è¿‘10æ¡æ€»ç»“
        const recentSummaries = summaries.slice(-10);
        
        const memoryLines = recentSummaries.map(s => {
            const timeStr = formatSummaryTime(s.time);
            const content = (s.content || '').replace(/ã€å…³é”®è¯ã€‘.*$/m, '').trim();
            return `- (è®°å½•äº ${timeStr}) ${content}`;
        }).join('\n');
        
        console.log(`[getSummaryMemoryContext] åŠ è½½äº† ${recentSummaries.length} æ¡æ€»ç»“è®°å¿†`);
        
        return `\n\n## é•¿æœŸè®°å¿†ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼Œè¿™æ˜¯ä½ ä»¬ä¹‹é—´å·²ç»ç¡®ç«‹çš„äº‹å®ï¼Œå¿…é¡»ä¸¥æ ¼éµå®ˆï¼‰
ä»¥ä¸‹æ˜¯ä½ å’Œå¯¹æ–¹ä¹‹å‰çš„å¯¹è¯æ€»ç»“ï¼Œä½ å¿…é¡»è®°ä½è¿™äº›å†…å®¹ï¼Œå¹¶åœ¨èŠå¤©ä¸­è‡ªç„¶åœ°ä½“ç°å‡ºä½ è®°å¾—è¿™äº›äº‹ï¼š
${memoryLines}`;
    } catch (e) {
        console.warn('[getSummaryMemoryContext] è·å–æ€»ç»“è®°å¿†å¤±è´¥:', e);
        return '';
    }
}

// æ ¼å¼åŒ–æ€»ç»“æ—¶é—´
function formatSummaryTime(timestamp) {
    if (!timestamp) return '';
    const date = new Date(timestamp);
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const day = date.getDate().toString().padStart(2, '0');
    const hour = date.getHours().toString().padStart(2, '0');
    const minute = date.getMinutes().toString().padStart(2, '0');
    return `${year}-${month}-${day} ${hour}:${minute}`;
}

// æ˜¾ç¤ºæ€»ç»“è¯¦æƒ…
async function showSummaryDetail(summaryId) {
    console.log('[showSummaryDetail] å¼€å§‹æŸ¥çœ‹æ€»ç»“è¯¦æƒ…, summaryId:', summaryId);
    
    const page = document.getElementById('summary-detail-page');
    if (!page) {
        console.error('[showSummaryDetail] æ‰¾ä¸åˆ° summary-detail-page å…ƒç´ ');
        alert('é¡µé¢åŠ è½½é”™è¯¯ï¼Œè¯·åˆ·æ–°é¡µé¢');
        return;
    }
    
    currentViewingSummaryId = summaryId;
    
    try {
        const summary = await db.chat_summaries.get(summaryId);
        if (!summary) {
            alert('æ€»ç»“ä¸å­˜åœ¨');
            return;
        }
        console.log('[showSummaryDetail] è·å–åˆ°æ€»ç»“:', summary);
        
        // è·å–èŠå¤©å¯¹è±¡ä¿¡æ¯
        let avatarUrl = '';
        let name = 'æœªçŸ¥';
        const _sdAid = getCurrentAccountId();
        
        if (summary.chatType === 'private') {
            const char = await db.characters.get(parseInt(summary.chatId));
            if (char) {
                avatarUrl = getCharAvatar(char, _sdAid) || '';
                name = getCharDisplayName(char, _sdAid) || 'æœªçŸ¥';
            }
        } else if (summary.chatType === 'group') {
            const group = await db.group_chats.get(parseInt(summary.chatId));
            if (group) {
                avatarUrl = group.avatar || '';
                name = group.name || 'ç¾¤èŠ';
            }
        }
    
    // å¡«å……é¡µé¢å†…å®¹
    document.getElementById('summary-detail-title').textContent = name + ' - èŠå¤©æ€»ç»“';
    
    const avatarEl = document.getElementById('summary-detail-avatar');
    if (avatarUrl) {
        avatarEl.style.backgroundImage = `url(${avatarUrl})`;
    } else {
        avatarEl.style.backgroundImage = '';
    }
    avatarEl.style.borderRadius = summary.chatType === 'group' ? '8px' : '50%';
    
    document.getElementById('summary-detail-name').textContent = name;
    document.getElementById('summary-detail-time').textContent = formatSummaryTime(summary.time);
    document.getElementById('summary-msg-count').textContent = summary.messageCount || 0;
    document.getElementById('summary-time-range').textContent = summary.timeRange || '-';
    document.getElementById('summary-detail-content').textContent = summary.content || 'æš‚æ— å†…å®¹';
    
        // å…³é”®è¯æ ‡ç­¾
        const keywordsSection = document.getElementById('summary-keywords-section');
        const keywordsContainer = document.getElementById('summary-detail-keywords');
        if (summary.keywords && summary.keywords.length > 0) {
            keywordsSection.style.display = 'block';
            keywordsContainer.innerHTML = summary.keywords.map(kw => 
                `<span style="padding:6px 12px; background:#f0f0f5; border-radius:16px; font-size:13px; color:#666;">${kw}</span>`
            ).join('');
        } else {
            keywordsSection.style.display = 'none';
        }
        
        console.log('[showSummaryDetail] æ˜¾ç¤ºè¯¦æƒ…é¡µé¢');
        page.style.display = 'flex';
        page.style.zIndex = '1001'; // ç¡®ä¿åœ¨æ€»ç»“åˆ—è¡¨é¡µé¢ä¹‹ä¸Š
    } catch (error) {
        console.error('[showSummaryDetail] æ˜¾ç¤ºæ€»ç»“è¯¦æƒ…æ—¶å‡ºé”™:', error);
        alert('æŸ¥çœ‹æ€»ç»“è¯¦æƒ…å¤±è´¥ï¼š' + (error.message || 'æœªçŸ¥é”™è¯¯'));
    }
}

// éšè—æ€»ç»“è¯¦æƒ…é¡µ
function hideSummaryDetailPage() {
    const page = document.getElementById('summary-detail-page');
    if (page) page.style.display = 'none';
    currentViewingSummaryId = null;
}

// åˆ é™¤æ€»ç»“
async function deleteSummary() {
    if (!currentViewingSummaryId) return;
    
    if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡æ€»ç»“å—ï¼Ÿ')) return;
    
    try {
        await db.chat_summaries.delete(currentViewingSummaryId);
        hideSummaryDetailPage();
        
        // åˆ·æ–°æ”¶è—åˆ—è¡¨
        const favPage = document.getElementById('favorites-page');
        if (favPage && favPage.style.display !== 'none') {
            await renderFavoritesList('all');
        }
        
        // åˆ·æ–°èŠå¤©æ€»ç»“åˆ—è¡¨
        const chatSummariesPage = document.getElementById('chat-summaries-page');
        if (chatSummariesPage && chatSummariesPage.style.display !== 'none') {
            // é‡æ–°åŠ è½½å½“å‰èŠå¤©çš„æ€»ç»“
        }
        
        showToast('åˆ é™¤æˆåŠŸ');
    } catch (e) {
        console.error('åˆ é™¤æ€»ç»“å¤±è´¥:', e);
        alert('åˆ é™¤å¤±è´¥');
    }
}

// ä¿å­˜ç¼–è¾‘å‰çš„åŸå§‹å†…å®¹
let originalSummaryContent = '';

// åˆ‡æ¢æ€»ç»“ç¼–è¾‘æ¨¡å¼
function toggleEditSummary() {
    const contentDiv = document.getElementById('summary-detail-content');
    const contentTextarea = document.getElementById('summary-detail-content-edit');
    const editHint = document.getElementById('summary-edit-hint');
    const editBtn = document.getElementById('summary-edit-btn');
    const saveBtn = document.getElementById('summary-save-btn');
    const cancelBtn = document.getElementById('summary-cancel-btn');
    const deleteBtn = document.getElementById('summary-delete-btn');
    
    if (!contentDiv || !contentTextarea) {
        console.error('æ‰¾ä¸åˆ°æ€»ç»“å†…å®¹å…ƒç´ ');
        alert('ç¼–è¾‘åŠŸèƒ½åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
        return;
    }
    
    // ä¿å­˜åŸå§‹å†…å®¹
    originalSummaryContent = contentDiv.textContent;
    
    // åˆ‡æ¢åˆ°ç¼–è¾‘æ¨¡å¼
    contentDiv.style.display = 'none';
    contentTextarea.style.display = 'block';
    contentTextarea.value = originalSummaryContent;
    if (editHint) editHint.style.display = 'block';
    
    // åˆ‡æ¢æŒ‰é’®æ˜¾ç¤º
    if (editBtn) editBtn.style.display = 'none';
    if (saveBtn) saveBtn.style.display = 'block';
    if (cancelBtn) cancelBtn.style.display = 'block';
    if (deleteBtn) deleteBtn.style.display = 'none';
    
    // è‡ªåŠ¨èšç„¦åˆ°è¾“å…¥æ¡†å¹¶é€‰ä¸­å…¨éƒ¨æ–‡æœ¬ï¼ˆæ–¹ä¾¿ç”¨æˆ·ç¼–è¾‘ï¼‰
    setTimeout(() => {
        contentTextarea.focus();
        contentTextarea.select();
    }, 100);
}

// å–æ¶ˆç¼–è¾‘æ€»ç»“
function cancelEditSummary() {
    const contentDiv = document.getElementById('summary-detail-content');
    const contentTextarea = document.getElementById('summary-detail-content-edit');
    const editHint = document.getElementById('summary-edit-hint');
    const editBtn = document.getElementById('summary-edit-btn');
    const saveBtn = document.getElementById('summary-save-btn');
    const cancelBtn = document.getElementById('summary-cancel-btn');
    const deleteBtn = document.getElementById('summary-delete-btn');
    
    // æ¢å¤æ˜¾ç¤ºæ¨¡å¼
    if (contentDiv) contentDiv.style.display = 'block';
    if (contentTextarea) contentTextarea.style.display = 'none';
    if (editHint) editHint.style.display = 'none';
    
    // åˆ‡æ¢æŒ‰é’®æ˜¾ç¤º
    if (editBtn) editBtn.style.display = 'block';
    if (saveBtn) saveBtn.style.display = 'none';
    if (cancelBtn) cancelBtn.style.display = 'none';
    if (deleteBtn) deleteBtn.style.display = 'block';
}

// ä¿å­˜æ€»ç»“ç¼–è¾‘
async function saveSummaryEdit() {
    if (!currentViewingSummaryId) return;
    
    const contentTextarea = document.getElementById('summary-detail-content-edit');
    const newContent = contentTextarea.value.trim();
    
    if (!newContent) {
        alert('æ€»ç»“å†…å®¹ä¸èƒ½ä¸ºç©º');
        return;
    }
    
    try {
        // è·å–å½“å‰æ€»ç»“
        const summary = await db.chat_summaries.get(currentViewingSummaryId);
        if (!summary) {
            alert('æ€»ç»“ä¸å­˜åœ¨');
            return;
        }
        
        // æ›´æ–°å†…å®¹
        summary.content = newContent;
        summary.updated_at = Date.now(); // æ·»åŠ æ›´æ–°æ—¶é—´æˆ³
        
        // ä¿å­˜åˆ°æ•°æ®åº“
        await db.chat_summaries.put(summary);
        
        // æ›´æ–°æ˜¾ç¤º
        const contentDiv = document.getElementById('summary-detail-content');
        if (contentDiv) contentDiv.textContent = newContent;
        
        // é€€å‡ºç¼–è¾‘æ¨¡å¼
        cancelEditSummary();
        
        // åˆ·æ–°æ”¶è—åˆ—è¡¨ï¼ˆå¦‚æœæ­£åœ¨æ˜¾ç¤ºï¼‰
        const favPage = document.getElementById('favorites-page');
        if (favPage && favPage.style.display !== 'none') {
            await renderFavoritesList('all');
        }
        
        showToast('ä¿å­˜æˆåŠŸ');
    } catch (e) {
        console.error('ä¿å­˜æ€»ç»“å¤±è´¥:', e);
        alert('ä¿å­˜å¤±è´¥: ' + e.message);
    }
}

// æ˜¾ç¤ºæŸä¸ªèŠå¤©çš„æ€»ç»“åˆ—è¡¨
async function showChatSummaries(chatType) {
    console.log('[showChatSummaries] å¼€å§‹æŸ¥çœ‹æ€»ç»“è®°å½•, chatType:', chatType);
    
    const page = document.getElementById('chat-summaries-page');
    if (!page) {
        console.error('[showChatSummaries] æ‰¾ä¸åˆ° chat-summaries-page å…ƒç´ ');
        alert('é¡µé¢åŠ è½½é”™è¯¯ï¼Œè¯·åˆ·æ–°é¡µé¢');
        return;
    }
    
    let accountId = getCurrentAccountId();
    // ğŸ”§ ä¿®å¤ï¼šçº¿ä¸‹æ¨¡å¼æ²¡æœ‰è´¦å·IDï¼Œä½¿ç”¨é»˜è®¤å€¼
    if (!accountId) {
        accountId = 'offline';
        console.log('[showChatSummaries] çº¿ä¸‹æ¨¡å¼ï¼Œä½¿ç”¨é»˜è®¤è´¦å·ID: offline');
    }
    console.log('[showChatSummaries] accountId:', accountId);
    
    let chatId, name;
    
    if (chatType === 'private') {
        if (!currentChatCharId) {
            console.error('[showChatSummaries] æ²¡æœ‰å½“å‰èŠå¤©è§’è‰²ID');
            alert('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªèŠå¤©çª—å£');
            return;
        }
        chatId = currentChatCharId;
        const char = await db.characters.get(parseInt(chatId));
        name = char ? (char.remark || char.wx_nickname || char.name) : 'ç§èŠ';
        console.log('[showChatSummaries] ç§èŠ, chatId:', chatId, 'name:', name);
    } else if (chatType === 'group') {
        if (!window.currentGroupChatId) {
            console.error('[showChatSummaries] æ²¡æœ‰å½“å‰ç¾¤èŠID');
            alert('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªç¾¤èŠçª—å£');
            return;
        }
        chatId = window.currentGroupChatId;
        const group = await db.group_chats.get(parseInt(chatId));
        name = group ? group.name : 'ç¾¤èŠ';
        console.log('[showChatSummaries] ç¾¤èŠ, chatId:', chatId, 'name:', name);
    }
    
    document.getElementById('chat-summaries-title').textContent = name + ' - æ€»ç»“è®°å½•';
    
    try {
        // è·å–è¯¥èŠå¤©çš„æ‰€æœ‰æ€»ç»“
        console.log('[showChatSummaries] å¼€å§‹æŸ¥è¯¢æ€»ç»“, chatId:', chatId, 'chatType:', chatType);
        let summaries = await db.chat_summaries
            .where(['accountId', 'chatType', 'chatId'])
            .equals([accountId, chatType, String(chatId)])
            .toArray();
        
        console.log('[showChatSummaries] å¤åˆç´¢å¼•æŸ¥è¯¢ç»“æœ:', summaries.length);
        
        // å¦‚æœå¤åˆç´¢å¼•ä¸å·¥ä½œï¼Œä½¿ç”¨è¿‡æ»¤
        if (summaries.length === 0) {
            console.log('[showChatSummaries] å¤åˆç´¢å¼•æ— ç»“æœï¼Œä½¿ç”¨è¿‡æ»¤æ–¹å¼');
            summaries = await db.chat_summaries.where('accountId').equals(accountId).toArray();
            summaries = summaries.filter(s => s.chatType === chatType && String(s.chatId) === String(chatId));
            console.log('[showChatSummaries] è¿‡æ»¤åç»“æœ:', summaries.length);
        }
        
        // æŒ‰æ—¶é—´æ­£åºï¼ˆç¬¬ä¸€æ¬¡æ€»ç»“æ’ç¬¬ä¸€ï¼Œåé¢çš„ä¾æ¬¡æ’åˆ—ï¼‰
        summaries.sort((a, b) => a.time - b.time);
        
        const listContainer = document.getElementById('chat-summaries-list');
        const emptyState = document.getElementById('chat-summaries-empty');
        
        if (summaries.length === 0) {
            listContainer.innerHTML = '';
            emptyState.style.display = 'block';
        } else {
            emptyState.style.display = 'none';
            listContainer.innerHTML = summaries.map(summary => `
                <div onclick="showSummaryDetail(${summary.id})" style="background:#fff; border-radius:12px; padding:16px; cursor:pointer; transition:all 0.2s; box-shadow:0 1px 3px rgba(0,0,0,0.05);">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                        <span style="font-size:14px; font-weight:600; color:#333;">ç¬¬ ${summaries.indexOf(summary) + 1} æ¬¡æ€»ç»“</span>
                        <span style="font-size:12px; color:#999;">${formatSummaryTime(summary.time)}</span>
                    </div>
                    <div style="font-size:13px; color:#666; line-height:1.5; display:-webkit-box; -webkit-line-clamp:3; -webkit-box-orient:vertical; overflow:hidden;">
                        ${summary.content ? summary.content.substring(0, 120) + (summary.content.length > 120 ? '...' : '') : 'æš‚æ— å†…å®¹'}
                    </div>
                    <div style="margin-top:10px; font-size:12px; color:#999;">
                        ${summary.messageCount || 0}æ¡æ¶ˆæ¯ Â· ${summary.timeRange || '-'}
                    </div>
                </div>
            `).join('');
        }
        
        console.log('[showChatSummaries] æ˜¾ç¤ºé¡µé¢ï¼Œæ€»ç»“æ•°é‡:', summaries.length);
        page.style.display = 'flex';
        
        // ğŸ”§ ç¡®ä¿é¡µé¢åœ¨æœ€ä¸Šå±‚
        page.style.zIndex = '1000';
    } catch (error) {
        console.error('[showChatSummaries] æŸ¥è¯¢æˆ–æ˜¾ç¤ºæ€»ç»“æ—¶å‡ºé”™:', error);
        alert('æŸ¥çœ‹æ€»ç»“è®°å½•å¤±è´¥ï¼š' + (error.message || 'æœªçŸ¥é”™è¯¯'));
    }
}

// éšè—èŠå¤©æ€»ç»“åˆ—è¡¨é¡µ
function hideChatSummariesPage() {
    const page = document.getElementById('chat-summaries-page');
    if (page) page.style.display = 'none';
}

// æ‰‹åŠ¨è§¦å‘ç”Ÿæˆæ€»ç»“ â€”â€” å¼¹å‡ºèŒƒå›´é€‰æ‹©å™¨
async function triggerManualSummary(chatType) {
    const rawAccountId = getCurrentAccountId();
    let accountId = rawAccountId || 'offline';

    let chatId, chatHistory, name;

    if (chatType === 'private') {
        if (!currentChatCharId) { alert('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªèŠå¤©'); return; }
        chatId = currentChatCharId;
        const char = await db.characters.get(parseInt(chatId));
        name = char ? (char.remark || char.wx_nickname || char.name) : 'ç§èŠ';
        chatHistory = getChatHistory(char, rawAccountId);
        try {
            if (rawAccountId) {
                const offlineHistory = await loadOfflineChatHistory(rawAccountId, chatId);
                if (offlineHistory && offlineHistory.length > 0) {
                    const taggedOffline = offlineHistory.map(m => ({ ...m, _source: 'offline' }));
                    chatHistory = [...chatHistory, ...taggedOffline];
                    chatHistory.sort((a, b) => (a.time || a.timestamp || 0) - (b.time || b.timestamp || 0));
                    console.log(`[triggerManualSummary] åˆå¹¶çº¿ä¸‹è®°å½• ${offlineHistory.length} æ¡ï¼Œæ€»è®¡ ${chatHistory.length} æ¡`);
                }
            }
        } catch (e) { console.warn('[triggerManualSummary] è¯»å–çº¿ä¸‹è®°å½•å¤±è´¥:', e); }
    } else if (chatType === 'group') {
        if (!window.currentGroupChatId) { alert('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªç¾¤èŠ'); return; }
        chatId = window.currentGroupChatId;
        const group = await db.group_chats.get(parseInt(chatId));
        name = group ? group.name : 'ç¾¤èŠ';
        chatHistory = group ? (group.chat_history || []) : [];
    }

    if (!chatHistory || chatHistory.length < 5) {
        alert('èŠå¤©è®°å½•å¤ªå°‘ï¼ˆè‡³å°‘éœ€è¦5æ¡ï¼‰ï¼Œæ— æ³•ç”Ÿæˆæ€»ç»“');
        return;
    }

    // â€”â€” å¼¹å‡ºèŒƒå›´é€‰æ‹©å¼¹çª— â€”â€”
    showSummaryRangePicker(chatType, chatId, accountId, chatHistory, name);
}

// æ˜¾ç¤ºæ€»ç»“èŒƒå›´é€‰æ‹©å¼¹çª—
function showSummaryRangePicker(chatType, chatId, accountId, chatHistory, name) {
    const total = chatHistory.length;

    // ç§»é™¤æ—§å¼¹çª—
    const old = document.getElementById('summary-range-modal');
    if (old) old.remove();

    // ç”Ÿæˆæ¶ˆæ¯é¢„è§ˆï¼ˆé¦–æ¡ & æœ«æ¡ï¼Œå¸®åŠ©ç”¨æˆ·å®šä½ï¼‰
    const previewMsg = (idx) => {
        if (idx < 0 || idx >= total) return '';
        const m = chatHistory[idx];
        const who = m.role === 'user' ? 'æˆ‘' : (m.name || m.displayName || 'å¯¹æ–¹');
        const txt = (m.content || m.message || '').slice(0, 30);
        const t = m.time || m.timestamp;
        const timeStr = t ? new Date(t).toLocaleString('zh-CN', { month:'numeric', day:'numeric', hour:'2-digit', minute:'2-digit' }) : '';
        return `<span style="color:#999;font-size:11px;">#${idx + 1} ${timeStr}</span> <span style="color:#333;font-size:12px;">${who}: ${txt}${(m.content||'').length > 30 ? 'â€¦' : ''}</span>`;
    };

    const html = `
    <div id="summary-range-modal" style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.45);z-index:9999;display:flex;align-items:center;justify-content:center;padding:20px;box-sizing:border-box;">
        <div style="background:#fff;border-radius:16px;width:100%;max-width:380px;padding:24px 20px;box-shadow:0 8px 30px rgba(0,0,0,0.15);">
            <div style="font-size:17px;font-weight:600;color:#333;margin-bottom:4px;">é€‰æ‹©æ€»ç»“èŒƒå›´</div>
            <div style="font-size:13px;color:#999;margin-bottom:16px;">ä¸ã€Œ${name}ã€å…± ${total} æ¡æ¶ˆæ¯</div>

            <div style="display:flex;flex-direction:column;gap:14px;">
                <!-- èµ·å§‹ -->
                <div>
                    <div style="font-size:13px;color:#666;margin-bottom:6px;">ä»ç¬¬å‡ æ¡å¼€å§‹</div>
                    <input type="number" id="summary-range-start" value="1" min="1" max="${total}" style="width:100%;padding:10px 12px;border:1px solid #e0e0e0;border-radius:10px;font-size:15px;outline:none;box-sizing:border-box;" oninput="updateSummaryRangePreview()">
                    <div id="summary-range-start-preview" style="margin-top:4px;line-height:1.5;">${previewMsg(0)}</div>
                </div>
                <!-- ç»“æŸ -->
                <div>
                    <div style="font-size:13px;color:#666;margin-bottom:6px;">åˆ°ç¬¬å‡ æ¡ç»“æŸ</div>
                    <input type="number" id="summary-range-end" value="${total}" min="1" max="${total}" style="width:100%;padding:10px 12px;border:1px solid #e0e0e0;border-radius:10px;font-size:15px;outline:none;box-sizing:border-box;" oninput="updateSummaryRangePreview()">
                    <div id="summary-range-end-preview" style="margin-top:4px;line-height:1.5;">${previewMsg(total - 1)}</div>
                </div>
                <!-- é€‰ä¸­æ¡æ•°æç¤º -->
                <div id="summary-range-info" style="text-align:center;font-size:13px;color:var(--ins-pink);font-weight:500;">å°†æ€»ç»“ ${total} æ¡æ¶ˆæ¯</div>
            </div>

            <div style="display:flex;gap:10px;margin-top:20px;">
                <button onclick="document.getElementById('summary-range-modal').remove()" style="flex:1;padding:12px;background:#f0f0f0;color:#666;border:none;border-radius:10px;font-size:15px;cursor:pointer;">å–æ¶ˆ</button>
                <button onclick="confirmSummaryRange()" style="flex:1;padding:12px;background:var(--ins-pink,#ff6b9d);color:#fff;border:none;border-radius:10px;font-size:15px;font-weight:600;cursor:pointer;">ç”Ÿæˆæ€»ç»“</button>
            </div>
        </div>
    </div>`;

    document.body.insertAdjacentHTML('beforeend', html);

    // ç¼“å­˜ä¸Šä¸‹æ–‡åˆ° window ä¾›å›è°ƒç”¨
    window._summaryRangeCtx = { chatType, chatId, accountId, chatHistory, name };
}

// å®æ—¶æ›´æ–°èŒƒå›´é¢„è§ˆ
function updateSummaryRangePreview() {
    const ctx = window._summaryRangeCtx;
    if (!ctx) return;
    const total = ctx.chatHistory.length;

    let startIdx = parseInt(document.getElementById('summary-range-start').value) - 1;
    let endIdx = parseInt(document.getElementById('summary-range-end').value) - 1;
    if (isNaN(startIdx)) startIdx = 0;
    if (isNaN(endIdx)) endIdx = total - 1;
    startIdx = Math.max(0, Math.min(total - 1, startIdx));
    endIdx = Math.max(0, Math.min(total - 1, endIdx));

    const previewMsg = (idx) => {
        if (idx < 0 || idx >= total) return '';
        const m = ctx.chatHistory[idx];
        const who = m.role === 'user' ? 'æˆ‘' : (m.name || m.displayName || 'å¯¹æ–¹');
        const txt = (m.content || m.message || '').slice(0, 30);
        const t = m.time || m.timestamp;
        const timeStr = t ? new Date(t).toLocaleString('zh-CN', { month:'numeric', day:'numeric', hour:'2-digit', minute:'2-digit' }) : '';
        return `<span style="color:#999;font-size:11px;">#${idx + 1} ${timeStr}</span> <span style="color:#333;font-size:12px;">${who}: ${txt}${(m.content||'').length > 30 ? 'â€¦' : ''}</span>`;
    };

    document.getElementById('summary-range-start-preview').innerHTML = previewMsg(startIdx);
    document.getElementById('summary-range-end-preview').innerHTML = previewMsg(endIdx);

    const count = endIdx >= startIdx ? (endIdx - startIdx + 1) : 0;
    const infoEl = document.getElementById('summary-range-info');
    if (count < 5) {
        infoEl.textContent = `é€‰ä¸­ ${count} æ¡ï¼ˆè‡³å°‘éœ€è¦5æ¡ï¼‰`;
        infoEl.style.color = '#ff3b30';
    } else {
        infoEl.textContent = `å°†æ€»ç»“ ${count} æ¡æ¶ˆæ¯`;
        infoEl.style.color = 'var(--ins-pink, #ff6b9d)';
    }
}

// ç¡®è®¤èŒƒå›´å¹¶ç”Ÿæˆæ€»ç»“
async function confirmSummaryRange() {
    const ctx = window._summaryRangeCtx;
    if (!ctx) return;
    const total = ctx.chatHistory.length;

    let startIdx = parseInt(document.getElementById('summary-range-start').value) - 1;
    let endIdx = parseInt(document.getElementById('summary-range-end').value) - 1;
    if (isNaN(startIdx)) startIdx = 0;
    if (isNaN(endIdx)) endIdx = total - 1;
    startIdx = Math.max(0, Math.min(total - 1, startIdx));
    endIdx = Math.max(startIdx, Math.min(total - 1, endIdx));

    const count = endIdx - startIdx + 1;
    if (count < 5) {
        alert('é€‰ä¸­çš„æ¶ˆæ¯å¤ªå°‘ï¼ˆè‡³å°‘éœ€è¦5æ¡ï¼‰ï¼Œæ— æ³•ç”Ÿæˆæ€»ç»“');
        return;
    }

    // å…³é—­å¼¹çª—
    document.getElementById('summary-range-modal').remove();

    const sliced = ctx.chatHistory.slice(startIdx, endIdx + 1);

    showToast('æ­£åœ¨ç”Ÿæˆæ€»ç»“...');
    try {
        await generateChatSummary(ctx.chatType, ctx.chatId, ctx.accountId, sliced);
        showToast('æ€»ç»“ç”ŸæˆæˆåŠŸï¼');
        await updateSummaryCount(ctx.chatType, ctx.chatId, ctx.accountId);
    } catch (e) {
        console.error('ç”Ÿæˆæ€»ç»“å¤±è´¥:', e);
        alert('ç”Ÿæˆæ€»ç»“å¤±è´¥: ' + e.message);
    }
}

// ç”ŸæˆèŠå¤©æ€»ç»“
async function generateChatSummary(chatType, chatId, accountId, chatHistory) {
    // ğŸ”§ ä¿®å¤ï¼šç›´æ¥ä½¿ç”¨ç”¨æˆ·é€‰æ‹©çš„å…¨éƒ¨æ¶ˆæ¯ï¼Œä¸å†æˆªæ–­
    const allMessages = chatHistory;
    
    if (allMessages.length < 5) {
        throw new Error('èŠå¤©è®°å½•å¤ªå°‘');
    }
    
    // ğŸ”§ è·å–åŸåï¼ˆä¸ä½¿ç”¨å¤‡æ³¨ï¼Œç›´æ¥ä½¿ç”¨è§’è‰²çš„çœŸåï¼‰
    let charName = 'å¯¹æ–¹';
    let userName = 'ç”¨æˆ·';
    
    if (chatType === 'private') {
        // ç§èŠï¼šä½¿ç”¨è§’è‰²çš„åŸå
        const char = await db.characters.get(parseInt(chatId));
        if (char) {
            charName = char.name; // ğŸ”§ ä¿®æ”¹ï¼šåªä½¿ç”¨åŸåï¼Œä¸ä½¿ç”¨å¤‡æ³¨æˆ–å¾®ä¿¡æ˜µç§°
            // ä¼˜å…ˆä½¿ç”¨æŒ‚è½½çš„ç”¨æˆ·æ¡£æ¡ˆçš„åŸå
            if (char.linked_user_id) {
                const user = await db.characters.get(char.linked_user_id);
                if (user) {
                    userName = user.name; // ğŸ”§ ä¿®æ”¹ï¼šåªä½¿ç”¨åŸå
                }
            } else {
                // æ²¡æŒ‚è½½æ—¶å°è¯•ç”¨å½“å‰ç™»å½•è´¦å·çš„åŸå
                // ğŸ”§ ä¿®å¤ï¼šaccountIdä¸º'offline'æ—¶parseIntä¼šè¿”å›NaNï¼Œéœ€è¦å…ˆæ£€æŸ¥
                const parsedAccountId = parseInt(accountId);
                if (!isNaN(parsedAccountId)) {
                    const myChar = await db.characters.get(parsedAccountId);
                    if (myChar) {
                        userName = myChar.name; // ğŸ”§ ä¿®æ”¹ï¼šåªä½¿ç”¨åŸå
                    }
                }
            }
        }
    } else if (chatType === 'group') {
        // ç¾¤èŠï¼šä½¿ç”¨ç¾¤å
        const group = await db.group_chats.get(parseInt(chatId));
        if (group) {
            charName = group.name || 'ç¾¤èŠ';
        }
        // å°è¯•è·å–ç”¨æˆ·çš„åŸå
        // ğŸ”§ ä¿®å¤ï¼šaccountIdä¸º'offline'æ—¶parseIntä¼šè¿”å›NaNï¼Œéœ€è¦å…ˆæ£€æŸ¥
        const parsedAccountId = parseInt(accountId);
        if (!isNaN(parsedAccountId)) {
            const myChar = await db.characters.get(parsedAccountId);
            if (myChar) {
                userName = myChar.name; // ğŸ”§ ä¿®æ”¹ï¼šåªä½¿ç”¨åŸå
            }
        }
    }
    
    // è®¡ç®—æ—¶é—´èŒƒå›´
    const firstMsgTime = allMessages[0].time || allMessages[0].timestamp || Date.now();
    const lastMsgTime = allMessages[allMessages.length - 1].time || allMessages[allMessages.length - 1].timestamp || Date.now();
    const timeRange = formatTimeRange(firstMsgTime, lastMsgTime);
    
    // å°†æ¶ˆæ¯è½¬ä¸ºæ–‡æœ¬çš„è¾…åŠ©å‡½æ•°
    const msgToText = (msg) => {
        let role;
        if (msg.role === 'user') {
            role = userName;
        } else if (chatType === 'group' && msg.name) {
            role = msg.displayName || msg.name || charName;
        } else {
            role = charName;
        }
        const content = msg.content || msg.message || '';
        const sourceTag = msg._source === 'offline' ? '[çº¿ä¸‹è§é¢] ' : '';
        return `${sourceTag}${role}: ${content}`;
    };
    
    let finalSummary;
    
    // ğŸ”§ åˆ†æ®µç­–ç•¥ï¼šè¶…è¿‡300æ¡æ¶ˆæ¯æ—¶åˆ†æ‰¹æ€»ç»“ï¼Œæœ€ååˆå¹¶
    const CHUNK_SIZE = 200;
    if (allMessages.length > 300) {
        console.log(`[generateChatSummary] æ¶ˆæ¯è¾ƒå¤š(${allMessages.length}æ¡)ï¼Œåˆ†æ®µæ€»ç»“`);
        showToast(`æ¶ˆæ¯è¾ƒå¤š(${allMessages.length}æ¡)ï¼Œåˆ†æ®µæ€»ç»“ä¸­...`);
        
        // åˆ†æˆå¤šä¸ªæ‰¹æ¬¡
        const chunks = [];
        for (let i = 0; i < allMessages.length; i += CHUNK_SIZE) {
            chunks.push(allMessages.slice(i, i + CHUNK_SIZE));
        }
        
        // é€æ‰¹ç”Ÿæˆå­æ€»ç»“
        const chunkSummaries = [];
        for (let ci = 0; ci < chunks.length; ci++) {
            const chunk = chunks[ci];
            const chunkStart = chunk[0].time || chunk[0].timestamp || Date.now();
            const chunkEnd = chunk[chunk.length - 1].time || chunk[chunk.length - 1].timestamp || Date.now();
            const chunkTimeRange = formatTimeRange(chunkStart, chunkEnd);
            const chunkContent = chunk.map(msgToText).join('\n');
            
            showToast(`æ­£åœ¨æ€»ç»“ç¬¬ ${ci + 1}/${chunks.length} æ®µ...`);
            
            const chunkPrompt = `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„èŠå¤©è®°å½•æ€»ç»“åŠ©æ‰‹ã€‚è¯·æ ¹æ®ä»¥ä¸‹èŠå¤©è®°å½•ç‰‡æ®µï¼Œç”Ÿæˆä¸€ä»½ç®€æ´ä½†å®Œæ•´çš„æ€»ç»“ã€‚

æ€»ç»“è¦æ±‚ï¼š
1. å¿…é¡»ä½¿ç”¨ç¬¬ä¸‰äººç§°è§†è§’ï¼Œä»¥æ—è§‚è€…è§’åº¦å®¢è§‚æè¿°
2. ä½¿ç”¨"${userName}"å’Œ"${charName}"çš„åå­—ï¼Œä¸¥ç¦ä½¿ç”¨"AI"ã€"åŠ©æ‰‹"ã€"æœºå™¨äºº"ã€"ç”¨æˆ·"ç­‰è¯æ±‡
3. æç‚¼å‡ºä¸»è¦è¯é¢˜å’Œå…³é”®ä¿¡æ¯
4. å¦‚æœæœ‰é‡è¦çš„æƒ…æ„Ÿå˜åŒ–æˆ–äº‹ä»¶ï¼Œè¦ç‰¹åˆ«æŒ‡å‡º
5. æ€»ç»“é•¿åº¦æ§åˆ¶åœ¨150-300å­—ä¹‹é—´

è¿™æ˜¯ç¬¬ ${ci + 1}/${chunks.length} æ®µï¼Œæ—¶é—´èŒƒå›´ï¼š${chunkTimeRange}
èŠå¤©è®°å½•å¦‚ä¸‹ï¼š
${chunkContent}`;
            
            const chunkMessages = [
                { role: 'system', content: chunkPrompt },
                { role: 'user', content: 'è¯·ä¸ºè¿™æ®µèŠå¤©è®°å½•ç”Ÿæˆæ€»ç»“ã€‚' }
            ];
            
            const chunkResult = await callAI(chunkMessages, { _useSecondary: true });
            chunkSummaries.push(`ã€ç¬¬${ci + 1}æ®µ ${chunkTimeRange}ã€‘\n${chunkResult}`);
        }
        
        // åˆå¹¶æ‰€æœ‰å­æ€»ç»“ä¸ºæœ€ç»ˆæ€»ç»“
        showToast('æ­£åœ¨åˆå¹¶æ€»ç»“...');
        const mergePrompt = `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„èŠå¤©è®°å½•æ€»ç»“åŠ©æ‰‹ã€‚ä¸‹é¢æ˜¯åˆ†æ®µç”Ÿæˆçš„èŠå¤©æ€»ç»“ï¼Œè¯·å°†å®ƒä»¬åˆå¹¶ä¸ºä¸€ä»½å®Œæ•´ã€è¿è´¯çš„æ€»ç»“ã€‚

åˆå¹¶è¦æ±‚ï¼š
1. **å¿…é¡»ä½¿ç”¨ç¬¬ä¸‰äººç§°è§†è§’**ï¼šä»¥æ—è§‚è€…è§’åº¦å®¢è§‚æè¿°ï¼Œä¸¥ç¦ä½¿ç”¨"æˆ‘"ã€"æˆ‘ä»¬"ã€"ä½ "ç­‰ç¬¬ä¸€/ç¬¬äºŒäººç§°
2. **å¿…é¡»åŒ…å«æ—¶é—´ä¿¡æ¯**ï¼šåœ¨æ€»ç»“å¼€å¤´æ³¨æ˜æ—¶é—´æ®µï¼Œä¾‹å¦‚"åœ¨XæœˆXæ—¥è‡³XæœˆXæ—¥æœŸé—´"
3. **ä½¿ç”¨å¯¹è¯ä¸­çš„ç§°å‘¼**ï¼šæ€»ç»“ä¸­ç›´æ¥ä½¿ç”¨"${userName}"å’Œ"${charName}"çš„åå­—ï¼Œä¸¥ç¦ä½¿ç”¨"AI"ã€"åŠ©æ‰‹"ã€"æœºå™¨äºº"ã€"ç”¨æˆ·"ç­‰è¯æ±‡
4. ç”¨å®¢è§‚çš„å™äº‹å£å»æè¿°åŒæ–¹çš„äº¤æµ
5. æŒ‰æ—¶é—´é¡ºåºç»„ç»‡ï¼Œä¿ç•™æ‰€æœ‰é‡è¦äº‹ä»¶å’Œæƒ…æ„Ÿå˜åŒ–
6. å»é™¤é‡å¤å†…å®¹ï¼Œä½¿æ€»ç»“è¿è´¯æµç•…
7. æ€»ç»“é•¿åº¦æ§åˆ¶åœ¨300-600å­—ä¹‹é—´
8. å¦‚æœèƒ½æå–3-5ä¸ªå…³é”®è¯ï¼Œè¯·åœ¨æœ€åç”¨ã€å…³é”®è¯ã€‘æ ‡æ³¨

æ€»æ—¶é—´èŒƒå›´ï¼š${timeRange}
å…± ${allMessages.length} æ¡æ¶ˆæ¯

ä»¥ä¸‹æ˜¯å„æ®µæ€»ç»“ï¼š
${chunkSummaries.join('\n\n')}`;
        
        const mergeMessages = [
            { role: 'system', content: mergePrompt },
            { role: 'user', content: 'è¯·åˆå¹¶ä»¥ä¸Šåˆ†æ®µæ€»ç»“ä¸ºä¸€ä»½å®Œæ•´çš„æ€»ç»“ã€‚' }
        ];
        
        finalSummary = await callAI(mergeMessages, { _useSecondary: true });
    } else {
        // æ¶ˆæ¯é‡ä¸å¤§ï¼Œç›´æ¥ä¸€æ¬¡æ€§æ€»ç»“
        const chatContent = allMessages.map(msgToText).join('\n');
        
        const systemPrompt = `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„èŠå¤©è®°å½•æ€»ç»“åŠ©æ‰‹ã€‚è¯·æ ¹æ®ä»¥ä¸‹èŠå¤©è®°å½•ï¼Œç”Ÿæˆä¸€ä»½ç®€æ´ä½†å®Œæ•´çš„æ€»ç»“ã€‚

æ€»ç»“è¦æ±‚ï¼š
1. **å¿…é¡»ä½¿ç”¨ç¬¬ä¸‰äººç§°è§†è§’**ï¼šä»¥æ—è§‚è€…è§’åº¦å®¢è§‚æè¿°ï¼Œä¸¥ç¦ä½¿ç”¨"æˆ‘"ã€"æˆ‘ä»¬"ã€"ä½ "ç­‰ç¬¬ä¸€/ç¬¬äºŒäººç§°
2. **å¿…é¡»åŒ…å«æ—¶é—´ä¿¡æ¯**ï¼šåœ¨æ€»ç»“å¼€å¤´æ³¨æ˜æ—¶é—´æ®µï¼Œä¾‹å¦‚"åœ¨XæœˆXæ—¥è‡³XæœˆXæ—¥æœŸé—´"
3. **ä½¿ç”¨å¯¹è¯ä¸­çš„ç§°å‘¼**ï¼šæ€»ç»“ä¸­ç›´æ¥ä½¿ç”¨"${userName}"å’Œ"${charName}"çš„åå­—ï¼Œä¸¥ç¦ä½¿ç”¨"AI"ã€"åŠ©æ‰‹"ã€"æœºå™¨äºº"ã€"ç”¨æˆ·"ç­‰è¯æ±‡
4. ç”¨å®¢è§‚çš„å™äº‹å£å»æè¿°åŒæ–¹çš„äº¤æµï¼Œä¾‹å¦‚ï¼š"${userName}å‘${charName}è¡¨ç¤º..."ã€"${charName}å›åº”é“..."
5. æç‚¼å‡ºä¸»è¦è¯é¢˜å’Œå…³é”®ä¿¡æ¯
6. å¦‚æœæœ‰é‡è¦çš„æƒ…æ„Ÿå˜åŒ–æˆ–äº‹ä»¶ï¼Œè¦ç‰¹åˆ«æŒ‡å‡º
7. æ€»ç»“é•¿åº¦æ§åˆ¶åœ¨200-400å­—ä¹‹é—´
8. ä½¿ç”¨è‡ªç„¶æµç•…çš„ä¸­æ–‡è¡¨è¾¾
9. å¦‚æœèƒ½æå–3-5ä¸ªå…³é”®è¯ï¼Œè¯·åœ¨æœ€åç”¨ã€å…³é”®è¯ã€‘æ ‡æ³¨
10. èŠå¤©è®°å½•åŒ…å«çº¿ä¸ŠèŠå¤©ï¼ˆå¾®ä¿¡æ¶ˆæ¯ï¼‰å’Œçº¿ä¸‹è§é¢ï¼ˆæ ‡æ³¨äº†[çº¿ä¸‹è§é¢]ï¼‰çš„å†…å®¹ï¼Œè¯·ä¸€å¹¶æ€»ç»“ï¼Œè‡ªç„¶èåˆæè¿°

èŠå¤©æ—¶é—´ï¼š${timeRange}
èŠå¤©è®°å½•å¦‚ä¸‹ï¼š
${chatContent}`;

        const messages = [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: 'è¯·ä¸ºè¿™æ®µèŠå¤©è®°å½•ç”Ÿæˆæ€»ç»“ã€‚' }
        ];
        
        finalSummary = await callAI(messages, { _useSecondary: true });
    }

    // æå–å…³é”®è¯
    let keywords = [];
    const keywordMatch = finalSummary.match(/ã€å…³é”®è¯ã€‘[:ï¼š]?\s*(.+?)$/);
    let content = finalSummary;
    if (keywordMatch) {
        keywords = keywordMatch[1].split(/[,ï¼Œã€\s]+/).filter(k => k.trim());
        content = finalSummary.replace(/ã€å…³é”®è¯ã€‘[:ï¼š]?\s*.+?$/, '').trim();
    }
    
    // ä¿å­˜åˆ°æ•°æ®åº“
    const summaryData = {
        accountId: accountId,
        chatType: chatType,
        chatId: String(chatId),
        time: Date.now(),
        content: content,
        messageCount: allMessages.length,
        timeRange: timeRange,
        keywords: keywords,
        startTime: firstMsgTime,
        endTime: lastMsgTime
    };
    
    await db.chat_summaries.add(summaryData);
    
    return summaryData;
}

// æ ¼å¼åŒ–æ—¶é—´èŒƒå›´
function formatTimeRange(startTime, endTime) {
    const start = new Date(startTime);
    const end = new Date(endTime);
    
    const formatDateTime = (d) => {
        const month = d.getMonth() + 1;
        const day = d.getDate();
        const hour = String(d.getHours()).padStart(2, '0');
        const minute = String(d.getMinutes()).padStart(2, '0');
        return `${month}æœˆ${day}æ—¥ ${hour}:${minute}`;
    };
    
    const formatDate = (d) => {
        const month = d.getMonth() + 1;
        const day = d.getDate();
        return `${month}æœˆ${day}æ—¥`;
    };
    
    const startDate = formatDate(start);
    const endDate = formatDate(end);
    
    // å¦‚æœæ˜¯åŒä¸€å¤©ï¼Œæ˜¾ç¤ºå…·ä½“æ—¶é—´æ®µ
    if (startDate === endDate) {
        const startHour = String(start.getHours()).padStart(2, '0');
        const startMinute = String(start.getMinutes()).padStart(2, '0');
        const endHour = String(end.getHours()).padStart(2, '0');
        const endMinute = String(end.getMinutes()).padStart(2, '0');
        return `${startDate} ${startHour}:${startMinute} - ${endHour}:${endMinute}`;
    }
    
    // è·¨å¤©æ˜¾ç¤ºå®Œæ•´æ—¶é—´
    return `${formatDateTime(start)} - ${formatDateTime(end)}`;
}

// æ›´æ–°æ€»ç»“è®¡æ•°æ˜¾ç¤º
async function updateSummaryCount(chatType, chatId, accountId) {
    // ğŸ”§ ä¿®å¤ï¼šçº¿ä¸‹æ¨¡å¼æ²¡æœ‰è´¦å·IDï¼Œä½¿ç”¨é»˜è®¤å€¼
    if (!accountId) {
        accountId = 'offline';
        console.log('[updateSummaryCount] çº¿ä¸‹æ¨¡å¼ï¼Œä½¿ç”¨é»˜è®¤è´¦å·ID: offline');
    }
    
    let summaries = await db.chat_summaries.where('accountId').equals(accountId).toArray();
    summaries = summaries.filter(s => s.chatType === chatType && String(s.chatId) === String(chatId));
    
    const count = summaries.length;
    
    if (chatType === 'private') {
        const countEl = document.getElementById('detail-summary-count');
        if (countEl) countEl.textContent = `${count}æ¡æ€»ç»“`;
    } else if (chatType === 'group') {
        const countEl = document.getElementById('group-detail-summary-count');
        if (countEl) countEl.textContent = `${count}æ¡æ€»ç»“`;
    }
}

// æ£€æŸ¥æ˜¯å¦éœ€è¦è‡ªåŠ¨æ€»ç»“ï¼ˆåœ¨å‘é€æ¶ˆæ¯åè°ƒç”¨ï¼‰
async function checkAutoSummary(chatType, chatId, accountId) {
    const rawAccountId = accountId; // ä¿ç•™åŸå§‹å€¼ç”¨äºçº¿ä¸‹è®°å½•key
    if (!accountId) {
        accountId = 'offline';
    }
    
    let autoSummaryEnabled = false;
    let summaryInterval = 50;
    let chatHistory = [];
    
    if (chatType === 'private') {
        const char = await db.characters.get(parseInt(chatId));
        if (!char) return;
        autoSummaryEnabled = char.auto_summary_enabled;
        summaryInterval = char.summary_interval || 50;
        chatHistory = getChatHistory(char, rawAccountId);
        
        // ğŸ”§ åˆå¹¶çº¿ä¸‹æ¨¡å¼èŠå¤©è®°å½•ï¼ˆçº¿ä¸‹è®°å½•ä¹Ÿè¦ä¸€èµ·è®¡æ•°å’Œæ€»ç»“ï¼‰
        try {
            if (rawAccountId) {
                const offlineHistory = await loadOfflineChatHistory(rawAccountId, chatId);
                if (offlineHistory && offlineHistory.length > 0) {
                    // âœ… æ·»åŠ çº¿ä¸‹æ¥æºæ ‡è®°ï¼Œè®©æ€»ç»“èƒ½åŒºåˆ†çº¿ä¸Š/çº¿ä¸‹æ¶ˆæ¯
                    const taggedOffline = offlineHistory.map(m => ({ ...m, _source: 'offline' }));
                    chatHistory = [...chatHistory, ...taggedOffline];
                    chatHistory.sort((a, b) => (a.time || a.timestamp || 0) - (b.time || b.timestamp || 0));
                    console.log(`[checkAutoSummary] åˆå¹¶çº¿ä¸‹è®°å½• ${offlineHistory.length} æ¡ï¼Œæ€»è®¡ ${chatHistory.length} æ¡`);
                }
            }
        } catch (e) {
            console.warn('[checkAutoSummary] è¯»å–çº¿ä¸‹è®°å½•å¤±è´¥:', e);
        }
    } else if (chatType === 'group') {
        const group = await db.group_chats.get(parseInt(chatId));
        if (!group) return;
        autoSummaryEnabled = group.auto_summary_enabled;
        summaryInterval = group.summary_interval || 50;
        chatHistory = group.chat_history || [];
    }
    
    if (!autoSummaryEnabled) return;
    
    // è·å–ä¸Šæ¬¡æ€»ç»“åçš„æ¶ˆæ¯æ•°
    let summaries = await db.chat_summaries.where('accountId').equals(accountId).toArray();
    summaries = summaries.filter(s => s.chatType === chatType && String(s.chatId) === String(chatId));
    summaries.sort((a, b) => b.time - a.time);
    
    const lastSummary = summaries[0];
    const lastSummaryTime = lastSummary ? lastSummary.endTime : 0;
    
    // ç»Ÿè®¡ä¸Šæ¬¡æ€»ç»“åçš„æ¶ˆæ¯æ•°
    const newMessages = chatHistory.filter(msg => {
        const msgTime = msg.time || msg.timestamp || 0;
        return msgTime > lastSummaryTime;
    });
    
    // å¦‚æœè¾¾åˆ°é˜ˆå€¼ï¼Œè‡ªåŠ¨ç”Ÿæˆæ€»ç»“
    if (newMessages.length >= summaryInterval) {
        console.log(`[AutoSummary] è¾¾åˆ°é˜ˆå€¼ ${summaryInterval}ï¼Œè‡ªåŠ¨ç”Ÿæˆæ€»ç»“`);
        try {
            await generateChatSummary(chatType, chatId, accountId, newMessages);
            showToast('å·²è‡ªåŠ¨ç”ŸæˆèŠå¤©æ€»ç»“');
        } catch (e) {
            console.error('[AutoSummary] è‡ªåŠ¨æ€»ç»“å¤±è´¥:', e);
        }
    }
}

// åœ¨åŠ è½½èŠå¤©è¯¦æƒ…æ—¶æ›´æ–°æ€»ç»“è®¡æ•°
async function loadSummarySettings(chatType, chatId) {
    let accountId = getCurrentAccountId();
    // ğŸ”§ ä¿®å¤ï¼šçº¿ä¸‹æ¨¡å¼æ²¡æœ‰è´¦å·IDï¼Œä½¿ç”¨é»˜è®¤å€¼
    if (!accountId) {
        accountId = 'offline';
        console.log('[loadSummarySettings] çº¿ä¸‹æ¨¡å¼ï¼Œä½¿ç”¨é»˜è®¤è´¦å·ID: offline');
    }
    
    // æ›´æ–°æ€»ç»“è®¡æ•°
    await updateSummaryCount(chatType, chatId, accountId);
    
    // åŠ è½½è‡ªåŠ¨æ€»ç»“è®¾ç½®
    if (chatType === 'private') {
        const char = await db.characters.get(parseInt(chatId));
        if (char) {
            document.getElementById('detail-auto-summary-switch').checked = !!char.auto_summary_enabled;
            document.getElementById('detail-summary-interval').value = char.summary_interval || '';
        }
    } else if (chatType === 'group') {
        const group = await db.group_chats.get(parseInt(chatId));
        if (group) {
            document.getElementById('group-detail-auto-summary-switch').checked = !!group.auto_summary_enabled;
            document.getElementById('group-detail-summary-interval').value = group.summary_interval || '';
        }
    }
}

// ===== è”æœºåŠŸèƒ½ =====

// å…¨å±€å˜é‡
let onlineSocket = null;
let onlineConnected = false;
let onlineUserData = null;
let onlineToken = null;
let onlineCharacters = []; // å·²ä¸Šçº¿çš„è§’è‰²åˆ—è¡¨
let onlineGroups = []; // è”æœºç¾¤èŠåˆ—è¡¨
let hasShownAuthFailedAlert = false; // æ ‡å¿—ä½ï¼šæ˜¯å¦å·²ç»æç¤ºè¿‡è®¤è¯å¤±è´¥ï¼ˆé¿å…é‡è¿æ—¶åå¤å¼¹çª—ï¼‰
let currentOnlineGroupId = null; // å½“å‰æ‰“å¼€çš„è”æœºç¾¤èŠID
let currentOnlineGroupMessages = []; // å½“å‰ç¾¤èŠæ¶ˆæ¯
let currentOnlineGroupMembers = []; // å½“å‰ç¾¤èŠæˆå‘˜
let myOnlineGroupCharacter = null; // æˆ‘åœ¨å½“å‰ç¾¤èŠä¸­çš„è§’è‰²

// åˆ‡æ¢è”æœºè®¾ç½®é¢æ¿
function toggleOnlineSettings() {
    const body = document.getElementById('online-setting-body');
    const arrow = document.getElementById('online-setting-arrow');
    if (body.style.display === 'none') {
        body.style.display = 'block';
        arrow.textContent = 'â–²';
        loadOnlineSettings();
    } else {
        body.style.display = 'none';
        arrow.textContent = 'â–¼';
    }
}

// âœ… è‡ªåŠ¨åˆå§‹åŒ–è”æœºç³»ç»Ÿï¼ˆé¡µé¢åŠ è½½æ—¶è°ƒç”¨ï¼‰
async function initOnlineSystem() {
    const serverUrl = localStorage.getItem('online_server_url') || '';
    
    // åŠ è½½å·²ä¿å­˜çš„token
    onlineToken = localStorage.getItem('online_token');
    const savedUserData = localStorage.getItem('online_user_data');
    if (savedUserData) {
        try {
            onlineUserData = JSON.parse(savedUserData);
        } catch (e) {
            onlineUserData = null;
        }
    }
    
    // å¯åŠ¨è‡ªåŠ¨åŒæ­¥å®šæ—¶å™¨
    startAutoSync();
    
    // å¦‚æœæœ‰æœåŠ¡å™¨åœ°å€ï¼Œè‡ªåŠ¨è¿æ¥
    if (serverUrl) {
        console.log('[Online] è‡ªåŠ¨è¿æ¥æœåŠ¡å™¨:', serverUrl);
        try {
            await connectToOnlineServer();
            console.log('[Online] æœåŠ¡å™¨è¿æ¥æˆåŠŸ');
        } catch (e) {
            console.warn('[Online] è‡ªåŠ¨è¿æ¥å¤±è´¥:', e.message);
        }
    }
}

// åŠ è½½è”æœºè®¾ç½®ï¼ˆæ‰“å¼€è®¾ç½®é¢æ¿æ—¶è°ƒç”¨ï¼‰
function loadOnlineSettings() {
    const serverUrl = localStorage.getItem('online_server_url') || '';
    const serverUrlInput = document.getElementById('online-server-url');
    if (serverUrlInput) {
        serverUrlInput.value = serverUrl;
    }
    
    updateOnlineStatus();
}

// ä¿å­˜è”æœºè®¾ç½®
function saveOnlineSettings() {
    const serverUrl = document.getElementById('online-server-url').value.trim();
    localStorage.setItem('online_server_url', serverUrl);
}

// æ›´æ–°åœ¨çº¿çŠ¶æ€æ˜¾ç¤º
function updateOnlineStatus() {
    const statusDot = document.getElementById('online-status-dot');
    const statusText = document.getElementById('online-status-text');
    const userInfo = document.getElementById('online-user-info');
    const usernameDisplay = document.getElementById('online-username-display');
    const authButtons = document.getElementById('online-auth-buttons');
    const loggedInActions = document.getElementById('online-logged-in-actions');
    
    if (onlineConnected && onlineUserData) {
        statusDot.style.background = '#4caf50';
        statusText.textContent = 'å·²è¿æ¥';
        statusText.style.color = '#4caf50';
        userInfo.style.display = 'block';
        usernameDisplay.textContent = onlineUserData.username;
        authButtons.style.display = 'none';
        loggedInActions.style.display = 'block';
    } else if (onlineConnected) {
        statusDot.style.background = '#ff9800';
        statusText.textContent = 'å·²è¿æ¥ï¼ˆæœªç™»å½•ï¼‰';
        statusText.style.color = '#ff9800';
        userInfo.style.display = 'none';
        authButtons.style.display = 'flex';
        loggedInActions.style.display = 'none';
    } else {
        statusDot.style.background = '#ccc';
        statusText.textContent = 'æœªè¿æ¥';
        statusText.style.color = '#666';
        userInfo.style.display = 'none';
        authButtons.style.display = 'flex';
        loggedInActions.style.display = 'none';
    }
}

// æµ‹è¯•è¿æ¥
async function testOnlineConnection() {
    const serverUrl = document.getElementById('online-server-url').value.trim();
    const statusEl = document.getElementById('online-connection-status');
    const btnText = document.getElementById('test-online-btn-text');
    
    if (!serverUrl) {
        statusEl.innerHTML = '<span style="color:#ff3b30;">è¯·å¡«å†™æœåŠ¡å™¨åœ°å€</span>';
        return;
    }
    
    btnText.textContent = 'è¿æ¥ä¸­...';
    statusEl.innerHTML = '<span style="color:#999;">æ­£åœ¨è¿æ¥...</span>';
    
    try {
        await connectToOnlineServer();
        statusEl.innerHTML = '<span style="color:#4caf50;">âœ“ è¿æ¥æˆåŠŸ</span>';
    } catch (e) {
        statusEl.innerHTML = `<span style="color:#ff3b30;">âœ— è¿æ¥å¤±è´¥: ${e.message}</span>`;
    }
    
    btnText.textContent = 'æµ‹è¯•è¿æ¥';
}

// è¿æ¥åˆ°æœåŠ¡å™¨
function connectToOnlineServer() {
    return new Promise((resolve, reject) => {
        const serverUrl = document.getElementById('online-server-url').value.trim() || localStorage.getItem('online_server_url');
        
        if (!serverUrl) {
            reject(new Error('æœªè®¾ç½®æœåŠ¡å™¨åœ°å€'));
            return;
        }
        
        // å…³é—­æ—§è¿æ¥
        if (onlineSocket) {
            onlineSocket.close();
        }
        
        try {
            onlineSocket = new WebSocket(serverUrl);
            
            onlineSocket.onopen = async () => {
                console.log('[Online] WebSocket connected');
                onlineConnected = true;
                updateOnlineStatus();
                
                // è·å–äº²å±å¡åˆ—è¡¨
                const onlineUserChar = await getOrCreateOnlineUserChar();
                if (onlineUserChar) {
                    onlineSocket.send(JSON.stringify({
                        type: 'get_family_cards',
                        my_wx_account: onlineUserChar.identity.account
                    }));
                }
                
                // å¦‚æœæœ‰tokenï¼Œå‘é€è®¤è¯
                if (onlineToken) {
                    onlineSocket.send(JSON.stringify({
                        type: 'auth',
                        token: onlineToken
                    }));
                }
                
                // å¯åŠ¨å¿ƒè·³å®šæ—¶å™¨ï¼Œæ¯25ç§’å‘é€ä¸€æ¬¡å¿ƒè·³
                if (window.onlineHeartbeatTimer) {
                    clearInterval(window.onlineHeartbeatTimer);
                }
                window.onlineHeartbeatTimer = setInterval(() => {
                    if (onlineConnected && onlineSocket && onlineSocket.readyState === WebSocket.OPEN) {
                        onlineSocket.send(JSON.stringify({ type: 'ping' }));
                    }
                }, 25000);
                
                resolve();
            };
            
            onlineSocket.onmessage = (event) => {
                handleOnlineMessage(JSON.parse(event.data));
            };
            
            onlineSocket.onclose = () => {
                console.log('[Online] WebSocket disconnected');
                onlineConnected = false;
                onlineCharacters = []; // æ¸…ç©ºåœ¨çº¿è§’è‰²åˆ—è¡¨
                updateOnlineStatus();
                
                // æ¸…é™¤å¿ƒè·³å®šæ—¶å™¨
                if (window.onlineHeartbeatTimer) {
                    clearInterval(window.onlineHeartbeatTimer);
                    window.onlineHeartbeatTimer = null;
                }
            };
            
            onlineSocket.onerror = (error) => {
                console.error('[Online] WebSocket error:', error);
                onlineConnected = false;
                updateOnlineStatus();
                reject(new Error('è¿æ¥å¤±è´¥'));
            };
            
            // è®¾ç½®è¶…æ—¶
            setTimeout(() => {
                if (!onlineConnected) {
                    onlineSocket.close();
                    reject(new Error('è¿æ¥è¶…æ—¶'));
                }
            }, 10000);
            
        } catch (e) {
            reject(e);
        }
    });
}

// å¤„ç†æœåŠ¡å™¨æ¶ˆæ¯
async function handleOnlineMessage(data) {
    // å¿ƒè·³å“åº”ä¸éœ€è¦æ‰“å°æ—¥å¿—
    if (data.type === 'pong') return;
    
    console.log('[Online] Received:', data);
    
    switch (data.type) {
        case 'auth_success':
            onlineUserData = data.user;
            localStorage.setItem('online_user_data', JSON.stringify(data.user));
            updateOnlineStatus();
            // âœ… è®¤è¯æˆåŠŸåï¼Œé‡ç½®æç¤ºæ ‡å¿—ä½
            hasShownAuthFailedAlert = false;
            console.log('[Online] è®¤è¯æˆåŠŸï¼Œè‡ªåŠ¨æ³¨å†Œæ‰€æœ‰è§’è‰²åˆ°æœåŠ¡å™¨...');
            // å…ˆæ³¨å†Œæ‰€æœ‰è§’è‰²åˆ°æœåŠ¡å™¨ï¼ˆä¸ä¸Šçº¿ï¼Œä»…ç”¨äºæœç´¢ï¼‰
            await autoRegisterAllUserCharacters();
            // è·å–å·²ä¸Šçº¿çš„è§’è‰²ï¼Œç„¶åè‡ªåŠ¨ä¸Šçº¿æœ¬åœ°è§’è‰²
            requestOnlineCharacters();
            // âœ… è‡ªåŠ¨ä¸Šçº¿æ‰€æœ‰ User ç±»å‹çš„è§’è‰²ï¼ˆè§’è‰²ä¸Šçº¿åä¼šé€šè¿‡ character_online äº‹ä»¶è‡ªåŠ¨è·å–ç¾¤èŠåˆ—è¡¨ï¼‰
            autoGoOnlineAllUserCharacters();
            break;
            
        case 'auth_failed':
            onlineToken = null;
            onlineUserData = null;
            localStorage.removeItem('online_token');
            localStorage.removeItem('online_user_data');
            updateOnlineStatus();
            
            // âœ… é¿å…é‡è¿æ—¶åå¤å¼¹çª—ï¼šåªåœ¨é¦–æ¬¡å¤±è´¥æ—¶å¼¹å‡º alertï¼Œåç»­åªè®°å½•æ—¥å¿—å’Œä½¿ç”¨ toast
            const errorMsg = data.message || 'è®¤è¯å¤±è´¥';
            if (!hasShownAuthFailedAlert) {
                // é¦–æ¬¡æç¤ºï¼šä½¿ç”¨ alert
                hasShownAuthFailedAlert = true;
                if (errorMsg.includes('è¿‡æœŸ') || errorMsg.includes('æ— æ•ˆ') || errorMsg.includes('expired') || errorMsg.includes('invalid')) {
                    alert('ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•ï¼ˆä¸è¦æ³¨å†Œæ–°è´¦å·ï¼Œä½¿ç”¨ä¹‹å‰çš„ç”¨æˆ·åå’Œå¯†ç ç™»å½•ï¼‰');
                    // æ˜¾ç¤ºç™»å½•å¼¹çª—
                    showOnlineLoginModal();
                } else {
                    alert('ç™»å½•å¤±è´¥: ' + errorMsg);
                }
            } else {
                // åç»­é‡è¿æ—¶ï¼šåªä½¿ç”¨é™é»˜çš„ toast æç¤ºæˆ–æ§åˆ¶å°æ—¥å¿—
                console.log('[Online] è®¤è¯å¤±è´¥ï¼ˆå·²æç¤ºè¿‡ï¼‰:', errorMsg);
                // ä½¿ç”¨éä¾µå…¥å¼çš„ toast æ›¿ä»£ alert
                showToast('ç™»å½•å·²è¿‡æœŸï¼Œè¯·ç‚¹å‡»è”æœºæŒ‰é’®é‡æ–°ç™»å½•');
            }
            break;
            
        case 'login_success':
            onlineToken = data.token;
            onlineUserData = data.user;
            localStorage.setItem('online_token', data.token);
            localStorage.setItem('online_user_data', JSON.stringify(data.user));
            updateOnlineStatus();
            // âœ… ç™»å½•æˆåŠŸåï¼Œé‡ç½®æç¤ºæ ‡å¿—ä½
            hasShownAuthFailedAlert = false;
            closeModal('online-login-modal');
            showToast('ç™»å½•æˆåŠŸ');
            console.log('[Online] ç™»å½•æˆåŠŸï¼Œè‡ªåŠ¨æ³¨å†Œæ‰€æœ‰è§’è‰²åˆ°æœåŠ¡å™¨...');
            // å…ˆæ³¨å†Œæ‰€æœ‰è§’è‰²åˆ°æœåŠ¡å™¨ï¼ˆä¸ä¸Šçº¿ï¼Œä»…ç”¨äºæœç´¢ï¼‰
            await autoRegisterAllUserCharacters();
            requestOnlineCharacters();
            // âœ… è‡ªåŠ¨ä¸Šçº¿æ‰€æœ‰ User ç±»å‹çš„è§’è‰²
            autoGoOnlineAllUserCharacters();
            break;
            
        case 'register_success':
            onlineToken = data.token;
            onlineUserData = data.user;
            localStorage.setItem('online_token', data.token);
            localStorage.setItem('online_user_data', JSON.stringify(data.user));
            updateOnlineStatus();
            closeModal('online-register-modal');
            showToast('æ³¨å†ŒæˆåŠŸ');
            break;
            
        case 'error':
            alert(data.message || 'æ“ä½œå¤±è´¥');
            break;
            
        case 'search_result':
            displayOnlineSearchResult(data.result);
            break;
            
        case 'friend_request':
            // æ”¶åˆ°å¥½å‹ç”³è¯·
            handleOnlineFriendRequest(data.request);
            break;
            
        case 'friend_request_accepted':
            // å¥½å‹ç”³è¯·è¢«æ¥å—
            handleFriendRequestAccepted(data);
            break;
        
        case 'family_card_received':
            // æ”¶åˆ°äº²å±å¡
            handleFamilyCardReceived(data);
            break;
        
        case 'family_card_sent':
            // äº²å±å¡å‘é€æˆåŠŸ
            showToast('äº²å±å¡å·²èµ é€');
            // é‡æ–°è·å–äº²å±å¡åˆ—è¡¨
            const onlineUserChar = await getOrCreateOnlineUserChar();
            if (onlineUserChar && onlineSocket) {
                onlineSocket.send(JSON.stringify({
                    type: 'get_family_cards',
                    my_wx_account: onlineUserChar.identity.account
                }));
            }
            break;
        
        case 'family_card_used':
            // äº²å±å¡è¢«ä½¿ç”¨
            handleFamilyCardUsed(data);
            break;
        
        case 'family_card_payment_success':
            // ä½¿ç”¨äº²å±å¡æ”¯ä»˜æˆåŠŸ
            showToast('æ”¯ä»˜æˆåŠŸ');
            break;
        
        case 'family_cards_list':
            // æ”¶åˆ°äº²å±å¡åˆ—è¡¨
            handleFamilyCardsList(data);
            break;
            
        case 'message':
            // æ”¶åˆ°è”æœºæ¶ˆæ¯
            handleOnlineIncomingMessage(data);
            break;
            
        case 'online_characters':
            // å·²ä¸Šçº¿çš„è§’è‰²åˆ—è¡¨
            onlineCharacters = data.characters || [];
            console.log('[Online] æ”¶åˆ°åœ¨çº¿è§’è‰²åˆ—è¡¨:', onlineCharacters.length, 'ä¸ª', onlineCharacters.map(c => c.wx_account).join(', '));
            // åˆ·æ–°è”æœºçŠ¶æ€é¡µé¢ï¼ˆå¦‚æœæ‰“å¼€çš„è¯ï¼‰
            refreshOnlineStatusPageContent();
            break;
            
        case 'character_online':
            // è‡ªåŠ¨ä¸Šçº¿ï¼Œä¸éœ€è¦ Toast æç¤º
            console.log(`[Online] è§’è‰² ${data.nickname} å·²åŒæ­¥`);
            requestOnlineCharacters();
            // åˆ·æ–°è”æœºçŠ¶æ€é¡µé¢ï¼ˆå¦‚æœæ‰“å¼€çš„è¯ï¼‰
            refreshOnlineStatusPageContent();
            // âœ… è·å–è”æœºç¾¤èŠåˆ—è¡¨ï¼ˆä½¿ç”¨ç¬¬ä¸€ä¸ªä¸Šçº¿çš„è§’è‰²ï¼‰
            if (data.wx_account && onlineSocket && onlineSocket.readyState === WebSocket.OPEN) {
                console.log('[Online] è§’è‰²ä¸Šçº¿åï¼Œè‡ªåŠ¨è·å–ç¾¤èŠåˆ—è¡¨ï¼Œä½¿ç”¨å¾®ä¿¡å·:', data.wx_account);
                onlineSocket.send(JSON.stringify({
                    type: 'get_online_groups',
                    my_wx_account: data.wx_account
                }));
            }
            break;
            
        case 'character_offline':
            // è‡ªåŠ¨å¤„ç†ï¼Œä¸éœ€è¦ Toast æç¤º
            console.log('[Online] è§’è‰²å·²ç¦»çº¿');
            requestOnlineCharacters();
            // åˆ·æ–°è”æœºçŠ¶æ€é¡µé¢ï¼ˆå¦‚æœæ‰“å¼€çš„è¯ï¼‰
            refreshOnlineStatusPageContent();
            break;
        
        // ==================== è”æœºç¾¤èŠæ¶ˆæ¯ ====================
        case 'online_group_created':
            // ç¾¤èŠåˆ›å»ºæˆåŠŸ
            showToast(`ç¾¤èŠ"${data.group.name}"åˆ›å»ºæˆåŠŸ`);
            onlineGroups.push(data.group);
            refreshOnlineGroupList();
            // åŒæ—¶åœ¨æœ¬åœ°åˆ›å»ºç¾¤èŠè®°å½•ï¼Œè®©å®ƒæ˜¾ç¤ºåœ¨æ¶ˆæ¯åˆ—è¡¨ä¸­
            await createLocalOnlineGroupChat(data.group);
            break;
            
        case 'group_invite':
            // æ”¶åˆ°ç¾¤èŠé‚€è¯·
            handleOnlineGroupInvite(data);
            break;
            
        case 'online_group_joined':
            // åŠ å…¥ç¾¤èŠæˆåŠŸ
            showToast(`å·²åŠ å…¥ç¾¤èŠ"${data.group.name}"`);
            if (!onlineGroups.find(g => g.id === data.group.id)) {
                onlineGroups.push(data.group);
            }
            refreshOnlineGroupList();
            // åŒæ—¶åœ¨æœ¬åœ°åˆ›å»ºç¾¤èŠè®°å½•ï¼Œè®©å®ƒæ˜¾ç¤ºåœ¨æ¶ˆæ¯åˆ—è¡¨ä¸­
            await createLocalOnlineGroupChat(data.group);
            break;
            
        case 'group_member_joined':
            // æœ‰æ–°æˆå‘˜åŠ å…¥ç¾¤èŠ
            if (currentOnlineGroupId === data.group_id) {
                showToast(`${data.member.user_name} åŠ å…¥äº†ç¾¤èŠ`);
                refreshOnlineGroupMembers();
            }
            break;
            
        case 'online_groups_list':
            // æ”¶åˆ°ç¾¤èŠåˆ—è¡¨
            onlineGroups = data.groups || [];
            refreshOnlineGroupList();
            // ä¸ºæ¯ä¸ªç¾¤èŠåˆ›å»ºæœ¬åœ°è®°å½•
            for (const group of onlineGroups) {
                await createLocalOnlineGroupChat(group);
            }
            break;
            
        case 'group_messages':
            // æ”¶åˆ°ç¾¤èŠæ¶ˆæ¯è®°å½•
            handleOnlineGroupMessages(data);
            break;
            
        case 'group_message':
            // æ”¶åˆ°å®æ—¶ç¾¤æ¶ˆæ¯
            handleOnlineGroupMessage(data);
            break;
            
        case 'group_typing_start':
            // æ”¶åˆ°ç¾¤æˆå‘˜æ­£åœ¨è¾“å…¥çš„é€šçŸ¥
            handleGroupTypingStart(data);
            break;
            
        case 'group_typing_stop':
            // æ”¶åˆ°ç¾¤æˆå‘˜åœæ­¢è¾“å…¥çš„é€šçŸ¥
            handleGroupTypingStop(data);
            break;
            
        case 'group_members':
            // æ”¶åˆ°ç¾¤æˆå‘˜åˆ—è¡¨
            handleOnlineGroupMembers(data);
            break;
            
        case 'group_character_updated':
            // è§’è‰²æ›´æ–°æˆåŠŸ
            showToast('ç¾¤å†…è§’è‰²å·²æ›´æ–°');
            break;
            
        case 'redpacket_claimed':
            // çº¢åŒ…è¢«é¢†å–ï¼Œæ›´æ–°çº¢åŒ…çŠ¶æ€
            handleRedPacketClaimed(data);
            break;
    }
}

// æ˜¾ç¤ºç™»å½•å¼¹çª—
function showOnlineLoginModal() {
    const serverUrl = document.getElementById('online-server-url').value.trim();
    if (!serverUrl) {
        alert('è¯·å…ˆå¡«å†™æœåŠ¡å™¨åœ°å€');
        return;
    }
    document.getElementById('online-login-modal').style.display = 'flex';
}

// æ˜¾ç¤ºæ³¨å†Œå¼¹çª—
function showOnlineRegisterModal() {
    const serverUrl = document.getElementById('online-server-url').value.trim();
    if (!serverUrl) {
        alert('è¯·å…ˆå¡«å†™æœåŠ¡å™¨åœ°å€');
        return;
    }
    document.getElementById('online-register-modal').style.display = 'flex';
}

// æ‰§è¡Œç™»å½•
async function doOnlineLogin() {
    const username = document.getElementById('online-login-username').value.trim();
    const password = document.getElementById('online-login-password').value;
    
    if (!username || !password) {
        alert('è¯·å¡«å†™ç”¨æˆ·åå’Œå¯†ç ');
        return;
    }
    
    // ç¡®ä¿å·²è¿æ¥
    if (!onlineConnected) {
        try {
            await connectToOnlineServer();
        } catch (e) {
            alert('æ— æ³•è¿æ¥æœåŠ¡å™¨: ' + e.message);
            return;
        }
    }
    
    onlineSocket.send(JSON.stringify({
        type: 'login',
        username: username,
        password: password
    }));
}

// æ‰§è¡Œæ³¨å†Œ
async function doOnlineRegister() {
    const username = document.getElementById('online-register-username').value.trim();
    const email = document.getElementById('online-register-email').value.trim();
    const password = document.getElementById('online-register-password').value;
    const password2 = document.getElementById('online-register-password2').value;
    
    if (!username) {
        alert('è¯·å¡«å†™ç”¨æˆ·å');
        return;
    }
    
    if (!/^[a-zA-Z0-9_]{3,20}$/.test(username)) {
        alert('ç”¨æˆ·ååªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—å’Œä¸‹åˆ’çº¿ï¼Œé•¿åº¦3-20ä½');
        return;
    }
    
    if (!password || password.length < 6) {
        alert('å¯†ç è‡³å°‘6ä½');
        return;
    }
    
    if (password !== password2) {
        alert('ä¸¤æ¬¡è¾“å…¥çš„å¯†ç ä¸ä¸€è‡´');
        return;
    }
    
    // ç¡®ä¿å·²è¿æ¥
    if (!onlineConnected) {
        try {
            await connectToOnlineServer();
        } catch (e) {
            alert('æ— æ³•è¿æ¥æœåŠ¡å™¨: ' + e.message);
            return;
        }
    }
    
    onlineSocket.send(JSON.stringify({
        type: 'register',
        username: username,
        email: email || null,
        password: password
    }));
}

// é€€å‡ºç™»å½•
function onlineLogout() {
    if (confirm('ç¡®å®šè¦é€€å‡ºè”æœºç™»å½•å—ï¼Ÿ')) {
        onlineToken = null;
        onlineUserData = null;
        onlineCharacters = [];
        localStorage.removeItem('online_token');
        localStorage.removeItem('online_user_data');
        updateOnlineStatus();
        
        if (onlineSocket) {
            onlineSocket.send(JSON.stringify({ type: 'logout' }));
        }
        
        showToast('å·²é€€å‡ºç™»å½•');
    }
}

// æ˜¾ç¤ºè”æœºæœç´¢å¼¹çª—
async function showOnlineSearchModal() {
    toggleWechatMenu(); // å…³é—­èœå•
    
    if (!onlineConnected || !onlineUserData) {
        alert('è¯·å…ˆåœ¨è®¾ç½®ä¸­è¿æ¥æœåŠ¡å™¨å¹¶ç™»å½•');
        return;
    }
    
    // âœ… æ£€æŸ¥æ˜¯å¦æœ‰å¯ç”¨çš„Userè§’è‰²ï¼ˆæœ‰å¾®ä¿¡å·ï¼‰
    const userChars = await db.characters.where('type').equals('user').toArray();
    const availableChars = userChars.filter(c => c.identity?.account);
    
    if (availableChars.length === 0) {
        alert('è¯·å…ˆåˆ›å»ºè‡³å°‘ä¸€ä¸ªUserè§’è‰²å¹¶è®¾ç½®å¾®ä¿¡å·');
        return;
    }
    
    // å¡«å……èº«ä»½é€‰æ‹©ä¸‹æ‹‰æ¡† - ä½¿ç”¨æœ¬åœ°Userè§’è‰²åˆ—è¡¨
    const select = document.getElementById('online-search-my-persona');
    select.innerHTML = availableChars.map(char => 
        `<option value="${char.identity.account}">${char.remark || char.wx_nickname || char.name} (${char.identity.account})</option>`
    ).join('');
    
    // æ¸…ç©ºä¹‹å‰çš„æœç´¢ç»“æœ
    document.getElementById('online-search-input').value = '';
    document.getElementById('online-search-result').style.display = 'none';
    document.getElementById('online-search-empty').style.display = 'none';
    document.getElementById('online-search-message').value = '';
    
    document.getElementById('online-search-modal').style.display = 'flex';
}

// æ‰§è¡Œè”æœºæœç´¢
function doOnlineSearch() {
    const wxAccount = document.getElementById('online-search-input').value.trim();
    
    if (!wxAccount) {
        alert('è¯·è¾“å…¥è¦æœç´¢çš„è™šæ‹Ÿå¾®ä¿¡å·');
        return;
    }
    
    if (!onlineConnected) {
        alert('æœåŠ¡å™¨æœªè¿æ¥ï¼Œè¯·å…ˆè¿æ¥æœåŠ¡å™¨');
        return;
    }
    
    if (!onlineSocket || onlineSocket.readyState !== WebSocket.OPEN) {
        alert('WebSocket è¿æ¥æœªå»ºç«‹ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨è¿æ¥');
        return;
    }
    
    console.log('[Online] æœç´¢å¾®ä¿¡å·:', wxAccount);
    
    // æ˜¾ç¤ºæœç´¢ä¸­çŠ¶æ€
    const resultEl = document.getElementById('online-search-result');
    const emptyEl = document.getElementById('online-search-empty');
    if (resultEl) resultEl.style.display = 'none';
    if (emptyEl) {
        emptyEl.style.display = 'block';
        emptyEl.innerHTML = '<div style="text-align:center; padding:20px; color:#999;">æœç´¢ä¸­...</div>';
    }
    
    try {
        onlineSocket.send(JSON.stringify({
            type: 'search_user',
            wx_account: wxAccount
        }));
        console.log('[Online] æœç´¢è¯·æ±‚å·²å‘é€');
    } catch (e) {
        console.error('[Online] å‘é€æœç´¢è¯·æ±‚å¤±è´¥:', e);
        alert('æœç´¢å¤±è´¥: ' + e.message);
    }
}

// æ˜¾ç¤ºæœç´¢ç»“æœ
function displayOnlineSearchResult(result) {
    console.log('[Online] æ”¶åˆ°æœç´¢ç»“æœ:', result);
    
    const resultEl = document.getElementById('online-search-result');
    const emptyEl = document.getElementById('online-search-empty');
    
    if (!result) {
        console.log('[Online] æœç´¢ç»“æœä¸ºç©º');
        if (resultEl) resultEl.style.display = 'none';
        if (emptyEl) {
            emptyEl.style.display = 'block';
            emptyEl.innerHTML = '<div style="text-align:center; padding:20px; color:#999;">æœªæ‰¾åˆ°è¯¥å¾®ä¿¡å·<br><span style="font-size:12px; color:#ccc;">æç¤ºï¼šåªæœ‰è§’è‰²ä¸Šçº¿åæ‰èƒ½è¢«æœç´¢åˆ°</span></div>';
        }
        return;
    }
    
    console.log('[Online] æ˜¾ç¤ºæœç´¢ç»“æœ:', result.nickname);
    
    if (emptyEl) emptyEl.style.display = 'none';
    if (resultEl) {
        resultEl.style.display = 'block';
        
        // å¡«å……ç»“æœ
        const avatarEl = document.getElementById('online-search-avatar');
        const nicknameEl = document.getElementById('online-search-nickname');
        const wxidEl = document.getElementById('online-search-wxid');
        const bioEl = document.getElementById('online-search-bio');
        const statusEl = document.getElementById('online-search-online-status');
        
        if (avatarEl) {
            avatarEl.style.backgroundImage = result.avatar ? `url(${result.avatar})` : '';
        }
        if (nicknameEl) {
            nicknameEl.textContent = result.nickname || 'æœªè®¾ç½®æ˜µç§°';
        }
        if (wxidEl) {
            wxidEl.textContent = result.wx_account;
        }
        // éšè— bioï¼ˆäººè®¾ï¼‰ï¼Œä¿æŠ¤éšç§
        if (bioEl) {
            bioEl.style.display = 'none';
        }
        
        if (statusEl) {
            if (result.is_online) {
                statusEl.textContent = 'åœ¨çº¿';
                statusEl.style.background = '#e8f5e9';
                statusEl.style.color = '#4caf50';
            } else {
                statusEl.textContent = 'ç¦»çº¿';
                statusEl.style.background = '#f5f5f5';
                statusEl.style.color = '#999';
            }
        }
        
        // ä¿å­˜æœç´¢ç»“æœä¾›å‘é€ç”³è¯·ä½¿ç”¨
        resultEl.dataset.wxAccount = result.wx_account;
    }
}

// å‘é€è”æœºå¥½å‹ç”³è¯·
function sendOnlineFriendRequest() {
    const resultEl = document.getElementById('online-search-result');
    const toWxAccount = resultEl.dataset.wxAccount;
    const fromWxAccount = document.getElementById('online-search-my-persona').value;
    const message = document.getElementById('online-search-message').value.trim();
    
    if (!toWxAccount || !fromWxAccount) {
        alert('è¯·é€‰æ‹©ä½ çš„èº«ä»½');
        return;
    }
    
    onlineSocket.send(JSON.stringify({
        type: 'friend_request',
        from_wx_account: fromWxAccount,
        to_wx_account: toWxAccount,
        message: message || 'è¯·æ±‚æ·»åŠ ä½ ä¸ºå¥½å‹'
    }));
    
    closeModal('online-search-modal');
    showToast('å¥½å‹ç”³è¯·å·²å‘é€');
}

// å¤„ç†æ”¶åˆ°çš„å¥½å‹ç”³è¯·
async function handleOnlineFriendRequest(request) {
    console.log('[Online] æ”¶åˆ°å¥½å‹ç”³è¯·:', request);
    
    // åˆ›å»ºä¸€ä¸ªé€šçŸ¥
    sendSystemNotification('æ–°çš„å¥½å‹ç”³è¯·', `${request.from_nickname} (${request.from_wx_account}) æƒ³æ·»åŠ ä½ ä¸ºå¥½å‹`);
    
    // å°†ç”³è¯·ä¿å­˜åˆ°æœ¬åœ°å¥½å‹ç”³è¯·åˆ—è¡¨
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    await db.friend_requests.add({
        fromCharId: null, // è”æœºå¥½å‹æ²¡æœ‰æœ¬åœ°charId
        toAccountId: accountId,
        status: 'pending',
        time: Date.now(),
        isOnline: true, // æ ‡è®°ä¸ºè”æœºå¥½å‹ç”³è¯·
        onlineData: request // ä¿å­˜è”æœºæ•°æ®
    });
    
    // åˆ·æ–°æ–°çš„å¥½å‹é¡µé¢
    if (document.getElementById('new-friends-page').style.display !== 'none') {
        renderNewFriendsPage();
    }
}

// å¥½å‹ç”³è¯·è¢«æ¥å—
async function handleFriendRequestAccepted(data) {
    console.log('[Online] å¥½å‹ç”³è¯·è¢«æ¥å—:', data);
    
    // åœ¨æœ¬åœ°åˆ›å»ºä¸€ä¸ªè”æœºå¥½å‹è§’è‰²
    const accountId = getCurrentAccountId();
    const newChar = {
        name: data.friend_nickname,
        type: 'online_friend', // ç‰¹æ®Šç±»å‹ï¼šè”æœºå¥½å‹
        avatar: data.friend_avatar || '',
        description: data.friend_bio || '',
        identity: {
            account: data.friend_wx_account
        },
        isOnlineFriend: true,
        onlineData: {
            wx_account: data.friend_wx_account,
            user_id: data.friend_user_id
        },
        wechat_status_by_user: {}  // ä½¿ç”¨æ­£ç¡®çš„å­—æ®µåï¼Œä¸ getFriendStatus åŒ¹é…
    };
    
    // è®¾ç½®å¥½å‹å…³ç³»
    if (accountId) {
        newChar.wechat_status_by_user[accountId] = 'friend';
    }
    
    const charId = await db.characters.add(newChar);
    
    showToast(`${data.friend_nickname} å·²æˆä¸ºä½ çš„å¥½å‹`);
    
    // åˆ·æ–°å¾®ä¿¡åˆ—è¡¨
    const content = document.getElementById('wechat-content');
    if (content) {
        renderWechatList(content);
    }
}

// å¤„ç†æ”¶åˆ°çš„è”æœºæ¶ˆæ¯
async function handleOnlineIncomingMessage(data) {
    console.log('[Online] æ”¶åˆ°æ¶ˆæ¯:', data);
    
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    // æŸ¥æ‰¾æœ¬åœ°å¯¹åº”çš„è”æœºå¥½å‹è§’è‰²
    const chars = await db.characters.where('type').equals('online_friend').toArray();
    let targetChar = chars.find(c => c.onlineData?.wx_account === data.from_wx_account);
    
    if (!targetChar) {
        console.warn('[Online] æœªæ‰¾åˆ°å¯¹åº”çš„è”æœºå¥½å‹è§’è‰²');
        return;
    }
    
    // âœ… æ›´æ–°å¥½å‹çš„å¤´åƒï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰
    const _onlineAid = getCurrentAccountId();
    const _curOnlineAvatar = getCharAvatar(targetChar, _onlineAid);
    if (data.from_avatar && data.from_avatar !== _curOnlineAvatar) {
        console.log('[Online] æ›´æ–°å¥½å‹å¤´åƒ:', data.from_wx_account);
        setCharAvatar(targetChar, _onlineAid, data.from_avatar);
        await safeCharacterPut(targetChar);
        targetChar = await db.characters.get(targetChar.id);
    }
    
    // âœ… ç¡®ä¿è”æœºå¥½å‹åœ¨å½“å‰è´¦å·ä¸‹çš„å¥½å‹çŠ¶æ€æ˜¯ 'friend'
    // è¿™æ ·åˆ‡æ¢è´¦å·åæ¶ˆæ¯ä¹Ÿèƒ½æ­£å¸¸æ˜¾ç¤º
    const currentFriendStatus = getFriendStatus(targetChar, accountId);
    if (currentFriendStatus !== 'friend') {
        console.log('[Online] ä¸ºå½“å‰è´¦å·è®¾ç½®è”æœºå¥½å‹çŠ¶æ€ä¸º friend');
        if (!targetChar.wechat_status_by_user) targetChar.wechat_status_by_user = {};
        targetChar.wechat_status_by_user[accountId] = 'friend';
        // æ›´æ–°åé‡æ–°è·å–ï¼Œç¡®ä¿åç»­é€»è¾‘ä½¿ç”¨æœ€æ–°æ•°æ®
        await safeCharacterPut(targetChar);
        targetChar = await db.characters.get(targetChar.id);
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯ç‰¹æ®Šæ¶ˆæ¯ç±»å‹ï¼ˆå¦‚è½¬è´¦ï¼‰
    let msgObj = {
        role: 'char',
        content: data.content,
        time: data.timestamp || Date.now(),
        isOnlineMessage: true
    };
    
    // å°è¯•è§£æ JSON æ ¼å¼çš„ç‰¹æ®Šæ¶ˆæ¯
    try {
        const parsed = JSON.parse(data.content);
        if (parsed.__type === 'transfer') {
            // è¿™æ˜¯è½¬è´¦æ¶ˆæ¯ï¼Œè½¬æ¢ä¸ºè½¬è´¦å¡ç‰‡æ ¼å¼
            msgObj.type = 'transfer';
            msgObj.content = JSON.stringify({
                amount: parsed.amount,
                desc: parsed.desc,
                status: 'sent'  // å¯¹äºæ¥æ”¶æ–¹æ¥è¯´æ˜¯å¾…æ¥æ”¶çŠ¶æ€
            });
            msgObj.id = 'trans_' + Date.now();
            console.log('[Online] æ”¶åˆ°è½¬è´¦æ¶ˆæ¯:', parsed);
        } else if (parsed.__type === 'familyCard') {
            // ğŸ¯ è¿™æ˜¯äº²å±å¡æ¶ˆæ¯ï¼ˆå’Œè½¬è´¦ä¸€æ ·çš„å¤„ç†æ–¹å¼ï¼‰
            msgObj.type = 'familyCard';
            msgObj.content = JSON.stringify({
                fromName: parsed.fromName || data.from_nickname,
                monthlyLimit: parsed.monthlyLimit || 0,
                status: 'received',
                isOnline: true,
                message: parsed.message || ''
            });
            console.log('[Online] æ”¶åˆ°äº²å±å¡æ¶ˆæ¯:', parsed);
        } else if (parsed.__type === 'audio') {
            // è¿™æ˜¯è¯­éŸ³æ¶ˆæ¯
            msgObj.type = 'audio';
            msgObj.content = parsed.audio;
            msgObj.duration = parsed.duration;
            msgObj.effect = parsed.effect;
            console.log('[Online] æ”¶åˆ°è¯­éŸ³æ¶ˆæ¯, æ—¶é•¿:', parsed.duration, 'ç§’, æ•ˆæœ:', parsed.effect);
        }
    } catch (e) {
        // ä¸æ˜¯ JSONï¼Œæ™®é€šæ–‡æœ¬æ¶ˆæ¯
    }
    
    // ä¿å­˜æ¶ˆæ¯åˆ°èŠå¤©å†å²
    let history = getChatHistory(targetChar, accountId);
    history.push(msgObj);
    await setChatHistory(targetChar, accountId, history);
    
    // å¦‚æœå½“å‰æ­£åœ¨æŸ¥çœ‹è¿™ä¸ªèŠå¤©ï¼Œæ›´æ–°UI
    if (currentChatCharId === targetChar.id) {
        // ç‰¹æ®Šæ¶ˆæ¯ç±»å‹éœ€è¦é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©ï¼ˆåŒ…æ‹¬å›¾ç‰‡ã€è½¬è´¦ã€è¯­éŸ³ã€äº²å±å¡ï¼‰
        if (msgObj.type === 'transfer' || msgObj.type === 'familyCard' || msgObj.type === 'audio' || data.content.startsWith('[img:')) {
            renderChatBody(targetChar);
        } else {
            // âœ… ä½¿ç”¨æœåŠ¡å™¨å‘é€çš„å¤´åƒï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨æœ¬åœ°å¤´åƒ
            const avatarToUse = data.from_avatar || targetChar.avatar;
            appendMessageToUI('char', data.content, avatarToUse);
        }
    } else {
        // å‘é€é€šçŸ¥
        let notifyContent = data.content;
        if (msgObj.type === 'transfer') notifyContent = '[è½¬è´¦]';
        if (msgObj.type === 'familyCard') notifyContent = '[äº²å±å¡]';
        if (msgObj.type === 'audio') notifyContent = '[è¯­éŸ³æ¶ˆæ¯]';
        if (data.content.startsWith('[img:')) notifyContent = '[å›¾ç‰‡]';
        sendSystemNotification(targetChar.name, notifyContent);
    }
}

// ==================== äº²å±å¡å¤„ç†å‡½æ•° ====================

// å¤„ç†æ”¶åˆ°äº²å±å¡
async function handleFamilyCardReceived(data) {
    console.log('[Online] æ”¶åˆ°äº²å±å¡:', data);
    
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    // æŸ¥æ‰¾å¯¹åº”çš„è”æœºå¥½å‹è§’è‰²
    const chars = await db.characters.where('type').equals('online_friend').toArray();
    let friendChar = chars.find(c => c.onlineData?.wx_account === data.from_wx_account);
    
    if (!friendChar) {
        console.warn('[Online] æœªæ‰¾åˆ°å¯¹åº”çš„è”æœºå¥½å‹');
        return;
    }
    
    // ä¿å­˜äº²å±å¡æ¶ˆæ¯åˆ°èŠå¤©è®°å½•
    let history = getChatHistory(friendChar, accountId);
    const familyCardMsg = {
        role: 'char',
        type: 'familyCard',
        content: JSON.stringify({
            fromName: data.from_nickname,
            from_wx_account: data.from_wx_account,
            monthlyLimit: data.monthly_limit,
            status: 'received',
            isOnline: true
        }),
        time: Date.now()
    };
    
    history.push(familyCardMsg);
    await setChatHistory(friendChar, accountId, history);
    
    // å¦‚æœå½“å‰æ­£åœ¨æŸ¥çœ‹è¯¥èŠå¤©ï¼Œåˆ·æ–°æ˜¾ç¤º
    if (currentChatCharId === friendChar.id) {
        renderChatBody(friendChar);
    }
    
    // å‘é€é€šçŸ¥
    showToast(`${data.from_nickname} èµ é€äº†äº²å±å¡`);
    sendSystemNotification(friendChar.name, '[äº²å±å¡]');
    
    // é‡æ–°è·å–äº²å±å¡åˆ—è¡¨
    const onlineUserChar = await getOrCreateOnlineUserChar();
    if (onlineUserChar && onlineSocket) {
        onlineSocket.send(JSON.stringify({
            type: 'get_family_cards',
            my_wx_account: onlineUserChar.identity.account
        }));
    }
}

// å¤„ç†äº²å±å¡è¢«ä½¿ç”¨
async function handleFamilyCardUsed(data) {
    console.log('[Online] äº²å±å¡è¢«ä½¿ç”¨:', data);
    
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    // æŸ¥æ‰¾å¯¹åº”çš„è”æœºå¥½å‹è§’è‰²
    const chars = await db.characters.where('type').equals('online_friend').toArray();
    let friendChar = chars.find(c => c.onlineData?.wx_account === data.user_wx_account);
    
    if (!friendChar) {
        console.warn('[Online] æœªæ‰¾åˆ°å¯¹åº”çš„è”æœºå¥½å‹');
        return;
    }
    
    // æ˜¾ç¤ºé€šçŸ¥
    showToast(`${data.user_nickname} ä½¿ç”¨äº†æ‚¨çš„äº²å±å¡ Â¥${data.amount}`);
    
    // æ·»åŠ æµæ°´è®°å½•åˆ°æœ¬åœ°
    const user = await db.characters.get(parseInt(accountId));
    if (user) {
        if (!user.identity) user.identity = {};
        if (!user.identity.familyCardRecords) user.identity.familyCardRecords = [];
        
        user.identity.familyCardRecords.push({
            type: 'expense',
            user_wx_account: data.user_wx_account,
            user_nickname: data.user_nickname,
            amount: data.amount,
            description: data.description,
            used_this_month: data.used_this_month,
            monthly_limit: data.monthly_limit,
            time: Date.now()
        });
        
        await safeCharacterPut(user);
    }
}

// å¤„ç†äº²å±å¡åˆ—è¡¨
async function handleFamilyCardsList(data) {
    console.log('[Online] æ”¶åˆ°äº²å±å¡åˆ—è¡¨:', data);
    
    // ä¿å­˜åˆ°æœ¬åœ°ç¼“å­˜
    localStorage.setItem('online_family_cards_given', JSON.stringify(data.given || []));
    localStorage.setItem('online_family_cards_received', JSON.stringify(data.received || []));
    
    // å¦‚æœäº²å±å¡é¡µé¢æ‰“å¼€ç€ï¼Œåˆ·æ–°æ˜¾ç¤º
    const familyCardPage = document.getElementById('family-card-page');
    if (familyCardPage && familyCardPage.style.display !== 'none') {
        renderFamilyCardList();
    }
}

// ==================== äº²å±å¡å¤„ç†å‡½æ•°ç»“æŸ ====================

// è¯·æ±‚å·²ä¸Šçº¿çš„è§’è‰²åˆ—è¡¨
function requestOnlineCharacters() {
    if (!onlineConnected || !onlineUserData) return;
    
    onlineSocket.send(JSON.stringify({
        type: 'get_online_characters'
    }));
}

// ä¸Šçº¿è§’è‰²
async function goOnlineWithCharacter(charId) {
    if (!onlineConnected || !onlineUserData) {
        alert('è¯·å…ˆåœ¨è®¾ç½®ä¸­è¿æ¥æœåŠ¡å™¨å¹¶ç™»å½•');
        return;
    }
    
    const char = await db.characters.get(charId);
    if (!char || char.type !== 'user') {
        alert('åªèƒ½ä¸Šçº¿Userç±»å‹çš„è§’è‰²');
        return;
    }
    
    const wxAccount = char.identity?.account;
    if (!wxAccount) {
        alert('è¯¥è§’è‰²æ²¡æœ‰è®¾ç½®è™šæ‹Ÿå¾®ä¿¡å·ï¼Œè¯·å…ˆåœ¨WeChatä¸­æ³¨å†Œ');
        return;
    }
    
    onlineSocket.send(JSON.stringify({
        type: 'go_online',
        wx_account: wxAccount,
        nickname: char.remark || char.wx_nickname || char.name,
        avatar: char.avatar || '',
        bio: char.description?.substring(0, 100) || '',
        local_char_id: charId
    }));
}

// ä¸‹çº¿è§’è‰²
function goOfflineWithCharacter(wxAccount) {
    if (!onlineConnected) return;
    
    onlineSocket.send(JSON.stringify({
        type: 'go_offline',
        wx_account: wxAccount
    }));
}

// âœ… è‡ªåŠ¨ä¸Šçº¿æ‰€æœ‰ User ç±»å‹çš„è§’è‰²
// è‡ªåŠ¨æ³¨å†Œæ‰€æœ‰ User ç±»å‹è§’è‰²åˆ°æœåŠ¡å™¨ï¼ˆä¸ä¸Šçº¿ï¼Œä»…ç”¨äºæœç´¢ï¼‰
async function autoRegisterAllUserCharacters() {
    if (!onlineConnected || !onlineUserData) {
        console.log('[Online] æœªè¿æ¥æˆ–æœªç™»å½•ï¼Œè·³è¿‡è‡ªåŠ¨æ³¨å†Œ');
        return;
    }
    
    try {
        // è·å–æ‰€æœ‰ User ç±»å‹çš„è§’è‰²
        const userChars = await db.characters.where('type').equals('user').toArray();
        
        let registerCount = 0;
        for (const char of userChars) {
            const wxAccount = char.identity?.account;
            const nickname = char.remark || char.wx_nickname || char.name;
            
            // éªŒè¯å¿…å¡«å­—æ®µ
            if (!wxAccount || !nickname) {
                console.log(`[Online] è§’è‰² ${char.name} ç¼ºå°‘å¾®ä¿¡å·æˆ–æ˜µç§°ï¼Œè·³è¿‡æ³¨å†Œ`);
                continue;
            }
            
            // æ³¨å†Œè§’è‰²åˆ°æœåŠ¡å™¨ï¼ˆä¸ä¸Šçº¿ï¼Œis_online = 0ï¼‰
            console.log(`[Online] æ³¨å†Œè§’è‰²åˆ°æœåŠ¡å™¨: ${nickname} (${wxAccount})`);
            
            try {
                onlineSocket.send(JSON.stringify({
                    type: 'register_character',
                    wx_account: wxAccount,
                    nickname: nickname,
                    avatar: char.avatar || '',
                    bio: (char.description || '').substring(0, 100)
                }));
                registerCount++;
                
                // æ·»åŠ å°å»¶è¿Ÿé¿å…è¯·æ±‚è¿‡å¿«
                await new Promise(resolve => setTimeout(resolve, 100));
            } catch (sendError) {
                console.error(`[Online] æ³¨å†Œè§’è‰²å¤±è´¥: ${nickname}`, sendError);
            }
        }
        
        if (registerCount > 0) {
            console.log(`[Online] å·²æ³¨å†Œ ${registerCount} ä¸ªè§’è‰²åˆ°æœåŠ¡å™¨ï¼ˆå¯è¢«æœç´¢ï¼‰`);
        } else {
            console.log('[Online] æ²¡æœ‰å¯æ³¨å†Œçš„è§’è‰²ï¼ˆè¯·ç¡®ä¿ User è§’è‰²è®¾ç½®äº†å¾®ä¿¡å·ï¼‰');
        }
    } catch (e) {
        console.error('[Online] è‡ªåŠ¨æ³¨å†Œè§’è‰²å¤±è´¥:', e);
    }
}

async function autoGoOnlineAllUserCharacters() {
    if (!onlineConnected || !onlineUserData) {
        console.log('[Online] æœªè¿æ¥æˆ–æœªç™»å½•ï¼Œè·³è¿‡è‡ªåŠ¨ä¸Šçº¿');
        return;
    }
    
    try {
        // è·å–æ‰€æœ‰ User ç±»å‹çš„è§’è‰²
        const userChars = await db.characters.where('type').equals('user').toArray();
        
        let onlineCount = 0;
        for (const char of userChars) {
            const wxAccount = char.identity?.account;
            const nickname = char.remark || char.wx_nickname || char.name;
            
            // éªŒè¯å¿…å¡«å­—æ®µ
            if (!wxAccount || !nickname) {
                console.log(`[Online] è§’è‰² ${char.name} ç¼ºå°‘å¾®ä¿¡å·æˆ–æ˜µç§°ï¼Œè·³è¿‡ä¸Šçº¿`);
                continue;
            }
            
            // ä¸Šçº¿è§’è‰²
            console.log(`[Online] è‡ªåŠ¨ä¸Šçº¿è§’è‰²: ${nickname} (${wxAccount})`);
            
            try {
                onlineSocket.send(JSON.stringify({
                    type: 'go_online',
                    wx_account: wxAccount,
                    nickname: nickname,
                    avatar: char.avatar || '',
                    bio: (char.description || '').substring(0, 100),
                    local_char_id: char.id
                }));
                onlineCount++;
                
                // æ·»åŠ å°å»¶è¿Ÿé¿å…è¯·æ±‚è¿‡å¿«
                await new Promise(resolve => setTimeout(resolve, 150));
            } catch (sendError) {
                console.error(`[Online] ä¸Šçº¿è§’è‰²å¤±è´¥: ${nickname}`, sendError);
            }
        }
        
        if (onlineCount > 0) {
            console.log(`[Online] å·²å‘é€ ${onlineCount} ä¸ªè§’è‰²çš„ä¸Šçº¿è¯·æ±‚`);
            // âœ… å»¶è¿Ÿåè¯·æ±‚åœ¨çº¿è§’è‰²åˆ—è¡¨ï¼Œç¡®ä¿æœåŠ¡å™¨å·²å¤„ç†ä¸Šçº¿è¯·æ±‚
            setTimeout(() => {
                if (onlineConnected) {
                    requestOnlineCharacters();
                }
            }, 500);
        } else {
            console.log('[Online] æ²¡æœ‰å¯ä¸Šçº¿çš„è§’è‰²ï¼ˆè¯·ç¡®ä¿ User è§’è‰²è®¾ç½®äº†å¾®ä¿¡å·ï¼‰');
        }
    } catch (e) {
        console.error('[Online] è‡ªåŠ¨ä¸Šçº¿è§’è‰²å¤±è´¥:', e);
    }
}

// âœ… è·å–å½“å‰å¯ç”¨çš„åœ¨çº¿è§’è‰²ï¼ˆå¦‚æœæ²¡æœ‰åˆ™è‡ªåŠ¨ä¸Šçº¿ä¸€ä¸ªï¼‰
async function getOrCreateOnlineUserChar() {
    if (!onlineConnected || !onlineUserData) {
        return null;
    }
    
    const userChars = await db.characters.where('type').equals('user').toArray();
    
    // 1. å…ˆæ‰¾å·²ä¸Šçº¿çš„è§’è‰²
    let onlineUserChar = userChars.find(c => 
        c.identity?.account && onlineCharacters.some(oc => oc.wx_account === c.identity.account)
    );
    
    // 2. å¦‚æœæ²¡æœ‰ï¼Œæ‰¾ä¸€ä¸ªæœ‰å¾®ä¿¡å·çš„è§’è‰²å¹¶è‡ªåŠ¨ä¸Šçº¿
    if (!onlineUserChar) {
        const charWithAccount = userChars.find(c => c.identity?.account);
        if (charWithAccount) {
            console.log('[Online] è‡ªåŠ¨ä¸Šçº¿è§’è‰²:', charWithAccount.name);
            const wxAccount = charWithAccount.identity.account;
            onlineSocket.send(JSON.stringify({
                type: 'go_online',
                wx_account: wxAccount,
                nickname: charWithAccount.remark || charWithAccount.wx_nickname || charWithAccount.name,
                avatar: charWithAccount.avatar || '',
                bio: charWithAccount.description?.substring(0, 100) || '',
                local_char_id: charWithAccount.id
            }));
            onlineUserChar = charWithAccount;
        }
    }
    
    return onlineUserChar;
}

// å‘é€è”æœºæ¶ˆæ¯
function sendOnlineMessage(toWxAccount, content, fromWxAccount) {
    if (!onlineConnected) {
        console.warn('[Online] æœªè¿æ¥ï¼Œæ— æ³•å‘é€æ¶ˆæ¯');
        return false;
    }
    
    onlineSocket.send(JSON.stringify({
        type: 'message',
        to_wx_account: toWxAccount,
        from_wx_account: fromWxAccount,
        content: content
    }));
    
    return true;
}

// æ£€æŸ¥è§’è‰²æ˜¯å¦å·²ä¸Šçº¿
function isCharacterOnline(wxAccount) {
    return onlineCharacters.some(c => c.wx_account === wxAccount);
}

// è·å–è”æœºçŠ¶æ€
function getOnlineStatus() {
    return {
        connected: onlineConnected,
        loggedIn: !!onlineUserData,
        user: onlineUserData,
        characters: onlineCharacters
    };
}

// æ›´æ–°è”æœºåŠŸèƒ½åŒºæ˜¾ç¤º
function updateOnlineFeatureSection() {
    const badge = document.getElementById('online-char-count-badge');
    if (!badge) return;
    
    if (!onlineConnected) {
        badge.textContent = 'æœªè¿æ¥';
        badge.style.color = '#999';
    } else if (!onlineUserData) {
        badge.textContent = 'æœªç™»å½•';
        badge.style.color = '#ff9800';
    } else if (onlineCharacters.length === 0) {
        badge.textContent = 'å·²ç™»å½•';
        badge.style.color = '#4caf50';
    } else {
        badge.textContent = `${onlineCharacters.length}ä¸ªè§’è‰²åœ¨çº¿`;
        badge.style.color = '#4caf50';
    }
}

// æ˜¾ç¤ºè”æœºçŠ¶æ€é¡µé¢
async function showOnlineStatusPage() {
    const page = document.getElementById('online-status-page');
    if (!page) return;
    
    page.style.display = 'flex';
    
    // æ›´æ–°è¿æ¥çŠ¶æ€
    updateOnlineConnectionStatus();
    
    // æ›´æ–°è§’è‰²åˆ—è¡¨
    await renderOnlineCharList();
    
    // è·å–è”æœºç¾¤èŠåˆ—è¡¨
    const myWx = getMyOnlineWxAccount();
    if (myWx && onlineSocket && onlineSocket.readyState === WebSocket.OPEN) {
        onlineSocket.send(JSON.stringify({
            type: 'get_online_groups',
            my_wx_account: myWx
        }));
    }
    
    // åˆå§‹æ¸²æŸ“ç¾¤èŠåˆ—è¡¨
    const groupContainer = document.getElementById('online-group-list');
    if (groupContainer) {
        renderOnlineGroupList(groupContainer);
    }
}

// éšè—è”æœºçŠ¶æ€é¡µé¢
function hideOnlineStatusPage() {
    const page = document.getElementById('online-status-page');
    if (page) {
        page.style.display = 'none';
        // æ›´æ–°"æˆ‘"é¡µé¢çš„è”æœºçŠ¶æ€
        updateOnlineFeatureSection();
    }
}

// æ›´æ–°è¿æ¥çŠ¶æ€æ˜¾ç¤º
function updateOnlineConnectionStatus() {
    const statusEl = document.getElementById('online-sync-status');
    if (!statusEl) return;
    
    if (!onlineConnected) {
        statusEl.innerHTML = `
            <div style="display:flex; align-items:center; gap:8px;">
                <span style="width:8px; height:8px; border-radius:50%; background:#ff3b30;"></span>
                <span style="color:#ff3b30; font-weight:500;">æœªåŒæ­¥</span>
            </div>
            <div style="font-size:11px; color:#999; margin-top:4px;">æœªè¿æ¥æœåŠ¡å™¨ï¼Œè¯·åœ¨è®¾ç½®ä¸­é…ç½®</div>
        `;
    } else if (!onlineUserData) {
        statusEl.innerHTML = `
            <div style="display:flex; align-items:center; gap:8px;">
                <span style="width:8px; height:8px; border-radius:50%; background:#ff9800;"></span>
                <span style="color:#ff9800; font-weight:500;">ç­‰å¾…ç™»å½•</span>
            </div>
            <div style="font-size:11px; color:#999; margin-top:4px;">å·²è¿æ¥æœåŠ¡å™¨ï¼Œè¯·å…ˆç™»å½•è´¦å·</div>
        `;
    } else {
        statusEl.innerHTML = `
            <div style="display:flex; align-items:center; gap:8px;">
                <span style="width:8px; height:8px; border-radius:50%; background:#4caf50; animation:pulse 2s infinite;"></span>
                <span style="color:#4caf50; font-weight:500;">å·²åŒæ­¥</span>
            </div>
            <div style="font-size:11px; color:#666; margin-top:4px;">ç”¨æˆ·: ${onlineUserData.username} | è§’è‰²å·²è‡ªåŠ¨ä¸Šçº¿</div>
        `;
    }
}

// æ¸²æŸ“è§’è‰²åˆ—è¡¨
async function renderOnlineCharList() {
    const container = document.getElementById('online-status-char-list');
    if (!container) return;
    
    // è·å–æ‰€æœ‰Userç±»å‹è§’è‰²
    const users = await db.characters.where('type').equals('user').toArray();
    
    // æ£€æŸ¥æ¯ä¸ªè§’è‰²çš„åœ¨çº¿çŠ¶æ€
    // âœ… ä¿®å¤ï¼šå¦‚æœå·²ç™»å½•ï¼Œåˆ™è®¤ä¸ºæ‰€æœ‰æœ‰å¾®ä¿¡å·çš„è§’è‰²éƒ½åœ¨çº¿ï¼ˆå› ä¸ºç™»å½•åä¼šè‡ªåŠ¨ä¸Šçº¿ï¼‰
    const charList = users.map(char => {
        const wxAccount = char.identity?.account || '';
        // å¦‚æœå·²è¿æ¥å¹¶å·²ç™»å½•ï¼Œè®¤ä¸ºæœ‰å¾®ä¿¡å·çš„è§’è‰²éƒ½åœ¨çº¿
        const isOnline = wxAccount && onlineConnected && onlineUserData;
        return {
            id: char.id,
            name: char.remark || char.wx_nickname || char.name,
            avatar: char.avatar || '',
            wxAccount: wxAccount,
            isOnline: isOnline
        };
    }).filter(c => c.wxAccount);
    
    if (charList.length === 0) {
        container.innerHTML = `
            <div style="text-align:center; padding:40px 20px; color:#999;">
                <div style="font-size:14px;">æ²¡æœ‰å¯ç”¨çš„è§’è‰²</div>
                <div style="font-size:12px; margin-top:8px;">è¯·å…ˆåœ¨è§’è‰²æ¡£æ¡ˆåˆ›å»º User ç±»å‹è§’è‰²ï¼Œå¹¶è®¾ç½®å¾®ä¿¡å·</div>
            </div>
        `;
        return;
    }
    
    // æ˜¾ç¤ºè§’è‰²åˆ—è¡¨å’Œåœ¨çº¿çŠ¶æ€ï¼Œç™»å½•åä¼šè‡ªåŠ¨ä¸Šçº¿æ‰€æœ‰è§’è‰²
    container.innerHTML = charList.map(char => `
        <div style="padding:12px 16px; background:#fff; display:flex; align-items:center; gap:12px; border-bottom:1px solid #f0f0f0;">
            <div style="width:44px; height:44px; border-radius:8px; background-image:url(${char.avatar}); background-size:cover; background-position:center; background-color:#e0e0e0;"></div>
            <div style="flex:1;">
                <div style="font-size:15px; font-weight:500; color:#333;">${char.name}</div>
                <div style="font-size:12px; color:#999; margin-top:2px;">${char.wxAccount}</div>
            </div>
            <div style="display:flex; align-items:center;">
                ${char.isOnline ? `
                    <span style="font-size:12px; color:#4caf50; padding:4px 10px; background:#e8f5e9; border-radius:10px; display:flex; align-items:center; gap:4px;">
                        <span style="width:6px; height:6px; border-radius:50%; background:#4caf50;"></span>
                        åœ¨çº¿
                    </span>
                ` : `
                    <span style="font-size:12px; color:#999; padding:4px 10px; background:#f5f5f5; border-radius:10px; display:flex; align-items:center; gap:4px;">
                        <span style="width:6px; height:6px; border-radius:50%; background:#999;"></span>
                        ç¦»çº¿
                    </span>
                `}
            </div>
        </div>
    `).join('');
}

// åˆ·æ–°è”æœºçŠ¶æ€é¡µé¢å†…å®¹
async function refreshOnlineStatusPageContent() {
    const page = document.getElementById('online-status-page');
    if (!page || page.style.display === 'none') return; // é¡µé¢æ²¡æ‰“å¼€
    
    // åˆ·æ–°è§’è‰²åˆ—è¡¨
    await renderOnlineCharList();
}

// æ‰‹åŠ¨åŒæ­¥åœ¨çº¿çŠ¶æ€
async function manualSyncOnline() {
    const btn = document.getElementById('manual-sync-btn');
    const btnText = document.getElementById('sync-btn-text');
    const syncIcon = document.getElementById('sync-icon');
    
    if (!btn || !btnText) return;
    
    // æŒ‰é’®å˜ä¸ºåŒæ­¥ä¸­çŠ¶æ€
    btn.disabled = true;
    btn.style.opacity = '0.7';
    btnText.textContent = 'åŒæ­¥ä¸­...';
    if (syncIcon) {
        syncIcon.style.animation = 'spin 1s linear infinite';
    }
    
    try {
        if (!onlineConnected) {
            // å°è¯•é‡æ–°è¿æ¥æœåŠ¡å™¨
            const serverUrl = localStorage.getItem('online_server_url');
            if (!serverUrl) {
                showToast('è¯·å…ˆåœ¨è®¾ç½®ä¸­é…ç½®æœåŠ¡å™¨åœ°å€');
                return;
            }
            
            showToast('æ­£åœ¨è¿æ¥æœåŠ¡å™¨...');
            await connectToOnlineServer();
            showToast('è¿æ¥æˆåŠŸï¼Œæ­£åœ¨åŒæ­¥...');
        }
        
        // å¦‚æœå·²è¿æ¥ä½†æœªç™»å½•
        if (onlineConnected && !onlineUserData) {
            showToast('è¯·å…ˆç™»å½•è´¦å·');
            updateOnlineConnectionStatus();
            return;
        }
        
        // å¦‚æœå·²ç™»å½•ï¼Œé‡æ–°åŒæ­¥æ‰€æœ‰è§’è‰²
        if (onlineConnected && onlineUserData) {
            console.log('[Online] æ‰‹åŠ¨åŒæ­¥ï¼šé‡æ–°æ³¨å†Œå¹¶ä¸Šçº¿æ‰€æœ‰è§’è‰²');
            
            // é‡æ–°æ³¨å†Œè§’è‰²
            await autoRegisterAllUserCharacters();
            
            // é‡æ–°ä¸Šçº¿æ‰€æœ‰è§’è‰²
            await autoGoOnlineAllUserCharacters();
            
            // ç­‰å¾…ä¸€ä¸‹è®©æœåŠ¡å™¨å¤„ç†
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // åˆ·æ–°è§’è‰²åˆ—è¡¨
            requestOnlineCharacters();
            await refreshOnlineStatusPageContent();
            
            showToast('åŒæ­¥æˆåŠŸ');
        }
        
        updateOnlineConnectionStatus();
        
    } catch (error) {
        console.error('[Online] åŒæ­¥å¤±è´¥:', error);
        showToast('åŒæ­¥å¤±è´¥: ' + (error.message || 'æœªçŸ¥é”™è¯¯'));
    } finally {
        // æ¢å¤æŒ‰é’®çŠ¶æ€
        btn.disabled = false;
        btn.style.opacity = '1';
        btnText.textContent = 'ç«‹å³åŒæ­¥';
        if (syncIcon) {
            syncIcon.style.animation = '';
        }
    }
}

// è‡ªåŠ¨åŒæ­¥å®šæ—¶å™¨ï¼ˆæ¯30ç§’æ£€æŸ¥ä¸€æ¬¡ï¼‰
let autoSyncTimer = null;

function startAutoSync() {
    // æ¸…é™¤æ—§çš„å®šæ—¶å™¨
    if (autoSyncTimer) {
        clearInterval(autoSyncTimer);
    }
    
    // æ¯30ç§’è‡ªåŠ¨æ£€æŸ¥å¹¶åŒæ­¥
    autoSyncTimer = setInterval(async () => {
        // åªåœ¨å·²ç™»å½•ä½†æœªè¿æ¥çš„æƒ…å†µä¸‹å°è¯•è‡ªåŠ¨é‡è¿
        if (!onlineConnected && onlineToken && onlineUserData) {
            console.log('[Online] è‡ªåŠ¨åŒæ­¥ï¼šæ£€æµ‹åˆ°æ–­å¼€è¿æ¥ï¼Œå°è¯•é‡æ–°è¿æ¥...');
            try {
                await connectToOnlineServer();
                console.log('[Online] è‡ªåŠ¨é‡è¿æˆåŠŸ');
            } catch (error) {
                console.error('[Online] è‡ªåŠ¨é‡è¿å¤±è´¥:', error);
            }
        }
        
        // å¦‚æœå·²è¿æ¥ï¼Œå®šæœŸè¯·æ±‚è§’è‰²çŠ¶æ€
        if (onlineConnected && onlineUserData) {
            requestOnlineCharacters();
        }
    }, 30000); // 30ç§’
}

function stopAutoSync() {
    if (autoSyncTimer) {
        clearInterval(autoSyncTimer);
        autoSyncTimer = null;
    }
}

// ==================== è”æœºç¾¤èŠåŠŸèƒ½ ====================

// åˆ·æ–°è”æœºç¾¤èŠåˆ—è¡¨
function refreshOnlineGroupList() {
    // å¦‚æœç¾¤èŠé¡µé¢æ‰“å¼€äº†ï¼Œåˆ·æ–°æ˜¾ç¤º
    const container = document.getElementById('online-group-list');
    if (container) {
        renderOnlineGroupList(container);
    }
}

// æ¸²æŸ“è”æœºç¾¤èŠåˆ—è¡¨
function renderOnlineGroupList(container) {
    if (onlineGroups.length === 0) {
        container.innerHTML = `<div style="text-align:center; padding:40px; color:#999;">æš‚æ— è”æœºç¾¤èŠ</div>`;
        return;
    }
    
    container.innerHTML = onlineGroups.map(g => `
        <div onclick="openOnlineGroup('${g.id}')" style="padding:14px 16px; background:#fff; display:flex; align-items:center; gap:12px; border-bottom:1px solid #f0f0f0; cursor:pointer;">
            <div style="width:48px; height:48px; border-radius:8px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); display:flex; align-items:center; justify-content:center; color:#fff; font-size:18px;">ğŸ‘¥</div>
            <div style="flex:1;">
                <div style="font-size:15px; font-weight:500; color:#333;">${g.name}</div>
                <div style="font-size:12px; color:#999; margin-top:2px;">è”æœºç¾¤èŠ</div>
            </div>
            <svg viewBox="0 0 24 24" style="width:20px; height:20px; stroke:#ccc; fill:none;"><polyline points="9 18 15 12 9 6"></polyline></svg>
        </div>
    `).join('');
}

// å¤„ç†ç¾¤èŠé‚€è¯· - ä¿å­˜åˆ°æ•°æ®åº“ï¼Œæ˜¾ç¤ºåœ¨"æ–°çš„å¥½å‹"é¡µé¢
async function handleOnlineGroupInvite(data) {
    // å°†ç¾¤èŠé‚€è¯·ä¿å­˜åˆ° friend_requests è¡¨
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒçš„é‚€è¯·
    const existingInvites = await db.friend_requests
        .where('toAccountId')
        .equals(accountId)
        .toArray();
    const alreadyExists = existingInvites.some(r => 
        r.isGroupInvite && 
        r.groupData?.group_id === data.group_id &&
        r.status === 'pending'
    );
    if (alreadyExists) return;
    
    // åˆ›å»ºç¾¤èŠé‚€è¯·è®°å½•
    await db.friend_requests.add({
        toAccountId: accountId,
        isOnline: true,
        isGroupInvite: true,
        status: 'pending',
        time: Date.now(),
        groupData: {
            group_id: data.group_id,
            group_name: data.group_name,
            inviter_wx: data.inviter_wx,
            inviter_name: data.inviter_name
        }
    });
    
    // æ˜¾ç¤ºé€šçŸ¥
    showToast(`${data.inviter_name} é‚€è¯·ä½ åŠ å…¥ç¾¤èŠ"${data.group_name}"`);
    
    // å¦‚æœæ–°çš„å¥½å‹é¡µé¢æ­£åœ¨æ˜¾ç¤ºï¼Œåˆ·æ–°å®ƒ
    if (document.getElementById('new-friends-page').style.display !== 'none') {
        await renderNewFriendsPage();
    }
}

// åœ¨æœ¬åœ°æ•°æ®åº“åˆ›å»ºè”æœºç¾¤èŠè®°å½•ï¼Œè®©å®ƒæ˜¾ç¤ºåœ¨æ¶ˆæ¯åˆ—è¡¨ä¸­
async function createLocalOnlineGroupChat(group) {
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    try {
        // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        const existing = await db.group_chats
            .where('ownerAccountId').equals(accountId)
            .filter(g => g.isOnlineGroup && g.onlineGroupId === group.id)
            .first();
        
        if (existing) {
            console.log('è”æœºç¾¤èŠå·²å­˜åœ¨äºæœ¬åœ°ï¼Œè·³è¿‡åˆ›å»º');
            return;
        }
        
        // åˆ›å»ºæœ¬åœ°ç¾¤èŠè®°å½•
        const groupChat = {
            name: group.name,
            avatar: DEFAULT_GROUP_AVATAR,
            memberIds: [], // è”æœºç¾¤èŠçš„æˆå‘˜ç”±æœåŠ¡å™¨ç®¡ç†
            ownerAccountId: accountId,
            created_at: group.created_at || Date.now(),
            updated_at: Date.now(),
            is_pinned: false,
            chat_history: [{
                role: 'system',
                content: 'è”æœºç¾¤èŠå·²åˆ›å»º',
                time: Date.now()
            }],
            isOnlineGroup: true, // æ ‡è®°ä¸ºè”æœºç¾¤èŠ
            onlineGroupId: group.id, // è”æœºç¾¤èŠçš„ID
            onlineGroupCreator: group.creator_wx // åˆ›å»ºè€…å¾®ä¿¡å·
        };
        
        await db.group_chats.add(groupChat);
        console.log('å·²åœ¨æœ¬åœ°åˆ›å»ºè”æœºç¾¤èŠè®°å½•');
        
        // åˆ·æ–°èŠå¤©åˆ—è¡¨
        if (document.querySelector('.wechat-tab-item.active')?.innerText.includes('å¾®ä¿¡')) {
            renderWechatList(document.getElementById('wechat-content'));
        }
    } catch (e) {
        console.error('åˆ›å»ºæœ¬åœ°è”æœºç¾¤èŠè®°å½•å¤±è´¥:', e);
    }
}

// æ›´æ–°æœ¬åœ°è”æœºç¾¤èŠçš„æœ€åæ¶ˆæ¯
async function updateLocalOnlineGroupLastMessage(onlineGroupId, message) {
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    try {
        // æŸ¥æ‰¾å¯¹åº”çš„æœ¬åœ°ç¾¤èŠè®°å½•
        const groups = await db.group_chats
            .where('ownerAccountId').equals(accountId)
            .filter(g => g.isOnlineGroup && g.onlineGroupId === onlineGroupId)
            .toArray();
        
        if (groups.length === 0) {
            console.log('æœªæ‰¾åˆ°æœ¬åœ°è”æœºç¾¤èŠè®°å½•');
            return;
        }
        
        const group = groups[0];
        
        // æ·»åŠ æ¶ˆæ¯åˆ°èŠå¤©å†å²
        if (!group.chat_history) {
            group.chat_history = [];
        }
        
        // æ„å»ºæ¶ˆæ¯è®°å½•
        const chatMessage = {
            role: 'assistant', // ç¾¤èŠæ¶ˆæ¯è§†ä¸ºåŠ©æ‰‹æ¶ˆæ¯
            content: message.content,
            time: message.created_at || Date.now(),
            sender_name: message.sender_name,
            sender_type: message.sender_type,
            character_name: message.character_name
        };
        
        group.chat_history.push(chatMessage);
        group.updated_at = Date.now();
        
        await safeGroupChatPut(group);
        
        // åˆ·æ–°èŠå¤©åˆ—è¡¨ï¼ˆå¦‚æœæ­£åœ¨æ˜¾ç¤ºï¼‰
        if (document.querySelector('.wechat-tab-item.active')?.innerText.includes('å¾®ä¿¡')) {
            renderWechatList(document.getElementById('wechat-content'));
        }
    } catch (e) {
        console.error('æ›´æ–°æœ¬åœ°è”æœºç¾¤èŠæ¶ˆæ¯å¤±è´¥:', e);
    }
}

// æ˜¾ç¤ºåŠ å…¥ç¾¤èŠå¼¹çª—ï¼ˆé€‰æ‹©è¦å¸¦å…¥çš„è§’è‰²ï¼‰
async function showJoinOnlineGroupModal(groupId, groupName) {
    // è·å–æ‰€æœ‰å¯ç”¨çš„è§’è‰²ï¼ˆéUserç±»å‹ï¼‰
    const chars = await db.characters.toArray();
    const availableChars = chars.filter(c => c.type !== 'user' && c.type !== 'online_friend');
    
    const modal = document.createElement('div');
    modal.id = 'join-group-modal';
    modal.style.cssText = `position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:10000; display:flex; align-items:center; justify-content:center;`;
    
    modal.innerHTML = `
        <div style="background:#fff; border-radius:16px; padding:24px; width:85%; max-width:360px;">
            <h3 style="margin:0 0 16px 0; text-align:center; font-size:18px;">åŠ å…¥ã€Œ${groupName}ã€</h3>
            
            <div style="margin-bottom:16px;">
                <div style="font-size:13px; color:#666; margin-bottom:8px;">é€‰æ‹©è¦å¸¦å…¥ç¾¤èŠçš„è§’è‰²ï¼ˆå¯é€‰ï¼‰ï¼š</div>
                <select id="join-group-char-select" style="width:100%; padding:12px; border:1px solid #ddd; border-radius:8px; font-size:14px;">
                    <option value="">ä¸å¸¦è§’è‰²</option>
                    ${availableChars.map(c => `<option value="${c.id}">${c.name}</option>`).join('')}
                </select>
            </div>
            
            <div style="font-size:12px; color:#999; margin-bottom:20px; line-height:1.5;">
                å¸¦å…¥è§’è‰²åï¼Œä½ å¯ä»¥åœ¨ç¾¤èŠä¸­è®©è¯¥è§’è‰²å‘è¨€ï¼ˆè°ƒç”¨AIï¼‰
            </div>
            
            <div style="display:flex; gap:12px;">
                <button onclick="this.closest('#join-group-modal').remove()" style="flex:1; padding:12px; background:#f0f0f0; color:#666; border:none; border-radius:8px; font-size:15px;">å–æ¶ˆ</button>
                <button onclick="doJoinOnlineGroup('${groupId}')" style="flex:1; padding:12px; background:var(--ins-pink); color:#fff; border:none; border-radius:8px; font-size:15px;">åŠ å…¥</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// æ‰§è¡ŒåŠ å…¥ç¾¤èŠ
async function doJoinOnlineGroup(groupId) {
    const charSelect = document.getElementById('join-group-char-select');
    const charId = charSelect?.value;
    
    let myChar = null;
    if (charId) {
        const char = await db.characters.get(parseInt(charId));
        if (char) {
            myChar = {
                name: char.name,
                avatar: char.avatar || '',
                desc: char.description?.substring(0, 200) || ''
            };
        }
    }
    
    // è·å–æˆ‘çš„ä¸Šçº¿å¾®ä¿¡å·
    const myWx = getMyOnlineWxAccount();
    if (!myWx) {
        alert('è¯·å…ˆä¸Šçº¿ä¸€ä¸ªè§’è‰²');
        return;
    }
    
    onlineSocket.send(JSON.stringify({
        type: 'join_online_group',
        group_id: groupId,
        my_wx_account: myWx,
        my_character: myChar
    }));
    
    document.getElementById('join-group-modal')?.remove();
}

// è·å–æˆ‘å½“å‰ä¸Šçº¿çš„å¾®ä¿¡å·
function getMyOnlineWxAccount() {
    if (!onlineCharacters || onlineCharacters.length === 0) return null;
    return onlineCharacters[0]?.wx_account;
}

// æ˜¾ç¤ºåˆ›å»ºè”æœºç¾¤èŠå¼¹çª—
async function showCreateOnlineGroupModal() {
    if (!onlineConnected || !onlineUserData) {
        alert('è¯·å…ˆè¿æ¥æœåŠ¡å™¨å¹¶ç™»å½•');
        return;
    }
    
    // è·å–è”æœºå¥½å‹åˆ—è¡¨
    const friends = await db.characters.where('type').equals('online_friend').toArray();
    
    // è·å–å¯é€‰çš„è§’è‰²ï¼ˆéUserç±»å‹ï¼‰
    const chars = await db.characters.toArray();
    const availableChars = chars.filter(c => c.type !== 'user' && c.type !== 'online_friend');
    
    const modal = document.createElement('div');
    modal.id = 'create-online-group-modal';
    modal.style.cssText = `position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:10000; display:flex; align-items:center; justify-content:center;`;
    
    modal.innerHTML = `
        <div style="background:#fff; border-radius:16px; width:90%; max-width:400px; max-height:80vh; display:flex; flex-direction:column;">
            <div style="padding:16px 20px; border-bottom:1px solid #f0f0f0; display:flex; justify-content:space-between; align-items:center;">
                <span style="font-size:17px; font-weight:600;">åˆ›å»ºè”æœºç¾¤èŠ</span>
                <button onclick="this.closest('#create-online-group-modal').remove()" style="background:none; border:none; font-size:20px; color:#999; cursor:pointer;">Ã—</button>
            </div>
            
            <div style="flex:1; overflow-y:auto; padding:20px;">
                <div style="margin-bottom:16px;">
                    <label style="font-size:13px; color:#666; display:block; margin-bottom:6px;">ç¾¤åç§°</label>
                    <input type="text" id="og-name" placeholder="è¾“å…¥ç¾¤èŠåç§°" style="width:100%; padding:12px; border:1px solid #ddd; border-radius:8px; font-size:14px; box-sizing:border-box;">
                </div>
                
                <div style="margin-bottom:16px;">
                    <label style="font-size:13px; color:#666; display:block; margin-bottom:6px;">é€‰æ‹©æˆ‘è¦å¸¦å…¥çš„è§’è‰²ï¼ˆå¯é€‰ï¼‰</label>
                    <select id="og-my-char" style="width:100%; padding:12px; border:1px solid #ddd; border-radius:8px; font-size:14px;">
                        <option value="">ä¸å¸¦è§’è‰²</option>
                        ${availableChars.map(c => `<option value="${c.id}">${c.name}</option>`).join('')}
                    </select>
                </div>
                
                <div style="margin-bottom:16px;">
                    <label style="font-size:13px; color:#666; display:block; margin-bottom:6px;">é‚€è¯·è”æœºå¥½å‹ï¼ˆå¯å¤šé€‰ï¼‰</label>
                    <div id="og-friends-list" style="max-height:200px; overflow-y:auto; border:1px solid #ddd; border-radius:8px;">
                        ${friends.length === 0 ? 
                            `<div style="padding:20px; text-align:center; color:#999;">æš‚æ— è”æœºå¥½å‹</div>` :
                            friends.map(f => `
                                <label style="display:flex; align-items:center; padding:10px 12px; border-bottom:1px solid #f5f5f5; cursor:pointer;">
                                    <input type="checkbox" value="${f.onlineData?.wx_account || ''}" style="margin-right:10px;">
                                    <div style="width:36px; height:36px; border-radius:6px; background-image:url(${f.avatar}); background-size:cover; background-color:#e0e0e0; margin-right:10px;"></div>
                                    <span style="font-size:14px;">${f.name}</span>
                                </label>
                            `).join('')
                        }
                    </div>
                </div>
            </div>
            
            <div style="padding:16px 20px; border-top:1px solid #f0f0f0;">
                <button onclick="doCreateOnlineGroup()" style="width:100%; padding:14px; background:var(--ins-pink); color:#fff; border:none; border-radius:10px; font-size:16px; font-weight:500;">åˆ›å»ºç¾¤èŠ</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// æ‰§è¡Œåˆ›å»ºè”æœºç¾¤èŠ
async function doCreateOnlineGroup() {
    const name = document.getElementById('og-name').value.trim();
    if (!name) {
        alert('è¯·è¾“å…¥ç¾¤åç§°');
        return;
    }
    
    const myWx = getMyOnlineWxAccount();
    if (!myWx) {
        alert('è¯·å…ˆä¸Šçº¿ä¸€ä¸ªè§’è‰²');
        return;
    }
    
    // è·å–é€‰æ‹©çš„è§’è‰²
    let myChar = null;
    const charId = document.getElementById('og-my-char').value;
    if (charId) {
        const char = await db.characters.get(parseInt(charId));
        if (char) {
            myChar = {
                name: char.name,
                avatar: char.avatar || '',
                desc: char.description?.substring(0, 200) || ''
            };
        }
    }
    
    // è·å–é‚€è¯·çš„å¥½å‹
    const checkboxes = document.querySelectorAll('#og-friends-list input[type="checkbox"]:checked');
    const inviteWxs = Array.from(checkboxes).map(cb => cb.value).filter(v => v);
    
    onlineSocket.send(JSON.stringify({
        type: 'create_online_group',
        name: name,
        my_wx_account: myWx,
        invite_wx_accounts: inviteWxs,
        my_character: myChar
    }));
    
    document.getElementById('create-online-group-modal')?.remove();
}

// æ‰“å¼€è”æœºç¾¤èŠ
function openOnlineGroup(groupId) {
    currentOnlineGroupId = groupId;
    currentOnlineGroupMessages = [];
    currentOnlineGroupMembers = [];
    
    const group = onlineGroups.find(g => g.id === groupId);
    if (!group) return;
    
    // æ˜¾ç¤ºç¾¤èŠé¡µé¢
    showOnlineGroupChatPage(group);
    
    // åº”ç”¨èƒŒæ™¯å›¾ï¼ˆå»¶è¿Ÿä¸€ä¸‹ç¡®ä¿é¡µé¢å·²åˆ›å»ºï¼‰
    setTimeout(() => {
        applyOnlineGroupBackground(groupId);
    }, 100);
    
    // è¯·æ±‚ç¾¤æˆå‘˜
    const myWx = getMyOnlineWxAccount();
    if (myWx) {
        onlineSocket.send(JSON.stringify({
            type: 'get_group_members',
            group_id: groupId,
            my_wx_account: myWx
        }));
        
        // è¯·æ±‚æ¶ˆæ¯è®°å½•
        onlineSocket.send(JSON.stringify({
            type: 'get_group_messages',
            group_id: groupId,
            my_wx_account: myWx,
            limit: 100
        }));
    }
}

// æ˜¾ç¤ºè”æœºç¾¤èŠé¡µé¢
function showOnlineGroupChatPage(group) {
    // åˆ›å»ºæˆ–æ˜¾ç¤ºç¾¤èŠé¡µé¢
    let page = document.getElementById('online-group-chat-page');
    if (!page) {
        page = document.createElement('div');
        page.id = 'online-group-chat-page';
        page.style.cssText = `position:fixed; top:0; left:0; right:0; bottom:0; background:#ffffff; z-index:300; display:flex; flex-direction:column;`;
        document.body.appendChild(page);
    }
    
    page.innerHTML = `
        <div class="wechat-header" style="background:#fff; border-bottom:1px solid #f0f0f0;">
            <div class="back-btn" onclick="hideOnlineGroupChat()" style="margin:0; background:none; width:40px; justify-content:flex-start; color:#333;">
                <svg class="svg-icon" viewBox="0 0 24 24" style="width:24px; height:24px;"><polyline points="15 18 9 12 15 6"></polyline></svg>
            </div>
            <div class="wechat-title" id="online-group-chat-title" style="flex:1; text-align:center;">${group.name}</div>
            <div onclick="showOnlineGroupInfo('${group.id}')" style="width:40px; display:flex; justify-content:flex-end; cursor:pointer;">
                <svg viewBox="0 0 24 24" style="width:20px; height:20px; stroke:#333; fill:none;"><circle cx="12" cy="12" r="1"></circle><circle cx="19" cy="12" r="1"></circle><circle cx="5" cy="12" r="1"></circle></svg>
            </div>
        </div>
        
        <div id="online-group-messages" style="flex:1; overflow-y:auto; padding:16px;">
            <div style="text-align:center; padding:20px; color:#999;">åŠ è½½ä¸­...</div>
        </div>
        
        <div class="chat-footer" id="online-group-footer">
            <div class="chat-input-bar">
                <!-- å·¦ä¾§ï¼šç”ŸæˆæŒ‰é’® (è®©è§’è‰²è¯´è¯) -->
                <div class="chat-icon-btn" onclick="letMyCharacterSpeak()" title="è®©è§’è‰²è¯´è¯">
                    <svg class="svg-icon" viewBox="0 0 24 24"><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M9 5H1"/></svg>
                </div>
                
                <!-- ä¸­é—´ï¼šè¾“å…¥æ¡† -->
                <input type="text" class="chat-input" id="online-group-input" placeholder="å‘é€æ¶ˆæ¯..." onfocus="closeOnlineGroupPanel()">
                
                <!-- å³ä¾§ï¼šè¡¨æƒ… -->
                <div class="chat-icon-btn" onclick="toggleOnlineGroupPanel('emoji')">
                    <svg class="svg-icon" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg>
                </div>
                
                <!-- å³ä¾§ï¼šèœå• (+) -->
                <div class="chat-icon-btn" id="online-group-btn-more" onclick="toggleOnlineGroupPanel('action')">
                    <svg class="svg-icon" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line></svg>
                </div>
                
                <!-- å³ä¾§ï¼šå‘é€ (Send) - é»˜è®¤éšè— -->
                <div class="chat-send-btn" id="online-group-btn-send" onclick="sendOnlineGroupMsg()">
                    <svg class="svg-icon" viewBox="0 0 24 24" style="width:18px; height:18px; stroke-width:3; transform: rotate(90deg) translateX(-2px);"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                </div>
            </div>
            
            <!-- é¢æ¿å®¹å™¨ -->
            <div class="chat-panel-container" id="online-group-panel-container">
                <!-- è¡¨æƒ…åŒ… Tab -->
                <div style="height: 40px; display: flex; border-bottom: 1px solid #eee; background: #fff;" id="online-group-emoji-tab-bar">
                    <div class="wechat-tab-item active" onclick="switchOnlineGroupEmojiTab('emoji')" style="flex:1; font-size:14px;">Emoji</div>
                    <div class="wechat-tab-item" onclick="switchOnlineGroupEmojiTab('sticker')" style="flex:1; font-size:14px;">è¡¨æƒ…åŒ…</div>
                </div>
                <!-- Emoji é¢æ¿ -->
                <div class="emoji-panel" id="online-group-emoji-panel" style="height: calc(100% - 40px);">
                    <!-- åŠ¨æ€ç”Ÿæˆè¡¨æƒ… -->
                </div>
                <!-- è‡ªå®šä¹‰è¡¨æƒ…åŒ…é¢æ¿ -->
                <div id="online-group-sticker-panel" style="height: calc(100% - 40px); display: none; flex-direction: column; overflow: hidden;">
                    <!-- åˆ†ç±»æ ‡ç­¾æ  -->
                    <div id="online-group-sticker-category-tabs" style="display: flex; overflow-x: auto; border-bottom: 1px solid #eee; background: #fff; flex-shrink: 0; height: 40px;">
                        <!-- åŠ¨æ€ç”Ÿæˆåˆ†ç±»æ ‡ç­¾ -->
                    </div>
                    <!-- è¡¨æƒ…åŒ…å†…å®¹åŒºåŸŸ -->
                    <div id="online-group-sticker-content" style="display: grid; flex: 1; grid-template-columns: repeat(4, 1fr); gap: 10px; padding: 10px; overflow-y: auto; align-content: start;">
                        <!-- åŠ¨æ€ç”Ÿæˆè‡ªå®šä¹‰è¡¨æƒ… -->
                        <div style="text-align:center; grid-column:span 4; color:#999; margin-top:20px;">æš‚æ— è¡¨æƒ…åŒ…<br>è¯·å»ã€æˆ‘-è¡¨æƒ…ã€‘æ·»åŠ </div>
                    </div>
                </div>

                <!-- åŠŸèƒ½èœå•é¢æ¿ -->
                <div class="action-panel" id="online-group-action-panel">
                    <div class="action-item" onclick="onlineGroupVoiceInput()">
                        <div class="action-icon-box">
                            <svg class="svg-icon" viewBox="0 0 24 24"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
                        </div>
                        <div class="action-name">è¯­éŸ³è¾“å…¥</div>
                    </div>
                    <div class="action-item" onclick="onlineGroupSendImage()">
                        <div class="action-icon-box">
                            <svg class="svg-icon" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
                        </div>
                        <div class="action-name">ç›¸å†Œ</div>
                    </div>
                    <div class="action-item" onclick="onlineGroupTransfer()">
                        <div class="action-icon-box transfer-icon">
                            <svg class="svg-icon" viewBox="0 0 24 24"><path d="M17 1l4 4-4 4"></path><path d="M3 11V9a4 4 0 0 1 4-4h14"></path><path d="M7 23l-4-4 4-4"></path><path d="M21 13v2a4 4 0 0 1-4 4H3"></path></svg>
                        </div>
                        <div class="action-name">è½¬è´¦</div>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    page.style.display = 'flex';
    
    // ç»‘å®šå›è½¦å‘é€
    const input = document.getElementById('online-group-input');
    input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') sendOnlineGroupMsg();
    });
    
    // ç»‘å®šè¾“å…¥å˜åŒ–äº‹ä»¶ï¼Œæ§åˆ¶å‘é€æŒ‰é’®æ˜¾ç¤º
    input.addEventListener('input', function() {
        const btnSend = document.getElementById('online-group-btn-send');
        const btnMore = document.getElementById('online-group-btn-more');
        if (this.value.trim()) {
            btnSend.style.display = 'flex';
            btnMore.style.display = 'none';
        } else {
            btnSend.style.display = 'none';
            btnMore.style.display = 'flex';
        }
    });
    
    // åˆå§‹åŒ–Emojié¢æ¿
    initOnlineGroupEmojiPanel();
    
    // åº”ç”¨èƒŒæ™¯å›¾
    applyOnlineGroupBackground(group.id);
}

// éšè—è”æœºç¾¤èŠé¡µé¢
function hideOnlineGroupChat() {
    const page = document.getElementById('online-group-chat-page');
    if (page) page.style.display = 'none';
    currentOnlineGroupId = null;
}

// å¤„ç†ç¾¤èŠæ¶ˆæ¯è®°å½•
function handleOnlineGroupMessages(data) {
    if (data.group_id !== currentOnlineGroupId) return;
    currentOnlineGroupMessages = data.messages || [];
    // æŒ‰æ—¶é—´æˆ³æ’åºï¼Œç¡®ä¿æ¶ˆæ¯é¡ºåºæ­£ç¡®
    currentOnlineGroupMessages.sort((a, b) => (a.created_at || 0) - (b.created_at || 0));
    renderOnlineGroupMessages();
}

// å¤„ç†å®æ—¶ç¾¤æ¶ˆæ¯
async function handleOnlineGroupMessage(data) {
    // æ›´æ–°æœ¬åœ°ç¾¤èŠè®°å½•ï¼Œè®©æ¶ˆæ¯åˆ—è¡¨æ˜¾ç¤ºæœ€æ–°æ¶ˆæ¯
    await updateLocalOnlineGroupLastMessage(data.group_id, data.message);
    
    if (data.group_id !== currentOnlineGroupId) {
        // ä¸æ˜¯å½“å‰ç¾¤ï¼Œæ˜¾ç¤ºé€šçŸ¥
        showToast(`[${data.message.sender_name}] ${data.message.content.substring(0, 20)}...`);
        return;
    }
    
    // å¦‚æœæ˜¯ç³»ç»Ÿæ¶ˆæ¯ï¼Œæ£€æŸ¥æ˜¯å¦æ˜¯çº¢åŒ…é¢†å–é€šçŸ¥ï¼Œå¦‚æœæ˜¯åˆ™æ›´æ–°çº¢åŒ…çŠ¶æ€
    if (data.message.msg_type === 'system' && data.message.content.includes('é¢†å–äº†çº¢åŒ…')) {
        // å°è¯•ä»ç³»ç»Ÿæ¶ˆæ¯ä¸­æå–çº¢åŒ…IDå’Œé¢†å–è€…ä¿¡æ¯
        // æ ¼å¼ï¼šXXX é¢†å–äº†çº¢åŒ…ï¼Œè·å¾— Â¥X.XX
        // ç”±äºæˆ‘ä»¬æ— æ³•ä»ç³»ç»Ÿæ¶ˆæ¯ä¸­ç›´æ¥è·å–çº¢åŒ…IDï¼Œè¿™é‡Œåªæ›´æ–°æ˜¾ç¤º
        // å®é™…çš„çº¢åŒ…çŠ¶æ€æ›´æ–°åœ¨ claimOnlineGroupRedPacket ä¸­å®Œæˆ
    }
    
    currentOnlineGroupMessages.push(data.message);
    // æŒ‰æ—¶é—´æˆ³æ’åºï¼Œç¡®ä¿æ¶ˆæ¯é¡ºåºæ­£ç¡®
    currentOnlineGroupMessages.sort((a, b) => (a.created_at || 0) - (b.created_at || 0));
    renderOnlineGroupMessages();
}

// å¤„ç†ç¾¤æˆå‘˜å¼€å§‹è¾“å…¥
function handleGroupTypingStart(data) {
    // åªåœ¨å½“å‰æ‰“å¼€çš„ç¾¤èŠä¸­æ˜¾ç¤º
    if (data.group_id !== currentOnlineGroupId) return;
    
    const chatTitleEl = document.getElementById('online-group-chat-title');
    if (chatTitleEl) {
        chatTitleEl.innerText = `${data.character_name} æ­£åœ¨è¾“å…¥ä¸­...`;
    }
}

// å¤„ç†ç¾¤æˆå‘˜åœæ­¢è¾“å…¥
function handleGroupTypingStop(data) {
    // åªåœ¨å½“å‰æ‰“å¼€çš„ç¾¤èŠä¸­æ˜¾ç¤º
    if (data.group_id !== currentOnlineGroupId) return;
    
    const chatTitleEl = document.getElementById('online-group-chat-title');
    const group = onlineGroups.find(g => g.id === currentOnlineGroupId);
    if (chatTitleEl && group) {
        chatTitleEl.innerText = group.name;
    }
}

// æ¸²æŸ“ç¾¤èŠæ¶ˆæ¯
function renderOnlineGroupMessages() {
    const container = document.getElementById('online-group-messages');
    if (!container) return;
    
    const myWx = getMyOnlineWxAccount();
    
    container.innerHTML = currentOnlineGroupMessages.map(msg => {
        // å¤„ç†ç³»ç»Ÿæ¶ˆæ¯
        if (msg.msg_type === 'system' || msg.sender_type === 'system') {
            return `<div style="text-align:center; padding:8px 16px; margin:8px 0;">
                <span style="background:#fff; color:#999; font-size:12px; padding:4px 12px; border-radius:4px; border:1px solid #ddd;">${msg.content}</span>
            </div>`;
        }
        
        const isCharacter = msg.sender_type === 'character';
        // åªæœ‰æˆ‘å‘çš„çœŸäººæ¶ˆæ¯æ‰æ˜¾ç¤ºåœ¨å³è¾¹ï¼Œæ‰€æœ‰è§’è‰²æ¶ˆæ¯ï¼ˆåŒ…æ‹¬æˆ‘çš„è§’è‰²ï¼‰éƒ½æ˜¾ç¤ºåœ¨å·¦è¾¹
        const isMe = msg.sender_wx === myWx && !isCharacter;
        const avatar = isCharacter ? (msg.character_avatar || '') : (msg.sender_avatar || '');
        const name = isCharacter ? `${msg.character_name} (${msg.sender_name})` : msg.sender_name;
        // ç¡®ä¿å¤´åƒURLä¸ä¸ºç©ºå­—ç¬¦ä¸²æ‰è®¾ç½®èƒŒæ™¯å›¾
        const avatarStyle = (avatar && avatar.trim()) ? `background-image:url(${avatar})` : 'background:#ccc';
        
        let messageContent = '';
        let isSpecialMsg = false;
        
        // å°è¯•è§£æJSONæ¶ˆæ¯ï¼ˆè¯­éŸ³ã€è½¬è´¦ç­‰ç‰¹æ®Šæ¶ˆæ¯ï¼‰
        let parsedContent = null;
        try {
            if (msg.content && msg.content.startsWith('{') && msg.content.includes('__type')) {
                parsedContent = JSON.parse(msg.content);
            }
        } catch(e) {}
        
        // å¤„ç†è¯­éŸ³æ¶ˆæ¯
        if (parsedContent && parsedContent.__type === 'audio') {
            isSpecialMsg = true;
            const audioId = 'online_group_audio_' + (msg.id || msg.created_at);
            const effectIcon = parsedContent.effect === 'loli' ? 'ğŸ€' : 
                              parsedContent.effect === 'uncle' ? 'ğŸ§”' :
                              parsedContent.effect === 'robot' ? 'ğŸ¤–' : 'ğŸ™ï¸';
            messageContent = `
                <div class="online-audio-bubble" style="min-width:120px; max-width:200px; padding:10px 14px; background:${isMe ? '#ffe4e8' : '#f2f2f7'}; border-radius:18px; display:flex; align-items:center; gap:10px; cursor:pointer;" onclick="playOnlineGroupAudio('${audioId}')">
                    <div class="audio-play-icon" id="icon_${audioId}" data-original="${effectIcon}" style="font-size:20px;">${effectIcon}</div>
                    <div style="flex:1; display:flex; flex-direction:column;">
                        <div style="height:20px; background:#fff; border-radius:10px; position:relative; overflow:hidden;">
                            <div style="height:100%; background:var(--ins-pink); width:0%; transition:width 0.1s;" id="progress_${audioId}"></div>
                        </div>
                        <div style="font-size:11px; color:#999; margin-top:2px;">${parsedContent.duration}"</div>
                    </div>
                    <audio id="${audioId}" src="${parsedContent.audio}" style="display:none;"></audio>
                </div>
            `;
        }
        // å¤„ç†çº¢åŒ…æ¶ˆæ¯
        else if (msg.msg_type === 'redpacket') {
            isSpecialMsg = true;
            try {
                const data = JSON.parse(msg.content);
                const msgId = msg.id || ('rp_' + msg.created_at);
                const claimedCount = (data.claimed || []).length;
                const isAllClaimed = claimedCount >= data.count;
                const myWx = getMyOnlineWxAccount();
                const hasClaimed = data.claimed?.includes(myWx) || false;
                
                messageContent = `<div class="redpacket-card" onclick="showOnlineGroupRedPacketDetail('${msgId}')" style="width:220px; background:#fff; border-radius:12px; overflow:hidden; box-shadow:0 1px 3px rgba(0,0,0,0.08); border:1px solid #eee; cursor:pointer;">
                    <div style="padding:14px 16px; display:flex; align-items:center; gap:12px; background:linear-gradient(135deg, #ff6b6b 0%, #ff8e8e 100%);">
                        <div style="width:40px; height:40px; background:#fff; border-radius:10px; display:flex; align-items:center; justify-content:center; border:1px solid rgba(255,255,255,0.3);">
                            <svg viewBox="0 0 24 24" style="width:20px; height:20px; stroke:#ff6b6b; fill:#ff6b6b; stroke-width:1.5;"><rect x="3" y="4" width="18" height="16" rx="2"/><path d="M3 10h18"/><circle cx="12" cy="15" r="2"/></svg>
                        </div>
                        <div style="flex:1;">
                            <div style="font-size:13px; color:rgba(255,255,255,0.9); margin-bottom:2px;">${escapeHtml(data.wish || 'æ­å–œå‘è´¢')}</div>
                            <div style="font-size:11px; color:rgba(255,255,255,0.7);">${data.redpacketType === 'lucky' ? 'æ‹¼æ‰‹æ°”çº¢åŒ…' : 'æ™®é€šçº¢åŒ…'}</div>
                        </div>
                    </div>
                    <div style="padding:8px 16px; display:flex; justify-content:space-between; align-items:center; border-top:1px solid #eee;">
                        <span style="font-size:11px; color:#999;">${isAllClaimed ? 'å·²é¢†å®Œ' : `${claimedCount}/${data.count}ä¸ªå·²é¢†å–`}</span>
                        <span style="font-size:11px; color:#999;">${hasClaimed ? 'å·²é¢†å–' : isAllClaimed ? 'å·²é¢†å®Œ' : 'é¢†å–'}</span>
                    </div>
                </div>`;
            } catch(e) {
                messageContent = renderMessageContent(msg.content);
                isSpecialMsg = false;
            }
        }
        // å¤„ç†è½¬è´¦æ¶ˆæ¯
        else if (msg.msg_type === 'transfer') {
            isSpecialMsg = true;
            try {
                const data = JSON.parse(msg.content);
                const msgId = msg.id || ('trans_' + msg.created_at);
                const targetHint = data.targetName ? `è½¬ç»™ ${data.targetName}` : 'è½¬è´¦';
                messageContent = `<div class="redpacket-card" onclick="receiveOnlineGroupTransfer('${msgId}')" style="width:220px; background:#fff; border-radius:12px; overflow:hidden; box-shadow:0 1px 3px rgba(0,0,0,0.08); border:1px solid #eee; cursor:pointer;">
                    <div style="padding:14px 16px; display:flex; align-items:center; gap:12px;">
                        <div style="width:40px; height:40px; background:#fff; border-radius:10px; display:flex; align-items:center; justify-content:center; border:1px solid #eee;">
                            <svg viewBox="0 0 24 24" style="width:20px; height:20px; stroke:#666; fill:none; stroke-width:1.5;"><path d="M17 1l4 4-4 4"/><path d="M3 11V9a4 4 0 0 1 4-4h14"/><path d="M7 23l-4-4 4-4"/><path d="M21 13v2a4 4 0 0 1-4 4H3"/></svg>
                        </div>
                        <div style="flex:1;">
                            <div style="font-size:18px; font-weight:600; color:#333; margin-bottom:2px;">Â¥${data.amount}</div>
                            <div style="font-size:12px; color:#999;">${escapeHtml(data.desc || 'è½¬è´¦')}</div>
                        </div>
                    </div>
                    <div style="padding:8px 16px; display:flex; justify-content:space-between; align-items:center; border-top:1px solid #eee;">
                        <span style="font-size:11px; color:#999;">${targetHint}</span>
                        <span style="font-size:11px; color:#999;">${data.status === 'received' ? 'å·²æ”¶æ¬¾' : 'å¾…æ”¶æ¬¾'}</span>
                    </div>
                </div>`;
            } catch(e) {
                messageContent = renderMessageContent(msg.content);
                isSpecialMsg = false;
            }
        } else {
            // æ™®é€šæ¶ˆæ¯
            messageContent = renderMessageContent(msg.content);
        }
        
        // å®Œå…¨æŒ‰ç…§æ™®é€šç¾¤èŠçš„æ ·å¼
        if (isMe) {
            // æˆ‘å‘çš„æ¶ˆæ¯
            if (isSpecialMsg) {
                return `
                    <div style="display:flex; flex-direction:row-reverse; align-items:flex-end; gap:8px; margin-bottom:12px;">
                        <div style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                        <div style="display:flex; flex-direction:column; align-items:flex-end; max-width:70%;">
                            <div style="font-size:12px; color:#999; margin-bottom:2px;">${name}${isCharacter ? ' ğŸ­' : ''}</div>
                            <div style="display:flex; align-items:flex-end; gap:6px;">
                                <div style="font-size:10px; color:#999;">${formatChatTime(msg.created_at)}</div>
                                <div>${messageContent}</div>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                return `
                    <div style="display:flex; flex-direction:row-reverse; align-items:flex-end; gap:8px; margin-bottom:12px;">
                        <div style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                        <div style="display:flex; flex-direction:column; align-items:flex-end; max-width:70%;">
                            <div style="font-size:12px; color:#999; margin-bottom:2px;">${name}${isCharacter ? ' ğŸ­' : ''}</div>
                            <div style="display:flex; align-items:flex-end; gap:6px;">
                                <div style="font-size:10px; color:#999;">${formatChatTime(msg.created_at)}</div>
                                <div style="background:#ffe4e8; color:#000; padding:6px 10px; border-radius:18px 18px 4px 18px; font-size:15px; line-height:1.5; word-break:break-word;">${messageContent}</div>
                            </div>
                        </div>
                    </div>
                `;
            }
        } else {
            // åˆ«äººå‘çš„æ¶ˆæ¯
            if (isSpecialMsg) {
                return `
                    <div style="display:flex; align-items:flex-end; gap:8px; margin-bottom:12px;">
                        <div style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                        <div style="display:flex; flex-direction:column; max-width:70%;">
                            <div style="font-size:12px; color:#999; margin-bottom:2px;">${name}${isCharacter ? ' ğŸ­' : ''}</div>
                            <div style="display:flex; align-items:flex-end; gap:6px;">
                                <div>${messageContent}</div>
                                <div style="font-size:10px; color:#999;">${formatChatTime(msg.created_at)}</div>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                return `
                    <div style="display:flex; align-items:flex-end; gap:8px; margin-bottom:12px;">
                        <div style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                        <div style="display:flex; flex-direction:column; max-width:70%;">
                            <div style="font-size:12px; color:#999; margin-bottom:2px;">${name}${isCharacter ? ' ğŸ­' : ''}</div>
                            <div style="display:flex; align-items:flex-end; gap:6px;">
                                <div style="background:#f2f2f7; color:#000; padding:6px 10px; border-radius:18px 18px 18px 4px; font-size:15px; line-height:1.5; word-break:break-word;">${messageContent}</div>
                                <div style="font-size:10px; color:#999;">${formatChatTime(msg.created_at)}</div>
                            </div>
                        </div>
                    </div>
                `;
            }
        }
    }).join('');
    
    // ä¸ºå›¾ç‰‡æ·»åŠ ç‚¹å‡»äº‹ä»¶
    container.querySelectorAll('.chat-image').forEach(img => {
        img.onclick = () => showFullImage(img.src);
    });
    
    container.scrollTop = container.scrollHeight;
}

// æ”¶å–è”æœºç¾¤èŠè½¬è´¦
function receiveOnlineGroupTransfer(msgId) {
    showToast('è½¬è´¦åŠŸèƒ½æš‚ä¸æ”¯æŒæ”¶å–ï¼Œä»…ç”¨äºå±•ç¤º');
}

// æ’­æ”¾è”æœºç¾¤èŠè¯­éŸ³æ¶ˆæ¯
let currentPlayingOnlineGroupAudio = null;
function playOnlineGroupAudio(audioId) {
    const audio = document.getElementById(audioId);
    const icon = document.getElementById('icon_' + audioId);
    const progress = document.getElementById('progress_' + audioId);
    
    if (!audio) return;
    
    // å¦‚æœæœ‰å…¶ä»–æ­£åœ¨æ’­æ”¾çš„ï¼Œå…ˆåœæ­¢
    if (currentPlayingOnlineGroupAudio && currentPlayingOnlineGroupAudio !== audio) {
        currentPlayingOnlineGroupAudio.pause();
        currentPlayingOnlineGroupAudio.currentTime = 0;
        // é‡ç½®ä¹‹å‰éŸ³é¢‘çš„å›¾æ ‡å’Œè¿›åº¦æ¡
        const prevIcon = document.getElementById('icon_' + currentPlayingOnlineGroupAudio.id);
        const prevProgress = document.getElementById('progress_' + currentPlayingOnlineGroupAudio.id);
        if (prevIcon) {
            const bubble = currentPlayingOnlineGroupAudio.closest('.online-audio-bubble');
            if (bubble) {
                const originalIcon = bubble.querySelector('.audio-play-icon');
                if (originalIcon) prevIcon.textContent = prevIcon.dataset.original || 'ğŸ™ï¸';
            }
        }
        if (prevProgress) prevProgress.style.width = '0%';
    }
    
    if (audio.paused) {
        audio.play();
        currentPlayingOnlineGroupAudio = audio;
        if (icon) icon.textContent = 'â¸ï¸';
        
        // æ›´æ–°è¿›åº¦æ¡
        audio.ontimeupdate = () => {
            if (progress && audio.duration) {
                const percent = (audio.currentTime / audio.duration) * 100;
                progress.style.width = percent + '%';
            }
        };
        
        audio.onended = () => {
            if (icon) icon.textContent = icon.dataset.original || 'ğŸ™ï¸';
            if (progress) progress.style.width = '0%';
            currentPlayingOnlineGroupAudio = null;
        };
    } else {
        audio.pause();
        audio.currentTime = 0;
        if (icon) icon.textContent = icon.dataset.original || 'ğŸ™ï¸';
        if (progress) progress.style.width = '0%';
        currentPlayingOnlineGroupAudio = null;
    }
}

// å¤„ç†ç¾¤æˆå‘˜åˆ—è¡¨
function handleOnlineGroupMembers(data) {
    if (data.group_id !== currentOnlineGroupId) return;
    currentOnlineGroupMembers = data.members || [];
    
    // æ‰¾åˆ°æˆ‘çš„è§’è‰²
    const myWx = getMyOnlineWxAccount();
    const myMember = currentOnlineGroupMembers.find(m => m.user_wx === myWx);
    if (myMember && myMember.character_name) {
        myOnlineGroupCharacter = {
            name: myMember.character_name,
            avatar: myMember.character_avatar,
            desc: myMember.character_desc
        };
    } else {
        myOnlineGroupCharacter = null;
    }
}

// åˆ‡æ¢è”æœºç¾¤èŠé¢æ¿
let currentOnlineGroupPanel = null;
function toggleOnlineGroupPanel(panelType) {
    const container = document.getElementById('online-group-panel-container');
    const emojiTabBar = document.getElementById('online-group-emoji-tab-bar');
    const emojiPanel = document.getElementById('online-group-emoji-panel');
    const stickerPanel = document.getElementById('online-group-sticker-panel');
    const actionPanel = document.getElementById('online-group-action-panel');
    
    if (!container) {
        console.error('[Panel] Missing container!');
        return;
    }
    
    if (currentOnlineGroupPanel === panelType) {
        // å…³é—­é¢æ¿
        container.classList.remove('open');
        if (emojiTabBar) emojiTabBar.style.display = 'none';
        if (emojiPanel) emojiPanel.style.display = 'none';
        if (stickerPanel) stickerPanel.style.display = 'none';
        if (actionPanel) actionPanel.style.display = 'none';
        currentOnlineGroupPanel = null;
    } else {
        // æ‰“å¼€é¢æ¿
        container.classList.add('open');
        if (panelType === 'emoji') {
            if (emojiTabBar) emojiTabBar.style.display = 'flex';
            if (emojiPanel) emojiPanel.style.display = 'grid';
            if (stickerPanel) stickerPanel.style.display = 'none';
            if (actionPanel) actionPanel.style.display = 'none';
        } else if (panelType === 'action') {
            if (emojiTabBar) emojiTabBar.style.display = 'none';
            if (emojiPanel) emojiPanel.style.display = 'none';
            if (stickerPanel) stickerPanel.style.display = 'none';
            if (actionPanel) actionPanel.style.display = 'grid';
        }
        currentOnlineGroupPanel = panelType;
    }
}

// å…³é—­è”æœºç¾¤èŠé¢æ¿
function closeOnlineGroupPanel() {
    const container = document.getElementById('online-group-panel-container');
    if (container) {
        container.classList.remove('open');
    }
    const emojiTabBar = document.getElementById('online-group-emoji-tab-bar');
    const emojiPanel = document.getElementById('online-group-emoji-panel');
    const stickerPanel = document.getElementById('online-group-sticker-panel');
    const actionPanel = document.getElementById('online-group-action-panel');
    if (emojiTabBar) emojiTabBar.style.display = 'none';
    if (emojiPanel) emojiPanel.style.display = 'none';
    if (stickerPanel) stickerPanel.style.display = 'none';
    if (actionPanel) actionPanel.style.display = 'none';
    currentOnlineGroupPanel = null;
}

// åˆ‡æ¢è”æœºç¾¤èŠè¡¨æƒ…Tab
async function switchOnlineGroupEmojiTab(type) {
    const tabs = document.querySelectorAll('#online-group-emoji-tab-bar .wechat-tab-item');
    const emojiPanel = document.getElementById('online-group-emoji-panel');
    const stickerPanel = document.getElementById('online-group-sticker-panel');

    if (type === 'emoji') {
        tabs[0].classList.add('active');
        tabs[1].classList.remove('active');
        emojiPanel.style.display = 'grid';
        stickerPanel.style.display = 'none';
    } else {
        tabs[0].classList.remove('active');
        tabs[1].classList.add('active');
        emojiPanel.style.display = 'none';
        stickerPanel.style.display = 'flex';
        // åŠ è½½è‡ªå®šä¹‰è¡¨æƒ…åŒ…
        await loadOnlineGroupStickers();
    }
}

// å½“å‰é€‰ä¸­çš„è”æœºç¾¤èŠè¡¨æƒ…åŒ…åˆ†ç±»ID
let currentActiveOnlineGroupStickerCategoryId = null;

// åŠ è½½è”æœºç¾¤èŠçš„è‡ªå®šä¹‰è¡¨æƒ…åŒ…
async function loadOnlineGroupStickers() {
    const tabsContainer = document.getElementById('online-group-sticker-category-tabs');
    const contentContainer = document.getElementById('online-group-sticker-content');
    if (!tabsContainer || !contentContainer) return;
    
    try {
    // è·å–æ‰€æœ‰è¡¨æƒ…åŒ…åˆ†ç±»
    const allCategories = await db.sticker_categories.toArray();
    
    if (allCategories.length === 0) {
        tabsContainer.innerHTML = '';
        contentContainer.innerHTML = `<div style="text-align:center; grid-column:span 4; color:#999; margin-top:20px;">æš‚æ— è¡¨æƒ…åŒ…<br>è¯·å»ã€æˆ‘-è¡¨æƒ…ã€‘æ·»åŠ </div>`;
        return;
    }
    
    // è¿‡æ»¤å‡ºæœ‰æœ‰æ•ˆè¡¨æƒ…åŒ…çš„åˆ†ç±»ï¼ˆç¡®ä¿stickersæ•°ç»„å­˜åœ¨ä¸”æœ‰urlæœ‰æ•ˆçš„è¡¨æƒ…ï¼‰
    const validCategories = allCategories.filter(cat => {
        if (!cat.stickers || cat.stickers.length === 0) return false;
        return cat.stickers.some(s => s && s.url);
    });
    
    if (validCategories.length === 0) {
        tabsContainer.innerHTML = '';
        contentContainer.innerHTML = `<div style="text-align:center; grid-column:span 4; color:#999; margin-top:20px;">æš‚æ— è¡¨æƒ…åŒ…<br>è¯·å»ã€æˆ‘-è¡¨æƒ…ã€‘æ·»åŠ </div>`;
        return;
    }
    
    // å¦‚æœè¿˜æ²¡æœ‰é€‰ä¸­çš„åˆ†ç±»ï¼Œé»˜è®¤é€‰ä¸­ç¬¬ä¸€ä¸ª
    if (!currentActiveOnlineGroupStickerCategoryId || !validCategories.find(c => c.id === currentActiveOnlineGroupStickerCategoryId)) {
        currentActiveOnlineGroupStickerCategoryId = validCategories[0].id;
    }
    
    // ç”Ÿæˆåˆ†ç±»æ ‡ç­¾
    let tabsHtml = '';
    for (const cat of validCategories) {
        const isActive = cat.id === currentActiveOnlineGroupStickerCategoryId;
        tabsHtml += `
            <div class="sticker-category-tab ${isActive ? 'active' : ''}" onclick="switchOnlineGroupStickerCategory(${cat.id})" style="
                flex-shrink: 0;
                padding: 10px 16px;
                font-size: 13px;
                color: ${isActive ? 'var(--ins-pink)' : '#666'};
                border-bottom: 2px solid ${isActive ? 'var(--ins-pink)' : 'transparent'};
                cursor: pointer;
                white-space: nowrap;
                transition: all 0.2s;
            ">
                ${cat.name}
            </div>
        `;
    }
    tabsContainer.innerHTML = tabsHtml;
    
    // æ˜¾ç¤ºå½“å‰é€‰ä¸­åˆ†ç±»çš„è¡¨æƒ…åŒ…
    const currentCategory = validCategories.find(c => c.id === currentActiveOnlineGroupStickerCategoryId);
    if (!currentCategory) return;
    
    let contentHtml = '';
    currentCategory.stickers.forEach(s => {
        // âœ… è·³è¿‡æ— æ•ˆçš„è¡¨æƒ…åŒ…æ¡ç›®ï¼ˆurlç¼ºå¤±æˆ–éå­—ç¬¦ä¸²ï¼‰
        if (!s || !s.url || typeof s.url !== 'string') return;
        const safeUrl = s.url.replace(/'/g, "\\'").replace(/"/g, '&quot;');
        const safeDesc = (s.description || '').replace(/'/g, "\\'").replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        contentHtml += `<div class="emoji-item" onclick="sendOnlineGroupSticker('${safeUrl}')" style="display:flex; flex-direction:column; align-items:center; gap:4px; cursor:pointer;">
            <img src="${s.url}" style="width:60px; height:60px; border-radius:8px; object-fit:cover;" onerror="this.onerror=null; this.style.cssText='width:60px; height:60px; display:flex; align-items:center; justify-content:center; background:#f5f5f5; border-radius:8px;'; this.outerHTML='<div style=\\'width:60px; height:60px; display:flex; align-items:center; justify-content:center; background:#f5f5f5; border-radius:8px; color:#ccc; font-size:10px;\\'>å¤±è´¥</div>';" />
            ${safeDesc ? `<div style="font-size:10px; color:#999; text-align:center; max-width:60px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${safeDesc}</div>` : ''}
        </div>`;
    });
    
    contentContainer.innerHTML = contentHtml || `<div style="text-align:center; grid-column:span 4; color:#999; margin-top:20px;">è¯¥åˆ†ç±»ä¸‹æš‚æ— æœ‰æ•ˆè¡¨æƒ…åŒ…</div>`;
    } catch (e) {
        console.error('[è”æœºç¾¤èŠè¡¨æƒ…åŒ…é¢æ¿] åŠ è½½å¤±è´¥:', e);
        contentContainer.innerHTML = `<div style="text-align:center; grid-column:span 4; color:#999; margin-top:20px;">è¡¨æƒ…åŒ…åŠ è½½å¤±è´¥<br>è¯·åˆ·æ–°é¡µé¢é‡è¯•</div>`;
    }
}

// åˆ‡æ¢è”æœºç¾¤èŠè¡¨æƒ…åŒ…åˆ†ç±»
async function switchOnlineGroupStickerCategory(categoryId) {
    currentActiveOnlineGroupStickerCategoryId = categoryId;
    await loadOnlineGroupStickers();
}

// å‘é€è”æœºç¾¤èŠè¡¨æƒ…åŒ…
function sendOnlineGroupSticker(stickerUrl) {
    const myWx = getMyOnlineWxAccount();
    const myChar = onlineCharacters.find(c => c.wx_account === myWx);
    
    const imgContent = `[img:${stickerUrl}]`;
    
    onlineSocket.send(JSON.stringify({
        type: 'send_group_message',
        group_id: currentOnlineGroupId,
        my_wx_account: myWx,
        sender_type: 'user',
        sender_name: myChar?.nickname || myWx,
        content: imgContent,
        msg_type: 'image'
    }));
    
    closeOnlineGroupPanel();
}

// åˆå§‹åŒ–è”æœºç¾¤èŠEmojié¢æ¿
function initOnlineGroupEmojiPanel() {
    const panel = document.getElementById('online-group-emoji-panel');
    if (!panel) return;
    
    const emojis = [
        'ğŸ˜€', 'ğŸ˜ƒ', 'ğŸ˜„', 'ğŸ˜', 'ğŸ˜†', 'ğŸ˜…', 'ğŸ¤£', 'ğŸ˜‚',
        'ğŸ™‚', 'ğŸ™ƒ', 'ğŸ˜‰', 'ğŸ˜Š', 'ğŸ˜‡', 'ğŸ¥°', 'ğŸ˜', 'ğŸ¤©',
        'ğŸ˜˜', 'ğŸ˜—', 'ğŸ˜š', 'ğŸ˜™', 'ğŸ˜‹', 'ğŸ˜›', 'ğŸ˜œ', 'ğŸ¤ª',
        'ğŸ˜', 'ğŸ¤‘', 'ğŸ¤—', 'ğŸ¤­', 'ğŸ¤«', 'ğŸ¤”', 'ğŸ¤', 'ğŸ¤¨',
        'ğŸ˜', 'ğŸ˜‘', 'ğŸ˜¶', 'ğŸ˜', 'ğŸ˜’', 'ğŸ™„', 'ğŸ˜¬', 'ğŸ¤¥',
        'ğŸ˜Œ', 'ğŸ˜”', 'ğŸ˜ª', 'ğŸ¤¤', 'ğŸ˜´', 'ğŸ˜·', 'ğŸ¤’', 'ğŸ¤•',
        'ğŸ¤¢', 'ğŸ¤®', 'ğŸ¤§', 'ğŸ¥µ', 'ğŸ¥¶', 'ğŸ¥´', 'ğŸ˜µ', 'ğŸ¤¯',
        'ğŸ¤ ', 'ğŸ¥³', 'ğŸ˜', 'ğŸ¤“', 'ğŸ§', 'ğŸ˜•', 'ğŸ˜Ÿ', 'ğŸ™',
        'â˜¹ï¸', 'ğŸ˜®', 'ğŸ˜¯', 'ğŸ˜²', 'ğŸ˜³', 'ğŸ¥º', 'ğŸ˜¦', 'ğŸ˜§',
        'ğŸ˜¨', 'ğŸ˜°', 'ğŸ˜¥', 'ğŸ˜¢', 'ğŸ˜­', 'ğŸ˜±', 'ğŸ˜–', 'ğŸ˜£',
        'ğŸ˜', 'ğŸ˜“', 'ğŸ˜©', 'ğŸ˜«', 'ğŸ¥±', 'ğŸ˜¤', 'ğŸ˜¡', 'ğŸ˜ ',
        'ğŸ¤¬', 'ğŸ˜ˆ', 'ğŸ‘¿', 'ğŸ’€', 'â˜ ï¸', 'ğŸ’©', 'ğŸ¤¡', 'ğŸ‘¹',
        'ğŸ‘º', 'ğŸ‘»', 'ğŸ‘½', 'ğŸ‘¾', 'ğŸ¤–', 'ğŸ˜º', 'ğŸ˜¸', 'ğŸ˜¹',
        'ğŸ˜»', 'ğŸ˜¼', 'ğŸ˜½', 'ğŸ™€', 'ğŸ˜¿', 'ğŸ˜¾', 'ğŸ‘‹', 'ğŸ¤š',
        'ğŸ–', 'âœ‹', 'ğŸ––', 'ğŸ‘Œ', 'ğŸ¤', 'âœŒï¸', 'ğŸ¤', 'ğŸ¤Ÿ',
        'ğŸ¤˜', 'ğŸ¤™', 'ğŸ‘ˆ', 'ğŸ‘‰', 'ğŸ‘†', 'ğŸ–•', 'ğŸ‘‡', 'â˜ï¸',
        'ğŸ‘', 'ğŸ‘', 'âœŠ', 'ğŸ‘Š', 'ğŸ¤›', 'ğŸ¤œ', 'ğŸ‘', 'ğŸ™Œ',
        'ğŸ‘', 'ğŸ¤²', 'ğŸ¤', 'ğŸ™', 'âœï¸', 'ğŸ’…', 'ğŸ¤³', 'ğŸ’ª'
    ];
    
    panel.innerHTML = emojis.map(emoji => 
        `<div class="emoji-item" onclick="insertOnlineGroupEmoji('${emoji}')">${emoji}</div>`
    ).join('');
}

// æ’å…¥Emojiåˆ°è¾“å…¥æ¡†
function insertOnlineGroupEmoji(emoji) {
    const input = document.getElementById('online-group-input');
    if (input) {
        input.value += emoji;
        input.focus();
        // è§¦å‘è¾“å…¥äº‹ä»¶ä»¥æ›´æ–°å‘é€æŒ‰é’®çŠ¶æ€
        input.dispatchEvent(new Event('input'));
    }
}

// è”æœºç¾¤èŠè¯­éŸ³è¾“å…¥
async function onlineGroupVoiceInput() {
    closeOnlineGroupPanel();
    
    // æ˜¾ç¤ºè¯­éŸ³å½•åˆ¶+å˜å£°å¼¹çª—ï¼ˆå®Œå…¨å‚ç…§è”æœºç§èŠï¼‰
    const modal = document.createElement('div');
    modal.id = 'online-group-voice-modal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
    `;
    
    modal.innerHTML = `
        <div style="background: white; border-radius: 16px; padding: 24px; width: 85%; max-width: 320px;">
            <h3 style="margin: 0 0 20px 0; text-align: center; color: #333; font-size: 18px;">ğŸ¤ è¯­éŸ³å½•åˆ¶</h3>
            
            <div style="margin-bottom: 20px;">
                <div style="font-size: 13px; color: #666; margin-bottom: 10px;">é€‰æ‹©å˜å£°æ•ˆæœï¼š</div>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                    <label style="display: flex; align-items: center; padding: 12px; background: #f5f5f5; border-radius: 8px; cursor: pointer;">
                        <input type="radio" name="online-group-voice-effect" value="normal" checked style="margin-right: 8px;">
                        <span>ğŸ™ï¸ åŸå£°</span>
                    </label>
                    <label style="display: flex; align-items: center; padding: 12px; background: #fff0f5; border-radius: 8px; cursor: pointer;">
                        <input type="radio" name="online-group-voice-effect" value="loli" style="margin-right: 8px;">
                        <span>ğŸ€ èè‰éŸ³</span>
                    </label>
                    <label style="display: flex; align-items: center; padding: 12px; background: #f0f5ff; border-radius: 8px; cursor: pointer;">
                        <input type="radio" name="online-group-voice-effect" value="uncle" style="margin-right: 8px;">
                        <span>ğŸ§” å¤§å”éŸ³</span>
                    </label>
                    <label style="display: flex; align-items: center; padding: 12px; background: #f5fff0; border-radius: 8px; cursor: pointer;">
                        <input type="radio" name="online-group-voice-effect" value="robot" style="margin-right: 8px;">
                        <span>ğŸ¤– æœºå™¨äºº</span>
                    </label>
                </div>
            </div>
            
            <div id="online-group-voice-record-status" style="text-align: center; padding: 20px; background: #f9f9f9; border-radius: 12px; margin-bottom: 16px;">
                <div style="font-size: 14px; color: #999;">ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¼€å§‹å½•éŸ³</div>
                <div id="online-group-voice-record-time" style="font-size: 24px; font-weight: 600; color: #333; margin-top: 8px; display: none;">00:00</div>
            </div>
            
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <button id="btn-start-online-group-record" onclick="startOnlineGroupVoiceRecord()" style="padding: 14px; background: var(--ins-pink); color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 500; cursor: pointer;">
                    ğŸ¤ æŒ‰ä½å½•éŸ³
                </button>
                <button onclick="closeOnlineGroupVoiceModal()" style="padding: 12px; background: #f0f0f0; color: #666; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;">
                    å–æ¶ˆ
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// å…³é—­è”æœºç¾¤èŠè¯­éŸ³å¼¹çª—
function closeOnlineGroupVoiceModal() {
    document.getElementById('online-group-voice-modal')?.remove();
}

// âœ… è”æœºç¾¤èŠè¯­éŸ³å½•åˆ¶å˜é‡
let onlineGroupVoiceRecorder = null;
let onlineGroupVoiceChunks = [];
let onlineGroupVoiceStartTime = 0;
let onlineGroupVoiceTimer = null;

// å¼€å§‹è”æœºç¾¤èŠè¯­éŸ³å½•åˆ¶
async function startOnlineGroupVoiceRecord() {
    const btn = document.getElementById('btn-start-online-group-record');
    const statusDiv = document.getElementById('online-group-voice-record-status');
    const timeDiv = document.getElementById('online-group-voice-record-time');
    
    // å¦‚æœæ­£åœ¨å½•éŸ³ï¼Œåˆ™åœæ­¢
    if (onlineGroupVoiceRecorder && onlineGroupVoiceRecorder.state === 'recording') {
        stopOnlineGroupVoiceRecord();
        return;
    }
    
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        onlineGroupVoiceRecorder = new MediaRecorder(stream);
        onlineGroupVoiceChunks = [];
        onlineGroupVoiceStartTime = Date.now();
        
        onlineGroupVoiceRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) {
                onlineGroupVoiceChunks.push(e.data);
            }
        };
        
        onlineGroupVoiceRecorder.onstop = async () => {
            stream.getTracks().forEach(track => track.stop());
            clearInterval(onlineGroupVoiceTimer);
            
            const duration = Math.round((Date.now() - onlineGroupVoiceStartTime) / 1000);
            const blob = new Blob(onlineGroupVoiceChunks, { type: 'audio/webm' });
            
            // è·å–é€‰æ‹©çš„å˜å£°æ•ˆæœ
            const effectRadio = document.querySelector('input[name="online-group-voice-effect"]:checked');
            const effect = effectRadio ? effectRadio.value : 'normal';
            
            statusDiv.innerHTML = '<div style="color: var(--ins-pink);">â³ æ­£åœ¨å¤„ç†...</div>';
            
            // å¤„ç†å˜å£°å¹¶å‘é€
            await processAndSendOnlineGroupVoice(blob, effect, duration);
        };
        
        onlineGroupVoiceRecorder.start();
        
        // æ›´æ–°UI
        btn.textContent = 'â¹ï¸ åœæ­¢å½•éŸ³';
        btn.style.background = '#ff3b30';
        timeDiv.style.display = 'block';
        statusDiv.querySelector('div').textContent = 'ğŸ”´ æ­£åœ¨å½•éŸ³...';
        
        // è®¡æ—¶å™¨
        onlineGroupVoiceTimer = setInterval(() => {
            const elapsed = Math.round((Date.now() - onlineGroupVoiceStartTime) / 1000);
            const min = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const sec = (elapsed % 60).toString().padStart(2, '0');
            timeDiv.textContent = `${min}:${sec}`;
        }, 1000);
        
    } catch (err) {
        console.error('å½•éŸ³å¤±è´¥:', err);
        alert('æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·ç¡®ä¿å·²æˆäºˆæƒé™');
    }
}

// åœæ­¢è”æœºç¾¤èŠè¯­éŸ³å½•åˆ¶
function stopOnlineGroupVoiceRecord() {
    if (onlineGroupVoiceRecorder && onlineGroupVoiceRecorder.state === 'recording') {
        onlineGroupVoiceRecorder.stop();
    }
}

// å¤„ç†å˜å£°å¹¶å‘é€è”æœºç¾¤èŠè¯­éŸ³
async function processAndSendOnlineGroupVoice(blob, effect, duration) {
    try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const arrayBuffer = await blob.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        
        // æ ¹æ®æ•ˆæœè®¾ç½®å‚æ•°
        let pitchRate = 1.0;
        switch (effect) {
            case 'loli':    pitchRate = 1.4; break;  // èè‰éŸ³ï¼šæé«˜éŸ³è°ƒ
            case 'uncle':   pitchRate = 0.7; break;  // å¤§å”éŸ³ï¼šé™ä½éŸ³è°ƒ
            case 'robot':   pitchRate = 1.0; break;  // æœºå™¨äººï¼šç‰¹æ®Šå¤„ç†
            default:        pitchRate = 1.0; break;
        }
        
        // åˆ›å»ºç¦»çº¿éŸ³é¢‘ä¸Šä¸‹æ–‡è¿›è¡Œå¤„ç†
        const offlineContext = new OfflineAudioContext(
            audioBuffer.numberOfChannels,
            Math.ceil(audioBuffer.length / pitchRate),
            audioBuffer.sampleRate
        );
        
        const source = offlineContext.createBufferSource();
        source.buffer = audioBuffer;
        source.playbackRate.value = pitchRate;
        
        // æœºå™¨äººæ•ˆæœï¼šæ·»åŠ æ³¢å½¢è°ƒåˆ¶
        if (effect === 'robot') {
            const oscillator = offlineContext.createOscillator();
            const gainNode = offlineContext.createGain();
            oscillator.frequency.value = 50;
            gainNode.gain.value = 0.3;
            oscillator.connect(gainNode);
            gainNode.connect(offlineContext.destination);
            oscillator.start();
        }
        
        source.connect(offlineContext.destination);
        source.start();
        
        const renderedBuffer = await offlineContext.startRendering();
        
        // å°†å¤„ç†åçš„éŸ³é¢‘è½¬ä¸º base64
        const wavBlob = await audioBufferToWavForOnlineGroup(renderedBuffer);
        const base64 = await blobToBase64ForOnlineGroup(wavBlob);
        
        // è®¡ç®—å®é™…æ—¶é•¿
        const actualDuration = Math.ceil(duration / pitchRate);
        
        // å‘é€è¯­éŸ³æ¶ˆæ¯åˆ°ç¾¤èŠ
        await sendOnlineGroupVoiceMessage(base64, actualDuration, effect);
        
        closeOnlineGroupVoiceModal();
        
    } catch (err) {
        console.error('è¯­éŸ³å¤„ç†å¤±è´¥:', err);
        alert('è¯­éŸ³å¤„ç†å¤±è´¥: ' + err.message);
    }
}

// AudioBuffer è½¬ WAVï¼ˆè”æœºç¾¤èŠï¼‰
function audioBufferToWavForOnlineGroup(buffer) {
    const numChannels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const format = 1; // PCM
    const bitDepth = 16;
    
    const bytesPerSample = bitDepth / 8;
    const blockAlign = numChannels * bytesPerSample;
    
    const data = [];
    for (let i = 0; i < buffer.length; i++) {
        for (let ch = 0; ch < numChannels; ch++) {
            const sample = buffer.getChannelData(ch)[i];
            const intSample = Math.max(-1, Math.min(1, sample));
            data.push(intSample < 0 ? intSample * 0x8000 : intSample * 0x7FFF);
        }
    }
    
    const dataLength = data.length * bytesPerSample;
    const headerLength = 44;
    const totalLength = headerLength + dataLength;
    
    const arrayBuffer = new ArrayBuffer(totalLength);
    const view = new DataView(arrayBuffer);
    
    // WAV header
    const writeString = (offset, string) => {
        for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    };
    
    writeString(0, 'RIFF');
    view.setUint32(4, totalLength - 8, true);
    writeString(8, 'WAVE');
    writeString(12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, format, true);
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * blockAlign, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, bitDepth, true);
    writeString(36, 'data');
    view.setUint32(40, dataLength, true);
    
    let offset = 44;
    for (let i = 0; i < data.length; i++, offset += 2) {
        view.setInt16(offset, data[i], true);
    }
    
    return new Blob([arrayBuffer], { type: 'audio/wav' });
}

// Blob è½¬ Base64ï¼ˆè”æœºç¾¤èŠï¼‰
function blobToBase64ForOnlineGroup(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    });
}

// å‘é€è”æœºç¾¤èŠè¯­éŸ³æ¶ˆæ¯
async function sendOnlineGroupVoiceMessage(audioBase64, duration, effect) {
    if (!currentOnlineGroupId) return;
    
    const myWx = getMyOnlineWxAccount();
    const myChar = onlineCharacters.find(c => c.wx_account === myWx);
    
    // æ„å»ºè¯­éŸ³æ¶ˆæ¯JSON
    const voiceMsg = JSON.stringify({
        __type: 'audio',
        audio: audioBase64,
        duration: duration,
        effect: effect
    });
    
    // å‘é€åˆ°æœåŠ¡å™¨
    onlineSocket.send(JSON.stringify({
        type: 'send_group_message',
        group_id: currentOnlineGroupId,
        my_wx_account: myWx,
        sender_type: 'user',
        sender_name: myChar?.nickname || myWx,
        content: voiceMsg
    }));
    
    console.log('[è”æœºç¾¤èŠ] è¯­éŸ³æ¶ˆæ¯å·²å‘é€ï¼Œæ—¶é•¿:', duration, 'ç§’ï¼Œæ•ˆæœ:', effect);
    showToast('è¯­éŸ³å·²å‘é€');
}

// è”æœºç¾¤èŠå‘é€å›¾ç‰‡
function onlineGroupSendImage() {
    closeOnlineGroupPanel();
    
    // åˆ›å»ºéšè—çš„æ–‡ä»¶è¾“å…¥
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        // è¯»å–å›¾ç‰‡å¹¶è½¬ä¸ºbase64
        const reader = new FileReader();
        reader.onload = async (event) => {
            const base64 = event.target.result;
            const imgContent = `[img:${base64}]`;
            
            // å‘é€å›¾ç‰‡æ¶ˆæ¯
            const myWx = getMyOnlineWxAccount();
            const myChar = onlineCharacters.find(c => c.wx_account === myWx);
            
            onlineSocket.send(JSON.stringify({
                type: 'send_group_message',
                group_id: currentOnlineGroupId,
                my_wx_account: myWx,
                sender_type: 'user',
                sender_name: myChar?.nickname || myWx,
                content: imgContent,
                msg_type: 'image'
            }));
            
            showToast('å›¾ç‰‡å·²å‘é€');
        };
        reader.readAsDataURL(file);
    };
    input.click();
}

// è”æœºç¾¤èŠè½¬è´¦ - æ˜¾ç¤ºç±»å‹é€‰æ‹©å¼¹çª—
function onlineGroupTransfer() {
    closeOnlineGroupPanel();
    
    const modal = document.createElement('div');
    modal.id = 'online-group-transfer-type-modal';
    modal.className = 'modal-overlay';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
    `;
    
    modal.innerHTML = `
        <div class="modal-box" style="max-width:300px; padding:0; overflow:hidden; border-radius:16px; background:#fff;">
            <div style="padding:20px 16px; text-align:center; border-bottom:0.5px solid #f0f0f0;">
                <div style="font-size:17px; font-weight:600; color:#333;">é€‰æ‹©ç±»å‹</div>
            </div>
            <div style="padding:16px;">
                <div onclick="showOnlineGroupRedPacket()" style="display:flex; align-items:center; padding:14px 16px; background:#fafafa; border-radius:12px; margin-bottom:12px; cursor:pointer; transition:all 0.2s; border:1px solid #f0f0f0;">
                    <div style="width:44px; height:44px; border-radius:12px; background:#fff; border:1px solid #eee; display:flex; align-items:center; justify-content:center; margin-right:14px;">
                        <svg viewBox="0 0 24 24" style="width:22px; height:22px; stroke:var(--ins-pink); fill:none; stroke-width:1.5;"><rect x="3" y="4" width="18" height="16" rx="2"/><path d="M3 10h18"/><circle cx="12" cy="15" r="2"/></svg>
                    </div>
                    <div style="flex:1;">
                        <div style="font-size:15px; font-weight:500; color:#333;">ç¾¤çº¢åŒ…</div>
                        <div style="font-size:12px; color:#999; margin-top:2px;">æ‹¼æ‰‹æ°”æˆ–æ™®é€šçº¢åŒ…</div>
                    </div>
                    <svg viewBox="0 0 24 24" style="width:18px; height:18px; stroke:#ccc; fill:none;"><polyline points="9 18 15 12 9 6"></polyline></svg>
                </div>
                <div onclick="showOnlineGroupExclusiveTransfer()" style="display:flex; align-items:center; padding:14px 16px; background:#fafafa; border-radius:12px; cursor:pointer; transition:all 0.2s; border:1px solid #f0f0f0;">
                    <div style="width:44px; height:44px; border-radius:12px; background:#fff; border:1px solid #eee; display:flex; align-items:center; justify-content:center; margin-right:14px;">
                        <svg viewBox="0 0 24 24" style="width:22px; height:22px; stroke:var(--ins-pink); fill:none; stroke-width:1.5;"><path d="M17 1l4 4-4 4"/><path d="M3 11V9a4 4 0 0 1 4-4h14"/><path d="M7 23l-4-4 4-4"/><path d="M21 13v2a4 4 0 0 1-4 4H3"/></svg>
                    </div>
                    <div style="flex:1;">
                        <div style="font-size:15px; font-weight:500; color:#333;">ä¸“å±è½¬è´¦</div>
                        <div style="font-size:12px; color:#999; margin-top:2px;">è½¬ç»™æŒ‡å®šç¾¤æˆå‘˜</div>
                    </div>
                    <svg viewBox="0 0 24 24" style="width:18px; height:18px; stroke:#ccc; fill:none;"><polyline points="9 18 15 12 9 6"></polyline></svg>
                </div>
            </div>
            <div onclick="document.getElementById('online-group-transfer-type-modal').remove()" style="padding:14px 16px; text-align:center; border-top:0.5px solid #f0f0f0; color:#999; font-size:15px; cursor:pointer;">å–æ¶ˆ</div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// æ˜¾ç¤ºè”æœºç¾¤èŠçº¢åŒ…é¡µé¢
function showOnlineGroupRedPacket() {
    document.getElementById('online-group-transfer-type-modal')?.remove();
    
    // åˆ›å»ºæˆ–æ˜¾ç¤ºçº¢åŒ…é¡µé¢
    let page = document.getElementById('online-group-redpacket-page');
    if (!page) {
        page = document.createElement('div');
        page.id = 'online-group-redpacket-page';
        page.className = 'transfer-modal';
        page.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:#fff; z-index:350; display:none; flex-direction:column;';
        document.body.appendChild(page);
    }
    
    page.innerHTML = `
        <div class="transfer-page-header" style="background:#fff; border-bottom:0.5px solid #f0f0f0;">
            <div class="back-btn" onclick="hideOnlineGroupRedPacketPage()" style="margin:0; background:none; width:40px; justify-content:flex-start; padding-left:0; color:#333;">
                <svg class="svg-icon" viewBox="0 0 24 24" style="width:28px; height:28px;"><polyline points="15 18 9 12 15 6"></polyline></svg>
            </div>
            <div class="transfer-page-title" style="color:#333;">å‘çº¢åŒ…</div>
            <div style="width:40px;"></div>
        </div>
        
        <div style="flex:1; background:#fff; padding:16px;">
            <!-- çº¢åŒ…ç±»å‹é€‰æ‹© -->
            <div style="background:#fff; border-radius:12px; padding:16px; margin-bottom:12px; border:1px solid #eee;">
                <div style="font-size:13px; color:#999; margin-bottom:12px;">çº¢åŒ…ç±»å‹</div>
                <div style="display:flex; gap:12px;">
                    <div id="online-rp-type-lucky" onclick="selectOnlineRedPacketType('lucky')" style="flex:1; padding:12px; border:1.5px solid #333; border-radius:10px; text-align:center; cursor:pointer; background:#fff;">
                        <div style="font-size:14px; font-weight:500; color:#333;">æ‹¼æ‰‹æ°”çº¢åŒ…</div>
                        <div style="font-size:11px; color:#999; margin-top:4px;">é‡‘é¢éšæœº</div>
                    </div>
                    <div id="online-rp-type-normal" onclick="selectOnlineRedPacketType('normal')" style="flex:1; padding:12px; border:1.5px solid #e8e8e8; border-radius:10px; text-align:center; cursor:pointer; background:#fff;">
                        <div style="font-size:14px; font-weight:500; color:#666;">æ™®é€šçº¢åŒ…</div>
                        <div style="font-size:11px; color:#999; margin-top:4px;">é‡‘é¢ç›¸åŒ</div>
                    </div>
                </div>
            </div>
            
            <!-- çº¢åŒ…é‡‘é¢ -->
            <div style="background:#fff; border-radius:12px; padding:16px; margin-bottom:12px; border:1px solid #eee;">
                <div style="display:flex; align-items:center; border-bottom:1px solid #f0f0f0; padding-bottom:14px; margin-bottom:14px;">
                    <div style="font-size:14px; color:#999; width:70px;">æ€»é‡‘é¢</div>
                    <div style="flex:1; display:flex; align-items:center;">
                        <span style="font-size:18px; color:#333; margin-right:4px;">Â¥</span>
                        <input type="number" id="online-rp-amount-input" placeholder="0.00" style="flex:1; border:none; font-size:22px; font-weight:500; outline:none; color:#333;" oninput="checkOnlineRedPacketInput()">
                    </div>
                </div>
                <div style="display:flex; align-items:center;">
                    <div style="font-size:14px; color:#999; width:70px;">çº¢åŒ…ä¸ªæ•°</div>
                    <div style="flex:1; display:flex; align-items:center;">
                        <input type="number" id="online-rp-count-input" placeholder="1" min="1" style="flex:1; border:none; font-size:16px; outline:none; color:#333;" oninput="checkOnlineRedPacketInput()">
                        <span style="font-size:13px; color:#999;">ä¸ª</span>
                    </div>
                </div>
            </div>
            
            <!-- ç¥ç¦è¯­ -->
            <div style="background:#fff; border-radius:12px; padding:14px 16px; margin-bottom:24px; border:1px solid #eee;">
                <input type="text" id="online-rp-wish-input" placeholder="ç¥ç¦è¯­ï¼ˆé€‰å¡«ï¼‰" maxlength="20" style="width:100%; border:none; font-size:14px; outline:none; box-sizing:border-box; color:#333;">
            </div>
            
            <!-- é‡‘é¢æç¤º -->
            <div style="text-align:center; margin-bottom:20px;">
                <span style="font-size:13px; color:#999;" id="online-rp-total-hint">å…±0.00å…ƒ</span>
            </div>
            
            <!-- å‘é€æŒ‰é’® -->
            <button id="btn-send-online-redpacket" onclick="sendOnlineGroupRedPacket()" disabled style="width:100%; padding:14px; background:#ccc; color:#fff; border:none; border-radius:24px; font-size:16px; font-weight:500; cursor:not-allowed; transition:all 0.2s;">
                å‘çº¢åŒ…
            </button>
        </div>
    `;
    
    // é‡ç½®è¾“å…¥
    document.getElementById('online-rp-amount-input').value = '';
    document.getElementById('online-rp-count-input').value = '';
    document.getElementById('online-rp-wish-input').value = '';
    document.getElementById('online-rp-total-hint').innerText = 'å…±0.00å…ƒ';
    document.getElementById('btn-send-online-redpacket').disabled = true;
    document.getElementById('btn-send-online-redpacket').style.background = '#ccc';
    document.getElementById('btn-send-online-redpacket').style.cursor = 'not-allowed';
    
    // é»˜è®¤é€‰ä¸­æ‹¼æ‰‹æ°”
    selectOnlineRedPacketType('lucky');
    
    page.style.display = 'flex';
}

// éšè—è”æœºç¾¤èŠçº¢åŒ…é¡µé¢
function hideOnlineGroupRedPacketPage() {
    const page = document.getElementById('online-group-redpacket-page');
    if (page) page.style.display = 'none';
}

// è”æœºç¾¤èŠçº¢åŒ…ç±»å‹
let currentOnlineRedPacketType = 'lucky';

// é€‰æ‹©è”æœºç¾¤èŠçº¢åŒ…ç±»å‹
function selectOnlineRedPacketType(type) {
    currentOnlineRedPacketType = type;
    
    const luckyEl = document.getElementById('online-rp-type-lucky');
    const normalEl = document.getElementById('online-rp-type-normal');
    
    if (!luckyEl || !normalEl) return;
    
    if (type === 'lucky') {
        luckyEl.style.borderColor = '#333';
        luckyEl.style.background = '#fff';
        luckyEl.querySelector('div:first-child').style.color = '#333';
        
        normalEl.style.borderColor = '#e8e8e8';
        normalEl.style.background = '#fff';
        normalEl.querySelector('div:first-child').style.color = '#666';
    } else {
        normalEl.style.borderColor = '#333';
        normalEl.style.background = '#fff';
        normalEl.querySelector('div:first-child').style.color = '#333';
        
        luckyEl.style.borderColor = '#e8e8e8';
        luckyEl.style.background = '#fff';
        luckyEl.querySelector('div:first-child').style.color = '#666';
    }
}

// æ£€æŸ¥è”æœºç¾¤èŠçº¢åŒ…è¾“å…¥
function checkOnlineRedPacketInput() {
    const amount = parseFloat(document.getElementById('online-rp-amount-input')?.value || 0);
    const count = parseInt(document.getElementById('online-rp-count-input')?.value || 0);
    const btn = document.getElementById('btn-send-online-redpacket');
    const hint = document.getElementById('online-rp-total-hint');
    
    if (!btn || !hint) return;
    
    if (amount > 0 && count > 0) {
        hint.innerText = `å…±${amount.toFixed(2)}å…ƒ`;
        btn.disabled = false;
        btn.style.background = '#333';
        btn.style.cursor = 'pointer';
    } else {
        hint.innerText = 'å…±0.00å…ƒ';
        btn.disabled = true;
        btn.style.background = '#ccc';
        btn.style.cursor = 'not-allowed';
    }
}

// å‘é€è”æœºç¾¤èŠçº¢åŒ…
async function sendOnlineGroupRedPacket() {
    if (!currentOnlineGroupId) return;
    
    const amount = parseFloat(document.getElementById('online-rp-amount-input')?.value);
    const count = parseInt(document.getElementById('online-rp-count-input')?.value);
    const wish = document.getElementById('online-rp-wish-input')?.value.trim() || 'æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©';
    
    if (!amount || amount <= 0 || !count || count <= 0) {
        showToast('è¯·å¡«å†™æ­£ç¡®çš„é‡‘é¢å’Œä¸ªæ•°');
        return;
    }
    
    // æ£€æŸ¥ä½™é¢
    if (!currentMyCharId) {
        showToast("è¯·å…ˆè®¾ç½®Userèº«ä»½");
        return;
    }
    const user = await db.characters.get(parseInt(currentMyCharId));
    let currentBalance = 0;
    if (user && user.identity && user.identity.balance) {
        currentBalance = parseFloat(user.identity.balance.toString().replace(/,/g, ''));
    }
    
    if (currentBalance < amount) {
        showToast('ä½™é¢ä¸è¶³ (å½“å‰: Â¥' + currentBalance.toFixed(2) + ')');
        return;
    }
    
    // æ‰£æ¬¾
    const newBalance = currentBalance - amount;
    user.identity.balance = newBalance.toFixed(2);
    await safeCharacterPut(user);
    
    // æ„å»ºçº¢åŒ…æ•°æ®
    const redPacketData = {
        type: 'redpacket',
        redpacketType: currentOnlineRedPacketType, // 'lucky' æˆ– 'normal'
        totalAmount: amount.toFixed(2),
        count: count,
        wish: wish,
        claimed: [], // å·²é¢†å–çš„æˆå‘˜å¾®ä¿¡å·åˆ—è¡¨
        claimedAmounts: {}, // æ¯ä¸ªæˆå‘˜é¢†å–çš„é‡‘é¢ {wx_account: amount}
        id: 'rp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9)
    };
    
    // å‘é€åˆ°æœåŠ¡å™¨
    const myWx = getMyOnlineWxAccount();
    const myChar = onlineCharacters.find(c => c.wx_account === myWx);
    
    onlineSocket.send(JSON.stringify({
        type: 'send_group_message',
        group_id: currentOnlineGroupId,
        my_wx_account: myWx,
        sender_type: 'user',
        sender_name: myChar?.nickname || myWx,
        content: JSON.stringify(redPacketData),
        msg_type: 'redpacket'
    }));
    
    // è®°å½•è´¦å•
    await addTransaction('expense', amount, 'å‘çº¢åŒ…', `è”æœºç¾¤èŠ Â· ${count}ä¸ªçº¢åŒ…`);
    
    hideOnlineGroupRedPacketPage();
    showToast('çº¢åŒ…å·²å‘å‡º');
}

// æ˜¾ç¤ºè”æœºç¾¤èŠçº¢åŒ…è¯¦æƒ…
function showOnlineGroupRedPacketDetail(msgId) {
    // åœ¨æ¶ˆæ¯åˆ—è¡¨ä¸­æ‰¾åˆ°çº¢åŒ…æ¶ˆæ¯
    const msg = currentOnlineGroupMessages.find(m => {
        if (m.msg_type !== 'redpacket') return false;
        return (m.id || ('rp_' + m.created_at)) === msgId;
    });
    
    if (!msg) {
        showToast('çº¢åŒ…ä¸å­˜åœ¨');
        return;
    }
    
    try {
        const data = JSON.parse(msg.content);
        const myWx = getMyOnlineWxAccount();
        const hasClaimed = data.claimed?.includes(myWx) || false;
        const claimedCount = (data.claimed || []).length;
        const isAllClaimed = claimedCount >= data.count;
        
        // åˆ›å»ºæˆ–æ˜¾ç¤ºçº¢åŒ…è¯¦æƒ…é¡µé¢
        let page = document.getElementById('online-group-redpacket-detail-page');
        if (!page) {
            page = document.createElement('div');
            page.id = 'online-group-redpacket-detail-page';
            page.className = 'transfer-modal';
            page.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:#fff; z-index:360; display:none; flex-direction:column;';
            document.body.appendChild(page);
        }
        
        page.innerHTML = `
            <div class="transfer-page-header" style="background:#fff; border-bottom:0.5px solid #f0f0f0;">
                <div class="back-btn" onclick="hideOnlineGroupRedPacketDetail()" style="margin:0; background:none; width:40px; justify-content:flex-start; padding-left:0; color:#333;">
                    <svg class="svg-icon" viewBox="0 0 24 24" style="width:28px; height:28px;"><polyline points="15 18 9 12 15 6"></polyline></svg>
                </div>
                <div class="transfer-page-title" style="color:#333;">çº¢åŒ…è¯¦æƒ…</div>
                <div style="width:40px;"></div>
            </div>
            
            <div style="flex:1; background:#fff; overflow-y:auto;">
                <!-- çº¢åŒ…ä¿¡æ¯å¤´éƒ¨ -->
                <div style="padding:30px 20px; text-align:center; border-bottom:1px solid #f0f0f0;">
                    <div id="online-rp-detail-avatar" style="width:60px; height:60px; border-radius:50%; background:#eee; margin:0 auto 12px; background-size:cover; background-position:center;"></div>
                    <div id="online-rp-detail-sender" style="font-size:15px; color:#333; margin-bottom:8px;">${msg.sender_name} çš„çº¢åŒ…</div>
                    <div id="online-rp-detail-wish" style="font-size:18px; font-weight:500; color:#333; margin-bottom:6px;">${escapeHtml(data.wish || 'æ­å–œå‘è´¢')}</div>
                    <div id="online-rp-detail-type" style="font-size:13px; color:#999;">${data.redpacketType === 'lucky' ? 'æ‹¼æ‰‹æ°”çº¢åŒ…' : 'æ™®é€šçº¢åŒ…'}</div>
                </div>
                
                <!-- é¢†å–æŒ‰é’®åŒºåŸŸ -->
                <div id="online-rp-detail-action" style="padding:20px; border-bottom:1px solid #f0f0f0;">
                    <button id="btn-claim-online-redpacket" onclick="claimOnlineGroupRedPacket('${msgId}', '${myWx}', null)" style="width:100%; padding:14px; background:${isAllClaimed || hasClaimed ? '#ccc' : '#333'}; color:#fff; border:none; border-radius:24px; font-size:16px; font-weight:500; cursor:${isAllClaimed || hasClaimed ? 'not-allowed' : 'pointer'};" ${isAllClaimed || hasClaimed ? 'disabled' : ''}>
                        ${isAllClaimed ? 'çº¢åŒ…å·²é¢†å®Œ' : hasClaimed ? `å·²é¢†å– Â¥${(data.claimedAmounts?.[myWx] || '0.00')}` : 'é¢†å–çº¢åŒ…'}
                    </button>
                </div>
                
                <!-- å·²é¢†å–åˆ—è¡¨ -->
                <div style="padding:16px 20px;">
                    <div style="font-size:13px; color:#999; margin-bottom:12px;">
                        <span id="online-rp-detail-claimed-count">${claimedCount}</span>/<span id="online-rp-detail-total-count">${data.count}</span> å·²é¢†å–ï¼Œå…± <span id="online-rp-detail-total-amount">${Object.values(data.claimedAmounts || {}).reduce((a, b) => a + parseFloat(b), 0).toFixed(2)}</span> å…ƒ
                    </div>
                    <div id="online-rp-detail-claimed-list">
                        ${data.claimed && data.claimed.length > 0 ? 
                            data.claimed.map(wx => {
                                const member = currentOnlineGroupMembers.find(m => m.user_wx === wx);
                                const amount = data.claimedAmounts?.[wx] || '0.00';
                                return `
                                    <div style="display:flex; align-items:center; padding:12px 0; border-bottom:1px solid #f0f0f0;">
                                        <div style="width:40px; height:40px; border-radius:50%; background:#eee; background-image:url(${member?.user_avatar || ''}); background-size:cover; background-position:center; margin-right:12px; flex-shrink:0;"></div>
                                        <div style="flex:1;">
                                            <div style="font-size:14px; color:#333;">${member?.user_name || wx}</div>
                                        </div>
                                        <div style="font-size:15px; font-weight:500; color:#333;">Â¥${amount}</div>
                                    </div>
                                `;
                            }).join('') : 
                            '<div style="text-align:center; color:#999; padding:30px 0; font-size:13px;">æš‚æ— äººé¢†å–</div>'
                        }
                    </div>
                </div>
            </div>
        `;
        
        // è®¾ç½®å‘é€è€…å¤´åƒ
        const avatarEl = document.getElementById('online-rp-detail-avatar');
        if (msg.sender_avatar) {
            avatarEl.style.backgroundImage = `url(${msg.sender_avatar})`;
        }
        
        page.style.display = 'flex';
    } catch(e) {
        console.error('æ˜¾ç¤ºçº¢åŒ…è¯¦æƒ…å¤±è´¥:', e);
        showToast('çº¢åŒ…æ•°æ®é”™è¯¯');
    }
}

// éšè—è”æœºç¾¤èŠçº¢åŒ…è¯¦æƒ…
function hideOnlineGroupRedPacketDetail() {
    const page = document.getElementById('online-group-redpacket-detail-page');
    if (page) page.style.display = 'none';
}

// é¢†å–è”æœºç¾¤èŠçº¢åŒ…ï¼ˆç”¨æˆ·æˆ–è§’è‰²éƒ½å¯ä»¥ï¼‰
async function claimOnlineGroupRedPacket(msgId, claimerWx, characterName) {
    if (!currentOnlineGroupId || !onlineSocket || onlineSocket.readyState !== WebSocket.OPEN) {
        showToast('æœªè¿æ¥åˆ°æœåŠ¡å™¨');
        return;
    }
    
    const myWx = getMyOnlineWxAccount();
    const claimerName = characterName || (onlineCharacters.find(c => c.wx_account === myWx)?.nickname || myWx);
    
    // å‘é€é¢†å–è¯·æ±‚åˆ°æœåŠ¡å™¨
    onlineSocket.send(JSON.stringify({
        type: 'claim_group_redpacket',
        group_id: currentOnlineGroupId,
        my_wx_account: myWx,
        message_id: msgId,
        claimer_name: claimerName
    }));
}

// å¤„ç†çº¢åŒ…è¢«é¢†å–çš„é€šçŸ¥
async function handleRedPacketClaimed(data) {
    const { group_id, message_id, claimer_wx, claim_amount, redpacket_data } = data;
    
    if (group_id !== currentOnlineGroupId) return;
    
    // æ›´æ–°æœ¬åœ°æ¶ˆæ¯ä¸­çš„çº¢åŒ…æ•°æ®
    const msgIndex = currentOnlineGroupMessages.findIndex(m => m.id === message_id);
    if (msgIndex !== -1) {
        currentOnlineGroupMessages[msgIndex].content = JSON.stringify(redpacket_data);
        renderOnlineGroupMessages();
    }
    
    // å¦‚æœæ˜¯è‡ªå·±é¢†å–çš„ï¼Œæ›´æ–°é’±åŒ…
    const myWx = getMyOnlineWxAccount();
    if (claimer_wx === myWx) {
        const claimAmountNum = parseFloat(claim_amount);
        
        if (!currentMyCharId) {
            showToast(`æˆåŠŸé¢†å– Â¥${claim_amount}`);
            return;
        }
        
        const user = await db.characters.get(parseInt(currentMyCharId));
        if (user) {
            if (!user.identity) user.identity = {};
            let balance = parseFloat(user.identity.balance || 0);
            balance += claimAmountNum;
            user.identity.balance = balance.toFixed(2);
            await safeCharacterPut(user);
            
            // è®°å½•è´¦å•
            const group = onlineGroups.find(g => g.id === currentOnlineGroupId);
            await addTransaction('income', claimAmountNum, 'çº¢åŒ…', group?.name || 'è”æœºç¾¤èŠ');
            
            showToast(`æˆåŠŸé¢†å– Â¥${claim_amount}`);
        }
    }
    
    // åˆ·æ–°çº¢åŒ…è¯¦æƒ…é¡µé¢ï¼ˆå¦‚æœå·²æ‰“å¼€ï¼‰
    const detailPage = document.getElementById('online-group-redpacket-detail-page');
    if (detailPage && detailPage.style.display !== 'none') {
        showOnlineGroupRedPacketDetail(message_id);
    }
}

// æ˜¾ç¤ºè”æœºç¾¤èŠä¸“å±è½¬è´¦é€‰äººé¡µé¢
async function showOnlineGroupExclusiveTransfer() {
    document.getElementById('online-group-transfer-type-modal')?.remove();
    
    const listHtml = currentOnlineGroupMembers.map(m => {
        const avatarStyle = m.user_avatar ? `background-image:url(${m.user_avatar})` : 'background:#ccc';
        const myWx = getMyOnlineWxAccount();
        if (m.user_wx === myWx) return ''; // ä¸æ˜¾ç¤ºè‡ªå·±
        
        return `
            <div onclick="selectOnlineGroupTransferTarget('${m.user_wx}', '${m.user_name}')" style="display:flex; align-items:center; padding:12px 16px; cursor:pointer; transition:background 0.2s; border-bottom:0.5px solid #f0f0f0;">
                <div style="width:44px; height:44px; border-radius:6px; ${avatarStyle}; background-size:cover; background-position:center; margin-right:12px;"></div>
                <div style="flex:1;">
                    <div style="font-size:16px; color:#333;">${m.user_name}</div>
                    ${m.character_name ? `<div style="font-size:12px; color:#999;">${m.character_name}</div>` : ''}
                </div>
            </div>
        `;
    }).filter(h => h).join('');
    
    const modal = document.createElement('div');
    modal.id = 'online-group-exclusive-modal';
    modal.className = 'modal-overlay';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
    `;
    
    modal.innerHTML = `
        <div style="background:#fff; border-radius:16px; width:85%; max-width:400px; max-height:70%; overflow:hidden; display:flex; flex-direction:column;">
            <div style="padding:20px 16px; text-align:center; border-bottom:0.5px solid #f0f0f0;">
                <div style="font-size:17px; font-weight:600; color:#333;">é€‰æ‹©è½¬è´¦å¯¹è±¡</div>
            </div>
            <div style="flex:1; overflow-y:auto;">
                ${listHtml || '<div style="text-align:center; color:#999; padding:40px;">ç¾¤å†…æš‚æ— å…¶ä»–æˆå‘˜</div>'}
            </div>
            <div onclick="document.getElementById('online-group-exclusive-modal').remove()" style="padding:14px 16px; text-align:center; border-top:0.5px solid #f0f0f0; color:#999; font-size:15px; cursor:pointer;">å–æ¶ˆ</div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// é€‰æ‹©è”æœºç¾¤èŠè½¬è´¦ç›®æ ‡
function selectOnlineGroupTransferTarget(targetWx, targetName) {
    document.getElementById('online-group-exclusive-modal')?.remove();
    
    const modal = document.createElement('div');
    modal.id = 'online-group-transfer-amount-modal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
    `;
    
    modal.innerHTML = `
        <div style="background:#fff; border-radius:16px; padding:24px; width:85%; max-width:360px;">
            <h3 style="margin:0 0 16px 0; text-align:center; font-size:18px;">è½¬è´¦ç»™ ${targetName}</h3>
            
            <div style="margin-bottom:16px;">
                <label style="display:block; font-size:13px; color:#666; margin-bottom:8px;">è½¬è´¦é‡‘é¢</label>
                <input type="number" id="online-group-transfer-amount" placeholder="è¾“å…¥é‡‘é¢" style="width:100%; padding:12px; border:1px solid #ddd; border-radius:8px; font-size:14px;">
            </div>
            
            <div style="margin-bottom:20px;">
                <label style="display:block; font-size:13px; color:#666; margin-bottom:8px;">è½¬è´¦è¯´æ˜</label>
                <input type="text" id="online-group-transfer-note" placeholder="æ·»åŠ è½¬è´¦è¯´æ˜" style="width:100%; padding:12px; border:1px solid #ddd; border-radius:8px; font-size:14px;">
            </div>
            
            <div style="display:flex; gap:12px;">
                <button onclick="document.getElementById('online-group-transfer-amount-modal').remove()" style="flex:1; padding:12px; background:#f0f0f0; color:#666; border:none; border-radius:8px; font-size:15px;">å–æ¶ˆ</button>
                <button onclick="sendOnlineGroupExclusiveTransfer('${targetWx}', '${targetName}')" style="flex:1; padding:12px; background:var(--ins-pink); color:#fff; border:none; border-radius:8px; font-size:15px;">è½¬è´¦</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// å‘é€è”æœºç¾¤èŠä¸“å±è½¬è´¦
function sendOnlineGroupExclusiveTransfer(targetWx, targetName) {
    const amount = document.getElementById('online-group-transfer-amount').value.trim();
    const note = document.getElementById('online-group-transfer-note').value.trim();
    
    if (!amount || parseFloat(amount) <= 0) {
        alert('è¯·è¾“å…¥æœ‰æ•ˆçš„é‡‘é¢');
        return;
    }
    
    const myWx = getMyOnlineWxAccount();
    const myChar = onlineCharacters.find(c => c.wx_account === myWx);
    
    // ä½¿ç”¨å’Œæ™®é€šç¾¤èŠä¸€æ ·çš„JSONæ ¼å¼
    const transferData = {
        amount: parseFloat(amount),
        desc: note || 'è½¬è´¦',
        status: 'pending',
        targetWx: targetWx,
        targetName: targetName
    };
    
    onlineSocket.send(JSON.stringify({
        type: 'send_group_message',
        group_id: currentOnlineGroupId,
        my_wx_account: myWx,
        sender_type: 'user',
        sender_name: myChar?.nickname || myWx,
        content: JSON.stringify(transferData),
        msg_type: 'transfer'
    }));
    
    document.getElementById('online-group-transfer-amount-modal')?.remove();
    showToast('è½¬è´¦å·²å‘é€');
}

// åˆ·æ–°ç¾¤æˆå‘˜åˆ—è¡¨
function refreshOnlineGroupMembers() {
    const myWx = getMyOnlineWxAccount();
    if (myWx && currentOnlineGroupId) {
        onlineSocket.send(JSON.stringify({
            type: 'get_group_members',
            group_id: currentOnlineGroupId,
            my_wx_account: myWx
        }));
    }
}

// å‘é€ç¾¤æ¶ˆæ¯
function sendOnlineGroupMsg() {
    const input = document.getElementById('online-group-input');
    const content = input.value.trim();
    if (!content || !currentOnlineGroupId) return;
    
    const myWx = getMyOnlineWxAccount();
    const myChar = onlineCharacters.find(c => c.wx_account === myWx);
    
    onlineSocket.send(JSON.stringify({
        type: 'send_group_message',
        group_id: currentOnlineGroupId,
        my_wx_account: myWx,
        sender_type: 'user',
        sender_name: myChar?.nickname || myWx,
        content: content
    }));
    
    input.value = '';
    // è§¦å‘inputäº‹ä»¶ä»¥æ›´æ–°å‘é€æŒ‰é’®çŠ¶æ€
    input.dispatchEvent(new Event('input'));
    // å…³é—­é¢æ¿
    closeOnlineGroupPanel();
}

// è®©æˆ‘çš„è§’è‰²è¯´è¯ï¼ˆè°ƒç”¨APIï¼‰
async function letMyCharacterSpeak() {
    console.log('[è”æœºç¾¤èŠ] âš¡ è§¦å‘ AI å›å¤');
    
    if (!myOnlineGroupCharacter) {
        alert('ä½ æ²¡æœ‰åœ¨è¿™ä¸ªç¾¤èŠä¸­è®¾ç½®è§’è‰²ã€‚è¯·åœ¨ç¾¤èŠè®¾ç½®ä¸­é€‰æ‹©è¦å¸¦å…¥çš„è§’è‰²ã€‚');
        return;
    }
    
    if (currentOnlineGroupMessages.length === 0) {
        alert('ç¾¤èŠä¸­è¿˜æ²¡æœ‰æ¶ˆæ¯ï¼Œè§’è‰²æ— æ³•å›å¤');
        return;
    }
    
    const myWx = getMyOnlineWxAccount();
    const myUserName = onlineCharacters.find(c => c.wx_account === myWx)?.nickname || myWx;
    
    console.log('[è”æœºç¾¤èŠ] è§’è‰²åç§°:', myOnlineGroupCharacter.name);
    console.log('[è”æœºç¾¤èŠ] æˆ‘çš„å¾®ä¿¡å·:', myWx);
    console.log('[è”æœºç¾¤èŠ] æˆ‘çš„æ˜µç§°:', myUserName);
    console.log('[è”æœºç¾¤èŠ] ğŸ“š ç¾¤èŠæ¶ˆæ¯æ¡æ•°:', currentOnlineGroupMessages.length);
    console.log('[è”æœºç¾¤èŠ] ğŸ‘¥ ç¾¤æˆå‘˜æ•°é‡:', currentOnlineGroupMembers.length);
    
    // æ‰“å°æœ€è¿‘çš„æ¶ˆæ¯
    if (currentOnlineGroupMessages.length > 0) {
        console.log('[è”æœºç¾¤èŠ] æœ€è¿‘5æ¡æ¶ˆæ¯:');
        currentOnlineGroupMessages.slice(-5).forEach((msg, idx) => {
            const isChar = msg.sender_type === 'character';
            const prefix = isChar ? `[è§’è‰²]${msg.character_name}(${msg.sender_name})` : `[çœŸäºº]${msg.sender_name}`;
            console.log(`  [${currentOnlineGroupMessages.length - 5 + idx}] ${prefix}: ${msg.content}`);
        });
    }
    
    // ä¿®æ”¹æ ‡é¢˜ä¸ºæ­£åœ¨è¾“å…¥
    const chatTitleEl = document.getElementById('online-group-chat-title');
    const group = onlineGroups.find(g => g.id === currentOnlineGroupId);
    const originalTitle = group?.name || 'è”æœºç¾¤èŠ';
    
    if (chatTitleEl) {
        chatTitleEl.innerText = `${myOnlineGroupCharacter.name} æ­£åœ¨è¾“å…¥ä¸­...`;
        console.log('[è”æœºç¾¤èŠ] ä¿®æ”¹æ ‡é¢˜ä¸º:', `${myOnlineGroupCharacter.name} æ­£åœ¨è¾“å…¥ä¸­...`);
    }
    
    // é€šçŸ¥ç¾¤é‡Œå…¶ä»–äººï¼šæˆ‘çš„è§’è‰²æ­£åœ¨è¾“å…¥
    onlineSocket.send(JSON.stringify({
        type: 'group_typing_start',
        group_id: currentOnlineGroupId,
        my_wx_account: myWx,
        character_name: myOnlineGroupCharacter.name
    }));
    
    showToast('æ­£åœ¨ç”Ÿæˆå›å¤...');
    
    try {
        // æ„å»ºç¾¤æˆå‘˜ä¿¡æ¯ï¼ˆåªæœ‰åå­—ï¼Œæ²¡æœ‰äººè®¾ï¼‰
        let membersInfo = 'ç¾¤èŠæˆå‘˜ï¼š\n';
        currentOnlineGroupMembers.forEach(m => {
            if (m.character_name) {
                membersInfo += `- ${m.user_name}ï¼ˆå¸¦ç€è§’è‰²"${m.character_name}"ï¼‰\n`;
            } else {
                membersInfo += `- ${m.user_name}\n`;
            }
        });
        console.log('[è”æœºç¾¤èŠ] ç¾¤æˆå‘˜ä¿¡æ¯:\n', membersInfo);
        
        // æ”¶é›†æœªé¢†å®Œçš„çº¢åŒ…ä¿¡æ¯
        let pendingRedPackets = [];
        currentOnlineGroupMessages.forEach(msg => {
            if (msg.msg_type === 'redpacket') {
                try {
                    const rpData = JSON.parse(msg.content);
                    const claimedCount = (rpData.claimed || []).length;
                    const isAllClaimed = claimedCount >= rpData.count;
                    const myWx = getMyOnlineWxAccount();
                    const hasClaimed = rpData.claimed?.includes(myWx) || false;
                    
                    if (!isAllClaimed && !hasClaimed) {
                        pendingRedPackets.push({
                            id: msg.id || ('rp_' + msg.created_at),
                            wish: rpData.wish || 'æ­å–œå‘è´¢',
                            remaining: rpData.count - claimedCount,
                            claimed: rpData.claimed || []
                        });
                    }
                } catch(e) {}
            }
        });
        
        // æ„å»ºä¸Šä¸‹æ–‡
        const context = currentOnlineGroupMessages.map(msg => {
            const isChar = msg.sender_type === 'character';
            if (msg.msg_type === 'redpacket') {
                try {
                    const rpData = JSON.parse(msg.content);
                    const claimedCount = (rpData.claimed || []).length;
                    const isAllClaimed = claimedCount >= rpData.count;
                    return `[${msg.sender_name}]: [å‘é€äº†çº¢åŒ…] "${rpData.wish || 'æ­å–œå‘è´¢'}" (çº¢åŒ…ID: ${msg.id || ('rp_' + msg.created_at)}, ${isAllClaimed ? 'å·²é¢†å®Œ' : `è¿˜å‰©${rpData.count - claimedCount}ä¸ªå¯é¢†`})`;
                } catch(e) {
                    return `[${msg.sender_name}]: [å‘é€äº†çº¢åŒ…]`;
                }
            } else if (isChar) {
                // è§’è‰²æ¶ˆæ¯ï¼šæ˜¾ç¤ºè§’è‰²åå’Œä¸»äººå
                return `[${msg.character_name}ï¼ˆ${msg.sender_name}çš„è§’è‰²ï¼‰]: ${msg.content}`;
            } else {
                // çœŸäººæ¶ˆæ¯
                return `[${msg.sender_name}]: ${msg.content}`;
            }
        }).join('\n');
        console.log('[è”æœºç¾¤èŠ] ä¸Šä¸‹æ–‡æ¶ˆæ¯ï¼ˆå‰300å­—ï¼‰:', context.substring(0, 300));
        
        // æ„å»ºæç¤ºè¯
        const systemPrompt = `ä½ æ˜¯"${myOnlineGroupCharacter.name}"ï¼Œæ˜¯"${myUserName}"å¸¦å…¥ç¾¤èŠçš„AIè§’è‰²ã€‚
âš ï¸ é‡è¦ï¼šä½ çš„åå­—æ˜¯${myOnlineGroupCharacter.name}ï¼Œä½ ä¸æ˜¯${myUserName}æˆ–å…¶ä»–ç¾¤æˆå‘˜ï¼ä½ æ˜¯ç‹¬ç«‹çš„è§’è‰²ã€‚

ã€ä½ çš„äººè®¾ã€‘
${myOnlineGroupCharacter.desc || 'ï¼ˆæ— ç‰¹å®šäººè®¾ï¼‰'}

ã€${membersInfo}ã€‘

${pendingRedPackets.length > 0 ? `
ğŸ§§ ç¾¤é‡Œæœ‰æœªé¢†å®Œçš„çº¢åŒ…ï¼
${pendingRedPackets.map(rp => `- çº¢åŒ…ID: ${rp.id}, ç¥ç¦è¯­: "${rp.wish}", è¿˜å‰© ${rp.remaining} ä¸ªå¯é¢†`).join('\n')}
æç¤ºï¼šçœ‹åˆ°çº¢åŒ…æ—¶ï¼Œä½ å¯ä»¥ç§¯æå»æŠ¢ï¼ä½¿ç”¨ {"type": "claim_redpacket", "redpacketId": "çº¢åŒ…ID"} æ¥é¢†å–çº¢åŒ…ã€‚
` : ''}

ã€é‡è¦å›å¤è§„åˆ™ - å¿…é¡»ä¸¥æ ¼éµå®ˆã€‘
1. **å¿…é¡»**æ¨¡æ‹Ÿå¾®ä¿¡è¿å‘æ¶ˆæ¯çš„ä¹ æƒ¯ï¼šè¯·ç”Ÿæˆ ${myOnlineGroupCharacter.reply_min_count || 1} åˆ° ${myOnlineGroupCharacter.reply_max_count || 3} æ¡çŸ­æ¶ˆæ¯${(myOnlineGroupCharacter.reply_min_count || 1) === 1 ? '' : 'ï¼Œä¸èƒ½åªå‘ä¸€æ¡'}ï¼
2. **å¿…é¡»**ä½¿ç”¨åˆ†éš”ç¬¦ "|||" æ¥éš”å¼€æ¯ä¸€æ¡æ¶ˆæ¯ã€‚
3. **ä¸¥ç¦ä½¿ç”¨é€—å·**ï¼ˆåŒ…æ‹¬ä¸­æ–‡é€—å·å’Œè‹±æ–‡é€—å·ï¼‰ã€‚å¦‚æœæƒ³è¡¨è¾¾åœé¡¿ï¼Œè¯·ç›´æ¥æ‹†åˆ†æˆä¸‹ä¸€æ¡æ¶ˆæ¯ï¼Œæˆ–è€…ç”¨ç©ºæ ¼ä»£æ›¿ã€‚
   - é”™è¯¯ç¤ºä¾‹ï¼šå˜¿åœ¨å—ï¼Ÿåˆšåˆšçœ‹åˆ°ä¸ªå¥½ç©çš„è§†é¢‘ï¼Œå‘ç»™ä½ çœ‹çœ‹
   - æ­£ç¡®ç¤ºä¾‹ï¼šå˜¿åœ¨å—ï¼Ÿ|||åˆšåˆšçœ‹åˆ°ä¸ªå¥½ç©çš„è§†é¢‘|||å‘ç»™ä½ çœ‹çœ‹
4. åƒçœŸå®å¾®ä¿¡èŠå¤©ä¸€æ ·åˆ†å¤šæ¡å‘é€ã€‚
5. ä¸¥ç¦åªå‘é€æ ‡ç‚¹ç¬¦å·ã€‚æ¯ä¸€æ¡æ¶ˆæ¯éƒ½å¿…é¡»æœ‰å®é™…æ–‡å­—å†…å®¹ã€‚
6. è¯­æ°”è¦è‡ªç„¶ã€å£è¯­åŒ–ï¼Œç¬¦åˆäººè®¾ã€‚
7. ä½ åªçŸ¥é“å…¶ä»–æˆå‘˜å’Œè§’è‰²çš„åå­—ï¼Œä¸çŸ¥é“ä»–ä»¬è§’è‰²çš„å…·ä½“äººè®¾
8. è¯·æ ¹æ®ç¾¤èŠä¸Šä¸‹æ–‡ï¼Œä»¥"${myOnlineGroupCharacter.name}"çš„èº«ä»½è‡ªç„¶åœ°å‚ä¸å¯¹è¯
9. åªå›å¤ä½ è¦è¯´çš„å†…å®¹ï¼Œä¸è¦åŠ ä»»ä½•å‰ç¼€å¦‚"${myOnlineGroupCharacter.name}:"
10. å›å¤è¦ç¬¦åˆä½ çš„äººè®¾æ€§æ ¼
11. **é¢†å–çº¢åŒ…**ï¼šå¦‚æœç¾¤èŠä¸­æœ‰çº¢åŒ…æ¶ˆæ¯ï¼ˆmsg_typeä¸º'redpacket'ï¼‰ï¼Œä½ å¯ä»¥ç§¯æå»é¢†å–ï¼ä½¿ç”¨ {"type": "claim_redpacket", "redpacketId": "çº¢åŒ…ID"} æ¥é¢†å–çº¢åŒ…ã€‚çº¢åŒ…ä¼šè®°å…¥ä½ ä¸»äººçš„é’±åŒ…ä½™é¢ã€‚
12. **å‘é€çº¢åŒ…**ï¼šä½ å¯ä»¥åœ¨é€‚å½“çš„åœºåˆå‘çº¢åŒ…ï¼ˆæ¯”å¦‚ï¼šè¿‡èŠ‚ã€ç”Ÿæ—¥ã€è¡¨è¾¾æ„Ÿè°¢ã€æ´»è·ƒæ°”æ°›ã€ç©æ¢—ç­‰ï¼‰ï¼Œä½¿ç”¨ {"type": "send_redpacket", "redpacketType": "çº¢åŒ…ç±»å‹", "totalAmount": æ€»é‡‘é¢, "count": çº¢åŒ…ä¸ªæ•°, "wish": "ç¥ç¦è¯­"} æ¥å‘é€çº¢åŒ…ã€‚è§’è‰²å‘çº¢åŒ…ä¸ä¼šæ‰£é™¤ä»»ä½•äººçš„ä½™é¢ï¼Œå¯ä»¥è‡ªç”±å‘é€ï¼
   - redpacketTypeå¯é€‰å€¼: "lucky"(æ‹¼æ‰‹æ°”çº¢åŒ…), "normal"(æ™®é€šçº¢åŒ…)
   - æ‹¼æ‰‹æ°”çº¢åŒ…ï¼šæ¯ä¸ªäººé¢†åˆ°çš„é‡‘é¢éšæœºï¼Œå¢åŠ è¶£å‘³æ€§
   - æ™®é€šçº¢åŒ…ï¼šæ¯ä¸ªäººé¢†åˆ°çš„é‡‘é¢ç›¸åŒï¼Œå…¬å¹³åˆ†é…
   - ç¤ºä¾‹1: {"type": "send_redpacket", "redpacketType": "lucky", "totalAmount": 10, "count": 5, "wish": "å¤§å®¶å‘¨æœ«å¿«ä¹ï¼"}
   - ç¤ºä¾‹2: {"type": "send_redpacket", "redpacketType": "normal", "totalAmount": 20, "count": 10, "wish": "æ­å–œå‘è´¢"}

è¯·ä»¥JSONæ ¼å¼è¿”å›ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
{
  "reply": "ä½ çš„å›å¤å†…å®¹|||ç¬¬äºŒæ¡å†…å®¹|||ç¬¬ä¸‰æ¡å†…å®¹"
}

**ç‰¹æ®ŠæŒ‡ä»¤**ï¼š
1. é¢†å–çº¢åŒ…ï¼š
{
  "type": "claim_redpacket",
  "redpacketId": "çº¢åŒ…ID",
  "reply": "ä½ çš„å›å¤å†…å®¹ï¼ˆå¯é€‰ï¼‰"
}

2. å‘é€çº¢åŒ…ï¼š
{
  "type": "send_redpacket",
  "redpacketType": "luckyæˆ–normal",
  "totalAmount": é‡‘é¢æ•°å­—,
  "count": çº¢åŒ…ä¸ªæ•°,
  "wish": "ç¥ç¦è¯­",
  "reply": "ä½ çš„å›å¤å†…å®¹ï¼ˆå¯é€‰ï¼‰"
}

æç¤ºï¼šå‘é€çº¢åŒ…åï¼Œçº¢åŒ…ä¼šç«‹å³å‡ºç°åœ¨ç¾¤èŠä¸­ï¼Œå…¶ä»–æˆå‘˜å’Œè§’è‰²å°±å¯ä»¥æŠ¢çº¢åŒ…äº†ï¼ä½ å¯ä»¥åœ¨é€‚å½“çš„åœºåˆå‘çº¢åŒ…æ´»è·ƒæ°”æ°›ï¼Œè§’è‰²å‘çº¢åŒ…ä¸ä¼šæ‰£é™¤ä»»ä½•äººçš„ä½™é¢ï¼Œå¯ä»¥è‡ªç”±å‘é€ï¼

è¯·ä¸¥æ ¼è¿”å›JSONæ ¼å¼ï¼Œä¸è¦åŒ…å«Markdownä»£ç å—æ ‡è®°ã€‚`;
        
        console.log('[è”æœºç¾¤èŠ] ç³»ç»Ÿæç¤ºè¯ï¼ˆå‰500å­—ï¼‰:', systemPrompt.substring(0, 500));
        
        // æ„å»ºæ¶ˆæ¯æ•°ç»„ï¼ˆä¸ callAI å‡½æ•°çš„æ ‡å‡†æ ¼å¼ä¸€è‡´ï¼‰
        const messages = [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: `ç¾¤èŠè®°å½•ï¼š\n${context}\n\nè¯·ä»¥è§’è‰²èº«ä»½å›å¤ï¼š` }
        ];
        
        console.log('[è”æœºç¾¤èŠ] ğŸ“¤ å‡†å¤‡å‘é€ç»™ AI - å®Œæ•´ä¿¡æ¯æ±‡æ€»');
        console.log('[è”æœºç¾¤èŠ] - System Prompt é•¿åº¦:', systemPrompt.length);
        console.log('[è”æœºç¾¤èŠ] - ä¸Šä¸‹æ–‡é•¿åº¦:', context.length);
        console.log('[è”æœºç¾¤èŠ] ğŸš€ å¼€å§‹è°ƒç”¨ API...');
        
        // å…ˆæ·»åŠ ä¸€æ¡ç³»ç»Ÿæ¶ˆæ¯ä½œä¸ºåˆ†å‰²çº¿
        const systemMsg = {
            id: 'sys_' + Date.now(),
            sender_type: 'system',
            msg_type: 'system',
            content: `â€”â€”â€”â€” ${myOnlineGroupCharacter.name} å¼€å§‹å›å¤ â€”â€”â€”â€”`,
            created_at: Date.now()
        };
        currentOnlineGroupMessages.push(systemMsg);
        renderOnlineGroupMessages();
        console.log('[è”æœºç¾¤èŠ] âœ… å·²æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ†å‰²çº¿');
        
        // è°ƒç”¨ç»Ÿä¸€çš„ AI æ¥å£
        const aiResponse = await callAI(messages);
        
        console.log('[è”æœºç¾¤èŠ] âœ… API è°ƒç”¨æˆåŠŸ');
        console.log('[è”æœºç¾¤èŠ] åŸå§‹å“åº”:', aiResponse);
        
        // å°è¯•è§£æ JSON æ ¼å¼ï¼ˆå¦‚æœAIè¿”å›äº†JSONï¼‰
        let replyText = "";
        try {
            // å°è¯•è§£æä¸ºJSON
            let cleanResponse = aiResponse.trim();
            // æ¸…ç†å¯èƒ½çš„markdownæ ‡è®°
            if (cleanResponse.startsWith('```')) {
                cleanResponse = cleanResponse.replace(/```json?\n?/g, '').replace(/```$/g, '').trim();
            }
            const parsed = JSON.parse(cleanResponse);
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯å‘é€çº¢åŒ…æŒ‡ä»¤
            if (parsed.type === 'send_redpacket' && parsed.totalAmount && parsed.count && parsed.redpacketType) {
                console.log('[è”æœºç¾¤èŠ] ğŸ§§ è§’è‰²å°è¯•å‘é€çº¢åŒ…');
                
                const totalAmount = parseFloat(parsed.totalAmount);
                const count = parseInt(parsed.count);
                const wish = parsed.wish || 'æ­å–œå‘è´¢';
                const redpacketType = parsed.redpacketType;
                
                // éªŒè¯é‡‘é¢å’Œæ•°é‡
                if (totalAmount > 0 && count > 0 && totalAmount <= 200 && count <= 100) {
                    // ç”Ÿæˆçº¢åŒ…ID
                    const redpacketId = 'rp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    
                    // æ„å»ºçº¢åŒ…æ•°æ®
                    const redpacketData = {
                        id: redpacketId,
                        totalAmount: totalAmount.toFixed(2),
                        count: count,
                        wish: wish,
                        redpacketType: redpacketType,
                        claimed: [],
                        claimedAmounts: {}
                    };
                    
                    // å‘é€çº¢åŒ…æ¶ˆæ¯åˆ°æœåŠ¡å™¨
                    onlineSocket.send(JSON.stringify({
                        type: 'send_group_message',
                        group_id: currentOnlineGroupId,
                        my_wx_account: myWx,
                        sender_type: 'character',
                        sender_name: myUserName,
                        character_name: myOnlineGroupCharacter.name,
                        msg_type: 'redpacket',
                        content: JSON.stringify(redpacketData)
                    }));
                    
                    console.log('[è”æœºç¾¤èŠ] âœ… è§’è‰²çº¢åŒ…å·²å‘é€ï¼Œé‡‘é¢:', totalAmount, 'ä¸ªæ•°:', count, 'ï¼ˆä¸æ‰£é™¤ç”¨æˆ·ä½™é¢ï¼‰');
                    
                    // å¦‚æœæœ‰å›å¤å†…å®¹ï¼Œä¹Ÿå‘é€
                    if (parsed.reply) {
                        replyText = parsed.reply;
                    } else {
                        replyText = '';
                    }
                } else {
                    // å‚æ•°æ— æ•ˆ
                    console.log('[è”æœºç¾¤èŠ] âš ï¸ çº¢åŒ…å‚æ•°æ— æ•ˆ');
                    replyText = parsed.reply || '';
                }
            }
            // æ£€æŸ¥æ˜¯å¦æ˜¯é¢†å–çº¢åŒ…æŒ‡ä»¤
            else if (parsed.type === 'claim_redpacket' && parsed.redpacketId) {
                console.log('[è”æœºç¾¤èŠ] ğŸ§§ è§’è‰²å°è¯•é¢†å–çº¢åŒ…:', parsed.redpacketId);
                await claimOnlineGroupRedPacket(parsed.redpacketId, myWx, myOnlineGroupCharacter.name);
                
                // å¦‚æœæœ‰å›å¤å†…å®¹ï¼Œä¹Ÿå‘é€
                if (parsed.reply) {
                    replyText = parsed.reply;
                } else {
                    replyText = '';
                }
            } else {
                replyText = parsed.reply || parsed.content || parsed.message || aiResponse;
            }
            console.log('[è”æœºç¾¤èŠ] JSONè§£ææˆåŠŸï¼Œæå–åˆ°å›å¤å†…å®¹:', replyText);
        } catch (e) {
            // ä¸æ˜¯JSONæ ¼å¼ï¼Œç›´æ¥ä½¿ç”¨åŸå§‹å“åº”
            replyText = aiResponse.trim();
            console.log('[è”æœºç¾¤èŠ] ä¸æ˜¯JSONæ ¼å¼ï¼Œä½¿ç”¨åŸå§‹å“åº”');
        }
        
        if (replyText) {
            // æŒ‰ç…§ ||| åˆ†å‰²æˆå¤šæ¡æ¶ˆæ¯
            const segments = replyText.split('|||').map(s => s.trim()).filter(s => s.length > 0);
            console.log('[è”æœºç¾¤èŠ] åˆ†å‰²æˆ', segments.length, 'æ¡æ¶ˆæ¯');
            
            // ä¾æ¬¡å‘é€æ¯æ¡æ¶ˆæ¯ï¼Œé—´éš”100ms
            for (let i = 0; i < segments.length; i++) {
                const segment = segments[i];
                console.log(`[è”æœºç¾¤èŠ] å‘é€ç¬¬ ${i+1}/${segments.length} æ¡æ¶ˆæ¯:`, segment);
                
                onlineSocket.send(JSON.stringify({
                    type: 'send_group_message',
                    group_id: currentOnlineGroupId,
                    my_wx_account: myWx,
                    sender_type: 'character',
                    sender_name: myUserName,
                    character_name: myOnlineGroupCharacter.name,
                    content: segment
                }));
                
                // ç­‰å¾…ä¸€å°æ®µæ—¶é—´å†å‘é€ä¸‹ä¸€æ¡ï¼Œé¿å…æ¶ˆæ¯é¡ºåºæ··ä¹±
                if (i < segments.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            console.log('[è”æœºç¾¤èŠ] ğŸ“¤ æ‰€æœ‰æ¶ˆæ¯å·²å‘é€åˆ°æœåŠ¡å™¨');
        } else {
            console.warn('[è”æœºç¾¤èŠ] âš ï¸ å›å¤å†…å®¹ä¸ºç©º');
            // å¦‚æœæ²¡æœ‰å›å¤å†…å®¹ï¼Œç§»é™¤åˆšæ·»åŠ çš„ç³»ç»Ÿæ¶ˆæ¯
            currentOnlineGroupMessages.pop();
            renderOnlineGroupMessages();
        }
        
        // æ¢å¤æ ‡é¢˜
        if (chatTitleEl) {
            chatTitleEl.innerText = originalTitle;
            console.log('[è”æœºç¾¤èŠ] æ¢å¤æ ‡é¢˜ä¸º:', originalTitle);
        }
        
        // é€šçŸ¥ç¾¤é‡Œå…¶ä»–äººï¼šè¾“å…¥ç»“æŸ
        onlineSocket.send(JSON.stringify({
            type: 'group_typing_stop',
            group_id: currentOnlineGroupId,
            my_wx_account: myWx
        }));
    } catch (e) {
        console.error('[è”æœºç¾¤èŠ] âŒ è§’è‰²å›å¤å¤±è´¥:', e);
        console.error('[è”æœºç¾¤èŠ] é”™è¯¯å †æ ˆ:', e.stack);
        alert('è§’è‰²å›å¤å¤±è´¥: ' + e.message);
        
        // å‡ºé”™æ—¶ä¹Ÿè¦æ¢å¤æ ‡é¢˜
        if (chatTitleEl) {
            chatTitleEl.innerText = originalTitle;
            console.log('[è”æœºç¾¤èŠ] ï¼ˆå‡ºé”™ï¼‰æ¢å¤æ ‡é¢˜ä¸º:', originalTitle);
        }
        
        // é€šçŸ¥ç¾¤é‡Œå…¶ä»–äººï¼šè¾“å…¥ç»“æŸ
        onlineSocket.send(JSON.stringify({
            type: 'group_typing_stop',
            group_id: currentOnlineGroupId,
            my_wx_account: myWx
        }));
    }
}

// æ˜¾ç¤ºç¾¤èŠä¿¡æ¯é¡µé¢
function showOnlineGroupInfo(groupId) {
    const group = onlineGroups.find(g => g.id === groupId);
    if (!group) return;
    
    const myWx = getMyOnlineWxAccount();
    
    const page = document.createElement('div');
    page.id = 'online-group-info-page';
    page.style.cssText = `position:fixed; top:0; left:0; right:0; bottom:0; background:#f5f5f5; z-index:310; display:flex; flex-direction:column;`;
    
    page.innerHTML = `
        <div class="wechat-header" style="background:#fff; border-bottom:1px solid #f0f0f0;">
            <div class="back-btn" onclick="document.getElementById('online-group-info-page').remove()" style="margin:0; background:none; width:40px; justify-content:flex-start; color:#333;">
                <svg class="svg-icon" viewBox="0 0 24 24" style="width:24px; height:24px;"><polyline points="15 18 9 12 15 6"></polyline></svg>
            </div>
            <div class="wechat-title">ç¾¤èŠèµ„æ–™</div>
            <div style="width:40px;"></div>
        </div>
        
        <div style="flex:1; overflow-y:auto;">
            <div style="background:#fff; padding:20px; margin-bottom:10px; text-align:center;">
                <div style="width:60px; height:60px; border-radius:12px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); margin:0 auto 12px; display:flex; align-items:center; justify-content:center; color:#fff; font-size:24px;">ğŸ‘¥</div>
                <div style="font-size:18px; font-weight:600;">${group.name}</div>
            </div>
            
            <div style="background:#fff; padding:16px; margin-bottom:10px;">
                <div style="font-size:14px; font-weight:500; margin-bottom:12px;">ç¾¤æˆå‘˜ (${currentOnlineGroupMembers.length})</div>
                <div id="og-info-members" style="display:flex; flex-wrap:wrap; gap:12px;">
                    ${currentOnlineGroupMembers.map(m => `
                        <div style="text-align:center; width:60px;">
                            <div style="width:48px; height:48px; border-radius:8px; margin:0 auto 4px; background-image:url(${m.user_avatar}); background-size:cover; background-color:#e0e0e0;"></div>
                            <div style="font-size:12px; color:#333; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${m.user_name}</div>
                            ${m.character_name ? `<div style="font-size:10px; color:#667eea;">ğŸ­${m.character_name}</div>` : ''}
                        </div>
                    `).join('')}
                </div>
            </div>
            
            <div style="background:#fff; padding:16px; margin-bottom:10px;">
                <div style="font-size:14px; font-weight:500; margin-bottom:12px;">æˆ‘çš„ç¾¤è§’è‰²</div>
                <div style="display:flex; align-items:center; justify-content:space-between;">
                    <span style="color:#666;">${myOnlineGroupCharacter ? myOnlineGroupCharacter.name : 'æœªè®¾ç½®è§’è‰²'}</span>
                    <button onclick="showChangeGroupCharacterModal('${groupId}')" style="padding:8px 16px; background:var(--ins-pink); color:#fff; border:none; border-radius:6px; font-size:13px;">
                        ${myOnlineGroupCharacter ? 'æ›´æ¢' : 'è®¾ç½®'}è§’è‰²
                    </button>
                </div>
            </div>
            
            <div style="background:#fff; padding:16px; margin-bottom:10px;">
                <div style="font-size:14px; font-weight:500; margin-bottom:12px;">èŠå¤©èƒŒæ™¯å›¾</div>
                <div style="display:flex; flex-direction:column; gap:12px;">
                    <div style="display:flex; gap:8px;">
                        <button onclick="document.getElementById('online-group-bg-input').setAttribute('data-group-id', '${groupId}'); document.getElementById('online-group-bg-input').click()" style="flex:1; padding:8px 12px; background:#f0f0f0; border:none; border-radius:6px; font-size:13px; color:#666; cursor:pointer;">ä¸Šä¼ èƒŒæ™¯</button>
                        <button onclick="clearOnlineGroupBackground('${groupId}')" style="flex:1; padding:8px 12px; background:#f0f0f0; border:none; border-radius:6px; font-size:13px; color:#666; cursor:pointer;">æ¸…é™¤èƒŒæ™¯</button>
                    </div>
                    <div id="online-group-bg-preview" style="width:100%; height:120px; border-radius:8px; background:#f5f5f5; background-size:cover; background-position:center; border:1px solid #e8e8e8; display:flex; align-items:center; justify-content:center; color:#999; font-size:12px;">
                        æš‚æ— èƒŒæ™¯å›¾
                    </div>
                </div>
            </div>
            
            <div style="background:#fff; padding:16px;">
                <button onclick="inviteFriendToGroup('${groupId}')" style="width:100%; padding:14px; background:#f5f5f5; color:#333; border:none; border-radius:8px; font-size:15px; margin-bottom:10px;">é‚€è¯·å¥½å‹</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(page);
    
    // åŠ è½½å¹¶æ˜¾ç¤ºèƒŒæ™¯å›¾é¢„è§ˆ
    loadOnlineGroupBackgroundPreview(groupId);
}

// æ˜¾ç¤ºæ›´æ¢è§’è‰²å¼¹çª—
async function showChangeGroupCharacterModal(groupId) {
    const chars = await db.characters.toArray();
    const availableChars = chars.filter(c => c.type !== 'user' && c.type !== 'online_friend');
    
    const modal = document.createElement('div');
    modal.id = 'change-char-modal';
    modal.style.cssText = `position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:10000; display:flex; align-items:center; justify-content:center;`;
    
    modal.innerHTML = `
        <div style="background:#fff; border-radius:12px; padding:20px; width:80%; max-width:300px;">
            <h3 style="margin:0 0 16px 0; text-align:center;">é€‰æ‹©è§’è‰²</h3>
            <select id="change-char-select" style="width:100%; padding:12px; border:1px solid #ddd; border-radius:8px; margin-bottom:16px;">
                <option value="">ä¸ä½¿ç”¨è§’è‰²</option>
                ${availableChars.map(c => `<option value="${c.id}" ${myOnlineGroupCharacter?.name === c.name ? 'selected' : ''}>${c.name}</option>`).join('')}
            </select>
            <div style="display:flex; gap:10px;">
                <button onclick="this.closest('#change-char-modal').remove()" style="flex:1; padding:12px; background:#f0f0f0; color:#666; border:none; border-radius:8px;">å–æ¶ˆ</button>
                <button onclick="doChangeGroupCharacter('${groupId}')" style="flex:1; padding:12px; background:var(--ins-pink); color:#fff; border:none; border-radius:8px;">ç¡®å®š</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// æ‰§è¡Œæ›´æ¢è§’è‰²
async function doChangeGroupCharacter(groupId) {
    const charId = document.getElementById('change-char-select').value;
    
    let myChar = null;
    if (charId) {
        const char = await db.characters.get(parseInt(charId));
        if (char) {
            myChar = {
                name: char.name,
                avatar: char.avatar || '',
                desc: char.description?.substring(0, 200) || ''
            };
        }
    }
    
    const myWx = getMyOnlineWxAccount();
    onlineSocket.send(JSON.stringify({
        type: 'update_group_character',
        group_id: groupId,
        my_wx_account: myWx,
        character: myChar
    }));
    
    myOnlineGroupCharacter = myChar;
    document.getElementById('change-char-modal')?.remove();
    document.getElementById('online-group-info-page')?.remove();
    showOnlineGroupInfo(groupId);
}

// é‚€è¯·å¥½å‹åˆ°ç¾¤èŠ
async function inviteFriendToGroup(groupId) {
    const friends = await db.characters.where('type').equals('online_friend').toArray();
    
    if (friends.length === 0) {
        alert('æš‚æ— è”æœºå¥½å‹å¯é‚€è¯·');
        return;
    }
    
    const modal = document.createElement('div');
    modal.id = 'invite-friend-modal';
    modal.style.cssText = `position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:10000; display:flex; align-items:center; justify-content:center;`;
    
    modal.innerHTML = `
        <div style="background:#fff; border-radius:12px; padding:20px; width:80%; max-width:300px; max-height:60vh; display:flex; flex-direction:column;">
            <h3 style="margin:0 0 16px 0; text-align:center;">é‚€è¯·å¥½å‹</h3>
            <div style="flex:1; overflow-y:auto;">
                ${friends.map(f => `
                    <div onclick="doInviteFriend('${groupId}', '${f.onlineData?.wx_account}')" style="display:flex; align-items:center; padding:12px; border-bottom:1px solid #f5f5f5; cursor:pointer;">
                        <div style="width:40px; height:40px; border-radius:8px; background-image:url(${f.avatar}); background-size:cover; background-color:#e0e0e0; margin-right:12px;"></div>
                        <span>${f.name}</span>
                    </div>
                `).join('')}
            </div>
            <button onclick="this.closest('#invite-friend-modal').remove()" style="margin-top:12px; padding:12px; background:#f0f0f0; color:#666; border:none; border-radius:8px;">å–æ¶ˆ</button>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// æ‰§è¡Œé‚€è¯·å¥½å‹
function doInviteFriend(groupId, friendWx) {
    const myWx = getMyOnlineWxAccount();
    onlineSocket.send(JSON.stringify({
        type: 'invite_to_group',
        group_id: groupId,
        my_wx_account: myWx,
        invite_wx_account: friendWx
    }));
    
    document.getElementById('invite-friend-modal')?.remove();
    showToast('é‚€è¯·å·²å‘é€');
}

// è®¾ç½®è”æœºç¾¤èŠèƒŒæ™¯å›¾
async function setOnlineGroupBackground(input) {
    if (!input.files || !input.files[0]) return;
    
    const groupId = input.getAttribute('data-group-id') || currentOnlineGroupId;
    if (!groupId) {
        showToast('æ— æ³•è·å–ç¾¤èŠID');
        return;
    }
    
    const file = input.files[0];
    const reader = new FileReader();
    
    reader.onload = async function(e) {
        const base64 = e.target.result;
        const accountId = getCurrentAccountId();
        if (!accountId) return;
        
        try {
            // æŸ¥æ‰¾å¯¹åº”çš„æœ¬åœ°ç¾¤èŠè®°å½•
            const groups = await db.group_chats
                .where('ownerAccountId').equals(accountId)
                .filter(g => g.isOnlineGroup && g.onlineGroupId === groupId)
                .toArray();
            
            if (groups.length > 0) {
                const group = groups[0];
                group.chat_background = base64;
                await safeGroupChatPut(group);
                
                // åº”ç”¨èƒŒæ™¯å›¾
                applyOnlineGroupBackground(groupId);
                
                // æ›´æ–°é¢„è§ˆ
                loadOnlineGroupBackgroundPreview(groupId);
                
                showToast('èƒŒæ™¯å›¾å·²è®¾ç½®');
            }
        } catch (e) {
            console.error('ä¿å­˜è”æœºç¾¤èŠèƒŒæ™¯å›¾å¤±è´¥:', e);
            showToast('ä¿å­˜å¤±è´¥');
        }
    };
    
    reader.readAsDataURL(file);
}

// æ¸…é™¤è”æœºç¾¤èŠèƒŒæ™¯å›¾
async function clearOnlineGroupBackground(groupId) {
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    try {
        // æŸ¥æ‰¾å¯¹åº”çš„æœ¬åœ°ç¾¤èŠè®°å½•
        const groups = await db.group_chats
            .where('ownerAccountId').equals(accountId)
            .filter(g => g.isOnlineGroup && g.onlineGroupId === groupId)
            .toArray();
        
        if (groups.length > 0) {
            const group = groups[0];
            group.chat_background = null;
            await safeGroupChatPut(group);
            
            // åº”ç”¨èƒŒæ™¯å›¾ï¼ˆæ¸…é™¤ï¼‰
            applyOnlineGroupBackground(groupId);
            
            // æ›´æ–°é¢„è§ˆ
            loadOnlineGroupBackgroundPreview(groupId);
            
            showToast('èƒŒæ™¯å›¾å·²æ¸…é™¤');
        }
    } catch (e) {
        console.error('æ¸…é™¤è”æœºç¾¤èŠèƒŒæ™¯å›¾å¤±è´¥:', e);
        showToast('æ¸…é™¤å¤±è´¥');
    }
}

// åº”ç”¨è”æœºç¾¤èŠèƒŒæ™¯å›¾
async function applyOnlineGroupBackground(groupId) {
    const page = document.getElementById('online-group-chat-page');
    if (!page) return;
    
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    try {
        // æŸ¥æ‰¾å¯¹åº”çš„æœ¬åœ°ç¾¤èŠè®°å½•
        const groups = await db.group_chats
            .where('ownerAccountId').equals(accountId)
            .filter(g => g.isOnlineGroup && g.onlineGroupId === groupId)
            .toArray();
        
        if (groups.length > 0) {
            const group = groups[0];
            if (group.chat_background) {
                page.style.backgroundImage = `url(${group.chat_background})`;
                page.style.backgroundSize = 'cover';
                page.style.backgroundPosition = 'center';
                page.style.backgroundRepeat = 'no-repeat';
                page.style.backgroundAttachment = 'fixed';
            } else {
                page.style.backgroundImage = '';
                page.style.backgroundSize = '';
                page.style.backgroundPosition = '';
                page.style.backgroundRepeat = '';
                page.style.backgroundAttachment = '';
                page.style.backgroundColor = '#ffffff';
            }
        }
    } catch (e) {
        console.error('åº”ç”¨è”æœºç¾¤èŠèƒŒæ™¯å›¾å¤±è´¥:', e);
    }
}

// åŠ è½½è”æœºç¾¤èŠèƒŒæ™¯å›¾é¢„è§ˆ
async function loadOnlineGroupBackgroundPreview(groupId) {
    const preview = document.getElementById('online-group-bg-preview');
    if (!preview) return;
    
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    try {
        // æŸ¥æ‰¾å¯¹åº”çš„æœ¬åœ°ç¾¤èŠè®°å½•
        const groups = await db.group_chats
            .where('ownerAccountId').equals(accountId)
            .filter(g => g.isOnlineGroup && g.onlineGroupId === groupId)
            .toArray();
        
        if (groups.length > 0) {
            const group = groups[0];
            if (group.chat_background) {
                preview.style.backgroundImage = `url(${group.chat_background})`;
                preview.innerHTML = '';
            } else {
                preview.style.backgroundImage = '';
                preview.innerHTML = 'æš‚æ— èƒŒæ™¯å›¾';
            }
        } else {
            preview.style.backgroundImage = '';
            preview.innerHTML = 'æš‚æ— èƒŒæ™¯å›¾';
        }
    } catch (e) {
        console.error('åŠ è½½è”æœºç¾¤èŠèƒŒæ™¯å›¾é¢„è§ˆå¤±è´¥:', e);
    }
}

// ==================== è”æœºç¾¤èŠåŠŸèƒ½ç»“æŸ ====================

// å°†è”æœºç›¸å…³å‡½æ•°æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸ
window.toggleOnlineSettings = toggleOnlineSettings;
window.loadOnlineSettings = loadOnlineSettings;
window.saveOnlineSettings = saveOnlineSettings;
window.testOnlineConnection = testOnlineConnection;
window.connectToOnlineServer = connectToOnlineServer;
window.showOnlineLoginModal = showOnlineLoginModal;
window.showOnlineRegisterModal = showOnlineRegisterModal;
window.doOnlineLogin = doOnlineLogin;
window.doOnlineRegister = doOnlineRegister;
window.onlineLogout = onlineLogout;
window.showOnlineSearchModal = showOnlineSearchModal;
window.doOnlineSearch = doOnlineSearch;
window.sendOnlineFriendRequest = sendOnlineFriendRequest;
window.goOnlineWithCharacter = goOnlineWithCharacter;
window.goOfflineWithCharacter = goOfflineWithCharacter;
window.showOnlineStatusPage = showOnlineStatusPage;
window.hideOnlineStatusPage = hideOnlineStatusPage;
window.updateOnlineFeatureSection = updateOnlineFeatureSection;
window.refreshOnlineStatusPageContent = refreshOnlineStatusPageContent;
window.renderOnlineCharList = renderOnlineCharList;
window.updateOnlineConnectionStatus = updateOnlineConnectionStatus;
window.manualSyncOnline = manualSyncOnline;

// è”æœºç¾¤èŠå‡½æ•°
window.showCreateOnlineGroupModal = showCreateOnlineGroupModal;
window.doCreateOnlineGroup = doCreateOnlineGroup;
window.openOnlineGroup = openOnlineGroup;
window.hideOnlineGroupChat = hideOnlineGroupChat;
window.sendOnlineGroupMsg = sendOnlineGroupMsg;
window.letMyCharacterSpeak = letMyCharacterSpeak;
window.showOnlineGroupInfo = showOnlineGroupInfo;
window.showChangeGroupCharacterModal = showChangeGroupCharacterModal;
window.doChangeGroupCharacter = doChangeGroupCharacter;
window.inviteFriendToGroup = inviteFriendToGroup;
window.doInviteFriend = doInviteFriend;
window.onlineGroupVoiceInput = onlineGroupVoiceInput;
window.closeOnlineGroupVoiceModal = closeOnlineGroupVoiceModal;
window.startOnlineGroupVoiceRecord = startOnlineGroupVoiceRecord;
window.playOnlineGroupAudio = playOnlineGroupAudio;
window.receiveOnlineGroupTransfer = receiveOnlineGroupTransfer;
window.doJoinOnlineGroup = doJoinOnlineGroup;

// ============================================
// å¤´åƒåº“ç³»ç»Ÿ
// ============================================

let avatarLibraryMainTab = 'single'; // ä¸»åˆ†ç±»ï¼š'single' | 'couple'
let avatarLibraryCurrentTag = ''; // å½“å‰é€‰ä¸­çš„å°æ ‡ç­¾åï¼ˆç©º=å…¨éƒ¨ï¼‰
let avatarPreviewCurrentId = null; // å½“å‰é¢„è§ˆçš„å¤´åƒID
let couplePairingMode = false; // æƒ…å¤´é…å¯¹æ¨¡å¼
let couplePairingFirst = null; // é…å¯¹æ¨¡å¼ä¸‹é€‰ä¸­çš„ç¬¬ä¸€å¼ å¤´åƒID
let avatarBatchDeleteMode = false; // æ‰¹é‡åˆ é™¤æ¨¡å¼
let avatarBatchSelected = new Set(); // æ‰¹é‡é€‰ä¸­çš„å¤´åƒIDé›†åˆ

// æ‰“å¼€å¤´åƒåº“é¡µé¢
async function showAvatarLibraryPage() {
    const page = document.getElementById('avatar-library-page');
    if (page) {
        page.style.display = 'flex';
        avatarLibraryMainTab = 'single';
        avatarLibraryCurrentTag = '';
        updateMainTabUI();
        await loadSubTags();
        renderAvatarLibrary();
    }
}

function hideAvatarLibraryPage() {
    const page = document.getElementById('avatar-library-page');
    if (page) page.style.display = 'none';
    avatarBatchDeleteMode = false;
    avatarBatchSelected.clear();
}

// åˆ‡æ¢ä¸»åˆ†ç±»ï¼ˆå•äººå¤´åƒ / æƒ…å¤´ï¼‰
async function switchAvatarTab(tab) {
    avatarLibraryMainTab = tab;
    avatarLibraryCurrentTag = ''; // åˆ‡æ¢ä¸»Tabæ—¶é‡ç½®å­æ ‡ç­¾
    couplePairingMode = false; // é‡ç½®é…å¯¹æ¨¡å¼
    couplePairingFirst = null;
    avatarBatchDeleteMode = false; // é‡ç½®æ‰¹é‡åˆ é™¤æ¨¡å¼
    avatarBatchSelected.clear();
    updateMainTabUI();
    await loadSubTags();
    renderAvatarLibrary();
    updateBatchDeleteBar();
}

// æ›´æ–°ä¸»Tabçš„UIé«˜äº®
function updateMainTabUI() {
    const singleTab = document.getElementById('avatar-tab-single');
    const coupleTab = document.getElementById('avatar-tab-couple');
    const singleLine = document.getElementById('avatar-tab-single-line');
    const coupleLine = document.getElementById('avatar-tab-couple-line');
    
    if (avatarLibraryMainTab === 'single') {
        if (singleTab) { singleTab.style.color = '#262626'; singleTab.style.fontWeight = '600'; }
        if (coupleTab) { coupleTab.style.color = '#b0b0b0'; coupleTab.style.fontWeight = '500'; }
        if (singleLine) singleLine.style.width = '24px';
        if (coupleLine) coupleLine.style.width = '0';
    } else {
        if (coupleTab) { coupleTab.style.color = '#262626'; coupleTab.style.fontWeight = '600'; }
        if (singleTab) { singleTab.style.color = '#b0b0b0'; singleTab.style.fontWeight = '500'; }
        if (coupleLine) coupleLine.style.width = '24px';
        if (singleLine) singleLine.style.width = '0';
    }
}

// åŠ è½½å¹¶æ¸²æŸ“å½“å‰ä¸»åˆ†ç±»ä¸‹çš„å°æ ‡ç­¾
async function loadSubTags() {
    const container = document.getElementById('avatar-subtags-container');
    if (!container) return;
    
    let tags = [];
    try {
        // å…ˆæ¸…ç†æ—§çš„æ— parentCategoryè®°å½•ï¼ˆå…¼å®¹æ—§ç‰ˆï¼‰
        const allCats = await db.avatar_categories.toArray();
        for (const cat of allCats) {
            if (!cat.parentCategory) {
                // æ—§ç‰ˆæ•°æ®ï¼Œæ ¹æ®åå­—è‡ªåŠ¨åˆ†é…
                const pc = cat.name === 'æƒ…å¤´' ? 'couple' : 'single';
                await db.avatar_categories.update(cat.id, { parentCategory: pc });
            }
        }
        tags = await db.avatar_categories
            .where('parentCategory').equals(avatarLibraryMainTab)
            .sortBy('order');
    } catch (e) {
        console.error('[å¤´åƒåº“] åŠ è½½å­æ ‡ç­¾å¤±è´¥:', e);
        // é™çº§ï¼šæ‰‹åŠ¨ç­›é€‰
        try {
            const allCats = await db.avatar_categories.toArray();
            tags = allCats.filter(c => c.parentCategory === avatarLibraryMainTab)
                .sort((a, b) => (a.order || 0) - (b.order || 0));
        } catch (e2) {
            console.error('[å¤´åƒåº“] é™çº§åŠ è½½ä¹Ÿå¤±è´¥:', e2);
        }
    }
    
    let html = '';
    
    // "å…¨éƒ¨" æ ‡ç­¾
    const allActive = avatarLibraryCurrentTag === '';
    html += `<div onclick="selectAvatarSubTag('')" style="flex-shrink:0; padding:5px 14px; font-size:12px; 
        border-radius:14px; cursor:pointer; transition:all 0.2s; white-space:nowrap;
        background:${allActive ? '#262626' : '#f5f5f5'}; color:${allActive ? '#fff' : '#666'}; 
        font-weight:${allActive ? '600' : '400'};">å…¨éƒ¨</div>`;
    
    // ç”¨æˆ·æ·»åŠ çš„å°æ ‡ç­¾
    for (const tag of tags) {
        const isActive = avatarLibraryCurrentTag === tag.name;
        html += `<div onclick="selectAvatarSubTag('${tag.name.replace(/'/g, "\\'")}')" 
            oncontextmenu="event.preventDefault(); showSubTagMenu(event, ${tag.id}, '${tag.name.replace(/'/g, "\\'")}')"
            style="flex-shrink:0; padding:5px 14px; font-size:12px; border-radius:14px; cursor:pointer; 
            transition:all 0.2s; white-space:nowrap; user-select:none;
            background:${isActive ? '#262626' : '#f5f5f5'}; color:${isActive ? '#fff' : '#666'}; 
            font-weight:${isActive ? '600' : '400'};">${tag.name}</div>`;
    }
    
    // "+" æ·»åŠ æŒ‰é’®
    html += `<div onclick="addSubTagDialog()" style="flex-shrink:0; width:26px; height:26px; border-radius:50%; 
        background:#f5f5f5; display:flex; align-items:center; justify-content:center; cursor:pointer;">
        <svg viewBox="0 0 24 24" style="width:12px; height:12px; fill:none; stroke:#999; stroke-width:2.5;">
            <line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line>
        </svg>
    </div>`;
    
    container.innerHTML = html;
}

// é€‰ä¸­å­æ ‡ç­¾
function selectAvatarSubTag(tagName) {
    avatarLibraryCurrentTag = tagName;
    loadSubTags(); // æ›´æ–°é«˜äº®
    renderAvatarLibrary();
}

// æ·»åŠ å­æ ‡ç­¾å¼¹çª—
async function addSubTagDialog() {
    const name = prompt('è¯·è¾“å…¥æ ‡ç­¾åç§°ï¼š');
    if (!name || !name.trim()) return;
    
    const trimmed = name.trim();
    
    // æ£€æŸ¥åŒä¸»åˆ†ç±»ä¸‹æ˜¯å¦é‡å
    const existing = await db.avatar_categories
        .where('parentCategory').equals(avatarLibraryMainTab)
        .toArray();
    if (existing.find(t => t.name === trimmed)) {
        showToast('è¯¥æ ‡ç­¾å·²å­˜åœ¨');
        return;
    }
    
    const maxOrder = existing.length > 0 ? Math.max(...existing.map(t => t.order || 0)) + 1 : 0;
    
    await db.avatar_categories.add({
        name: trimmed,
        parentCategory: avatarLibraryMainTab,
        order: maxOrder,
        time: Date.now()
    });
    
    avatarLibraryCurrentTag = trimmed;
    await loadSubTags();
    renderAvatarLibrary();
    showToast(`å·²æ·»åŠ æ ‡ç­¾ã€Œ${trimmed}ã€`);
}

// å³é”®/é•¿æŒ‰å­æ ‡ç­¾èœå•
function showSubTagMenu(event, tagId, tagName) {
    const old = document.getElementById('avatar-subtag-menu');
    if (old) old.remove();
    
    const menu = document.createElement('div');
    menu.id = 'avatar-subtag-menu';
    menu.style.cssText = `position:fixed; z-index:99999; background:#fff; border-radius:10px; 
        box-shadow:0 4px 20px rgba(0,0,0,0.12); padding:4px 0; min-width:100px;`;
    
    const x = event.clientX || 100;
    const y = event.clientY || 100;
    menu.style.left = Math.min(x, window.innerWidth - 120) + 'px';
    menu.style.top = Math.min(y, window.innerHeight - 100) + 'px';
    
    menu.innerHTML = `
        <div onclick="renameSubTag(${tagId}, '${tagName.replace(/'/g, "\\'")}')" 
             style="padding:10px 16px; font-size:13px; color:#262626; cursor:pointer;"
             onmouseover="this.style.background='#f5f5f5'" onmouseout="this.style.background='#fff'">é‡å‘½å</div>
        <div onclick="deleteSubTag(${tagId}, '${tagName.replace(/'/g, "\\'")}')" 
             style="padding:10px 16px; font-size:13px; color:#ff3b30; cursor:pointer;"
             onmouseover="this.style.background='#f5f5f5'" onmouseout="this.style.background='#fff'">åˆ é™¤</div>
    `;
    
    document.body.appendChild(menu);
    const closeMenu = (e) => {
        if (!menu.contains(e.target)) { menu.remove(); document.removeEventListener('click', closeMenu); }
    };
    setTimeout(() => document.addEventListener('click', closeMenu), 50);
}

// é‡å‘½åå­æ ‡ç­¾
async function renameSubTag(tagId, oldName) {
    const old = document.getElementById('avatar-subtag-menu');
    if (old) old.remove();
    
    const newName = prompt('è¯·è¾“å…¥æ–°çš„æ ‡ç­¾åç§°ï¼š', oldName);
    if (!newName || !newName.trim() || newName.trim() === oldName) return;
    
    const trimmed = newName.trim();
    const siblings = await db.avatar_categories
        .where('parentCategory').equals(avatarLibraryMainTab).toArray();
    if (siblings.find(t => t.name === trimmed)) {
        showToast('è¯¥æ ‡ç­¾åå·²å­˜åœ¨');
        return;
    }
    
    await db.avatar_categories.update(tagId, { name: trimmed });
    
    // æ›´æ–°è¯¥æ ‡ç­¾ä¸‹å¤´åƒçš„tagå­—æ®µ
    const avatarsInTag = await db.avatar_library
        .where('tag').equals(oldName).toArray();
    for (const av of avatarsInTag) {
        if (av.category === avatarLibraryMainTab) {
            await db.avatar_library.update(av.id, { tag: trimmed });
        }
    }
    
    if (avatarLibraryCurrentTag === oldName) avatarLibraryCurrentTag = trimmed;
    await loadSubTags();
    renderAvatarLibrary();
    showToast(`å·²é‡å‘½åä¸ºã€Œ${trimmed}ã€`);
}

// åˆ é™¤å­æ ‡ç­¾
async function deleteSubTag(tagId, tagName) {
    const old = document.getElementById('avatar-subtag-menu');
    if (old) old.remove();
    
    // è¯¥æ ‡ç­¾ä¸‹çš„å¤´åƒä¸åˆ é™¤ï¼Œåªæ˜¯æŠŠå®ƒä»¬çš„tagæ¸…ç©º
    if (!confirm(`ç¡®å®šåˆ é™¤æ ‡ç­¾ã€Œ${tagName}ã€å—ï¼Ÿ\næ ‡ç­¾ä¸‹çš„å¤´åƒä¸ä¼šè¢«åˆ é™¤ï¼Œä¼šå˜ä¸ºæœªåˆ†ç±»ã€‚`)) return;
    
    await db.avatar_categories.delete(tagId);
    
    // æ¸…ç©ºè¯¥æ ‡ç­¾ä¸‹å¤´åƒçš„tag
    const avatarsInTag = await db.avatar_library.where('tag').equals(tagName).toArray();
    for (const av of avatarsInTag) {
        if (av.category === avatarLibraryMainTab) {
            await db.avatar_library.update(av.id, { tag: '' });
        }
    }
    
    if (avatarLibraryCurrentTag === tagName) avatarLibraryCurrentTag = '';
    await loadSubTags();
    renderAvatarLibrary();
    showToast(`å·²åˆ é™¤æ ‡ç­¾ã€Œ${tagName}ã€`);
}

// æ¸²æŸ“å¤´åƒåˆ—è¡¨
async function renderAvatarLibrary() {
    const content = document.getElementById('avatar-library-content');
    if (!content) return;
    
    let allInCategory = await db.avatar_library
        .where('category').equals(avatarLibraryMainTab)
        .toArray();
    
    // æŒ‰å­æ ‡ç­¾ç­›é€‰
    let avatars;
    if (avatarLibraryCurrentTag) {
        avatars = allInCategory.filter(a => a.tag === avatarLibraryCurrentTag);
    } else {
        avatars = allInCategory;
    }
    // æŒ‰æ—¶é—´å€’åº
    avatars.sort((a, b) => (b.time || 0) - (a.time || 0));
    
    if (!avatars || avatars.length === 0) {
        const tabName = avatarLibraryMainTab === 'single' ? 'å•äººå¤´åƒ' : 'æƒ…å¤´';
        content.innerHTML = `
            <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; padding:80px 40px;">
                <svg viewBox="0 0 24 24" style="width:40px; height:40px; fill:none; stroke:#dbdbdb; stroke-width:1.2;">
                    <circle cx="12" cy="8" r="4"></circle>
                    <path d="M20 21a8 8 0 1 0-16 0"></path>
                </svg>
                <div style="font-size:14px; color:#8e8e8e; margin-top:20px;">æš‚æ— ${avatarLibraryCurrentTag || tabName}</div>
                <div style="font-size:12px; color:#c7c7c7; margin-top:6px;">ç‚¹å‡»å³ä¸Šè§’ + æ·»åŠ å¤´åƒ</div>
            </div>
        `;
        return;
    }
    
    if (avatarLibraryMainTab === 'couple') {
        // æƒ…å¤´ - æ‰‹åŠ¨é…å¯¹å±•ç¤º
        // åˆ†ç¦»å·²é…å¯¹å’Œæœªé…å¯¹
        const paired = {}; // pairId -> [av1, av2]
        const unpaired = [];
        
        for (const av of avatars) {
            if (av.pairId) {
                if (!paired[av.pairId]) paired[av.pairId] = [];
                paired[av.pairId].push(av);
            } else {
                unpaired.push(av);
            }
        }
        
        let html = '';
        
        // é…å¯¹æ“ä½œæ 
        html += `<div style="display:flex; align-items:center; justify-content:space-between; padding:12px 16px;">
            <div style="font-size:12px; color:#999;">${Object.keys(paired).length} å¯¹æƒ…å¤´ Â· ${unpaired.length} å¼ æœªé…å¯¹</div>
            <div style="display:flex; gap:8px;">
                <div onclick="toggleAvatarBatchDelete()" style="padding:5px 14px; font-size:12px; border-radius:14px; cursor:pointer;
                    background:${avatarBatchDeleteMode ? '#ff3b30' : '#f5f5f5'}; color:${avatarBatchDeleteMode ? '#fff' : '#666'}; 
                    font-weight:500; transition:all 0.2s;">
                    ${avatarBatchDeleteMode ? 'å–æ¶ˆ' : 'æ‰¹é‡åˆ é™¤'}
                </div>
                <div onclick="toggleCouplePairingMode()" style="padding:5px 14px; font-size:12px; border-radius:14px; cursor:pointer;
                    background:${couplePairingMode ? '#ff6b81' : '#f5f5f5'}; color:${couplePairingMode ? '#fff' : '#666'}; 
                    font-weight:500; transition:all 0.2s;">
                    ${couplePairingMode ? 'å®Œæˆé…å¯¹' : 'é…å¯¹'}
                </div>
            </div>
        </div>`;
        
        // é…å¯¹æ¨¡å¼æç¤º
        if (couplePairingMode) {
            html += `<div style="text-align:center; padding:6px 16px 12px; font-size:12px; color:#ff6b81;">
                ${couplePairingFirst ? 'å†é€‰ä¸€å¼ å®Œæˆé…å¯¹ ğŸ’•' : 'é€‰æ‹©ç¬¬ä¸€å¼ å¤´åƒ'}
            </div>`;
        }
        
        // æ‰¹é‡åˆ é™¤æ¨¡å¼æç¤º
        if (avatarBatchDeleteMode) {
            html += `<div style="text-align:center; padding:6px 16px 12px; font-size:12px; color:#ff3b30;">
                ç‚¹å‡»å¤´åƒé€‰æ‹©è¦åˆ é™¤çš„å›¾ç‰‡
            </div>`;
        }
        
        // å·²é…å¯¹çš„æƒ…å¤´ - ä¸¤å¯¹ä¸€è¡Œ
        const pairIds = Object.keys(paired);
        if (pairIds.length > 0) {
            html += `<div style="display:flex; flex-wrap:wrap; padding:4px 8px;">`;
            for (const pid of pairIds) {
                const pair = paired[pid];
                const av1 = pair[0];
                const av2 = pair[1];
                if (!av1) continue;
                const isBatch1 = avatarBatchDeleteMode && avatarBatchSelected.has(av1.id);
                const isBatch2 = av2 && avatarBatchDeleteMode && avatarBatchSelected.has(av2.id);
                const clickAction1 = avatarBatchDeleteMode ? `toggleBatchSelect(${av1.id})` : `showAvatarPreview(${av1.id})`;
                const clickAction2 = av2 ? (avatarBatchDeleteMode ? `toggleBatchSelect(${av2.id})` : `showAvatarPreview(${av2.id})`) : '';
                html += `
                    <div style="width:50%; box-sizing:border-box; padding:6px 4px;">
                        <div style="display:flex; align-items:center; justify-content:center; gap:0;">
                            <div onclick="${clickAction1}" style="width:60px; height:60px; border-radius:12px; overflow:hidden; cursor:pointer; border:1px solid #f0f0f0; position:relative; flex-shrink:0;">
                                <img src="${av1.url}" style="width:100%; height:100%; object-fit:cover; display:block; ${isBatch1 ? 'opacity:0.5;' : ''}" onerror="this.parentElement.style.background='#fafafa';">
                                ${isBatch1 ? `<div style="position:absolute; top:2px; right:2px; width:18px; height:18px; border-radius:50%; background:#ff3b30; display:flex; align-items:center; justify-content:center;">
                                    <svg viewBox="0 0 24 24" style="width:12px; height:12px; fill:none; stroke:#fff; stroke-width:3;"><polyline points="20 6 9 17 4 12"></polyline></svg>
                                </div>` : ''}
                            </div>
                            <div style="display:flex; flex-direction:column; align-items:center; padding:0 4px; flex-shrink:0;">
                                <svg viewBox="0 0 24 24" style="width:12px; height:12px; fill:#ff6b81; stroke:none;">
                                    <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
                                </svg>
                                ${!avatarBatchDeleteMode ? `<div onclick="unpairCouple('${pid}')" style="margin-top:3px; font-size:9px; color:#ccc; cursor:pointer;">æ‹†å¼€</div>` : ''}
                            </div>
                            ${av2 ? `
                            <div onclick="${clickAction2}" style="width:60px; height:60px; border-radius:12px; overflow:hidden; cursor:pointer; border:1px solid #f0f0f0; position:relative; flex-shrink:0;">
                                <img src="${av2.url}" style="width:100%; height:100%; object-fit:cover; display:block; ${isBatch2 ? 'opacity:0.5;' : ''}" onerror="this.parentElement.style.background='#fafafa';">
                                ${isBatch2 ? `<div style="position:absolute; top:2px; right:2px; width:18px; height:18px; border-radius:50%; background:#ff3b30; display:flex; align-items:center; justify-content:center;">
                                    <svg viewBox="0 0 24 24" style="width:12px; height:12px; fill:none; stroke:#fff; stroke-width:3;"><polyline points="20 6 9 17 4 12"></polyline></svg>
                                </div>` : ''}
                            </div>
                            ` : '<div style="width:60px; height:60px; flex-shrink:0;"></div>'}
                        </div>
                    </div>
                `;
            }
            html += `</div>`;
        }
        
        // æœªé…å¯¹çš„å¤´åƒï¼ˆç½‘æ ¼å±•ç¤ºï¼‰
        if (unpaired.length > 0) {
            if (pairIds.length > 0) {
                html += `<div style="padding:12px 16px 6px; font-size:12px; color:#b0b0b0;">æœªé…å¯¹</div>`;
            }
            const gridItems = unpaired.map(av => {
                const isSelected = couplePairingMode && couplePairingFirst === av.id;
                const isBatchSel = avatarBatchDeleteMode && avatarBatchSelected.has(av.id);
                let clickAction;
                if (avatarBatchDeleteMode) {
                    clickAction = `toggleBatchSelect(${av.id})`;
                } else if (couplePairingMode) {
                    clickAction = `selectCoupleAvatar(${av.id})`;
                } else {
                    clickAction = `showAvatarPreview(${av.id})`;
                }
                return `
                    <div onclick="${clickAction}" 
                         style="aspect-ratio:1; overflow:hidden; cursor:pointer; position:relative; 
                         ${isSelected ? 'outline:3px solid #ff6b81; outline-offset:-3px; border-radius:4px;' : ''}">
                        <img src="${av.url}" style="width:100%; height:100%; object-fit:cover; display:block; 
                             ${isSelected || isBatchSel ? 'opacity:0.5;' : 'transition:opacity 0.2s;'}" 
                             onerror="this.style.display='none'; this.parentElement.style.background='#fafafa';">
                        ${isSelected ? `<div style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); 
                            width:28px; height:28px; border-radius:50%; background:#ff6b81; display:flex; align-items:center; justify-content:center;">
                            <span style="color:#fff; font-size:14px;">1</span>
                        </div>` : ''}
                        ${isBatchSel ? `<div style="position:absolute; top:4px; right:4px; width:20px; height:20px; border-radius:50%; background:#ff3b30; display:flex; align-items:center; justify-content:center;">
                            <svg viewBox="0 0 24 24" style="width:12px; height:12px; fill:none; stroke:#fff; stroke-width:3;"><polyline points="20 6 9 17 4 12"></polyline></svg>
                        </div>` : ''}
                    </div>
                `;
            }).join('');
            html += `<div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:1.5px;">${gridItems}</div>`;
        }
        
        // æ‰¹é‡æ¨¡å¼ä¸‹ç•™å‡ºåº•éƒ¨ç©ºé—´
        if (avatarBatchDeleteMode) {
            html += `<div style="height:60px;"></div>`;
        }
        
        content.innerHTML = html;
    } else {
        // å•äººå¤´åƒ - INSé£ä¸‰åˆ—ç½‘æ ¼
        let topBarHtml = '';
        if (avatars.length > 0) {
            topBarHtml = `<div style="display:flex; align-items:center; justify-content:flex-end; padding:10px 16px;">
                <div onclick="toggleAvatarBatchDelete()" style="padding:5px 14px; font-size:12px; border-radius:14px; cursor:pointer;
                    background:${avatarBatchDeleteMode ? '#ff3b30' : '#f5f5f5'}; color:${avatarBatchDeleteMode ? '#fff' : '#666'}; 
                    font-weight:500; transition:all 0.2s;">
                    ${avatarBatchDeleteMode ? 'å–æ¶ˆ' : 'æ‰¹é‡åˆ é™¤'}
                </div>
            </div>`;
            if (avatarBatchDeleteMode) {
                topBarHtml += `<div style="text-align:center; padding:0 16px 10px; font-size:12px; color:#ff3b30;">
                    ç‚¹å‡»å¤´åƒé€‰æ‹©è¦åˆ é™¤çš„å›¾ç‰‡
                </div>`;
            }
        }
        
        const gridHtml = avatars.map(av => {
            const isBatchSel = avatarBatchDeleteMode && avatarBatchSelected.has(av.id);
            const clickAction = avatarBatchDeleteMode ? `toggleBatchSelect(${av.id})` : `showAvatarPreview(${av.id})`;
            return `
                <div onclick="${clickAction}" style="aspect-ratio:1; overflow:hidden; cursor:pointer; position:relative;">
                    <img src="${av.url}" style="width:100%; height:100%; object-fit:cover; display:block; transition:opacity 0.2s; ${isBatchSel ? 'opacity:0.5;' : ''}" 
                         onmouseover="this.style.opacity='0.85'" onmouseout="this.style.opacity='${isBatchSel ? '0.5' : '1'}'" 
                         onerror="this.style.display='none'; this.parentElement.style.background='#fafafa';">
                    ${isBatchSel ? `<div style="position:absolute; top:4px; right:4px; width:20px; height:20px; border-radius:50%; background:#ff3b30; display:flex; align-items:center; justify-content:center;">
                        <svg viewBox="0 0 24 24" style="width:12px; height:12px; fill:none; stroke:#fff; stroke-width:3;"><polyline points="20 6 9 17 4 12"></polyline></svg>
                    </div>` : ''}
                </div>
            `;
        }).join('');
        
        let bottomPad = avatarBatchDeleteMode ? '<div style="height:60px;"></div>' : '';
        content.innerHTML = topBarHtml + `<div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:1.5px;">${gridHtml}</div>` + bottomPad;
    }
}

function showAvatarImportModal() {
    const modal = document.getElementById('avatar-import-modal');
    if (modal) {
        modal.style.display = 'flex';
        const urlArea = document.getElementById('avatar-url-input-area');
        if (urlArea) urlArea.style.display = 'none';
        const urlInput = document.getElementById('avatar-url-input');
        if (urlInput) urlInput.value = '';
    }
}

function hideAvatarImportModal() {
    const modal = document.getElementById('avatar-import-modal');
    if (modal) modal.style.display = 'none';
}

function showAvatarUrlInput() {
    const urlArea = document.getElementById('avatar-url-input-area');
    if (urlArea) {
        urlArea.style.display = 'block';
        const input = document.getElementById('avatar-url-input');
        if (input) input.focus();
    }
}

// ä»ç›¸å†Œæ–‡ä»¶å¯¼å…¥å¤´åƒ
async function handleAvatarFileImport(input) {
    if (!input.files || input.files.length === 0) return;
    
    const files = Array.from(input.files);
    let count = 0;
    
    for (const file of files) {
        try {
            const dataUrl = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
            
            await db.avatar_library.add({
                url: dataUrl,
                category: avatarLibraryMainTab,
                tag: avatarLibraryCurrentTag || '',
                time: Date.now(),
                source: 'file',
                fileName: file.name
            });
            count++;
        } catch (e) {
            console.error('[å¤´åƒåº“] å¯¼å…¥æ–‡ä»¶å¤±è´¥:', e);
        }
    }
    
    input.value = '';
    
    if (count > 0) {
        showToast(`å·²æ·»åŠ  ${count} å¼ å¤´åƒ`);
        renderAvatarLibrary();
    }
}

// ä»URLå¯¼å…¥å¤´åƒï¼ˆæ”¯æŒå¤šè¡Œæ‰¹é‡ç²˜è´´ï¼‰
async function importAvatarFromUrl() {
    const input = document.getElementById('avatar-url-input');
    const rawText = input ? input.value.trim() : '';
    
    if (!rawText) {
        showToast('è¯·è¾“å…¥å›¾ç‰‡é“¾æ¥');
        return;
    }
    
    // æŒ‰æ¢è¡Œåˆ†å‰²ï¼Œæ”¯æŒå¤šç§æ¢è¡Œç¬¦
    const lines = rawText.split(/[\r\n]+/).map(l => l.trim()).filter(l => l.length > 0);
    
    // è‡ªåŠ¨è¯†åˆ«æœ‰æ•ˆURL
    const validUrls = [];
    for (const line of lines) {
        if (line.startsWith('http://') || line.startsWith('https://') || line.startsWith('data:')) {
            validUrls.push(line);
        }
    }
    
    if (validUrls.length === 0) {
        showToast('æœªè¯†åˆ«åˆ°æœ‰æ•ˆçš„å›¾ç‰‡é“¾æ¥');
        return;
    }
    
    let count = 0;
    for (const url of validUrls) {
        try {
            await db.avatar_library.add({
                url: url,
                category: avatarLibraryMainTab,
                tag: avatarLibraryCurrentTag || '',
                time: Date.now() + count, // ä¿è¯æ—¶é—´é€’å¢ï¼Œé¡ºåºæ­£ç¡®
                source: 'url'
            });
            count++;
        } catch (e) {
            console.error('[å¤´åƒåº“] URLå¯¼å…¥å¤±è´¥:', url, e);
        }
    }
    
    if (count > 0) {
        input.value = '';
        hideAvatarImportModal();
        showToast(`å·²å¯¼å…¥ ${count} å¼ å¤´åƒ`);
        renderAvatarLibrary();
    } else {
        showToast('å¯¼å…¥å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
}

// é¢„è§ˆå¤´åƒ
async function showAvatarPreview(id) {
    const avatar = await db.avatar_library.get(id);
    if (!avatar) return;
    
    avatarPreviewCurrentId = id;
    
    const modal = document.getElementById('avatar-preview-modal');
    const img = document.getElementById('avatar-preview-img');
    
    if (modal && img) {
        img.src = avatar.url;
        modal.style.display = 'flex';
    }
}

function hideAvatarPreview() {
    const modal = document.getElementById('avatar-preview-modal');
    if (modal) modal.style.display = 'none';
    avatarPreviewCurrentId = null;
}

// è®¾ä¸ºå½“å‰è§’è‰²å¤´åƒ
async function useAvatarAsProfile() {
    if (!avatarPreviewCurrentId) return;
    
    const avatar = await db.avatar_library.get(avatarPreviewCurrentId);
    if (!avatar) return;
    
    if (!currentMyCharId) {
        showToast('è¯·å…ˆç™»å½•è´¦å·');
        return;
    }
    
    const myChar = await db.characters.get(parseInt(currentMyCharId));
    if (!myChar) {
        showToast('æœªæ‰¾åˆ°è§’è‰²ä¿¡æ¯');
        return;
    }
    
    const oldAvatar = myChar.avatar || '';
    myChar.avatar = avatar.url;
    if (avatar.url !== oldAvatar) {
        markUserAvatarChanged(myChar);
    }
    await safeCharacterPut(myChar);
    
    hideAvatarPreview();
    showToast('å¤´åƒè®¾ç½®æˆåŠŸ');
}

// ä»å¤´åƒåº“åˆ é™¤
async function deleteAvatarFromLibrary() {
    if (!avatarPreviewCurrentId) return;
    
    if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™å¼ å¤´åƒå—ï¼Ÿ')) return;
    
    try {
        await db.avatar_library.delete(avatarPreviewCurrentId);
        hideAvatarPreview();
        showToast('å·²åˆ é™¤');
        renderAvatarLibrary();
    } catch (e) {
        console.error('[å¤´åƒåº“] åˆ é™¤å¤±è´¥:', e);
        showToast('åˆ é™¤å¤±è´¥');
    }
}

// ========== æ‰¹é‡åˆ é™¤åŠŸèƒ½ ==========

// åˆ‡æ¢æ‰¹é‡åˆ é™¤æ¨¡å¼
function toggleAvatarBatchDelete() {
    avatarBatchDeleteMode = !avatarBatchDeleteMode;
    avatarBatchSelected.clear();
    // é€€å‡ºé…å¯¹æ¨¡å¼
    couplePairingMode = false;
    couplePairingFirst = null;
    renderAvatarLibrary();
    updateBatchDeleteBar();
}

// æ‰¹é‡é€‰ä¸­/å–æ¶ˆé€‰ä¸­å¤´åƒ
function toggleBatchSelect(id) {
    if (avatarBatchSelected.has(id)) {
        avatarBatchSelected.delete(id);
    } else {
        avatarBatchSelected.add(id);
    }
    renderAvatarLibrary();
    updateBatchDeleteBar();
}

// æ‰¹é‡å…¨é€‰å½“å‰åˆ†ç±»çš„å¤´åƒ
async function batchSelectAll() {
    let allInCategory = await db.avatar_library
        .where('category').equals(avatarLibraryMainTab)
        .toArray();
    if (avatarLibraryCurrentTag) {
        allInCategory = allInCategory.filter(a => a.tag === avatarLibraryCurrentTag);
    }
    if (avatarBatchSelected.size === allInCategory.length) {
        // å·²å…¨é€‰ï¼Œå–æ¶ˆå…¨é€‰
        avatarBatchSelected.clear();
    } else {
        avatarBatchSelected.clear();
        for (const av of allInCategory) {
            avatarBatchSelected.add(av.id);
        }
    }
    renderAvatarLibrary();
    updateBatchDeleteBar();
}

// æ›´æ–°åº•éƒ¨æ‰¹é‡æ“ä½œæ 
function updateBatchDeleteBar() {
    const bar = document.getElementById('avatar-batch-bar');
    if (!bar) return;
    if (avatarBatchDeleteMode) {
        bar.style.display = 'flex';
        const count = avatarBatchSelected.size;
        bar.innerHTML = `
            <div onclick="batchSelectAll()" style="padding:8px 16px; font-size:13px; color:#007aff; cursor:pointer; font-weight:500;">
                å…¨é€‰
            </div>
            <div style="flex:1; text-align:center; font-size:13px; color:#666;">
                å·²é€‰ <span style="color:#ff3b30; font-weight:600;">${count}</span> å¼ 
            </div>
            <div onclick="executeBatchDelete()" style="padding:8px 16px; font-size:13px; color:${count > 0 ? '#ff3b30' : '#ccc'}; cursor:${count > 0 ? 'pointer' : 'default'}; font-weight:600;">
                åˆ é™¤
            </div>
        `;
    } else {
        bar.style.display = 'none';
        bar.innerHTML = '';
    }
}

// æ‰§è¡Œæ‰¹é‡åˆ é™¤
async function executeBatchDelete() {
    const count = avatarBatchSelected.size;
    if (count === 0) {
        showToast('è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„å¤´åƒ');
        return;
    }
    
    if (!confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${count} å¼ å¤´åƒå—ï¼Ÿ`)) return;
    
    try {
        const ids = Array.from(avatarBatchSelected);
        for (const id of ids) {
            await db.avatar_library.delete(id);
        }
        avatarBatchSelected.clear();
        avatarBatchDeleteMode = false;
        updateBatchDeleteBar();
        renderAvatarLibrary();
        showToast(`å·²åˆ é™¤ ${count} å¼ å¤´åƒ`);
    } catch (e) {
        console.error('[å¤´åƒåº“] æ‰¹é‡åˆ é™¤å¤±è´¥:', e);
        showToast('åˆ é™¤å¤±è´¥');
    }
}

// åˆ‡æ¢é…å¯¹æ¨¡å¼
function toggleCouplePairingMode() {
    couplePairingMode = !couplePairingMode;
    couplePairingFirst = null;
    // é€€å‡ºæ‰¹é‡åˆ é™¤æ¨¡å¼
    avatarBatchDeleteMode = false;
    avatarBatchSelected.clear();
    updateBatchDeleteBar();
    renderAvatarLibrary();
}

// é…å¯¹æ¨¡å¼ä¸‹é€‰ä¸­å¤´åƒ
async function selectCoupleAvatar(id) {
    if (!couplePairingMode) return;
    
    if (couplePairingFirst === null) {
        // é€‰ä¸­ç¬¬ä¸€å¼ 
        couplePairingFirst = id;
        renderAvatarLibrary();
    } else if (couplePairingFirst === id) {
        // ç‚¹äº†åŒä¸€å¼ ï¼Œå–æ¶ˆé€‰ä¸­
        couplePairingFirst = null;
        renderAvatarLibrary();
    } else {
        // é€‰ä¸­ç¬¬äºŒå¼ ï¼Œå®Œæˆé…å¯¹
        const pairId = 'pair_' + Date.now();
        try {
            await db.avatar_library.update(couplePairingFirst, { pairId: pairId });
            await db.avatar_library.update(id, { pairId: pairId });
            couplePairingFirst = null;
            showToast('é…å¯¹æˆåŠŸ ğŸ’•');
            renderAvatarLibrary();
        } catch (e) {
            console.error('[å¤´åƒåº“] é…å¯¹å¤±è´¥:', e);
            showToast('é…å¯¹å¤±è´¥');
        }
    }
}

// å–æ¶ˆé…å¯¹ï¼ˆæ‹†å¼€ï¼‰
async function unpairCouple(pairId) {
    if (!confirm('ç¡®å®šè¦æ‹†å¼€è¿™å¯¹æƒ…å¤´å—ï¼Ÿ')) return;
    
    try {
        const paired = await db.avatar_library.toArray();
        const toUnpair = paired.filter(a => a.pairId === pairId);
        for (const av of toUnpair) {
            await db.avatar_library.update(av.id, { pairId: '' });
        }
        showToast('å·²æ‹†å¼€');
        renderAvatarLibrary();
    } catch (e) {
        console.error('[å¤´åƒåº“] å–æ¶ˆé…å¯¹å¤±è´¥:', e);
    }
}

// ============================================
// AIè‡ªä¸»æ¢å¤´åƒåŠŸèƒ½
// ============================================

// æ‰§è¡Œæ¢å¤´åƒï¼šä»å¤´åƒåº“éšæœºé€‰ä¸€å¼ å•äººå¤´åƒè®¾ä¸ºè§’è‰²å¤´åƒ
async function executeChangeAvatar(charId, accountId) {
    try {
        const singleAvatars = await db.avatar_library.where('category').equals('single').toArray();
        if (!singleAvatars || singleAvatars.length === 0) {
            console.log('[æ¢å¤´åƒ] å¤´åƒåº“ä¸­æ²¡æœ‰å•äººå¤´åƒ');
            return;
        }
        
        // è·å–è§’è‰²å½“å‰å¤´åƒ
        const char = await db.characters.get(charId);
        if (!char) return;
        
        const currentAvatarUrl = char.avatar || '';
        
        // ğŸ”¥ ä¿®å¤ï¼šè¿‡æ»¤æ‰æ— æ•ˆURLå’Œå½“å‰æ­£åœ¨ä½¿ç”¨çš„å¤´åƒï¼Œé¿å…"æ¢äº†ä½†æ²¡å˜"
        let availableAvatars = singleAvatars.filter(a => {
            if (!a.url || a.url.trim() === '') return false; // æ’é™¤ç©ºURL
            if (a.url === currentAvatarUrl) return false; // æ’é™¤å½“å‰å¤´åƒ
            return true;
        });
        
        // å¦‚æœè¿‡æ»¤åæ²¡æœ‰å¯é€‰çš„ï¼ˆæ¯”å¦‚åªæœ‰ä¸€å¼ ä¸”å°±æ˜¯å½“å‰å¤´åƒï¼‰ï¼Œç”¨å…¨éƒ¨
        if (availableAvatars.length === 0) {
            availableAvatars = singleAvatars.filter(a => a.url && a.url.trim() !== '');
            if (availableAvatars.length === 0) {
                console.log('[æ¢å¤´åƒ] å¤´åƒåº“ä¸­æ²¡æœ‰æœ‰æ•ˆçš„å¤´åƒURL');
                return;
            }
        }
        
        // éšæœºé€‰æ‹©ä¸€å¼ 
        const randomIndex = Math.floor(Math.random() * availableAvatars.length);
        const selectedAvatar = availableAvatars[randomIndex];
        
        console.log(`[æ¢å¤´åƒ] ${char.name} å‡†å¤‡æ¢å¤´åƒ, å¯é€‰: ${availableAvatars.length}å¼ , é€‰ä¸­ç¬¬${randomIndex + 1}å¼ `);
        
        // ğŸ”¥ ä¿®å¤ï¼šé‡æ–°è·å–æœ€æ–°çš„charï¼Œé˜²æ­¢å¹¶å‘ä¿®æ”¹è¦†ç›–
        const freshChar = await db.characters.get(charId);
        if (!freshChar) return;
        
        const currentAccountId = accountId || getCurrentAccountId();
        const oldAvatar = getCharAvatar(freshChar, currentAccountId);
        setCharAvatar(freshChar, currentAccountId, selectedAvatar.url);
        // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°å¤´åƒå­—æ®µï¼Œé˜²æ­¢è¦†ç›–è®¾ç½®
        const avatarPayload = currentAccountId
            ? { [`avatar_by_user.${currentAccountId}`]: selectedAvatar.url }
            : { avatar: selectedAvatar.url };
        await safeDexieUpdate(db.characters, charId, avatarPayload, `æ¢å¤´åƒ[${freshChar.name}]`);
        
        console.log(`[æ¢å¤´åƒ] ${freshChar.name} æ¢äº†æ–°å¤´åƒ (æ—§: ${oldAvatar?.substring(0, 50)}... â†’ æ–°: ${selectedAvatar.url.substring(0, 50)}...)`);
        
        // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ°èŠå¤©è®°å½•
        let history = getChatHistory(freshChar, currentAccountId);
        history.push({
            role: 'system',
            content: `${freshChar.name} æ›´æ¢äº†å¤´åƒ`,
            time: Date.now(),
            type: 'avatar_change'
        });
        await setChatHistory(freshChar, currentAccountId, history);
        
        // ğŸ”¥ ä¿®å¤ï¼šåˆ·æ–°UI - ä¸è®ºæ˜¯å¦åœ¨å½“å‰èŠå¤©é¡µéƒ½åˆ·æ–°ç›¸å…³UI
        if (currentChatCharId === charId) {
            // é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©é¡µé¢ï¼Œç¡®ä¿æ‰€æœ‰å¤´åƒç«‹å³æ›´æ–°ï¼ˆforceRender=true é˜²æ­¢ç¼“å­˜è·³è¿‡ï¼‰
            const updatedChar = await db.characters.get(charId);
            if (updatedChar) {
                renderChatBody(updatedChar, true);
            }
            // æ›´æ–°èŠå¤©æ ‡é¢˜æ çš„å¤´åƒï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
            const chatHeaderAvatar = document.querySelector('#chat-page .chat-header .msg-avatar, #chat-page .chat-header img');
            if (chatHeaderAvatar) {
                if (chatHeaderAvatar.tagName === 'IMG') {
                    chatHeaderAvatar.src = selectedAvatar.url;
                } else {
                    chatHeaderAvatar.style.backgroundImage = `url(${selectedAvatar.url})`;
                }
            }
        }
        
        // ğŸ”¥ ä¿®å¤ï¼šåŒæ—¶åˆ·æ–°å¾®ä¿¡åˆ—è¡¨ä¸­çš„å¤´åƒæ˜¾ç¤º
        try {
            const wechatContent = document.getElementById('wechat-content');
            if (wechatContent && wechatContent.innerHTML) {
                // æ‰¾åˆ°å¯¹åº”è§’è‰²çš„å¤´åƒå…ƒç´ å¹¶æ›´æ–°
                const avatarEls = wechatContent.querySelectorAll(`[data-char-id="${charId}"] .msg-avatar, [onclick*="openChat(${charId})"] .msg-avatar`);
                avatarEls.forEach(el => {
                    el.style.backgroundImage = `url(${selectedAvatar.url})`;
                });
                // å¦‚æœæ‰¾ä¸åˆ°ç‰¹å®šçš„ï¼Œåˆ·æ–°æ•´ä¸ªåˆ—è¡¨
                if (avatarEls.length === 0) {
                    renderWechatList(wechatContent);
                }
            }
        } catch (uiErr) {
            console.warn('[æ¢å¤´åƒ] åˆ·æ–°å¾®ä¿¡åˆ—è¡¨å¤´åƒå¤±è´¥:', uiErr);
        }
        
        showToast(`${freshChar.name} æ¢äº†æ–°å¤´åƒ`);
    } catch (e) {
        console.error('[æ¢å¤´åƒ] æ‰§è¡Œå¤±è´¥:', e);
    }
}

// å‘é€æƒ…å¤´é‚€è¯·å¡ç‰‡
async function sendCoupleAvatarCard(charId, accountId) {
    try {
        // æŸ¥æ‰¾å·²é…å¯¹çš„æƒ…å¤´
        const coupleAvatars = await db.avatar_library.where('category').equals('couple').toArray();
        const paired = {};
        for (const av of coupleAvatars) {
            if (av.pairId) {
                if (!paired[av.pairId]) paired[av.pairId] = [];
                paired[av.pairId].push(av);
            }
        }
        
        // åªå–å®Œæ•´é…å¯¹çš„ï¼ˆæœ‰2å¼ çš„ï¼‰
        const completePairs = Object.keys(paired).filter(k => paired[k].length === 2);
        
        if (completePairs.length === 0) {
            console.log('[æƒ…å¤´é‚€è¯·] æ²¡æœ‰å·²é…å¯¹çš„æƒ…å¤´');
            return false;
        }
        
        // éšæœºé€‰ä¸€å¯¹
        const randomPairId = completePairs[Math.floor(Math.random() * completePairs.length)];
        const pair = paired[randomPairId];
        const av1 = pair[0];
        const av2 = pair[1];
        
        const char = await db.characters.get(charId);
        if (!char) return false;
        
        // æ„å»ºæƒ…å¤´é‚€è¯·å¡ç‰‡HTML - ç´§å‡‘INSç™½è‰²é£æ ¼
        const cardHtml = `<div style="width:220px;background:#fff;border-radius:12px;overflow:hidden;box-shadow:0 1px 4px rgba(0,0,0,0.06);font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;"><div style="display:flex;align-items:center;justify-content:center;gap:0;padding:14px 16px 10px;"><div style="width:72px;height:72px;border-radius:50%;overflow:hidden;flex-shrink:0;box-shadow:0 0 0 1px rgba(0,0,0,0.04);"><img src="${av1.url}" style="width:100%;height:100%;object-fit:cover;display:block;" onerror="this.style.display='none'"></div><div style="padding:0 8px;display:flex;align-items:center;"><svg viewBox="0 0 24 24" style="width:14px;height:14px;fill:#ff6b81;stroke:none;opacity:0.8;"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg></div><div style="width:72px;height:72px;border-radius:50%;overflow:hidden;flex-shrink:0;box-shadow:0 0 0 1px rgba(0,0,0,0.04);"><img src="${av2.url}" style="width:100%;height:100%;object-fit:cover;display:block;" onerror="this.style.display='none'"></div></div><div style="text-align:center;padding:0 16px 12px;font-size:12px;color:#8e8e8e;letter-spacing:0.3px;">ä¸€èµ·æ¢æƒ…å¤´å§</div><div class="couple-card-actions" style="display:flex;border-top:0.5px solid #efefef;"><div onclick="acceptCoupleAvatar(this,${av1.id},${av2.id},${charId})" style="flex:1;text-align:center;padding:10px;font-size:13px;font-weight:500;color:#262626;cursor:pointer;">æ¢</div><div style="width:0.5px;background:#efefef;"></div><div onclick="declineCoupleAvatar(this)" style="flex:1;text-align:center;padding:10px;font-size:13px;color:#c7c7c7;cursor:pointer;">ç®—äº†</div></div></div>`;
        
        // å­˜å‚¨åˆ°èŠå¤©å†å²
        const freshChar = await db.characters.get(charId);
        if (freshChar) {
            let history = getChatHistory(freshChar, accountId);
            const cardMsg = {
                role: 'char',
                content: `[couple_avatar_card]${cardHtml}`,
                time: Date.now()
            };
            history.push(cardMsg);
            await setChatHistory(freshChar, accountId, history);
            
            // æ¸²æŸ“UI
            if (currentChatCharId === charId) {
                renderChatBody(freshChar);
            } else {
                sendSystemNotification(freshChar.name, '[æƒ…å¤´é‚€è¯·]');
            }
        }
        
        return true;
    } catch (e) {
        console.error('[æƒ…å¤´é‚€è¯·] å‘é€å¤±è´¥:', e);
        return false;
    }
}

// æ¥å—æƒ…å¤´é‚€è¯· - ç”¨æˆ·å’Œè§’è‰²éƒ½æ¢ä¸Šæƒ…å¤´
async function acceptCoupleAvatar(btn, av1Id, av2Id, charId) {
    try {
        const av1 = await db.avatar_library.get(av1Id);
        const av2 = await db.avatar_library.get(av2Id);
        
        if (!av1 || !av2) {
            showToast('å¤´åƒæ•°æ®ä¸å­˜åœ¨');
            return;
        }
        
        // è§’è‰²æ¢ç¬¬ä¸€å¼ ï¼Œç”¨æˆ·æ¢ç¬¬äºŒå¼ ï¼ˆæˆ–åè¿‡æ¥éšæœºï¼‰
        const useFirst = Math.random() > 0.5;
        const charAvatar = useFirst ? av1.url : av2.url;
        const userAvatar = useFirst ? av2.url : av1.url;
        
        // æ›´æ–°è§’è‰²å¤´åƒï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰â€” ä½¿ç”¨ update() åªæ›´æ–°å¤´åƒå­—æ®µ
        const char = await db.characters.get(charId);
        const _coupleAid = getCurrentAccountId();
        if (char) {
            const couplePayload = _coupleAid
                ? { [`avatar_by_user.${_coupleAid}`]: charAvatar }
                : { avatar: charAvatar };
            await safeDexieUpdate(db.characters, charId, couplePayload, `æƒ…å¤´[${char.name}]`);
            setCharAvatar(char, _coupleAid, charAvatar);
        }
        
        // æ›´æ–°ç”¨æˆ·å¤´åƒ
        if (currentMyCharId) {
            const myCharId = parseInt(currentMyCharId);
            const myChar = await db.characters.get(myCharId);
            if (myChar) {
                const oldAvatar = myChar.avatar || '';
                if (userAvatar !== oldAvatar) {
                    markUserAvatarChanged(myChar);
                    // ğŸ”§ ä¿®å¤ï¼šåŒæ—¶æŒä¹…åŒ– avatarUpdatedAtï¼Œé˜²æ­¢åˆ·æ–°åå¤´åƒé€šçŸ¥ä¸¢å¤±
                    await safeDexieUpdate(db.characters, myCharId, { avatar: userAvatar, avatarUpdatedAt: myChar.avatarUpdatedAt }, `æƒ…å¤´ç”¨æˆ·`);
                } else {
                    await safeDexieUpdate(db.characters, myCharId, { avatar: userAvatar }, `æƒ…å¤´ç”¨æˆ·`);
                }
                myChar.avatar = userAvatar;
            }
        }
        
        // æ›´æ–°æŒ‰é’®UI
        const cardEl = btn.closest('.couple-card-actions');
        if (cardEl) {
            cardEl.innerHTML = `<div style="flex:1;text-align:center;padding:10px;font-size:12px;color:#8e8e8e;">å·²æ¢ä¸Š â™¡</div>`;
        }
        
        // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ°èŠå¤©è®°å½•
        const accountId = getCurrentAccountId();
        let history = getChatHistory(char, accountId);
        history.push({
            role: 'system',
            content: `ä½ å’Œ ${char.name} æ¢ä¸Šäº†æƒ…å¤´ ğŸ’•`,
            time: Date.now(),
            type: 'couple_avatar_accepted'
        });
        await setChatHistory(char, accountId, history);
        
        // å¦‚æœå½“å‰æ­£åœ¨æŸ¥çœ‹èŠå¤©ï¼Œåˆ·æ–°
        if (currentChatCharId === charId) {
            const freshChar = await db.characters.get(charId);
            if (freshChar) renderChatBody(freshChar);
        }
        
        showToast('å·²æ¢ä¸Šæƒ…å¤´ ğŸ’•');
    } catch (e) {
        console.error('[æƒ…å¤´é‚€è¯·] æ¥å—å¤±è´¥:', e);
        showToast('æ¢å¤´åƒå¤±è´¥');
    }
}

// æ‹’ç»æƒ…å¤´é‚€è¯·
function declineCoupleAvatar(btn) {
    const cardEl = btn.closest('.couple-card-actions');
    if (cardEl) {
        cardEl.innerHTML = `<div style="flex:1;text-align:center;padding:10px;font-size:12px;color:#c7c7c7;">å·²å©‰æ‹’</div>`;
    }
}

// è§’è‰²æ¢å›å•äººå¤´åƒï¼ˆä»æƒ…å¤´æ¢å›æ¥ï¼‰
async function executeRevertCoupleAvatar(charId, accountId) {
    try {
        const singleAvatars = await db.avatar_library.where('category').equals('single').toArray();
        if (!singleAvatars || singleAvatars.length === 0) {
            console.log('[æ¢å›å•äººå¤´åƒ] å¤´åƒåº“ä¸­æ²¡æœ‰å•äººå¤´åƒ');
            return;
        }
        
        // éšæœºé€‰æ‹©ä¸€å¼ å•äººå¤´åƒ
        const randomIndex = Math.floor(Math.random() * singleAvatars.length);
        const selectedAvatar = singleAvatars[randomIndex];
        
        // æ›´æ–°è§’è‰²å¤´åƒï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰â€” ä½¿ç”¨ update() åªæ›´æ–°å¤´åƒå­—æ®µï¼Œé˜²æ­¢è¦†ç›–å…¶ä»–æ•°æ®
        const char = await db.characters.get(charId);
        if (!char) return;
        
        const _revertAid = getCurrentAccountId();
        const revertPayload = _revertAid
            ? { [`avatar_by_user.${_revertAid}`]: selectedAvatar.url }
            : { avatar: selectedAvatar.url };
        await safeDexieUpdate(db.characters, charId, revertPayload, `æ¢å›å•äººå¤´åƒ[${char.name}]`);
        // åŒæ­¥æ›´æ–°å†…å­˜ä¸­çš„charå¯¹è±¡
        setCharAvatar(char, _revertAid, selectedAvatar.url);
        
        console.log(`[æ¢å›å•äººå¤´åƒ] ${char.name} æ¢å›äº†å•äººå¤´åƒ`);
        
        // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ°èŠå¤©è®°å½•
        let history = getChatHistory(char, accountId);
        history.push({
            role: 'system',
            content: `${char.name} æ¢å›äº†å•äººå¤´åƒ`,
            time: Date.now(),
            type: 'revert_couple_avatar'
        });
        await setChatHistory(char, accountId, history);
        
        // ç«‹å³åˆ·æ–°UI
        if (currentChatCharId === charId) {
            const freshChar = await db.characters.get(charId);
            if (freshChar) {
                renderChatBody(freshChar);
            }
        }
        
        showToast(`${char.name} æ¢å›äº†å•äººå¤´åƒ`);
    } catch (e) {
        console.error('[æ¢å›å•äººå¤´åƒ] æ‰§è¡Œå¤±è´¥:', e);
    }
}

// è§’è‰²ä½¿ç”¨ç”¨æˆ·å‘é€çš„å›¾ç‰‡ä½œä¸ºå¤´åƒ
// imageIndex: ç¬¬å‡ å¼ å›¾ç‰‡ï¼ˆä»æœ€è¿‘å¾€å‰æ•°ï¼Œ1=æœ€è¿‘çš„ï¼Œ2=å€’æ•°ç¬¬2å¼ ...ï¼‰
async function executeUseImageAsAvatar(charId, accountId, imageIndex) {
    try {
        const char = await db.characters.get(charId);
        if (!char) return;
        
        // ä»èŠå¤©è®°å½•ä¸­æ”¶é›†ç”¨æˆ·å‘é€çš„æ‰€æœ‰å›¾ç‰‡ï¼ˆä»æ–°åˆ°æ—§ï¼‰
        let history = getChatHistory(char, accountId);
        let userImages = [];
        
        for (let i = history.length - 1; i >= 0; i--) {
            const msg = history[i];
            if (msg.role === 'user' && msg.content && msg.content.startsWith('[img:')) {
                // æå–å›¾ç‰‡URL
                const imgUrl = msg.content.substring(5, msg.content.length - 1);
                userImages.push({
                    url: imgUrl,
                    index: i,
                    desc: msg.imageDescription || ''
                });
            }
        }
        
        if (userImages.length === 0) {
            console.log('[ä½¿ç”¨å›¾ç‰‡å¤´åƒ] æ²¡æœ‰æ‰¾åˆ°ç”¨æˆ·å‘é€çš„å›¾ç‰‡');
            return;
        }
        
        // é€‰æ‹©ç¬¬ imageIndex å¼ ï¼ˆé»˜è®¤ç¬¬1å¼  = æœ€è¿‘çš„ï¼‰
        const targetIdx = Math.max(0, Math.min((imageIndex || 1) - 1, userImages.length - 1));
        const selectedImage = userImages[targetIdx];
        
        console.log(`[ä½¿ç”¨å›¾ç‰‡å¤´åƒ] ç”¨æˆ·å…±å‘é€ ${userImages.length} å¼ å›¾ç‰‡ï¼Œé€‰æ‹©ç¬¬ ${targetIdx + 1} å¼ ${selectedImage.desc ? `ï¼ˆæè¿°: ${selectedImage.desc}ï¼‰` : ''}`);
        
        // æ›´æ–°è§’è‰²å¤´åƒï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰â€” ä½¿ç”¨ update() åªæ›´æ–°å¤´åƒå­—æ®µï¼Œé˜²æ­¢è¦†ç›–å…¶ä»–æ•°æ®
        const _imgAid = getCurrentAccountId();
        const avatarPayload = _imgAid
            ? { [`avatar_by_user.${_imgAid}`]: selectedImage.url }
            : { avatar: selectedImage.url };
        await safeDexieUpdate(db.characters, charId, avatarPayload, `ä½¿ç”¨å›¾ç‰‡å¤´åƒ[${char.name}]`);
        // åŒæ­¥æ›´æ–°å†…å­˜ä¸­çš„charå¯¹è±¡ï¼ˆä¾›åç»­setChatHistoryä½¿ç”¨ï¼‰
        setCharAvatar(char, _imgAid, selectedImage.url);
        
        console.log(`[ä½¿ç”¨å›¾ç‰‡å¤´åƒ] ${char.name} ä½¿ç”¨äº†ç”¨æˆ·å‘é€çš„å›¾ç‰‡ä½œä¸ºå¤´åƒ`);
        
        // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ°èŠå¤©è®°å½•
        history = getChatHistory(char, accountId); // é‡æ–°è·å–æœ€æ–°
        history.push({
            role: 'system',
            content: `${char.name} æŠŠä½ å‘çš„å›¾ç‰‡æ¢æˆäº†å¤´åƒ`,
            time: Date.now(),
            type: 'use_image_avatar'
        });
        await setChatHistory(char, accountId, history);
        
        // ç«‹å³åˆ·æ–°UI
        if (currentChatCharId === charId) {
            const freshChar = await db.characters.get(charId);
            if (freshChar) {
                renderChatBody(freshChar);
            }
        }
        
        showToast(`${char.name} æ¢ä¸Šäº†ä½ å‘çš„å›¾ç‰‡ä½œä¸ºå¤´åƒ`);
    } catch (e) {
        console.error('[ä½¿ç”¨å›¾ç‰‡å¤´åƒ] æ‰§è¡Œå¤±è´¥:', e);
    }
}

// æ³¨å†Œå…¨å±€å‡½æ•°
window.showAvatarLibraryPage = showAvatarLibraryPage;
window.hideAvatarLibraryPage = hideAvatarLibraryPage;
window.switchAvatarTab = switchAvatarTab;
window.showAvatarImportModal = showAvatarImportModal;
window.hideAvatarImportModal = hideAvatarImportModal;
window.showAvatarUrlInput = showAvatarUrlInput;
window.handleAvatarFileImport = handleAvatarFileImport;
window.importAvatarFromUrl = importAvatarFromUrl;
window.showAvatarPreview = showAvatarPreview;
window.hideAvatarPreview = hideAvatarPreview;
window.useAvatarAsProfile = useAvatarAsProfile;
window.deleteAvatarFromLibrary = deleteAvatarFromLibrary;
window.selectAvatarSubTag = selectAvatarSubTag;
window.addSubTagDialog = addSubTagDialog;
window.showSubTagMenu = showSubTagMenu;
window.renameSubTag = renameSubTag;
window.deleteSubTag = deleteSubTag;
window.toggleCouplePairingMode = toggleCouplePairingMode;
window.selectCoupleAvatar = selectCoupleAvatar;
window.unpairCouple = unpairCouple;
window.toggleAvatarBatchDelete = toggleAvatarBatchDelete;
window.toggleBatchSelect = toggleBatchSelect;
window.batchSelectAll = batchSelectAll;
window.executeBatchDelete = executeBatchDelete;
window.executeChangeAvatar = executeChangeAvatar;
window.sendCoupleAvatarCard = sendCoupleAvatarCard;
window.acceptCoupleAvatar = acceptCoupleAvatar;
window.declineCoupleAvatar = declineCoupleAvatar;
window.executeRevertCoupleAvatar = executeRevertCoupleAvatar;
window.executeUseImageAsAvatar = executeUseImageAsAvatar;

// ============================================
// é¥¿ç¾äº†å¤–å–ç³»ç»Ÿ
// ============================================

// é¥¿ç¾äº†æ•°æ®å­˜å‚¨
let emeiData = {
    myCoupons: [], // æˆ‘çš„ä¼˜æƒ åˆ¸
    couponClaimCount: 3, // ä»Šæ—¥å‰©ä½™é¢†å–æ¬¡æ•°
    lastClaimDate: null, // ä¸Šæ¬¡é¢†å–æ—¥æœŸ
    currentStore: null, // å½“å‰é€‰ä¸­çš„åº—é“º
    cart: [], // è´­ç‰©è½¦
    selectedRecipient: 'self', // é€‰ä¸­çš„æ”¶è´§äºº
    selectedCoupon: null, // é€‰ä¸­çš„ä¼˜æƒ åˆ¸
    selectedPaymentMethod: null // é€‰ä¸­çš„æ”¯ä»˜æ–¹å¼
};

// é»˜è®¤åº—é“ºæ•°æ®ï¼ˆçœŸå®ç¾å›¢é£æ ¼ï¼‰
const defaultStores = [
    {
        id: 1,
        name: 'è‚¯å¾·åŸº',
        description: 'ç‚¸é¸¡æ±‰å ¡ | é…é€åˆ°å®¶',
        avatar: 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%23E4002B%22 width=%22100%22 height=%22100%22 rx=%2212%22/%3E%3Ctext x=%2250%22 y=%2265%22 font-size=%2240%22 text-anchor=%22middle%22 fill=%22%23fff%22 font-weight=%22bold%22%3EKFC%3C/text%3E%3C/svg%3E',
        sales: 5234,
        menu: [
            { id: 101, name: 'é¦™è¾£é¸¡è…¿å ¡', price: 18, image: 'ğŸ”' },
            { id: 102, name: 'åŸå‘³é¸¡å—', price: 12, image: 'ğŸ—' },
            { id: 103, name: 'è–¯æ¡ï¼ˆå¤§ï¼‰', price: 13, image: 'ğŸŸ' },
            { id: 104, name: 'è›‹æŒï¼ˆ2ä¸ªï¼‰', price: 10, image: 'ğŸ¥§' },
            { id: 105, name: 'å¯ä¹ï¼ˆå¤§ï¼‰', price: 9, image: 'ğŸ¥¤' },
            { id: 106, name: 'é¸¡ç±³èŠ±', price: 11, image: 'ğŸ¿' }
        ]
    },
    {
        id: 2,
        name: 'éº¦å½“åŠ³',
        description: 'æ±‰å ¡è–¯æ¡ | 24å°æ—¶è¥ä¸š',
        avatar: 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%23FFC72C%22 width=%22100%22 height=%22100%22 rx=%2212%22/%3E%3Ctext x=%2250%22 y=%2265%22 font-size=%2235%22 text-anchor=%22middle%22 fill=%22%23DA020E%22 font-weight=%22bold%22%3EM%3C/text%3E%3C/svg%3E',
        sales: 4892,
        menu: [
            { id: 201, name: 'å·¨æ— éœ¸', price: 25, image: 'ğŸ”' },
            { id: 202, name: 'éº¦è¾£é¸¡è…¿å ¡', price: 19, image: 'ğŸ”' },
            { id: 203, name: 'éº¦ä¹é¸¡å—ï¼ˆ10å—ï¼‰', price: 20, image: 'ğŸ—' },
            { id: 204, name: 'è–¯æ¡ï¼ˆå¤§ï¼‰', price: 13, image: 'ğŸŸ' },
            { id: 205, name: 'éº¦æ—‹é£', price: 15, image: 'ğŸ¦' },
            { id: 206, name: 'æ¿çƒ§é¸¡è…¿å ¡', price: 22, image: 'ğŸ”' }
        ]
    },
    {
        id: 3,
        name: 'èœœé›ªå†°åŸ',
        description: 'å†°æ·‡æ·‹ä¸èŒ¶ | è¶…é«˜æ€§ä»·æ¯”',
        avatar: 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%23E60012%22 width=%22100%22 height=%22100%22 rx=%2212%22/%3E%3Ctext x=%2250%22 y=%2245%22 font-size=%2228%22 text-anchor=%22middle%22 fill=%22%23fff%22%3EğŸ¦%3C/text%3E%3Ctext x=%2250%22 y=%2278%22 font-size=%2216%22 text-anchor=%22middle%22 fill=%22%23fff%22 font-weight=%22bold%22%3Eèœœé›ª%3C/text%3E%3C/svg%3E',
        sales: 8921,
        menu: [
            { id: 301, name: 'æŸ æª¬æ°´', price: 4, image: 'ğŸ‹' },
            { id: 302, name: 'å†°é²œæŸ æª¬èŒ¶', price: 5, image: 'ğŸµ' },
            { id: 303, name: 'æ‘‡æ‘‡å¥¶æ˜”', price: 6, image: 'ğŸ¥›' },
            { id: 304, name: 'å†°æ·‡æ·‹', price: 2, image: 'ğŸ¦' },
            { id: 305, name: 'æ£’æ‰“é²œæ©™', price: 6, image: 'ğŸŠ' },
            { id: 306, name: 'æ»¡æ¯ç™¾é¦™æœ', price: 7, image: 'ğŸ¥' },
            { id: 307, name: 'çç å¥¶èŒ¶', price: 7, image: 'ğŸ§‹' }
        ]
    },
    {
        id: 4,
        name: 'ç‘å¹¸å’–å•¡',
        description: 'ç²¾å“å’–å•¡ | æ–°ç”¨æˆ·é¦–æ¯å…è´¹',
        avatar: 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%230A3A6B%22 width=%22100%22 height=%22100%22 rx=%2212%22/%3E%3Ctext x=%2250%22 y=%2245%22 font-size=%2230%22 text-anchor=%22middle%22 fill=%22%23fff%22%3Eâ˜•%3C/text%3E%3Ctext x=%2250%22 y=%2278%22 font-size=%2214%22 text-anchor=%22middle%22 fill=%22%2300AEEF%22 font-weight=%22bold%22%3Eluckin%3C/text%3E%3C/svg%3E',
        sales: 7653,
        menu: [
            { id: 401, name: 'ç”Ÿæ¤°æ‹¿é“', price: 18, image: 'â˜•' },
            { id: 402, name: 'ç¾å¼å’–å•¡', price: 12, image: 'â˜•' },
            { id: 403, name: 'æ‹¿é“', price: 15, image: 'â˜•' },
            { id: 404, name: 'æ‘©å¡', price: 18, image: 'â˜•' },
            { id: 405, name: 'ç”Ÿé…ªæ‹¿é“', price: 20, image: 'â˜•' },
            { id: 406, name: 'æ¤°äº‘æ‹¿é“', price: 19, image: 'â˜•' },
            { id: 407, name: 'æŠ¹èŒ¶æ‹¿é“', price: 16, image: 'ğŸµ' }
        ]
    },
    {
        id: 5,
        name: 'å¿…èƒœå®¢',
        description: 'æŠ«è¨æ„é¢ | èšé¤ä¹‹é€‰',
        avatar: 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%23D4202C%22 width=%22100%22 height=%22100%22 rx=%2212%22/%3E%3Ctext x=%2250%22 y=%2245%22 font-size=%2232%22 text-anchor=%22middle%22 fill=%22%23fff%22%3EğŸ•%3C/text%3E%3Ctext x=%2250%22 y=%2278%22 font-size=%2212%22 text-anchor=%22middle%22 fill=%22%23fff%22 font-weight=%22bold%22%3EPizza Hut%3C/text%3E%3C/svg%3E',
        sales: 3421,
        menu: [
            { id: 501, name: 'è¶…çº§è‡³å°ŠæŠ«è¨ï¼ˆ9å¯¸ï¼‰', price: 68, image: 'ğŸ•' },
            { id: 502, name: 'é“ç›˜ç‰›è‚‰æŠ«è¨ï¼ˆ9å¯¸ï¼‰', price: 58, image: 'ğŸ•' },
            { id: 503, name: 'å¥¶æ²¹è˜‘è‡æ±¤', price: 18, image: 'ğŸ²' },
            { id: 504, name: 'æ„å¼è‚‰é…±é¢', price: 32, image: 'ğŸ' },
            { id: 505, name: 'çƒ¤é¸¡ç¿…ï¼ˆ6å—ï¼‰', price: 28, image: 'ğŸ—' },
            { id: 506, name: 'èŠå£«è›‹ç³•', price: 22, image: 'ğŸ°' }
        ]
    },
    {
        id: 6,
        name: 'æµ·åº•æå¤–é€',
        description: 'ç«é”…é£Ÿæ | åœ¨å®¶åƒç«é”…',
        avatar: 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%23C8102E%22 width=%22100%22 height=%22100%22 rx=%2212%22/%3E%3Ctext x=%2250%22 y=%2245%22 font-size=%2228%22 text-anchor=%22middle%22 fill=%22%23fff%22%3EğŸ²%3C/text%3E%3Ctext x=%2250%22 y=%2278%22 font-size=%2216%22 text-anchor=%22middle%22 fill=%22%23fff%22 font-weight=%22bold%22%3Eæµ·åº•æ%3C/text%3E%3C/svg%3E',
        sales: 2876,
        menu: [
            { id: 601, name: 'ç•ªèŒ„é”…åº•', price: 38, image: 'ğŸ…' },
            { id: 602, name: 'éº»è¾£é”…åº•', price: 42, image: 'ğŸŒ¶ï¸' },
            { id: 603, name: 'è‚¥ç‰›å·', price: 36, image: 'ğŸ¥©' },
            { id: 604, name: 'è™¾æ»‘', price: 28, image: 'ğŸ¦' },
            { id: 605, name: 'æ¯›è‚š', price: 32, image: 'ğŸ¥“' },
            { id: 606, name: 'åœŸè±†ç‰‡', price: 12, image: 'ğŸ¥”' },
            { id: 607, name: 'è±†è…', price: 10, image: 'ğŸ«˜' }
        ]
    },
    {
        id: 7,
        name: 'æ²™å¿å°åƒ',
        description: 'è’¸é¥ºæ‹Œé¢ | å®æƒ ç®¡é¥±',
        avatar: 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%23FF6B00%22 width=%22100%22 height=%22100%22 rx=%2212%22/%3E%3Ctext x=%2250%22 y=%2245%22 font-size=%2228%22 text-anchor=%22middle%22 fill=%22%23fff%22%3EğŸ¥Ÿ%3C/text%3E%3Ctext x=%2250%22 y=%2278%22 font-size=%2216%22 text-anchor=%22middle%22 fill=%22%23fff%22 font-weight=%22bold%22%3Eæ²™å¿%3C/text%3E%3C/svg%3E',
        sales: 6543,
        menu: [
            { id: 701, name: 'è’¸é¥ºï¼ˆä¸€ç¬¼ï¼‰', price: 6, image: 'ğŸ¥Ÿ' },
            { id: 702, name: 'æ‹Œé¢', price: 7, image: 'ğŸœ' },
            { id: 703, name: 'ç‚–ç½æ±¤', price: 8, image: 'ğŸ²' },
            { id: 704, name: 'æ‰é£Ÿï¼ˆé¦„é¥¨ï¼‰', price: 7, image: 'ğŸ¥Ÿ' },
            { id: 705, name: 'å¤è›‹', price: 2, image: 'ğŸ¥š' },
            { id: 706, name: 'é’èœ', price: 5, image: 'ğŸ¥¬' },
            { id: 707, name: 'å¤é¸¡è…¿', price: 8, image: 'ğŸ—' }
        ]
    },
    {
        id: 8,
        name: 'å…°å·æ‹‰é¢',
        description: 'æ‰‹å·¥æ‹‰é¢ | æ¸…çœŸç¾é£Ÿ',
        avatar: 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%2300875A%22 width=%22100%22 height=%22100%22 rx=%2212%22/%3E%3Ctext x=%2250%22 y=%2245%22 font-size=%2228%22 text-anchor=%22middle%22 fill=%22%23fff%22%3EğŸœ%3C/text%3E%3Ctext x=%2250%22 y=%2278%22 font-size=%2216%22 text-anchor=%22middle%22 fill=%22%23fff%22 font-weight=%22bold%22%3Eæ‹‰é¢%3C/text%3E%3C/svg%3E',
        sales: 4321,
        menu: [
            { id: 801, name: 'ç‰›è‚‰é¢', price: 15, image: 'ğŸœ' },
            { id: 802, name: 'ç‰›è‚‰æ‹Œé¢', price: 16, image: 'ğŸ' },
            { id: 803, name: 'é¸¡è›‹é¢', price: 10, image: 'ğŸœ' },
            { id: 804, name: 'ç‰›è‚‰ç›–æµ‡é¥­', price: 18, image: 'ğŸ›' },
            { id: 805, name: 'å‡‰çš®', price: 8, image: 'ğŸ¥—' },
            { id: 806, name: 'çƒ¤ç¾Šè‚‰ä¸²ï¼ˆ5ä¸²ï¼‰', price: 15, image: 'ğŸ¢' }
        ]
    },
    {
        id: 9,
        name: 'æ˜Ÿå·´å…‹',
        description: 'å’–å•¡ç”œå“ | å“è´¨ä¹‹é€‰',
        avatar: 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%2300704A%22 width=%22100%22 height=%22100%22 rx=%2212%22/%3E%3Ctext x=%2250%22 y=%2248%22 font-size=%2230%22 text-anchor=%22middle%22 fill=%22%23fff%22%3Eâ˜•%3C/text%3E%3Ctext x=%2250%22 y=%2278%22 font-size=%2211%22 text-anchor=%22middle%22 fill=%22%23fff%22 font-weight=%22bold%22%3ESTARBUCKS%3C/text%3E%3C/svg%3E',
        sales: 5678,
        menu: [
            { id: 901, name: 'ç„¦ç³–ç›å¥‡æœµï¼ˆå¤§æ¯ï¼‰', price: 38, image: 'â˜•' },
            { id: 902, name: 'æŠ¹èŒ¶æ˜Ÿå†°ä¹ï¼ˆå¤§æ¯ï¼‰', price: 39, image: 'ğŸµ' },
            { id: 903, name: 'ç¾å¼ï¼ˆå¤§æ¯ï¼‰', price: 28, image: 'â˜•' },
            { id: 904, name: 'æ‹¿é“ï¼ˆå¤§æ¯ï¼‰', price: 33, image: 'â˜•' },
            { id: 905, name: 'è”“è¶Šè“å¸åº·', price: 18, image: 'ğŸ§' },
            { id: 906, name: 'å·§å…‹åŠ›è›‹ç³•', price: 32, image: 'ğŸ°' }
        ]
    },
    {
        id: 10,
        name: 'å–œèŒ¶',
        description: 'æ–°å¼èŒ¶é¥® | çœŸèŒ¶çœŸæœ',
        avatar: 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%23000000%22 width=%22100%22 height=%22100%22 rx=%2212%22/%3E%3Ctext x=%2250%22 y=%2245%22 font-size=%2228%22 text-anchor=%22middle%22 fill=%22%23fff%22%3EğŸ§‹%3C/text%3E%3Ctext x=%2250%22 y=%2278%22 font-size=%2216%22 text-anchor=%22middle%22 fill=%22%23fff%22 font-weight=%22bold%22%3EHEYTEA%3C/text%3E%3C/svg%3E',
        sales: 6234,
        menu: [
            { id: 1001, name: 'å¤šè‚‰è‘¡è„', price: 25, image: 'ğŸ‡' },
            { id: 1002, name: 'èŠèŠèŠ’èŠ’', price: 28, image: 'ğŸ¥­' },
            { id: 1003, name: 'çƒ¤é»‘ç³–æ³¢æ³¢ç‰›ä¹³', price: 22, image: 'ğŸ§‹' },
            { id: 1004, name: 'çº¯ç»¿å¦èŒ¶å', price: 15, image: 'ğŸµ' },
            { id: 1005, name: 'èŠèŠè“è“', price: 26, image: 'ğŸ“' },
            { id: 1006, name: 'å¤šè‚‰èŠ’èŠ’ç”˜éœ²', price: 27, image: 'ğŸ¥­' }
        ]
    },
    {
        id: 11,
        name: 'åè±å£«',
        description: 'ç‚¸é¸¡æ±‰å ¡ | å¹³ä»·è¥¿å¼',
        avatar: 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%23FF4500%22 width=%22100%22 height=%22100%22 rx=%2212%22/%3E%3Ctext x=%2250%22 y=%2245%22 font-size=%2228%22 text-anchor=%22middle%22 fill=%22%23fff%22%3EğŸ”%3C/text%3E%3Ctext x=%2250%22 y=%2278%22 font-size=%2214%22 text-anchor=%22middle%22 fill=%22%23fff%22 font-weight=%22bold%22%3Eåè±å£«%3C/text%3E%3C/svg%3E',
        sales: 3987,
        menu: [
            { id: 1101, name: 'é¦™è¾£é¸¡è…¿å ¡', price: 10, image: 'ğŸ”' },
            { id: 1102, name: 'åŠ²è¾£é¸¡ç¿…ï¼ˆ4ä¸ªï¼‰', price: 12, image: 'ğŸ—' },
            { id: 1103, name: 'è–¯æ¡', price: 6, image: 'ğŸŸ' },
            { id: 1104, name: 'å¯ä¹', price: 4, image: 'ğŸ¥¤' },
            { id: 1105, name: 'è›‹æŒï¼ˆ2ä¸ªï¼‰', price: 6, image: 'ğŸ¥§' },
            { id: 1106, name: 'å…¨å®¶æ¡¶', price: 39, image: 'ğŸª£' }
        ]
    },
    {
        id: 12,
        name: 'æ¨å›½ç¦éº»è¾£çƒ«',
        description: 'éº»è¾£çƒ« | æŒ‰æ–¤ç§°é‡',
        avatar: 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%23CC0000%22 width=%22100%22 height=%22100%22 rx=%2212%22/%3E%3Ctext x=%2250%22 y=%2245%22 font-size=%2228%22 text-anchor=%22middle%22 fill=%22%23fff%22%3EğŸŒ¶ï¸%3C/text%3E%3Ctext x=%2250%22 y=%2278%22 font-size=%2214%22 text-anchor=%22middle%22 fill=%22%23fff%22 font-weight=%22bold%22%3Eæ¨å›½ç¦%3C/text%3E%3C/svg%3E',
        sales: 5123,
        menu: [
            { id: 1201, name: 'éº»è¾£çƒ«ï¼ˆå°ä»½ï¼‰', price: 18, image: 'ğŸ²' },
            { id: 1202, name: 'éº»è¾£çƒ«ï¼ˆå¤§ä»½ï¼‰', price: 28, image: 'ğŸ²' },
            { id: 1203, name: 'è‚¥ç‰›å·åŠ æ–™', price: 8, image: 'ğŸ¥©' },
            { id: 1204, name: 'é±¼ä¸¸åŠ æ–™', price: 5, image: 'ğŸŸ' },
            { id: 1205, name: 'å®½ç²‰åŠ æ–™', price: 4, image: 'ğŸœ' },
            { id: 1206, name: 'è±†çš®åŠ æ–™', price: 3, image: 'ğŸ«˜' },
            { id: 1207, name: 'ç±³é¥­', price: 2, image: 'ğŸš' }
        ]
    }
];

// ç”¨æˆ·è‡ªå®šä¹‰åº—é“ºï¼ˆä»DexieåŠ è½½ï¼‰
let customStores = [];

// è·å–æ‰€æœ‰åº—é“ºï¼ˆé»˜è®¤ + è‡ªå®šä¹‰ï¼‰
function getAllEmeiStores() {
    return [...defaultStores, ...customStores];
}

// ä»DexieåŠ è½½ç”¨æˆ·è‡ªå®šä¹‰åº—é“º
async function loadCustomStores() {
    try {
        const saved = await db.dexiData.get('emei_custom_stores');
        if (saved && saved.value) {
            customStores = JSON.parse(saved.value);
            console.log(`[é¥¿ç¾äº†] åŠ è½½äº† ${customStores.length} ä¸ªè‡ªå®šä¹‰åº—é“º`);
        }
    } catch (e) {
        console.error('[é¥¿ç¾äº†] åŠ è½½è‡ªå®šä¹‰åº—é“ºå¤±è´¥:', e);
    }
}

// ä¿å­˜è‡ªå®šä¹‰åº—é“ºåˆ°Dexie
async function saveCustomStores() {
    try {
        await db.dexiData.put({ key: 'emei_custom_stores', value: JSON.stringify(customStores) });
        console.log(`[é¥¿ç¾äº†] ä¿å­˜äº† ${customStores.length} ä¸ªè‡ªå®šä¹‰åº—é“º`);
    } catch (e) {
        console.error('[é¥¿ç¾äº†] ä¿å­˜è‡ªå®šä¹‰åº—é“ºå¤±è´¥:', e);
    }
}

// æ˜¾ç¤ºæ·»åŠ åº—é“ºå¼¹çª—
function showAddStoreModal() {
    // ç”Ÿæˆå”¯ä¸€ID
    const newId = Date.now();
    
    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    overlay.id = 'add-store-modal';
    overlay.style.display = 'flex';
    overlay.innerHTML = `
        <div class="modal-box" style="max-height: 85vh; overflow-y: auto; max-width: 380px;">
            <div style="font-size: 17px; font-weight: 600; text-align: center; margin-bottom: 20px;">æ·»åŠ è‡ªå®šä¹‰åº—é“º</div>
            
            <div style="margin-bottom: 14px;">
                <div style="font-size: 12px; color: #999; margin-bottom: 6px;">åº—é“ºåç§° *</div>
                <input type="text" id="add-store-name" placeholder="å¦‚ï¼šå°æ˜ç‚’é¥­" style="width: 100%; padding: 10px 14px; border: 1px solid #e5e5e5; border-radius: 10px; font-size: 14px; outline: none; box-sizing: border-box;">
            </div>
            
            <div style="margin-bottom: 14px;">
                <div style="font-size: 12px; color: #999; margin-bottom: 6px;">åº—é“ºæè¿°</div>
                <input type="text" id="add-store-desc" placeholder="å¦‚ï¼šå®¶å¸¸ç‚’èœ | å¥½åƒä¸è´µ" style="width: 100%; padding: 10px 14px; border: 1px solid #e5e5e5; border-radius: 10px; font-size: 14px; outline: none; box-sizing: border-box;">
            </div>
            
            <div style="margin-bottom: 14px;">
                <div style="font-size: 12px; color: #999; margin-bottom: 6px;">åº—é“ºå›¾æ ‡ (emoji)</div>
                <input type="text" id="add-store-emoji" placeholder="å¦‚ï¼šğŸ³" value="ğŸ½ï¸" style="width: 100%; padding: 10px 14px; border: 1px solid #e5e5e5; border-radius: 10px; font-size: 14px; outline: none; box-sizing: border-box;">
            </div>
            
            <div style="margin-bottom: 14px;">
                <div style="font-size: 12px; color: #999; margin-bottom: 6px;">ä¸»é¢˜è‰²</div>
                <input type="color" id="add-store-color" value="#FF6B9D" style="width: 100%; height: 40px; border: 1px solid #e5e5e5; border-radius: 10px; cursor: pointer; padding: 2px;">
            </div>
            
            <div style="margin-bottom: 14px;">
                <div style="font-size: 12px; color: #999; margin-bottom: 8px;">èœå•é¡¹ï¼ˆæ¯è¡Œä¸€ä¸ªï¼Œæ ¼å¼ï¼šèœå ä»·æ ¼ emojiï¼‰</div>
                <textarea id="add-store-menu" placeholder="å¦‚ï¼š&#10;è›‹ç‚’é¥­ 12 ğŸ³&#10;ç•ªèŒ„è›‹æ±¤ 8 ğŸ…&#10;çº¢çƒ§è‚‰ 22 ğŸ¥©&#10;å¯ä¹ 5 ğŸ¥¤" style="width: 100%; min-height: 140px; padding: 10px 14px; border: 1px solid #e5e5e5; border-radius: 10px; font-size: 13px; outline: none; resize: vertical; box-sizing: border-box; line-height: 1.8;"></textarea>
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 16px;">
                <button onclick="closeAddStoreModal()" style="flex: 1; padding: 12px; background: #f5f5f5; border: none; border-radius: 10px; font-size: 14px; color: #666; cursor: pointer;">å–æ¶ˆ</button>
                <button onclick="confirmAddStore()" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #ff6b9d 0%, #ff8fab 100%); border: none; border-radius: 10px; font-size: 14px; color: #fff; font-weight: 600; cursor: pointer; box-shadow: 0 4px 12px rgba(255,107,157,0.3);">æ·»åŠ </button>
            </div>
        </div>
    `;
    document.body.appendChild(overlay);
}

// å…³é—­æ·»åŠ åº—é“ºå¼¹çª—
function closeAddStoreModal() {
    const modal = document.getElementById('add-store-modal');
    if (modal) modal.remove();
}

// ç¡®è®¤æ·»åŠ åº—é“º
async function confirmAddStore() {
    const name = document.getElementById('add-store-name')?.value?.trim();
    const desc = document.getElementById('add-store-desc')?.value?.trim() || 'è‡ªå®šä¹‰åº—é“º';
    const emoji = document.getElementById('add-store-emoji')?.value?.trim() || 'ğŸ½ï¸';
    const color = document.getElementById('add-store-color')?.value || '#FF6B9D';
    const menuText = document.getElementById('add-store-menu')?.value?.trim() || '';
    
    if (!name) {
        showToast('âŒ è¯·è¾“å…¥åº—é“ºåç§°');
        return;
    }
    
    // è§£æèœå•
    const menuItems = [];
    const baseId = Date.now();
    if (menuText) {
        const lines = menuText.split('\n').filter(l => l.trim());
        lines.forEach((line, idx) => {
            const parts = line.trim().split(/\s+/);
            if (parts.length >= 2) {
                const itemName = parts[0];
                const price = parseFloat(parts[1]) || 10;
                const itemEmoji = parts[2] || 'ğŸ½ï¸';
                menuItems.push({ id: baseId + idx, name: itemName, price: price, image: itemEmoji });
            } else if (parts.length === 1) {
                menuItems.push({ id: baseId + idx, name: parts[0], price: 10, image: 'ğŸ½ï¸' });
            }
        });
    }
    
    if (menuItems.length === 0) {
        // æ²¡æœ‰èœå•å°±ç»™ä¸€ä¸ªé»˜è®¤é¡¹
        menuItems.push({ id: baseId, name: 'æ‹›ç‰Œèœ', price: 15, image: emoji });
    }
    
    // å°†é¢œè‰²è½¬ä¸ºhexç¼–ç ç”¨äºSVG
    const colorEncoded = encodeURIComponent(color);
    const nameShort = name.length > 3 ? name.substring(0, 3) : name;
    const nameEncoded = encodeURIComponent(nameShort);
    const emojiEncoded = encodeURIComponent(emoji);
    
    const newStore = {
        id: baseId,
        name: name,
        description: desc,
        avatar: `data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22${colorEncoded}%22 width=%22100%22 height=%22100%22 rx=%2212%22/%3E%3Ctext x=%2250%22 y=%2245%22 font-size=%2228%22 text-anchor=%22middle%22 fill=%22%23fff%22%3E${emojiEncoded}%3C/text%3E%3Ctext x=%2250%22 y=%2278%22 font-size=%2214%22 text-anchor=%22middle%22 fill=%22%23fff%22 font-weight=%22bold%22%3E${nameEncoded}%3C/text%3E%3C/svg%3E`,
        sales: Math.floor(Math.random() * 3000) + 500,
        menu: menuItems,
        isCustom: true // æ ‡è®°ä¸ºç”¨æˆ·è‡ªå®šä¹‰
    };
    
    customStores.push(newStore);
    await saveCustomStores();
    
    closeAddStoreModal();
    renderStoreList();
    showToast('âœ… åº—é“ºæ·»åŠ æˆåŠŸ');
}

// åˆ é™¤è‡ªå®šä¹‰åº—é“º
async function deleteCustomStore(storeId) {
    if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªåº—é“ºå—ï¼Ÿ')) return;
    
    customStores = customStores.filter(s => s.id !== storeId);
    await saveCustomStores();
    renderStoreList();
    showToast('âœ… åº—é“ºå·²åˆ é™¤');
}

// ç¼–è¾‘è‡ªå®šä¹‰åº—é“ºèœå•ï¼ˆæ·»åŠ èœå“ï¼‰
function showAddMenuItemModal(storeId) {
    const store = customStores.find(s => s.id === storeId);
    if (!store) return;
    
    const itemName = prompt('èœå“åç§°ï¼š');
    if (!itemName) return;
    
    const itemPrice = parseFloat(prompt('ä»·æ ¼ï¼ˆå…ƒï¼‰ï¼š') || '10');
    const itemEmoji = prompt('å›¾æ ‡emojiï¼ˆå¯é€‰ï¼‰ï¼š') || 'ğŸ½ï¸';
    
    store.menu.push({
        id: Date.now(),
        name: itemName,
        price: itemPrice,
        image: itemEmoji
    });
    
    saveCustomStores();
    
    // å¦‚æœå½“å‰æ­£åœ¨æŸ¥çœ‹è¿™ä¸ªåº—é“ºï¼Œåˆ·æ–°èœå•
    if (emeiData.currentStore && emeiData.currentStore.id === storeId) {
        emeiData.currentStore = store;
        renderEmeiMenu();
    }
    
    showToast('âœ… èœå“å·²æ·»åŠ ');
}

// åˆ é™¤è‡ªå®šä¹‰åº—é“ºçš„èœå“
async function deleteCustomMenuItem(storeId, itemId) {
    const store = customStores.find(s => s.id === storeId);
    if (!store) return;
    
    store.menu = store.menu.filter(m => m.id !== itemId);
    await saveCustomStores();
    
    // å¦‚æœå½“å‰æ­£åœ¨æŸ¥çœ‹è¿™ä¸ªåº—é“ºï¼Œåˆ·æ–°èœå•
    if (emeiData.currentStore && emeiData.currentStore.id === storeId) {
        emeiData.currentStore = store;
        renderEmeiMenu();
    }
    showToast('âœ… èœå“å·²åˆ é™¤');
}

// æ˜¾ç¤ºé¥¿ç¾äº†é¡µé¢
async function showEmeiPage() {
    const page = document.getElementById('emei-page');
    
    if (page) {
        page.style.display = 'flex';
        page.offsetHeight;
        page.classList.add('active');
        
        // åŠ è½½è‡ªå®šä¹‰åº—é“º
        await loadCustomStores();
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡ç½®æ¯æ—¥é¢†å–æ¬¡æ•°
        resetDailyCouponCount();
        
        // æ¸²æŸ“é¡µé¢
        renderEmeiMain();
    }
}

// éšè—é¥¿ç¾äº†é¡µé¢
function hideEmeiPage() {
    const page = document.getElementById('emei-page');
    
    if (page) {
        page.classList.remove('active');
        setTimeout(() => {
            page.style.display = 'none';
        }, 350);
    }
    
    // è¿”å›ä¸»è§†å›¾
    const mainView = document.getElementById('emei-main-view');
    const storeView = document.getElementById('emei-store-detail-view');
    const checkoutView = document.getElementById('emei-checkout-view');
    
    if (mainView) mainView.style.display = 'block';
    if (storeView) storeView.style.display = 'none';
    if (checkoutView) checkoutView.style.display = 'none';
}

// é‡ç½®æ¯æ—¥ä¼˜æƒ åˆ¸é¢†å–æ¬¡æ•°
function resetDailyCouponCount() {
    const today = new Date().toDateString();
    if (emeiData.lastClaimDate !== today) {
        emeiData.couponClaimCount = 3;
        emeiData.lastClaimDate = today;
    }
    
    // æ›´æ–°æ˜¾ç¤º
    const countEl = document.getElementById('emei-coupon-count');
    if (countEl) countEl.innerText = emeiData.couponClaimCount;
}

// æ¸²æŸ“ä¸»é¡µ
function renderEmeiMain() {
    // æ›´æ–°ä¼˜æƒ åˆ¸é¢†å–æ¬¡æ•°
    resetDailyCouponCount();
    
    // æ¸²æŸ“å·²é¢†å–çš„ä¼˜æƒ åˆ¸
    renderMyCoupons();
    
    // æ¸²æŸ“åº—é“ºåˆ—è¡¨
    renderStoreList();
}

// æ¸²æŸ“å·²é¢†å–çš„ä¼˜æƒ åˆ¸
function renderMyCoupons() {
    const container = document.getElementById('emei-my-coupons');
    if (!container) return;
    
    if (emeiData.myCoupons.length === 0) {
        container.style.display = 'none';
        return;
    }
    
    container.style.display = 'block';
    container.innerHTML = `
        <div style="font-size: 12px; color: #666; margin-bottom: 8px;">æˆ‘çš„ä¼˜æƒ åˆ¸</div>
        <div style="display: flex; gap: 8px; overflow-x: auto;">
            ${emeiData.myCoupons.map(coupon => `
                <div style="flex-shrink: 0; padding: 8px 16px; background: linear-gradient(135deg, #fff 0%, #fff9fa 100%); border: 1px solid rgba(255,107,157,0.2); border-radius: 8px; display: flex; flex-direction: column; align-items: center;">
                    <div style="font-size: 16px; font-weight: 600; color: var(--ins-pink);">${coupon.threshold}å‡${coupon.amount}</div>
                    <div style="font-size: 10px; color: #999; margin-top: 2px;">æ»¡${coupon.threshold}å¯ç”¨</div>
                </div>
            `).join('')}
        </div>
    `;
}

// é¢†å–ä¼˜æƒ åˆ¸
function claimEmeiCoupon() {
    if (emeiData.couponClaimCount <= 0) {
        alert('ä»Šæ—¥é¢†å–æ¬¡æ•°å·²ç”¨å®Œï¼Œæ˜å¤©å†æ¥å§ï¼');
        return;
    }
    
    // éšæœºç”Ÿæˆä¼˜æƒ åˆ¸
    const random = Math.random();
    let coupon;
    
    if (random < 0.7) {
        // 70%æ¦‚ç‡ï¼šå°é¢ä¼˜æƒ åˆ¸ (20-5)
        coupon = { threshold: 20, amount: 5, type: 'discount', expireDate: getExpireDate(7) };
    } else if (random < 0.9) {
        // 20%æ¦‚ç‡ï¼šä¸­é¢ä¼˜æƒ åˆ¸ (30-15)
        coupon = { threshold: 30, amount: 15, type: 'discount', expireDate: getExpireDate(7) };
    } else {
        // 10%æ¦‚ç‡ï¼šå¤§é¢ä¼˜æƒ åˆ¸ (20-15)
        coupon = { threshold: 20, amount: 15, type: 'discount', expireDate: getExpireDate(7) };
    }
    
    emeiData.myCoupons.push(coupon);
    emeiData.couponClaimCount--;
    
    // æ›´æ–°æ˜¾ç¤º
    document.getElementById('emei-coupon-count').innerText = emeiData.couponClaimCount;
    renderMyCoupons();
    
    // æç¤º
    alert(`ğŸ‰ æ­å–œé¢†å– ${coupon.threshold}å‡${coupon.amount} ä¼˜æƒ åˆ¸ï¼`);
}

// è·å–è¿‡æœŸæ—¥æœŸ
function getExpireDate(days) {
    const date = new Date();
    date.setDate(date.getDate() + days);
    return date.toLocaleDateString();
}

// æ¸²æŸ“åº—é“ºåˆ—è¡¨
function renderStoreList() {
    const container = document.getElementById('emei-store-list');
    if (!container) return;
    
    const allStores = getAllEmeiStores();
    
    container.innerHTML = allStores.map(store => {
        const rating = store.isCustom ? (4 + Math.random() * 0.9).toFixed(1) : '4.8';
        const deleteBtn = store.isCustom ? `<div onclick="event.stopPropagation(); deleteCustomStore(${store.id})" style="position: absolute; top: 8px; right: 8px; width: 24px; height: 24px; background: rgba(0,0,0,0.04); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 14px; color: #ccc; cursor: pointer;" onmouseover="this.style.color='#ff6b6b'; this.style.background='rgba(255,0,0,0.06)'" onmouseout="this.style.color='#ccc'; this.style.background='rgba(0,0,0,0.04)'">âœ•</div>` : '';
        const customTag = store.isCustom ? `<span style="font-size: 10px; padding: 2px 6px; background: #fff0f5; color: var(--ins-pink); border-radius: 4px; margin-left: 6px;">è‡ªå®šä¹‰</span>` : '';
        
        return `
        <div onclick="openEmeiStore(${store.id})" style="position: relative; background: #fff; border-radius: 16px; padding: 16px; margin-bottom: 12px; box-shadow: 0 2px 12px rgba(0,0,0,0.04); cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 16px rgba(0,0,0,0.08)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 12px rgba(0,0,0,0.04)'">
            ${deleteBtn}
            <div style="display: flex; gap: 12px;">
                <div style="width: 80px; height: 80px; border-radius: 12px; background-image: url(${store.avatar}); background-size: cover; background-color: #f5f5f5; flex-shrink: 0;"></div>
                <div style="flex: 1;">
                    <div style="font-size: 16px; font-weight: 600; color: #333; margin-bottom: 4px;">${store.name}${customTag}</div>
                    <div style="font-size: 12px; color: #999; margin-bottom: 8px;">${store.description}</div>
                    <div style="display: flex; gap: 12px; font-size: 11px; color: #666;">
                        <span>â­ ${rating}</span>
                        <span>æœˆå”® ${store.sales}+</span>
                    </div>
                </div>
            </div>
        </div>`;
    }).join('') + `
    <div onclick="showAddStoreModal()" style="background: #fafafa; border: 2px dashed #e0e0e0; border-radius: 16px; padding: 24px; margin-bottom: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; transition: all 0.2s;" onmouseover="this.style.borderColor='var(--ins-pink)'; this.style.background='#fff5f7'" onmouseout="this.style.borderColor='#e0e0e0'; this.style.background='#fafafa'">
        <svg width="20" height="20" fill="none" stroke="var(--ins-pink)" stroke-width="2" viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
        <span style="font-size: 14px; color: #999; font-weight: 500;">æ·»åŠ è‡ªå®šä¹‰åº—é“º</span>
    </div>`;
}


// æ‰“å¼€åº—é“ºè¯¦æƒ…
async function openEmeiStore(storeId) {
    const store = getAllEmeiStores().find(s => s.id === storeId);
    if (!store) return;
    
    emeiData.currentStore = store;
    emeiData.cart = [];
    
    // åˆ‡æ¢è§†å›¾
    document.getElementById('emei-main-view').style.display = 'none';
    document.getElementById('emei-store-detail-view').style.display = 'flex';
    
    // æ¸²æŸ“åº—é“ºä¿¡æ¯
    document.getElementById('emei-store-name').innerText = store.name;
    document.getElementById('emei-store-title').innerText = store.name;
    document.getElementById('emei-store-desc').innerText = store.description;
    document.getElementById('emei-store-sales').innerText = store.sales + '+';
    document.getElementById('emei-store-avatar').style.backgroundImage = `url(${store.avatar})`;
    
    // æ¸²æŸ“èœå•
    renderEmeiMenu();
    
    // æ¸²æŸ“æ”¶è´§äººé€‰é¡¹
    await renderRecipientOptions();
    
    // æ›´æ–°è´­ç‰©è½¦
    updateEmeiCart();
}

// è¿”å›ä¸»é¡µ
function backToEmeiMain() {
    const mainView = document.getElementById('emei-main-view');
    const storeView = document.getElementById('emei-store-detail-view');
    const checkoutView = document.getElementById('emei-checkout-view');
    
    if (mainView) mainView.style.display = 'block';
    if (storeView) storeView.style.display = 'none';
    if (checkoutView) checkoutView.style.display = 'none';
    emeiData.cart = [];
}

// æ¸²æŸ“èœå•
function renderEmeiMenu() {
    const container = document.getElementById('emei-menu-list');
    if (!container || !emeiData.currentStore) return;
    
    const store = emeiData.currentStore;
    const isCustom = store.isCustom;
    
    container.innerHTML = store.menu.map(item => `
        <div style="display: flex; align-items: center; justify-content: space-between; padding: 16px; background: #fff; border-radius: 12px; margin-bottom: 12px; box-shadow: 0 1px 4px rgba(0,0,0,0.04);">
            <div style="display: flex; align-items: center; gap: 12px; flex: 1;">
                <div style="width: 60px; height: 60px; background: linear-gradient(135deg, #fff5f7 0%, #ffeef2 100%); border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 32px;">${item.image}</div>
                <div style="flex: 1;">
                    <div style="font-size: 14px; font-weight: 500; color: #333; margin-bottom: 4px;">${item.name}${isCustom ? `<span onclick="event.stopPropagation(); deleteCustomMenuItem(${store.id}, ${item.id})" style="margin-left: 6px; font-size: 11px; color: #ccc; cursor: pointer;" title="åˆ é™¤èœå“">âœ•</span>` : ''}</div>
                    <div style="font-size: 16px; font-weight: 600; color: var(--ins-pink);">Â¥${item.price}</div>
                </div>
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
                <div onclick="decreaseEmeiItem(${item.id})" style="width: 28px; height: 28px; border: 1px solid #e5e5e5; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 18px; color: #666;">-</div>
                <div id="emei-item-count-${item.id}" style="min-width: 20px; text-align: center; font-size: 14px; font-weight: 500;">0</div>
                <div onclick="increaseEmeiItem(${item.id})" style="width: 28px; height: 28px; background: var(--ins-pink); border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 18px; color: #fff;">+</div>
            </div>
        </div>
    `).join('') + (isCustom ? `
    <div onclick="showAddMenuItemModal(${store.id})" style="background: #fafafa; border: 2px dashed #e0e0e0; border-radius: 12px; padding: 16px; margin-bottom: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px; transition: all 0.2s;" onmouseover="this.style.borderColor='var(--ins-pink)'; this.style.background='#fff5f7'" onmouseout="this.style.borderColor='#e0e0e0'; this.style.background='#fafafa'">
        <svg width="16" height="16" fill="none" stroke="var(--ins-pink)" stroke-width="2" viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
        <span style="font-size: 13px; color: #999;">æ·»åŠ èœå“</span>
    </div>` : '');
}

// æ¸²æŸ“æ”¶è´§äººé€‰é¡¹
async function renderRecipientOptions() {
    const select = document.getElementById('emei-recipient-select');
    if (!select) {
        console.warn('emei-recipient-select å…ƒç´ ä¸å­˜åœ¨');
        return;
    }
    
    try {
        // è·å–æ‰€æœ‰è§’è‰²
        const characters = await db.characters.toArray();
        console.log('æ•°æ®åº“ä¸­æ‰€æœ‰è§’è‰²:', characters.length);
        
        // è¿‡æ»¤æ‰ç³»ç»Ÿè§’è‰²å’Œåœ¨çº¿å¥½å‹ï¼Œåªæ˜¾ç¤ºå¯ä»¥é…é€çš„è§’è‰²
        const availableChars = characters.filter(c => {
            // æ’é™¤ç³»ç»Ÿè§’è‰²ã€åœ¨çº¿å¥½å‹ç­‰
            if (c.type === 'system' || c.type === 'online_friend') return false;
            // åªæ˜¾ç¤ºæœ‰åå­—çš„è§’è‰²
            if (!c.name || c.name.trim() === '') return false;
            return true;
        });
        
        console.log('å¯ç”¨è§’è‰²:', availableChars.length, availableChars.map(c => c.name));
        
        let html = '<option value="self">æˆ‘è‡ªå·±</option>';
        availableChars.forEach(char => {
            const safeName = (char.name || '').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
            html += `<option value="${char.id}">${safeName}</option>`;
        });
        
        select.innerHTML = html;
        select.value = emeiData.selectedRecipient;
        
        console.log('å·²åŠ è½½', availableChars.length, 'ä¸ªè§’è‰²åˆ°é…é€åˆ—è¡¨');
    } catch (err) {
        console.error('åŠ è½½è§’è‰²åˆ—è¡¨å¤±è´¥:', err);
        select.innerHTML = '<option value="self">æˆ‘è‡ªå·±</option>';
    }
}

// å¢åŠ å•†å“æ•°é‡
function increaseEmeiItem(itemId) {
    if (!emeiData.currentStore) return;
    
    const item = emeiData.currentStore.menu.find(m => m.id === itemId);
    if (!item) return;
    
    const cartItem = emeiData.cart.find(c => c.id === itemId);
    if (cartItem) {
        cartItem.count++;
    } else {
        emeiData.cart.push({ ...item, count: 1 });
    }
    
    updateEmeiCart();
}

// å‡å°‘å•†å“æ•°é‡
function decreaseEmeiItem(itemId) {
    const cartItem = emeiData.cart.find(c => c.id === itemId);
    if (!cartItem) return;
    
    cartItem.count--;
    if (cartItem.count <= 0) {
        emeiData.cart = emeiData.cart.filter(c => c.id !== itemId);
    }
    
    updateEmeiCart();
}

// æ›´æ–°è´­ç‰©è½¦æ˜¾ç¤º
function updateEmeiCart() {
    // æ›´æ–°æ•°é‡æ˜¾ç¤º
    if (emeiData.currentStore) {
        emeiData.currentStore.menu.forEach(item => {
            const countEl = document.getElementById(`emei-item-count-${item.id}`);
            if (countEl) {
                const cartItem = emeiData.cart.find(c => c.id === item.id);
                countEl.innerText = cartItem ? cartItem.count : 0;
            }
        });
    }
    
    // æ›´æ–°æ€»ä»·
    const total = emeiData.cart.reduce((sum, item) => sum + item.price * item.count, 0);
    const totalEl = document.getElementById('emei-total-price');
    if (totalEl) totalEl.innerText = total.toFixed(2);
}

// æ›´æ–°æ”¶è´§äºº
function updateEmeiRecipient(value) {
    emeiData.selectedRecipient = value;
}


// æ˜¾ç¤ºç»“ç®—é¡µé¢
async function showEmeiCheckout() {
    if (emeiData.cart.length === 0) {
        alert('è´­ç‰©è½¦æ˜¯ç©ºçš„ï¼Œå¿«å»é€‰ç‚¹åƒçš„å§ï¼');
        return;
    }
    
    const recipientSelect = document.getElementById('emei-recipient-select');
    emeiData.selectedRecipient = recipientSelect ? recipientSelect.value : 'self';
    
    // åˆ‡æ¢è§†å›¾
    document.getElementById('emei-store-detail-view').style.display = 'none';
    document.getElementById('emei-checkout-view').style.display = 'flex';
    
    // æ¸²æŸ“æ”¶è´§äººä¿¡æ¯
    await renderCheckoutRecipient();
    
    // æ¸²æŸ“è®¢å•è¯¦æƒ…
    renderCheckoutItems();
    
    // è®¡ç®—ä»·æ ¼
    calculateCheckoutPrice();
    
    // åŠ è½½é’±åŒ…ä½™é¢
    await loadEmeiWalletBalance();
}

// è¿”å›åº—é“ºé¡µé¢
function backToEmeiStore() {
    const storeView = document.getElementById('emei-store-detail-view');
    const checkoutView = document.getElementById('emei-checkout-view');
    
    if (storeView) storeView.style.display = 'flex';
    if (checkoutView) checkoutView.style.display = 'none';
}

// æ¸²æŸ“æ”¶è´§äººä¿¡æ¯
async function renderCheckoutRecipient() {
    const avatar = document.getElementById('emei-recipient-avatar');
    const name = document.getElementById('emei-recipient-name');
    
    if (emeiData.selectedRecipient === 'self') {
        name.innerText = 'æˆ‘è‡ªå·±';
        avatar.style.backgroundImage = 'url(https://api.dicebear.com/7.x/avataaars/svg?seed=self)';
    } else {
        const char = await db.characters.get(parseInt(emeiData.selectedRecipient));
        if (char) {
            name.innerText = char.name;
            avatar.style.backgroundImage = `url(${char.avatar})`;
            avatar.style.backgroundSize = 'cover';
        }
    }
}

// æ¸²æŸ“è®¢å•è¯¦æƒ…
function renderCheckoutItems() {
    const container = document.getElementById('emei-checkout-items');
    if (!container) return;
    
    container.innerHTML = emeiData.cart.map(item => `
        <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #f5f5f5;">
            <div style="flex: 1;">
                <span style="font-size: 14px; color: #333;">${item.name}</span>
                <span style="font-size: 12px; color: #999; margin-left: 8px;">x${item.count}</span>
            </div>
            <div style="font-size: 14px; color: #333;">Â¥${(item.price * item.count).toFixed(2)}</div>
        </div>
    `).join('');
}

// è®¡ç®—ä»·æ ¼
function calculateCheckoutPrice() {
    const subtotal = emeiData.cart.reduce((sum, item) => sum + item.price * item.count, 0);
    const delivery = 3;
    let discount = 0;
    
    // è®¡ç®—ä¼˜æƒ åˆ¸æŠ˜æ‰£
    if (emeiData.selectedCoupon) {
        if (subtotal >= emeiData.selectedCoupon.threshold) {
            discount = emeiData.selectedCoupon.amount;
        } else {
            emeiData.selectedCoupon = null;
            document.getElementById('emei-selected-coupon-text').innerText = 'æœªä½¿ç”¨';
        }
    }
    
    const total = Math.max(subtotal + delivery - discount, 0.01);
    
    // æ›´æ–°æ˜¾ç¤º
    document.getElementById('emei-checkout-subtotal').innerText = subtotal.toFixed(2);
    document.getElementById('emei-checkout-delivery').innerText = delivery.toFixed(2);
    document.getElementById('emei-checkout-total').innerText = total.toFixed(2);
    
    if (discount > 0) {
        document.getElementById('emei-checkout-discount').innerText = discount.toFixed(2);
        document.getElementById('emei-checkout-discount-row').style.display = 'flex';
    } else {
        document.getElementById('emei-checkout-discount-row').style.display = 'none';
    }
}

// é€‰æ‹©ä¼˜æƒ åˆ¸
function selectEmeiCoupon() {
    const modal = document.getElementById('emei-coupon-modal');
    const list = document.getElementById('emei-coupon-list');
    
    if (!modal || !list) return;
    
    const subtotal = emeiData.cart.reduce((sum, item) => sum + item.price * item.count, 0);
    
    if (emeiData.myCoupons.length === 0) {
        alert('æš‚æ— å¯ç”¨ä¼˜æƒ åˆ¸');
        return;
    }
    
    list.innerHTML = emeiData.myCoupons.map((coupon, index) => {
        const canUse = subtotal >= coupon.threshold;
        return `
            <div onclick="${canUse ? `useEmeiCoupon(${index})` : ''}" style="padding: 16px; background: ${canUse ? '#fff' : '#f5f5f5'}; border: 2px solid ${emeiData.selectedCoupon === coupon ? 'var(--ins-pink)' : '#e5e5e5'}; border-radius: 12px; margin-bottom: 12px; cursor: ${canUse ? 'pointer' : 'not-allowed'}; opacity: ${canUse ? '1' : '0.5'};">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="font-size: 18px; font-weight: 600; color: var(--ins-pink);">${coupon.threshold}å‡${coupon.amount}</div>
                        <div style="font-size: 12px; color: #999; margin-top: 4px;">æ»¡${coupon.threshold}å¯ç”¨ | æœ‰æ•ˆæœŸè‡³${coupon.expireDate}</div>
                    </div>
                    ${canUse ? `<svg width="20" height="20" fill="${emeiData.selectedCoupon === coupon ? 'var(--ins-pink)' : '#ccc'}" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/></svg>` : '<span style="font-size: 11px; color: #999;">ä¸å¯ç”¨</span>'}
                </div>
            </div>
        `;
    }).join('');
    
    modal.style.display = 'flex';
}

// ä½¿ç”¨ä¼˜æƒ åˆ¸
function useEmeiCoupon(index) {
    emeiData.selectedCoupon = emeiData.myCoupons[index];
    document.getElementById('emei-selected-coupon-text').innerText = `${emeiData.selectedCoupon.threshold}å‡${emeiData.selectedCoupon.amount}`;
    closeEmeiCouponModal();
    calculateCheckoutPrice();
}

// å…³é—­ä¼˜æƒ åˆ¸å¼¹çª—
function closeEmeiCouponModal() {
    const modal = document.getElementById('emei-coupon-modal');
    if (modal) modal.style.display = 'none';
}

// åŠ è½½é’±åŒ…ä½™é¢
async function loadEmeiWalletBalance() {
    const accountId = getCurrentAccountId();
    let balance = 0;
    
    try {
        // ğŸ”§ ä»å½“å‰ç™»å½•è§’è‰²çš„ identity.balance è·å–ä½™é¢
        if (accountId) {
            const myChar = await db.characters.get(parseInt(accountId));
            if (myChar && myChar.identity) {
                balance = parseFloat(myChar.identity.balance || 0);
            }
        }
    } catch (err) {
        console.error('åŠ è½½é’±åŒ…ä½™é¢å¤±è´¥:', err);
    }
    
    const balanceEl = document.getElementById('emei-wallet-balance');
    if (balanceEl) balanceEl.innerText = balance.toFixed(2);
    
    // åŠ è½½äº²å±å¡ä¿¡æ¯
    await loadFamilyCardInfo();
}

// åŠ è½½äº²å±å¡ä¿¡æ¯
async function loadFamilyCardInfo() {
    const info = document.getElementById('emei-family-card-info');
    if (!info) return;
    
    try {
        // ğŸ”§ ä½¿ç”¨å½“å‰è´¦å·è§’è‰²æ”¶åˆ°çš„äº²å±å¡
        const myCharId = parseInt(currentMyCharId);
        const myChar = myCharId ? await db.characters.get(myCharId) : null;
        const cards = myChar?.identity?.familyCardsReceived || [];
        
        if (cards.length > 0) {
            const card = cards[0];
            info.innerText = `æ¥è‡ª ${card.fromName}`;
        } else {
            info.innerText = 'æœªç»‘å®š';
        }
    } catch (err) {
        info.innerText = 'æœªç»‘å®š';
    }
}


// æ˜¾ç¤ºæ”¯ä»˜æ–¹å¼å¼¹çª—
async function showEmeiPaymentModal() {
    const modal = document.getElementById('emei-payment-modal');
    if (modal) {
        modal.style.display = 'flex';
        emeiData.selectedPaymentMethod = null;
        
        // æ¸…é™¤æ‰€æœ‰é€‰ä¸­çŠ¶æ€
        document.querySelectorAll('.emei-payment-option').forEach(opt => {
            opt.style.borderColor = '#f0f0f0';
        });
        document.querySelectorAll('input[name="emei-payment"]').forEach(input => {
            input.checked = false;
        });
        
        // ğŸ”§ è·å–å½“å‰è´¦å·çš„ä½™é¢ï¼ˆä»è§’è‰²çš„identity.balanceè·å–ï¼‰
        const accountId = getCurrentAccountId();
        let balance = 0;
        if (accountId) {
            const myChar = await db.characters.get(parseInt(accountId));
            if (myChar && myChar.identity) {
                balance = parseFloat(myChar.identity.balance || 0);
            }
        }
        const balanceEl = document.getElementById('emei-wallet-balance');
        if (balanceEl) balanceEl.textContent = balance.toFixed(2);
        
        // ğŸ”§ è·å–å½“å‰è´¦å·çš„äº²å±å¡
        const myCharId = parseInt(currentMyCharId);
        const myChar = myCharId ? await db.characters.get(myCharId) : null;
        const familyCards = myChar?.identity?.familyCardsReceived || [];
        const familyCardEl = document.getElementById('emei-family-card-info');
        if (familyCardEl) {
            if (familyCards.length > 0) {
                const card = familyCards[0]; // ä½¿ç”¨ç¬¬ä¸€å¼ äº²å±å¡
                familyCardEl.textContent = `æ¥è‡ª ${card.fromName}`;
            } else {
                familyCardEl.textContent = 'æœªç»‘å®š';
            }
        }
    }
}

// å…³é—­æ”¯ä»˜æ–¹å¼å¼¹çª—
function closeEmeiPaymentModal() {
    const modal = document.getElementById('emei-payment-modal');
    if (modal) modal.style.display = 'none';
}

// é€‰æ‹©æ”¯ä»˜æ–¹å¼
function selectEmeiPaymentMethod(method) {
    emeiData.selectedPaymentMethod = method;
    
    // æ›´æ–°é€‰ä¸­çŠ¶æ€
    document.querySelectorAll('.emei-payment-option').forEach(opt => {
        opt.style.borderColor = '#f0f0f0';
    });
    document.querySelectorAll('input[name="emei-payment"]').forEach(input => {
        input.checked = input.value === method;
        if (input.checked) {
            input.closest('.emei-payment-option').style.borderColor = 'var(--ins-pink)';
        }
    });
}

// ç¡®è®¤æ”¯ä»˜
async function confirmEmeiPayment() {
    if (!emeiData.selectedPaymentMethod) {
        alert('è¯·é€‰æ‹©æ”¯ä»˜æ–¹å¼');
        return;
    }
    
    const subtotal = emeiData.cart.reduce((sum, item) => sum + item.price * item.count, 0);
    const delivery = 3;
    const discount = emeiData.selectedCoupon ? emeiData.selectedCoupon.amount : 0;
    const total = subtotal + delivery - discount;
    
    closeEmeiPaymentModal();
    
    // æ ¹æ®ä¸åŒæ”¯ä»˜æ–¹å¼å¤„ç†
    if (emeiData.selectedPaymentMethod === 'wallet') {
        await payWithWallet(total);
    } else if (emeiData.selectedPaymentMethod === 'family') {
        await payWithFamilyCard(total);
    } else if (emeiData.selectedPaymentMethod === 'request') {
        await requestPayment(total);
    }
}

// é›¶é’±æ”¯ä»˜
async function payWithWallet(amount) {
    const accountId = getCurrentAccountId();
    if (!accountId) {
        alert('è¯·å…ˆç™»å½•è´¦å·');
        return;
    }
    
    // ğŸ”§ ä»å½“å‰ç™»å½•è§’è‰²çš„ identity.balance è·å–ä½™é¢
    const myChar = await db.characters.get(parseInt(accountId));
    if (!myChar) {
        alert('è´¦å·æ•°æ®å¼‚å¸¸');
        return;
    }
    
    if (!myChar.identity) myChar.identity = {};
    const balance = parseFloat(myChar.identity.balance || 0);
    
    if (balance < amount) {
        alert('ä½™é¢ä¸è¶³ï¼Œè¯·é€‰æ‹©å…¶ä»–æ”¯ä»˜æ–¹å¼');
        return;
    }
    
    // æ‰£æ¬¾
    myChar.identity.balance = (balance - amount).toFixed(2);
    await safeCharacterPut(myChar);
    
    // å‘é€è®¢å•å¡ç‰‡
    await sendEmeiOrderCard();
    
    alert('æ”¯ä»˜æˆåŠŸï¼');
    
    // ğŸ”§ å¦‚æœæ˜¯ç»™è‡ªå·±ç‚¹å•ï¼Œè¯¢é—®æ˜¯å¦åˆ†äº«ç»™å¥½å‹
    if (emeiData.selectedRecipient === 'self') {
        showShareOrderModal(amount);
    } else {
        hideEmeiPage();
    }
}

// äº²å±å¡æ”¯ä»˜
async function payWithFamilyCard(amount) {
    // ğŸ”§ ä½¿ç”¨å½“å‰è´¦å·è§’è‰²æ”¶åˆ°çš„äº²å±å¡
    const myCharId = parseInt(currentMyCharId);
    const myChar = myCharId ? await db.characters.get(myCharId) : null;
    const cards = myChar?.identity?.familyCardsReceived || [];
    
    if (cards.length === 0) {
        alert('æœªç»‘å®šäº²å±å¡ï¼Œè¯·å…ˆç»‘å®š');
        return;
    }
    
    // ä½¿ç”¨ç¬¬ä¸€å¼ äº²å±å¡
    const card = cards[0];
    
    // æ‰£æ¬¾é€»è¾‘ï¼ˆè¿™é‡Œç®€åŒ–å¤„ç†ï¼‰
    // å®é™…åº”è¯¥ä»å¡ä¸»è´¦æˆ·æ‰£æ¬¾
    
    // å‘é€è®¢å•å¡ç‰‡å’Œé€šçŸ¥
    await sendEmeiOrderCard();
    
    alert('æ”¯ä»˜æˆåŠŸï¼å·²ä½¿ç”¨äº²å±å¡æ”¯ä»˜');
    hideEmeiPage();
}

// ç”³è¯·ä»£ä»˜
async function requestPayment(amount) {
    // è·å–ä»£ä»˜å¯¹è±¡ï¼ˆå¯ä»¥é€‰æ‹©ä»»æ„è§’è‰²ï¼‰
    const allCharacters = await db.characters.toArray();
    const availableChars = allCharacters.filter(c => {
        if (c.type === 'system' || c.type === 'online_friend') return false;
        if (!c.name || c.name.trim() === '') return false;
        return true;
    });
    
    if (availableChars.length === 0) {
        alert('æ²¡æœ‰å¯é€‰æ‹©çš„ä»£ä»˜å¯¹è±¡');
        return;
    }
    
    // å¼¹å‡ºé€‰æ‹©ä»£ä»˜å¯¹è±¡çš„å¼¹çª—
    const modal = document.createElement('div');
    modal.id = 'emei-payment-request-modal';
    modal.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:10000; display:flex; align-items:center; justify-content:center;';
    
    modal.innerHTML = `
        <div style="background:#fff; border-radius:16px; padding:20px; width:80%; max-width:350px; max-height:60vh; display:flex; flex-direction:column;">
            <h3 style="margin:0 0 16px 0; text-align:center; font-size:16px; font-weight:600;">é€‰æ‹©ä»£ä»˜å¯¹è±¡</h3>
            <div style="flex:1; overflow-y:auto; margin-bottom:16px;">
                ${availableChars.map(char => `
                    <div onclick="selectPaymentRequestTarget(${char.id}, '${char.name.replace(/'/g, "\\'")}')" style="display:flex; align-items:center; padding:12px; border-bottom:1px solid #f5f5f5; cursor:pointer; transition:background 0.2s;" onmouseover="this.style.background='#f8f8f8'" onmouseout="this.style.background='#fff'">
                        <div style="width:40px; height:40px; border-radius:50%; background-image:url(${char.avatar || ''}); background-size:cover; background-color:#e0e0e0; margin-right:12px; flex-shrink:0;"></div>
                        <span style="font-size:14px; color:#333;">${char.name}</span>
                    </div>
                `).join('')}
            </div>
            <button onclick="this.closest('#emei-payment-request-modal').remove()" style="padding:12px; background:#f0f0f0; color:#666; border:none; border-radius:8px; font-size:14px; cursor:pointer;">å–æ¶ˆ</button>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// é€‰æ‹©ä»£ä»˜å¯¹è±¡
async function selectPaymentRequestTarget(charId, charName) {
    const modal = document.getElementById('emei-payment-request-modal');
    if (modal) modal.remove();
    
    const recipient = await db.characters.get(charId);
    if (!recipient) {
        alert('è§’è‰²ä¿¡æ¯ä¸å­˜åœ¨');
        return;
    }
    
    const subtotal = emeiData.cart.reduce((sum, item) => sum + item.price * item.count, 0);
    const delivery = 3;
    const discount = emeiData.selectedCoupon ? emeiData.selectedCoupon.amount : 0;
    const total = subtotal + delivery - discount;
    
    // å‘é€ä»£ä»˜è¯·æ±‚å¡ç‰‡åˆ°èŠå¤©
    await sendPaymentRequestCard(recipient, total);
    
    // è·å–æ”¶è´§äººä¿¡æ¯ç”¨äºæ˜¾ç¤º
    let recipientName = 'æˆ‘è‡ªå·±';
    if (emeiData.selectedRecipient !== 'self') {
        const recipientChar = await db.characters.get(parseInt(emeiData.selectedRecipient));
        if (recipientChar) recipientName = recipientChar.name;
    }
    
    alert(`å·²å‘ ${charName} å‘é€ä»£ä»˜è¯·æ±‚\nè®¢å•è¯¦æƒ…ï¼š${emeiData.currentStore.name}ï¼Œæ”¶è´§äººï¼š${recipientName}`);
    hideEmeiPage();
}

// å‘é€è®¢å•å¡ç‰‡åˆ°èŠå¤©
async function sendEmeiOrderCard() {
    // å¦‚æœæ˜¯ç»™è‡ªå·±ç‚¹å•ï¼Œä¸”æ²¡æœ‰æ‰“å¼€èŠå¤©ï¼Œä¸å‘é€å¡ç‰‡
    if (emeiData.selectedRecipient === 'self' && !currentChatCharId) {
        return;
    }
    
    const accountId = getCurrentAccountId();
    let chatCharId;
    
    // å¦‚æœæ˜¯ç»™è§’è‰²ç‚¹å•ï¼Œå‘é€åˆ°è¯¥è§’è‰²çš„èŠå¤©
    if (emeiData.selectedRecipient !== 'self') {
        chatCharId = parseInt(emeiData.selectedRecipient);
    } else {
        // ç»™è‡ªå·±ç‚¹å•ï¼Œå‘é€åˆ°å½“å‰æ‰“å¼€çš„èŠå¤©
        chatCharId = currentChatCharId;
    }
    
    if (!chatCharId) return;
    
    const char = await db.characters.get(chatCharId);
    if (!char) return;
    
    // æ„å»ºè®¢å•ä¿¡æ¯
    const orderInfo = {
        store: emeiData.currentStore.name,
        items: emeiData.cart.map(item => `${item.name} x${item.count}`).join('ã€'),
        total: (emeiData.cart.reduce((sum, item) => sum + item.price * item.count, 0) + 3 - (emeiData.selectedCoupon ? emeiData.selectedCoupon.amount : 0)).toFixed(2),
        recipient: emeiData.selectedRecipient === 'self' ? 'æˆ‘è‡ªå·±' : char.name
    };
    
    // ğŸ”§ å°ç¥¨é£æ ¼å¡ç‰‡
    const itemsHtml = emeiData.cart.map(item => `<div style="display:flex;justify-content:space-between;margin-bottom:6px;font-size:13px;"><span style="color:#333;font-weight:600;">${item.name} x${item.count}</span><span style="font-family:Arial,sans-serif;">Â¥${(item.price * item.count).toFixed(2)}</span></div>`).join('');
    const deliveryFee = 3;
    const couponAmount = emeiData.selectedCoupon ? emeiData.selectedCoupon.amount : 0;
    const cardHtml = `<div style="width:260px;background:#fff;padding:16px;box-shadow:0 4px 15px rgba(0,0,0,0.1);position:relative;font-family:'Courier New',Courier,monospace;box-sizing:border-box;"><div style="position:absolute;top:-5px;left:0;width:100%;height:10px;background:linear-gradient(135deg,transparent 5px,#fff 5px) 0 0,linear-gradient(225deg,transparent 5px,#fff 5px) 0 0;background-size:20px 20px;background-repeat:repeat-x;"></div><div style="position:absolute;bottom:-10px;left:0;width:100%;height:10px;background:linear-gradient(45deg,transparent 5px,#fff 5px) 0 0,linear-gradient(-45deg,transparent 5px,#fff 5px) 0 0;background-size:20px 20px;background-repeat:repeat-x;"></div><div style="text-align:center;font-weight:800;font-size:16px;color:#333;margin-bottom:5px;border-bottom:2px dashed #ddd;padding-bottom:12px;">${orderInfo.store} Â· è®¢å•è¯¦æƒ…</div><div style="margin:12px 0;font-size:13px;color:#555;">${itemsHtml}<div style="display:flex;justify-content:space-between;margin-bottom:6px;font-size:11px;color:#999;"><span>é…é€è´¹</span><span>Â¥${deliveryFee.toFixed(2)}</span></div>${couponAmount > 0 ? `<div style="display:flex;justify-content:space-between;margin-bottom:6px;font-size:11px;color:#ff6b6b;"><span>ä¼˜æƒ åˆ¸</span><span>-Â¥${couponAmount.toFixed(2)}</span></div>` : ''}</div><div style="border-top:1px dashed #ccc;margin:12px 0;"></div><div style="display:flex;justify-content:space-between;font-size:16px;font-weight:900;color:#000;margin-bottom:12px;"><span>åˆè®¡</span><span style="font-family:Arial,sans-serif;">Â¥${orderInfo.total}</span></div><div style="text-align:center;font-size:10px;color:#aaa;font-family:Arial,sans-serif;">${new Date().toLocaleString('zh-CN')}</div></div>`;
    
    // ğŸ”§ ä½¿ç”¨æŒ‰è´¦å·éš”ç¦»çš„èŠå¤©è®°å½•ï¼ˆaccountId å·²åœ¨å‡½æ•°å¼€å¤´å£°æ˜ï¼‰
    let history = getChatHistory(char, accountId);
    history.push({
        role: 'user',
        content: `[emei_order]${cardHtml}`,
        time: Date.now()
    });
    await setChatHistory(char, accountId, history);
    
    // å¦‚æœå½“å‰åœ¨è¯¥èŠå¤©çª—å£ï¼Œåˆ·æ–°æ˜¾ç¤º
    if (currentChatCharId === chatCharId) {
        renderChatBody(char);
    } else if (emeiData.selectedRecipient !== 'self') {
        // ç»™è§’è‰²ç‚¹å•ï¼Œå³ä½¿æ²¡æ‰“å¼€èŠå¤©çª—å£ä¹Ÿæç¤ºç”¨æˆ·
        alert(`è®¢å•å·²å‘é€ç»™ ${char.name}ï¼å¯ä»¥åœ¨èŠå¤©ä¸­æŸ¥çœ‹è®¢å•è¯¦æƒ…ã€‚`);
    }
}

// å‘é€ä»£ä»˜è¯·æ±‚å¡ç‰‡
async function sendPaymentRequestCard(recipient, amount) {
    if (!recipient) return;
    
    // è·å–æ”¶è´§äººä¿¡æ¯
    let recipientName = 'æˆ‘è‡ªå·±';
    if (emeiData.selectedRecipient !== 'self') {
        const recipientChar = await db.characters.get(parseInt(emeiData.selectedRecipient));
        if (recipientChar) recipientName = recipientChar.name;
    }
    
    // ğŸ”§ å°ç¥¨é£æ ¼ä»£ä»˜è¯·æ±‚å¡ç‰‡
    const storeName = emeiData.currentStore.name;
    const payItemsHtml = emeiData.cart.map(i => `<div style="display:flex;justify-content:space-between;margin-bottom:6px;font-size:13px;"><span style="color:#333;font-weight:600;">${i.name} x${i.count}</span><span style="font-family:Arial,sans-serif;">Â¥${(i.price * i.count).toFixed(2)}</span></div>`).join('');
    const cardHtml = `<div style="width:260px;background:#fff;padding:16px;box-shadow:0 4px 15px rgba(0,0,0,0.1);position:relative;font-family:'Courier New',Courier,monospace;box-sizing:border-box;"><div style="position:absolute;top:-5px;left:0;width:100%;height:10px;background:linear-gradient(135deg,transparent 5px,#fff 5px) 0 0,linear-gradient(225deg,transparent 5px,#fff 5px) 0 0;background-size:20px 20px;background-repeat:repeat-x;"></div><div style="position:absolute;bottom:-10px;left:0;width:100%;height:10px;background:linear-gradient(45deg,transparent 5px,#fff 5px) 0 0,linear-gradient(-45deg,transparent 5px,#fff 5px) 0 0;background-size:20px 20px;background-repeat:repeat-x;"></div><div style="text-align:center;font-weight:800;font-size:16px;color:#333;margin-bottom:5px;border-bottom:2px dashed #ddd;padding-bottom:12px;">${storeName} Â· ä»£ä»˜è¯·æ±‚</div><div style="text-align:center;font-size:12px;color:#888;margin:8px 0;">å¸®æˆ‘ä»˜ä¸€ä¸‹å¤–å–~</div><div style="margin:12px 0;font-size:13px;color:#555;">${payItemsHtml}</div><div style="border-top:1px dashed #ccc;margin:12px 0;"></div><div style="display:flex;justify-content:space-between;font-size:16px;font-weight:900;color:#000;margin-bottom:14px;"><span>åˆè®¡</span><span style="font-family:Arial,sans-serif;color:#ff4d4f;">Â¥${amount.toFixed(2)}</span></div><div onclick="handlePaymentRequest(this)" data-amount="${amount.toFixed(2)}" data-pay-type="char_pay" style="display:block;width:100%;padding:10px;background:#ff4d4f;color:white;text-align:center;border-radius:4px;font-family:sans-serif;font-weight:bold;letter-spacing:1px;cursor:pointer;box-sizing:border-box;">å¸®æˆ‘æ”¯ä»˜</div><div style="text-align:center;font-size:10px;color:#aaa;margin-top:12px;font-family:Arial,sans-serif;">${new Date().toLocaleString('zh-CN')}</div></div>`;
    
    // ğŸ”§ ä½¿ç”¨æŒ‰è´¦å·éš”ç¦»çš„èŠå¤©è®°å½•
    const accountId = getCurrentAccountId();
    let history = getChatHistory(recipient, accountId);
    history.push({
        role: 'user',
        content: `[payment_request]${cardHtml}`,
        time: Date.now()
    });
    await setChatHistory(recipient, accountId, history);
    
    if (currentChatCharId === recipient.id) {
        renderChatBody(recipient);
    }
}

// å¤„ç†ä»£ä»˜è¯·æ±‚
async function handlePaymentRequest(btn) {
    const payType = btn.getAttribute('data-pay-type');
    const amount = parseFloat(btn.getAttribute('data-amount') || 0);
    
    if (payType === 'user_pay') {
        // ç”¨æˆ·å¸®è§’è‰²æ”¯ä»˜å¤–å– â†’ æ‰£ç”¨æˆ·é’±åŒ…ä½™é¢
        const accountId = getCurrentAccountId();
        if (!accountId) {
            showToast('è¯·å…ˆç™»å½•è´¦å·');
            return;
        }
        
        const myChar = await db.characters.get(parseInt(accountId));
        if (!myChar) {
            showToast('è´¦å·æ•°æ®å¼‚å¸¸');
            return;
        }
        
        if (!myChar.identity) myChar.identity = {};
        const balance = parseFloat(myChar.identity.balance || 0);
        
        if (balance < amount) {
            showToast(`ä½™é¢ä¸è¶³ (å½“å‰: Â¥${balance.toFixed(2)})`);
            return;
        }
        
        // æ‰£æ¬¾
        myChar.identity.balance = (balance - amount).toFixed(2);
        await safeCharacterPut(myChar);
        
        // æ›´æ–°ä½™é¢æ˜¾ç¤º
        await updateBalancePageDisplay();
        await updateWalletBalanceDisplay();
        
        // è®°å½•è´¦å•ï¼ˆæ”¯å‡ºï¼‰
        await addTransaction('expense', amount, 'å¤–å–ä»£ä»˜', 'å¸®TAæ”¯ä»˜å¤–å–');
        
        // æ›´æ–°æŒ‰é’®çŠ¶æ€
        btn.innerText = 'å·²æ”¯ä»˜ Â¥' + amount.toFixed(2);
        btn.style.background = '#52c41a';
        btn.style.cursor = 'default';
        btn.onclick = null;
        
        showToast(`æ”¯ä»˜æˆåŠŸï¼å·²æ‰£æ¬¾ Â¥${amount.toFixed(2)}`);
    } else {
        // è§’è‰²å¸®ç”¨æˆ·æ”¯ä»˜å¤–å– â†’ ç›´æ¥æ˜¾ç¤ºå·²æ”¯ä»˜
        btn.innerText = 'å·²æ”¯ä»˜';
        btn.style.background = '#52c41a';
        btn.style.cursor = 'default';
        btn.onclick = null;
        
        showToast('å¯¹æ–¹å·²æ”¯ä»˜');
    }
}

// ğŸ”§ æ˜¾ç¤ºåˆ†äº«è®¢å•å¼¹çª—ï¼ˆç»™è‡ªå·±ç‚¹å•åå¯ä»¥åˆ†äº«ç»™å¥½å‹ï¼‰
async function showShareOrderModal(amount) {
    const allCharacters = await db.characters.toArray();
    const accountId = getCurrentAccountId();
    
    // è¿‡æ»¤å¯åˆ†äº«çš„è§’è‰²ï¼ˆæœ‰å¥½å‹å…³ç³»çš„è§’è‰²ï¼‰
    const availableChars = allCharacters.filter(c => {
        if (c.type === 'system' || c.type === 'user') return false;
        if (!c.name || c.name.trim() === '') return false;
        // æ£€æŸ¥æ˜¯å¦æ˜¯å¥½å‹
        const status = getFriendStatus(c, accountId);
        return status === 'friend';
    });
    
    if (availableChars.length === 0) {
        hideEmeiPage();
        return;
    }
    
    const modal = document.createElement('div');
    modal.id = 'emei-share-modal';
    modal.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:10000; display:flex; align-items:center; justify-content:center;';
    
    modal.innerHTML = `
        <div style="background:#fff; border-radius:16px; padding:20px; width:85%; max-width:350px; max-height:70vh; display:flex; flex-direction:column;">
            <h3 style="margin:0 0 8px 0; text-align:center; font-size:16px; font-weight:600;">åˆ†äº«è®¢å•ç»™å¥½å‹</h3>
            <p style="margin:0 0 16px 0; text-align:center; font-size:12px; color:#999;">é€‰æ‹©æƒ³è¦åˆ†äº«çš„å¥½å‹ï¼ˆå¯å¤šé€‰ï¼‰</p>
            <div id="share-char-list" style="flex:1; overflow-y:auto; margin-bottom:16px; max-height:300px;">
                ${availableChars.map(char => `
                    <label style="display:flex; align-items:center; padding:12px; border-bottom:1px solid #f5f5f5; cursor:pointer;">
                        <input type="checkbox" value="${char.id}" style="width:18px; height:18px; margin-right:12px; accent-color:var(--ins-pink);">
                        <div style="width:40px; height:40px; border-radius:50%; background-image:url(${char.avatar || ''}); background-size:cover; background-color:#e0e0e0; margin-right:12px; flex-shrink:0;"></div>
                        <span style="font-size:14px; color:#333;">${char.name}</span>
                    </label>
                `).join('')}
            </div>
            <div style="display:flex; gap:12px;">
                <button onclick="closeShareOrderModal()" style="flex:1; padding:12px; background:#f0f0f0; color:#666; border:none; border-radius:8px; font-size:14px; cursor:pointer;">è·³è¿‡</button>
                <button onclick="confirmShareOrder()" style="flex:1; padding:12px; background:var(--ins-pink); color:#fff; border:none; border-radius:8px; font-size:14px; cursor:pointer;">åˆ†äº«</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// å…³é—­åˆ†äº«å¼¹çª—
function closeShareOrderModal() {
    const modal = document.getElementById('emei-share-modal');
    if (modal) modal.remove();
    hideEmeiPage();
}

// ç¡®è®¤åˆ†äº«è®¢å•
async function confirmShareOrder() {
    const checkboxes = document.querySelectorAll('#share-char-list input[type="checkbox"]:checked');
    const selectedIds = Array.from(checkboxes).map(cb => parseInt(cb.value));
    
    if (selectedIds.length === 0) {
        closeShareOrderModal();
        return;
    }
    
    const accountId = getCurrentAccountId();
    
    // å‘æ¯ä¸ªé€‰ä¸­çš„å¥½å‹å‘é€åˆ†äº«å¡ç‰‡
    for (const charId of selectedIds) {
        await sendShareOrderCard(charId, accountId);
    }
    
    showToast(`å·²åˆ†äº«ç»™ ${selectedIds.length} ä½å¥½å‹`);
    closeShareOrderModal();
}

// å‘é€åˆ†äº«è®¢å•å¡ç‰‡
async function sendShareOrderCard(charId, accountId) {
    const char = await db.characters.get(charId);
    if (!char) return;
    
    const orderInfo = {
        store: emeiData.currentStore.name,
        items: emeiData.cart.map(item => `${item.name} x${item.count}`).join('ã€'),
        total: (emeiData.cart.reduce((sum, item) => sum + item.price * item.count, 0) + 3 - (emeiData.selectedCoupon ? emeiData.selectedCoupon.amount : 0)).toFixed(2)
    };
    
    // åˆ›å»ºå°ç¥¨é£æ ¼åˆ†äº«å¡ç‰‡HTML
    const shareItemsHtml = emeiData.cart.map(item => `<div style="display:flex;justify-content:space-between;margin-bottom:6px;font-size:13px;"><span style="color:#333;font-weight:600;">${item.name} x${item.count}</span><span style="font-family:Arial,sans-serif;">Â¥${(item.price * item.count).toFixed(2)}</span></div>`).join('');
    const cardHtml = `<div style="width:260px;background:#fff;padding:16px;box-shadow:0 4px 15px rgba(0,0,0,0.1);position:relative;font-family:'Courier New',Courier,monospace;box-sizing:border-box;"><div style="position:absolute;top:-5px;left:0;width:100%;height:10px;background:linear-gradient(135deg,transparent 5px,#fff 5px) 0 0,linear-gradient(225deg,transparent 5px,#fff 5px) 0 0;background-size:20px 20px;background-repeat:repeat-x;"></div><div style="position:absolute;bottom:-10px;left:0;width:100%;height:10px;background:linear-gradient(45deg,transparent 5px,#fff 5px) 0 0,linear-gradient(-45deg,transparent 5px,#fff 5px) 0 0;background-size:20px 20px;background-repeat:repeat-x;"></div><div style="text-align:center;font-weight:800;font-size:16px;color:#333;margin-bottom:5px;border-bottom:2px dashed #ddd;padding-bottom:12px;">ğŸ›µ ${orderInfo.store} Â· å¤–å–åˆ†äº«</div><div style="text-align:center;font-size:12px;color:#888;margin:8px 0;">æˆ‘åˆšç‚¹äº†å¤–å–ï¼Œåˆ†äº«ç»™ä½ çœ‹çœ‹~</div><div style="margin:12px 0;font-size:13px;color:#555;">${shareItemsHtml}</div><div style="border-top:1px dashed #ccc;margin:12px 0;"></div><div style="display:flex;justify-content:space-between;font-size:16px;font-weight:900;color:#000;margin-bottom:8px;"><span>åˆè®¡</span><span style="font-family:Arial,sans-serif;">Â¥${orderInfo.total}</span></div><div style="text-align:center;font-size:11px;color:#999;margin-top:8px;">ğŸ” ä¸€èµ·ç‚¹å¤–å–å‘€~</div></div>`;
    
    // æ·»åŠ åˆ°èŠå¤©è®°å½•
    let history = getChatHistory(char, accountId);
    history.push({
        role: 'user',
        content: `[emei_share]${cardHtml}`,
        time: Date.now()
    });
    await setChatHistory(char, accountId, history);
    
    // å¦‚æœå½“å‰åœ¨è¯¥èŠå¤©çª—å£ï¼Œåˆ·æ–°æ˜¾ç¤º
    if (currentChatCharId === charId) {
        renderChatBody(char);
    }
}

// æ³¨å†Œå…¨å±€å‡½æ•°
window.showEmeiPage = showEmeiPage;
window.hideEmeiPage = hideEmeiPage;
window.claimEmeiCoupon = claimEmeiCoupon;
window.openEmeiStore = openEmeiStore;
window.backToEmeiMain = backToEmeiMain;
window.increaseEmeiItem = increaseEmeiItem;
window.decreaseEmeiItem = decreaseEmeiItem;
window.updateEmeiRecipient = updateEmeiRecipient;
window.showEmeiCheckout = showEmeiCheckout;
window.backToEmeiStore = backToEmeiStore;
window.selectEmeiCoupon = selectEmeiCoupon;
window.useEmeiCoupon = useEmeiCoupon;
window.closeEmeiCouponModal = closeEmeiCouponModal;
window.showEmeiPaymentModal = showEmeiPaymentModal;
window.closeEmeiPaymentModal = closeEmeiPaymentModal;
window.selectEmeiPaymentMethod = selectEmeiPaymentMethod;
window.confirmEmeiPayment = confirmEmeiPayment;
window.handlePaymentRequest = handlePaymentRequest;
window.selectPaymentRequestTarget = selectPaymentRequestTarget;
window.showShareOrderModal = showShareOrderModal;
window.closeShareOrderModal = closeShareOrderModal;
window.confirmShareOrder = confirmShareOrder;

// ==================== é—²é±¼App Logic ====================

const xianyuDb = new Dexie('XianyuDB_Internal');

xianyuDb.version(3).stores({
    goods: '++id, title, price, category, collected, viewCount, wantCount, createdAt, userId, sold, bought, originalPrice, sellerId',
    collections: '++id, goodsId, goodsTitle, goodsPrice, goodsCategory, collectedAt, userId',
    messages: '++id, goodsId, content, sender, createdAt, userId, senderId, role',
    chatSessions: '++id, goodsId, lastMessage, updatedAt, userId',
    users: '++id, username, avatar, createdAt, userId, role, blockedUsers',
    orders: '++id, goodsId, goodsTitle, goodsPrice, type, createdAt, userId',
    characters: '++id, userId, role, personality, worldView, createdAt'
});

// ç‰ˆæœ¬4ï¼šæ¸…é™¤æ—§çš„é»˜è®¤å•†å“æ•°æ®
xianyuDb.version(4).stores({
    goods: '++id, title, price, category, collected, viewCount, wantCount, createdAt, userId, sold, bought, originalPrice, sellerId',
    collections: '++id, goodsId, goodsTitle, goodsPrice, goodsCategory, collectedAt, userId',
    messages: '++id, goodsId, content, sender, createdAt, userId, senderId, role',
    chatSessions: '++id, goodsId, lastMessage, updatedAt, userId',
    users: '++id, username, avatar, createdAt, userId, role, blockedUsers',
    orders: '++id, goodsId, goodsTitle, goodsPrice, type, createdAt, userId',
    characters: '++id, userId, role, personality, worldView, createdAt'
}).upgrade(tx => {
    // æ¸…é™¤æ—§ç‰ˆæœ¬çš„é»˜è®¤å•†å“ã€è®¢å•ã€ç”¨æˆ·æ•°æ®
    tx.table('goods').clear();
    tx.table('orders').clear();
    tx.table('users').clear();
    tx.table('collections').clear();
    tx.table('messages').clear();
    tx.table('chatSessions').clear();
    tx.table('characters').clear();
});

// é—²é±¼å½“å‰è´¦å·IDï¼ˆä»WeChatè´¦å·é€‰æ‹©ä¸­è·å–ï¼Œç”¨äºæ•°æ®éš”ç¦»ï¼‰
let XY_CURRENT_USER_ID = null;
window.xianyuCurrentAccountId = null;
window.xianyuCurrentAccountName = '';

const XianyuAppState = {
    currentPage: 'xyHomePage',
    currentTab: 'xy-tab-home',
    currentGoods: null,
    pageHistory: [],
    
    navigateTo(pageId, tabId = null, addToHistory = true) {
        document.querySelectorAll('#xianyuAppPage .xy-page').forEach(page => {
            page.classList.remove('active');
        });
        
        const targetPage = document.getElementById(pageId);
        if (targetPage) {
            targetPage.classList.add('active');
            this.currentPage = pageId;
            
            if (addToHistory && pageId !== 'xyHomePage' && !this.pageHistory.includes(pageId)) {
                this.pageHistory.push(pageId);
            }
        }
        
        // èŠå¤©é¡µå’Œè¯¦æƒ…é¡µéšè—åº•éƒ¨å¯¼èˆªæ 
        const tabBar = document.querySelector('#xyMainContent .xy-tab-bar');
        if (tabBar) {
            const hideTabPages = ['xyChatPage', 'xyDetailPage'];
            tabBar.style.display = hideTabPages.includes(pageId) ? 'none' : 'flex';
        }
        
        if (tabId) {
            this.updateTabBar(tabId);
        } else {
            const tabMap = {
                'xyHomePage': 'xy-tab-home',
                'xyDetailPage': 'xy-tab-home',
                'xyMessageListPage': 'xy-tab-message',
                'xyChatPage': 'xy-tab-message',
                'xyMyPage': 'xy-tab-mine',
                'xyMyGoodsPage': 'xy-tab-mine',
                'xyMySoldPage': 'xy-tab-mine',
                'xyMyBoughtPage': 'xy-tab-mine',
                'xyMyCollectionsPage': 'xy-tab-mine'
            };
            this.updateTabBar(tabMap[pageId] || 'xy-tab-home');
        }
        
        if (pageId === 'xyHomePage') {
            xianyuLoadGoods();
        } else if (pageId === 'xyChatPage' && this.currentGoods) {
            xianyuLoadChatMessages(this.currentGoods.id);
        } else if (pageId === 'xyMessageListPage') {
            xianyuLoadMessageList();
        } else if (pageId === 'xyMyPage') {
            xianyuLoadMyPageData();
        } else if (pageId === 'xyMyGoodsPage') {
            xianyuLoadMyGoods();
        } else if (pageId === 'xyMySoldPage') {
            xianyuLoadMySold();
        } else if (pageId === 'xyMyBoughtPage') {
            xianyuLoadMyBought();
        } else if (pageId === 'xyMyCollectionsPage') {
            xianyuLoadMyCollections();
        }
    },
    
    updateTabBar(tabId) {
        document.querySelectorAll('#xianyuAppPage .xy-tab-item').forEach(tab => {
            tab.classList.remove('active');
        });
        
        const targetTab = document.getElementById(tabId);
        if (targetTab) {
            targetTab.classList.add('active');
            this.currentTab = tabId;
        }
    },
    
    goBack() {
        if (this.pageHistory.length > 0) {
            this.pageHistory.pop();
            if (this.pageHistory.length > 0) {
                const previousPage = this.pageHistory[this.pageHistory.length - 1];
                this.navigateTo(previousPage, null, false);
            } else {
                this.navigateTo('xyHomePage', 'xy-tab-home', false);
            }
        } else {
            this.navigateTo('xyHomePage', 'xy-tab-home', false);
        }
    },
    
    goBackToMyPage() {
        this.navigateTo('xyMyPage', 'xy-tab-mine', false);
    },
    
    switchTab(pageId, tabId) {
        this.navigateTo(pageId, tabId, false);
    }
};

async function xianyuInitializeUser() {
    if (!XY_CURRENT_USER_ID) return;
    // æ£€æŸ¥å½“å‰è´¦å·æ˜¯å¦å·²æœ‰é—²é±¼ç”¨æˆ·è®°å½•
    const existingUser = await xianyuDb.users.get(XY_CURRENT_USER_ID);
    if (!existingUser) {
        // ä»WeChatè§’è‰²è·å–è´¦å·ä¿¡æ¯
        let username = window.xianyuCurrentAccountName || 'ç”¨æˆ·';
        let avatar = 'fa-user';
        try {
            const accountChar = await db.characters.get(XY_CURRENT_USER_ID);
            if (accountChar) {
                username = accountChar.nick || accountChar.name || 'ç”¨æˆ·';
            }
        } catch(e) {}
        await xianyuDb.users.add({
            id: XY_CURRENT_USER_ID,
            username: username,
            avatar: avatar,
            createdAt: new Date()
        });
    }
    xianyuLoadUserInfo();
}

async function xianyuLoadUserInfo() {
    if (!XY_CURRENT_USER_ID) return;
    const user = await xianyuDb.users.get(XY_CURRENT_USER_ID);
    if (user) {
        const nameEl = document.getElementById('xyUserName');
        const avatarEl = document.getElementById('xyUserAvatar');
        if (nameEl) nameEl.textContent = user.username;
        if (avatarEl) {
            // å°è¯•æ˜¾ç¤ºWeChatè´¦å·å¤´åƒ
            try {
                const accountChar = await db.characters.get(XY_CURRENT_USER_ID);
                if (accountChar && accountChar.avatar) {
                    avatarEl.innerHTML = `<img src="${accountChar.avatar}" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">`;
                } else {
                    avatarEl.innerHTML = `<i class="fa ${user.avatar}"></i>`;
                }
            } catch(e) {
                avatarEl.innerHTML = `<i class="fa ${user.avatar}"></i>`;
            }
        }
    }
    await xianyuUpdateMyPageStats();
}

async function xianyuUpdateMyPageStats() {
    if (!XY_CURRENT_USER_ID) return;
    const myGoodsCount = await xianyuDb.goods.where('userId').equals(XY_CURRENT_USER_ID).count();
    const el1 = document.getElementById('xyMyGoodsCount');
    if (el1) el1.textContent = myGoodsCount;
    
    const mySoldCount = await xianyuDb.goods.where('userId').equals(XY_CURRENT_USER_ID).filter(g => g.sold === 1).count();
    const el2 = document.getElementById('xyMySoldCount');
    if (el2) el2.textContent = mySoldCount;
    
    const myBoughtCount = await xianyuDb.orders.where('userId').equals(XY_CURRENT_USER_ID).filter(o => o.type === 'buy').count();
    const el3 = document.getElementById('xyMyBoughtCount');
    if (el3) el3.textContent = myBoughtCount;
}

function xianyuShowDataStatus(message) {
    const statusEl = document.getElementById('xyDataStatus');
    if (!statusEl) return;
    statusEl.textContent = message;
    statusEl.style.display = 'block';
    setTimeout(() => {
        statusEl.style.display = 'none';
    }, 2000);
}

async function xianyuInitializeDefaultGoods() {
    // ä¸å†åˆå§‹åŒ–é»˜è®¤å•†å“ï¼Œå•†å“ç”±ç”¨æˆ·è‡ªè¡Œå‘å¸ƒæˆ–AIç”Ÿæˆ
}

// ç»Ÿä¸€ç”Ÿæˆå•†å“å¡ç‰‡HTML
function xianyuGoodsCardHTML(goodsItem, extraBadge = '') {
    const sellerDisplay = goodsItem.sellerName || 'åŒ¿åå–å®¶';
    return `
        <div class="xy-goods-img"><i class="fa fa-image"></i></div>
        <div class="xy-goods-info">
            <div class="xy-goods-title">${goodsItem.title}</div>
            <div class="xy-goods-price">Â¥${goodsItem.price}${extraBadge}</div>
            <div class="xy-goods-seller-row">
                <span class="xy-goods-seller-name"><i class="fa fa-user" style="margin-right:3px;font-size:10px;"></i>${sellerDisplay}</span>
                <span class="xy-goods-category-tag">${goodsItem.category}</span>
            </div>
        </div>
    `;
}

async function xianyuLoadGoods(category = null) {
    const container = document.getElementById('xyGoodsListContainer');
    if (!container) return;
    let goods;
    if (category) {
        goods = await xianyuDb.goods.where('category').equals(category).toArray();
    } else {
        goods = await xianyuDb.goods.toArray();
    }
    goods.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    container.innerHTML = '';
    if (goods.length === 0) {
        container.innerHTML = '<div style="text-align: center; padding: 50px; color: #ccc;">æš‚æ— å•†å“ï¼Œå¿«å»å‘å¸ƒå§ï¼</div>';
        return;
    }
    goods.forEach(goodsItem => {
        const item = document.createElement('div');
        item.className = 'xy-goods-item';
        item.onclick = () => xianyuGoToDetail(goodsItem.id);
        item.innerHTML = xianyuGoodsCardHTML(goodsItem);
        container.appendChild(item);
    });
}

async function xianyuLoadMyGoods() {
    const container = document.getElementById('xyMyGoodsListContainer');
    if (!container) return;
    const goods = await xianyuDb.goods.where('userId').equals(XY_CURRENT_USER_ID).toArray();
    goods.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    container.innerHTML = '';
    if (goods.length === 0) {
        container.innerHTML = `
            <div class="xy-empty-state">
                <div class="xy-empty-icon"><i class="fa fa-box-open"></i></div>
                <div class="xy-empty-text">ä½ è¿˜æ²¡æœ‰å‘å¸ƒè¿‡å•†å“</div>
                <button onclick="xianyuShowPublishDialog()" style="margin-top: 15px; padding: 8px 20px; background-color: #e89ab0; color: white; border: none; border-radius: 5px; cursor: pointer;">å»å‘å¸ƒ</button>
            </div>
        `;
        return;
    }
    goods.forEach(goodsItem => {
        const item = document.createElement('div');
        item.className = 'xy-goods-item';
        item.onclick = () => xianyuGoToDetail(goodsItem.id);
        const soldBadge = goodsItem.sold ? '<span style="font-size: 10px; color: #ff6666; margin-left: 5px;">å·²å”®å‡º</span>' : '';
        item.innerHTML = xianyuGoodsCardHTML(goodsItem, ` ${soldBadge}`);
        container.appendChild(item);
    });
}

async function xianyuLoadMySold() {
    const container = document.getElementById('xyMySoldListContainer');
    if (!container) return;
    const goods = await xianyuDb.goods.where('userId').equals(XY_CURRENT_USER_ID).filter(g => g.sold === 1).toArray();
    container.innerHTML = '';
    if (goods.length === 0) {
        container.innerHTML = `
            <div class="xy-empty-state">
                <div class="xy-empty-icon"><i class="fa fa-shopping-bag"></i></div>
                <div class="xy-empty-text">ä½ è¿˜æ²¡æœ‰å–å‡ºè¿‡å•†å“</div>
            </div>
        `;
        return;
    }
    goods.forEach(goodsItem => {
        const item = document.createElement('div');
        item.className = 'xy-goods-item';
        item.onclick = () => xianyuGoToDetail(goodsItem.id);
        item.innerHTML = xianyuGoodsCardHTML(goodsItem);
        container.appendChild(item);
    });
}

async function xianyuLoadMyBought() {
    const container = document.getElementById('xyMyBoughtListContainer');
    if (!container) return;
    const orders = await xianyuDb.orders.where('userId').equals(XY_CURRENT_USER_ID).filter(o => o.type === 'buy').toArray();
    container.innerHTML = '';
    if (orders.length === 0) {
        container.innerHTML = `
            <div class="xy-empty-state">
                <div class="xy-empty-icon"><i class="fa fa-shopping-cart"></i></div>
                <div class="xy-empty-text">ä½ è¿˜æ²¡æœ‰ä¹°åˆ°è¿‡å•†å“</div>
            </div>
        `;
        return;
    }
    for (const order of orders) {
        const goodsItem = await xianyuDb.goods.get(order.goodsId);
        if (goodsItem) {
            const item = document.createElement('div');
            item.className = 'xy-goods-item';
            item.onclick = () => xianyuGoToDetail(goodsItem.id);
            item.innerHTML = xianyuGoodsCardHTML(goodsItem);
            container.appendChild(item);
        }
    }
}

async function xianyuLoadMyCollections() {
    const container = document.getElementById('xyMyCollectionsListContainer');
    if (!container) return;
    const collections = await xianyuDb.collections.where('userId').equals(XY_CURRENT_USER_ID).toArray();
    container.innerHTML = '';
    if (collections.length === 0) {
        container.innerHTML = `
            <div class="xy-empty-state">
                <div class="xy-empty-icon"><i class="fa fa-star"></i></div>
                <div class="xy-empty-text">ä½ è¿˜æ²¡æœ‰æ”¶è—è¿‡å•†å“</div>
            </div>
        `;
        return;
    }
    for (const collection of collections) {
        const goodsItem = await xianyuDb.goods.get(collection.goodsId);
        if (goodsItem) {
            const item = document.createElement('div');
            item.className = 'xy-goods-item';
            item.onclick = () => xianyuGoToDetail(goodsItem.id);
            item.innerHTML = xianyuGoodsCardHTML(goodsItem);
            container.appendChild(item);
        }
    }
}

async function xianyuLoadMyPageData() {
    await xianyuUpdateMyPageStats();
}

async function xianyuLoadMessageList() {
    const container = document.getElementById('xyChatListContent');
    if (!container) return;
    container.innerHTML = '';
    
    const sessions = await xianyuDb.chatSessions.toArray();
    
    if (sessions.length === 0) {
        container.innerHTML = '<div style="text-align: center; padding: 50px; color: #ccc;">æš‚æ— æ¶ˆæ¯</div>';
        return;
    }
    
    sessions.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
    
    for (const session of sessions) {
        const goods = await xianyuDb.goods.get(session.goodsId);
        if (!goods) continue;
        
        const lastMessage = await xianyuDb.messages.where('goodsId').equals(session.goodsId).sortBy('createdAt');
        const lastMsg = lastMessage[lastMessage.length - 1];
        let senderName = 'æœªçŸ¥ç”¨æˆ·';
        
        if (lastMsg) {
            if (lastMsg.sender === 'buyer' || (lastMsg.userId !== XY_CURRENT_USER_ID && lastMsg.role === 'buyer')) {
                const buyer = await xianyuDb.users.where('userId').equals(lastMsg.senderId).first();
                senderName = buyer ? buyer.username : lastMsg.senderId;
            } else if (lastMsg.sender === 'seller' || lastMsg.role === 'seller') {
                const seller = await xianyuDb.users.get(goods.userId);
                senderName = seller ? seller.username : lastMsg.senderId;
            }
        }
        
        const time = new Date(session.updatedAt);
        const timeStr = `${time.getMonth() + 1}/${time.getDate()} ${time.getHours().toString().padStart(2, '0')}:${time.getMinutes().toString().padStart(2, '0')}`;
        
        const item = document.createElement('div');
        item.className = 'xy-msg-list-item';
        item.style.cursor = 'pointer';
        item.onclick = () => {
            XianyuAppState.currentGoods = goods;
            xianyuGoToChat();
        };
        
        item.innerHTML = `
            <div class="xy-msg-avatar" style="background-color: #e89ab0; color: white;">
                <i class="fa fa-user"></i>
            </div>
            <div class="xy-msg-info">
                <div class="xy-msg-top">
                    <div class="xy-msg-name">${goods.title} - ${senderName}</div>
                    <div class="xy-msg-time">${timeStr}</div>
                </div>
                <div class="xy-msg-content">${session.lastMessage || 'æš‚æ— æ¶ˆæ¯'}</div>
            </div>
        `;
        
        container.appendChild(item);
    }
}

async function xianyuSearchGoods(keyword) {
    const container = document.getElementById('xyGoodsListContainer');
    if (!container) return;
    const allGoods = await xianyuDb.goods.toArray();
    const filteredGoods = allGoods.filter(goodsItem => 
        goodsItem.title.toLowerCase().includes(keyword.toLowerCase()) ||
        goodsItem.category.toLowerCase().includes(keyword.toLowerCase()) ||
        (goodsItem.description && goodsItem.description.toLowerCase().includes(keyword.toLowerCase()))
    );
    container.innerHTML = '';
    if (filteredGoods.length === 0) {
        container.innerHTML = '<div style="text-align: center; padding: 50px; color: #ccc;">æœªæ‰¾åˆ°ç›¸å…³å•†å“</div>';
        return;
    }
    filteredGoods.forEach(goodsItem => {
        const item = document.createElement('div');
        item.className = 'xy-goods-item';
        item.onclick = () => xianyuGoToDetail(goodsItem.id);
        item.innerHTML = xianyuGoodsCardHTML(goodsItem);
        container.appendChild(item);
    });
}

async function xianyuGoToDetail(goodsId) {
    const goods = await xianyuDb.goods.get(goodsId);
    if (!goods) return;
    
    goods.viewCount = (goods.viewCount || 0) + 1;
    await xianyuDb.goods.update(goodsId, { viewCount: goods.viewCount });
    
    document.getElementById('xyDetailTitle').textContent = goods.title;
    document.getElementById('xyDetailPrice').textContent = `Â¥${goods.price}`;
    document.getElementById('xyDetailPostage').textContent = goods.postage || 'åŒ…é‚®';
    document.getElementById('xyDetailMeta').textContent = `æƒ³è¦${goods.wantCount || 0} | æµè§ˆ${goods.viewCount || 0}`;
    document.getElementById('xyDetailMeta1Key').textContent = goods.metaKey || 'ç±»åˆ«';
    document.getElementById('xyDetailMeta1Val').textContent = goods.metaVal || goods.category;
    document.getElementById('xyDetailDescTitle').textContent = goods.title;
    document.getElementById('xyDetailDescContent').textContent = goods.description;
    document.getElementById('xyDetailTipsTitle').textContent = 'å°è´´å£«';
    document.getElementById('xyDetailTipsContent').textContent = goods.tips || 'æ¸©é¦¨æç¤ºå†…å®¹';
    
    // æ˜¾ç¤ºå–å®¶åå­—
    const sellerNameEl = document.querySelector('#xyDetailPage .xy-seller-name');
    if (sellerNameEl) {
        const sellerDisplay = goods.sellerName || 'åŒ¿åå–å®¶';
        sellerNameEl.innerHTML = `${sellerDisplay} <span class="xy-credit-tag">å–å®¶ä¿¡ç”¨æå¥½</span>`;
    }
    // æ˜¾ç¤ºå–å®¶å¤´åƒ
    const sellerAvatarEl = document.querySelector('#xyDetailPage .xy-seller-avatar');
    if (sellerAvatarEl) {
        if (goods.sellerAvatar && goods.sellerAvatar.startsWith('http')) {
            sellerAvatarEl.innerHTML = `<img src="${goods.sellerAvatar}" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">`;
        } else {
            sellerAvatarEl.innerHTML = `<i class="fa ${goods.sellerAvatar || 'fa-user'}"></i>`;
        }
    }
    
    if (goods.category === 'ç¾å¦†' || goods.category === 'å¥³è£…') {
        document.getElementById('xySellerLocation').textContent = '7å°æ—¶å‰å‰æ¥è¿‡ | æ³‰å·';
        document.getElementById('xySellerService').textContent = '230+å·²æœåŠ¡(æ¬¡) | 2å¹´æœåŠ¡ç»éªŒ';
    } else {
        document.getElementById('xySellerLocation').textContent = 'åˆšåˆšæ¥è¿‡ | æ²³åŒ—Â·å¼ å®¶å£';
        document.getElementById('xySellerService').textContent = '83+å·²æœåŠ¡(æ¬¡) | 1å¹´æœåŠ¡ç»éªŒ';
    }
    
    xianyuUpdateCollectButton(goodsId);
    XianyuAppState.currentGoods = goods;
    XianyuAppState.navigateTo('xyDetailPage');
}

async function xianyuUpdateCollectButton(goodsId) {
    const collectBtn = document.getElementById('xyCollectBtn');
    const detailCollectBtn = document.getElementById('xyDetailCollectBtn');
    if (!collectBtn || !detailCollectBtn) return;
    
    const collection = await xianyuDb.collections.where('goodsId').equals(goodsId).filter(c => c.userId === XY_CURRENT_USER_ID).first();
    
    if (collection) {
        collectBtn.innerHTML = '<i class="fa fa-star"></i> å·²æ”¶è—';
        detailCollectBtn.className = 'fa fa-star';
        detailCollectBtn.title = 'å–æ¶ˆæ”¶è—';
    } else {
        collectBtn.innerHTML = '<i class="fa fa-star-o"></i> æ”¶è—';
        detailCollectBtn.className = 'fa fa-star-o';
        detailCollectBtn.title = 'æ”¶è—';
    }
}

async function xianyuToggleCollect(goodsId) {
    const goods = await xianyuDb.goods.get(goodsId);
    if (!goods) return;
    
    const collection = await xianyuDb.collections.where('goodsId').equals(goodsId).filter(c => c.userId === XY_CURRENT_USER_ID).first();
    
    if (collection) {
        await xianyuDb.collections.delete(collection.id);
        xianyuShowDataStatus('å·²å–æ¶ˆæ”¶è—');
    } else {
        await xianyuDb.collections.add({
            goodsId: goodsId,
            goodsTitle: goods.title,
            goodsPrice: goods.price,
            goodsCategory: goods.category,
            userId: XY_CURRENT_USER_ID,
            collectedAt: new Date()
        });
        xianyuShowDataStatus('å·²æ”¶è—');
    }
    xianyuUpdateCollectButton(goodsId);
    await xianyuUpdateMyPageStats();
}

async function xianyuLoadChatMessages(goodsId) {
    const container = document.getElementById('xyChatContent');
    if (!container) return;
    const messages = await xianyuDb.messages.where('goodsId').equals(goodsId).toArray();
    
    messages.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
    
    container.innerHTML = '';
    if (messages.length > 0) {
        messages.forEach(msg => {
            const messageDiv = document.createElement('div');
            const isUser = msg.sender === 'user' || (msg.userId === XY_CURRENT_USER_ID && msg.sender !== 'seller' && msg.sender !== 'buyer');
            const isSystem = msg.sender === 'system';
            
            messageDiv.className = `xy-message-item ${isUser ? 'xy-message-user' : isSystem ? 'xy-message-system' : 'xy-message-seller'}`;
            
            const time = new Date(msg.createdAt);
            const timeStr = `${time.getHours().toString().padStart(2, '0')}:${time.getMinutes().toString().padStart(2, '0')}`;
            
            let senderName = '';
            if (!isUser && !isSystem) {
                const goodsData = XianyuAppState.currentGoods;
                const displayName = (goodsData && goodsData.sellerName) ? goodsData.sellerName : (msg.senderId || 'å–å®¶');
                senderName = `<div style="font-size: 11px; color: #999; margin-bottom: 3px;">${displayName}</div>`;
            }
            
            messageDiv.innerHTML = `
                ${senderName}
                <div class="xy-message-bubble">${msg.content}</div>
                <div class="xy-message-time">${timeStr}</div>
            `;
            container.appendChild(messageDiv);
        });
    } else {
        container.innerHTML = '<div style="text-align: center; padding: 50px; color: #ccc;">è¿˜æ²¡æœ‰æ¶ˆæ¯ï¼Œå¼€å§‹èŠå¤©å§ï¼</div>';
    }
    
    container.scrollTop = container.scrollHeight;
}

// è·å–é—²é±¼çš„APIé…ç½®ï¼ˆä½¿ç”¨é¡¹ç›®çš„db.dexiDataï¼‰
async function getXianyuApiConfig() {
    const urlItem = await db.dexiData.get('aiBaseUrl');
    const keyItem = await db.dexiData.get('aiApiKey');
    const modelItem = await db.dexiData.get('aiCurrentModel');
    const tempItem = await db.dexiData.get('aiTemperature');

    let baseUrl = urlItem?.value || 'https://api.openai.com/v1';
    if (baseUrl.endsWith('/')) baseUrl = baseUrl.slice(0, -1);
    if (!baseUrl.includes('/v1')) {
        baseUrl += '/v1';
    }
    const apiUrl = baseUrl + '/chat/completions';

    return {
        apiUrl: apiUrl,
        apiKey: keyItem?.value || '',
        model: modelItem?.value || 'gpt-3.5-turbo',
        temperature: parseFloat(tempItem?.value) || 0.8
    };
}

async function xianyuSendMessage() {
    const input = document.getElementById('xyChatInput');
    if (!input) return;
    const content = input.value.trim();
    if (!content || !XianyuAppState.currentGoods) return;
    
    const goods = XianyuAppState.currentGoods;
    const seller = await xianyuDb.users.get(goods.userId);
    const currentUser = await xianyuDb.users.get(XY_CURRENT_USER_ID);
    const currentUserId = currentUser ? (currentUser.userId || `user_${XY_CURRENT_USER_ID}`) : `user_${XY_CURRENT_USER_ID}`;
    
    if (seller && seller.blockedUsers && seller.blockedUsers.includes(currentUserId)) {
        alert('æ‚¨å·²è¢«å–å®¶æ‹‰é»‘ï¼Œæ— æ³•å‘é€æ¶ˆæ¯');
        return;
    }
    
    await xianyuDb.messages.add({
        goodsId: goods.id,
        content: content,
        sender: 'user',
        userId: XY_CURRENT_USER_ID,
        senderId: XY_CURRENT_USER_ID,
        role: 'buyer',
        createdAt: new Date()
    });
    
    const existingSession = await xianyuDb.chatSessions.where('goodsId').equals(goods.id).first();
    if (existingSession) {
        await xianyuDb.chatSessions.update(existingSession.id, {
            lastMessage: content,
            updatedAt: new Date()
        });
    } else {
        await xianyuDb.chatSessions.add({
            goodsId: goods.id,
            lastMessage: content,
            updatedAt: new Date(),
            userId: XY_CURRENT_USER_ID
        });
    }
    
    input.value = '';
    xianyuLoadChatMessages(goods.id);
    
    if (XianyuAppState.currentPage === 'xyMessageListPage') {
        xianyuLoadMessageList();
    }
}

// æ¥æ”¶å›å¤æŒ‰é’® - æ‰‹åŠ¨è§¦å‘AIå›å¤
async function xianyuReceiveReply() {
    const goods = XianyuAppState.currentGoods;
    if (!goods) {
        alert('å½“å‰æ²¡æœ‰å•†å“ä¿¡æ¯');
        return;
    }
    
    // è·å–æœ€åä¸€æ¡ç”¨æˆ·æ¶ˆæ¯ä½œä¸ºä¸Šä¸‹æ–‡
    const messages = await xianyuDb.messages
        .where('goodsId').equals(goods.id)
        .toArray();
    
    const userMessages = messages.filter(m => m.sender === 'user');
    const lastUserMessage = userMessages.length > 0 ? userMessages[userMessages.length - 1].content : 'ä½ å¥½';
    
    // æŒ‰é’®loadingçŠ¶æ€
    const btn = document.querySelector('.xy-chat-receive-btn');
    if (btn) {
        btn.classList.add('loading');
        btn.textContent = 'ç­‰å¾…å›å¤...';
    }
    
    try {
        await xianyuGenerateAIResponse(goods.id, lastUserMessage, goods);
    } catch (e) {
        console.error('æ¥æ”¶å›å¤å¤±è´¥:', e);
        alert('æ¥æ”¶å›å¤å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
        if (btn) {
            btn.classList.remove('loading');
            btn.textContent = 'æ¥æ”¶å›å¤';
        }
    }
}

async function xianyuGenerateAIResponse(goodsId, userMessage, goods) {
    try {
        const config = await getXianyuApiConfig();
        const worldView = localStorage.getItem('xyWorldView') || '';
        
        if (!config.apiKey) {
            xianyuDefaultResponse(goodsId, userMessage, goods);
            return;
        }
        
        const seller = await xianyuDb.users.get(goods.userId);
        const sellerId = seller ? seller.userId : `seller_${goods.userId}`;
        const sellerName = goods.sellerName || 'å–å®¶';
        
        // å°è¯•ä»db.charactersä¸­æŸ¥æ‰¾åŒåè§’è‰²ï¼Œè·å–äººè®¾
        let sellerPersonality = '';
        try {
            const allChars = await db.characters.toArray();
            const matchedChar = allChars.find(c => 
                (c.nick === sellerName || c.name === sellerName) && c.type !== 'user'
            );
            if (matchedChar) {
                sellerPersonality = `\nã€ä½ çš„è§’è‰²äººè®¾ã€‘\nåå­—ï¼š${matchedChar.name}${matchedChar.nick ? `\næ˜µç§°ï¼š${matchedChar.nick}` : ''}${matchedChar.description ? `\nè®¾å®šï¼š${matchedChar.description}` : ''}`;
            }
        } catch(e) { console.log('è·å–è§’è‰²äººè®¾å¤±è´¥:', e); }
        
        // è·å–èŠå¤©å†å²ä½œä¸ºä¸Šä¸‹æ–‡
        const allMessages = await xianyuDb.messages
            .where('goodsId').equals(goodsId)
            .toArray();
        allMessages.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
        
        // æ„å»ºå¯¹è¯å†å²
        const chatHistory = allMessages.slice(-10).map(m => {
            return m.sender === 'user' ? `ä¹°å®¶ï¼š${m.content}` : `${sellerName}ï¼š${m.content}`;
        }).join('\n');
        
        // è·å–ä¹°å®¶åå­—
        const buyerName = window.xianyuCurrentAccountName || 'ä¹°å®¶';
        
        const systemPrompt = `ä½ æ˜¯é—²é±¼å–å®¶"${sellerName}"ï¼Œæ­£åœ¨å’Œä¹°å®¶"${buyerName}"èŠå¤©ã€‚${worldView ? `ä¸–ç•Œè§‚ï¼š${worldView}ã€‚` : ''}
å•†å“ä¿¡æ¯ï¼š${goods.title}ï¼Œå½“å‰ä»·æ ¼ï¼šÂ¥${goods.price}ã€‚
${sellerPersonality}

è¯·ä»¥"${sellerName}"çš„èº«ä»½å’Œè¯­æ°”å›å¤ã€‚å¦‚æœä½ æœ‰è§’è‰²äººè®¾ï¼Œå¿…é¡»ä¸¥æ ¼æŒ‰ç…§äººè®¾çš„æ€§æ ¼æ¥å›å¤ã€‚
ä½ å¯èƒ½ä¼šä¹Ÿå¯èƒ½ä¸ä¼šæ„è¯†åˆ°ä¹°å®¶æ˜¯è°ï¼Œè¿™å–å†³äºä½ çš„åˆ¤æ–­ã€‚`;

        const userPrompt = `ä»¥ä¸‹æ˜¯èŠå¤©è®°å½•ï¼š
${chatHistory}

å›å¤è§„åˆ™ï¼š
1. å¦‚æœä¹°å®¶ç ä»·ï¼Œä½ ä¸ä¸€å®šè¦åŒæ„ã€‚æ‹’ç»æ—¶ä¸è¦æåˆ°å…·ä½“ä»·æ ¼æ•°å­—
2. å¦‚æœä½ ä¸»åŠ¨åŒæ„é™ä»·ï¼Œç”¨è¿™ä¸ªç‰¹æ®Šæ ¼å¼æ ‡è®°æ–°ä»·æ ¼ï¼šã€æ”¹ä»·:æ•°å­—ã€‘ï¼Œä¾‹å¦‚ã€æ”¹ä»·:85ã€‘
3. å¦‚æœä¸åŒæ„é™ä»·ï¼Œå°±æ­£å¸¸æ‹’ç»ï¼Œç»å¯¹ä¸è¦å‡ºç°ã€æ”¹ä»·:ã€‘æ ‡è®°
4. å›å¤è¦è‡ªç„¶ã€å£è¯­åŒ–ï¼Œç¬¦åˆä½ çš„äººè®¾
5. ä½ å¯ä»¥åˆ†å¤šæ¡æ¶ˆæ¯å›å¤ï¼Œæ¯æ¡æ¶ˆæ¯ç”¨ ||| åˆ†éš”ã€‚æ¯”å¦‚"ä½ å¥½|||è¿™ä¸ªè¿˜åœ¨çš„|||è¦çš„è¯æ‹ä¸‹å§"
6. æ¯æ¡æ¶ˆæ¯è¦çŸ­å°ç²¾æ‚ï¼ŒåƒçœŸå®èŠå¤©ä¸€æ ·

è¯·åªå›å¤æ¶ˆæ¯å†…å®¹ï¼Œä¸è¦åŠ ä»»ä½•å‰ç¼€ã€‚`;
        
        const response = await fetch(config.apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${config.apiKey}`
            },
            body: JSON.stringify({
                model: config.model,
                messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: userPrompt }
                ],
                temperature: config.temperature
            })
        });
        
        if (!response.ok) {
            throw new Error('APIè°ƒç”¨å¤±è´¥');
        }
        
        const data = await response.json();
        const aiResponse = data.choices[0].message.content.trim();
        
        // åªåœ¨AIæ˜ç¡®æ ‡è®°ã€æ”¹ä»·:æ•°å­—ã€‘æ—¶æ‰æ”¹ä»·
        const priceMatch = aiResponse.match(/ã€æ”¹ä»·[:ï¼š](\d+(?:\.\d+)?)ã€‘/);
        if (priceMatch) {
            const newPrice = parseFloat(priceMatch[1]);
            if (newPrice < goods.price && newPrice > 0) {
                await xianyuDb.goods.update(goodsId, { 
                    price: newPrice,
                    originalPrice: goods.originalPrice || goods.price
                });
                XianyuAppState.currentGoods.price = newPrice;
                const priceEl1 = document.getElementById('xyChatGoodsPrice');
                const priceEl2 = document.getElementById('xyDetailPrice');
                if (priceEl1) priceEl1.textContent = `Â¥${newPrice}`;
                if (priceEl2) priceEl2.textContent = `Â¥${newPrice}`;
            }
        }
        
        // æ¸…ç†å›å¤ä¸­çš„ç‰¹æ®Šæ ‡è®°
        const cleanResponse = aiResponse.replace(/ã€æ”¹ä»·[:ï¼š]\d+(?:\.\d+)?ã€‘/g, '').trim();
        
        // å°†å›å¤æŒ‰ ||| åˆ†éš”ä¸ºå¤šæ¡æ¶ˆæ¯ï¼Œé€æ¡å‘é€
        const messageParts = cleanResponse.split('|||').map(s => s.trim()).filter(s => s.length > 0);
        
        if (messageParts.length === 0) {
            messageParts.push(cleanResponse || 'å—¯å—¯');
        }
        
        // é€æ¡å‘é€æ¶ˆæ¯ï¼Œæ¯æ¡ä¹‹é—´æœ‰å»¶è¿Ÿ
        for (let i = 0; i < messageParts.length; i++) {
            const msgContent = messageParts[i];
            
            if (i > 0) {
                // éé¦–æ¡æ¶ˆæ¯ï¼Œç­‰å¾…ä¸€æ®µæ—¶é—´æ¨¡æ‹Ÿæ‰“å­—
                await new Promise(resolve => setTimeout(resolve, 600 + Math.random() * 800));
            }
            
            await xianyuDb.messages.add({
                goodsId: goodsId,
                content: msgContent,
                sender: 'seller',
                userId: goods.userId,
                senderId: sellerId,
                role: 'seller',
                createdAt: new Date()
            });
            
            // æ›´æ–°ä¼šè¯
            const existingSession = await xianyuDb.chatSessions.where('goodsId').equals(goodsId).first();
            if (existingSession) {
                await xianyuDb.chatSessions.update(existingSession.id, {
                    lastMessage: msgContent,
                    updatedAt: new Date()
                });
            } else {
                await xianyuDb.chatSessions.add({
                    goodsId: goodsId,
                    lastMessage: msgContent,
                    updatedAt: new Date(),
                    userId: XY_CURRENT_USER_ID
                });
            }
            
            // æ¯æ¡æ¶ˆæ¯å‘é€åç«‹å³åˆ·æ–°èŠå¤©ç•Œé¢
            xianyuLoadChatMessages(goodsId);
        }
        
        if (XianyuAppState.currentPage === 'xyMessageListPage') {
            xianyuLoadMessageList();
        }
    } catch (error) {
        console.error('AIå›å¤ç”Ÿæˆå¤±è´¥:', error);
        xianyuDefaultResponse(goodsId, userMessage, goods);
    }
}

async function xianyuDefaultResponse(goodsId, userMessage, goods) {
    const lowerMessage = userMessage.toLowerCase();
    let responses = [];
    
    if (lowerMessage.includes('ä¾¿å®œ') || lowerMessage.includes('é™ä»·') || lowerMessage.includes('ç ä»·')) {
        // é»˜è®¤å›å¤ä¸æ”¹ä»·ï¼Œåªæ˜¯å£å¤´å›åº”
        responses = ['è¿™ä¸ªä»·æ ¼å·²ç»å¾ˆå®æƒ äº†', 'ä¸å¥½æ„æ€ï¼Œä¸å¤ªèƒ½é™äº†'];
    } else if (lowerMessage.includes('åŒ…é‚®') || lowerMessage.includes('è¿è´¹')) {
        responses = ['åŒ…é‚®çš„ï¼Œæ”¾å¿ƒè´­ä¹°ï½'];
    } else if (lowerMessage.includes('è´¨é‡') || lowerMessage.includes('æ–°æ—§')) {
        responses = ['è´¨é‡å¾ˆå¥½çš„', 'å‡ ä¹å…¨æ–°ï¼Œå¯ä»¥æ”¾å¿ƒ'];
    } else {
        const defaultReplies = [
            ['æ‚¨å¥½ï¼Œæœ‰ä»€ä¹ˆå¯ä»¥å¸®æ‚¨çš„ï¼Ÿ'],
            ['åœ¨çš„', 'è¿™ä¸ªå•†å“è¿˜æœ‰å“¦'],
            ['æ„Ÿå…´è¶£çš„è¯å¯ä»¥ç›´æ¥æ‹ä¸‹å“¦'],
            ['æœ‰ç°è´§', 'ä»Šå¤©å¯ä»¥å‘è´§']
        ];
        responses = defaultReplies[Math.floor(Math.random() * defaultReplies.length)];
    }
    
    const seller = await xianyuDb.users.get(goods.userId);
    const sellerId = seller ? seller.userId : `seller_${goods.userId}`;
    
    for (let i = 0; i < responses.length; i++) {
        if (i > 0) {
            await new Promise(resolve => setTimeout(resolve, 500 + Math.random() * 500));
        }
        
        await xianyuDb.messages.add({
            goodsId: goodsId,
            content: responses[i],
            sender: 'seller',
            userId: goods.userId,
            senderId: sellerId,
            role: 'seller',
            createdAt: new Date()
        });
        
        const existingSession = await xianyuDb.chatSessions.where('goodsId').equals(goodsId).first();
        if (existingSession) {
            await xianyuDb.chatSessions.update(existingSession.id, {
                lastMessage: responses[i],
                updatedAt: new Date()
            });
        } else {
            await xianyuDb.chatSessions.add({
                goodsId: goodsId,
                lastMessage: responses[i],
                updatedAt: new Date(),
                userId: XY_CURRENT_USER_ID
            });
        }
        
        xianyuLoadChatMessages(goodsId);
    }
    
    if (XianyuAppState.currentPage === 'xyMessageListPage') {
        xianyuLoadMessageList();
    }
}

function xianyuSendQuickMessage(content) {
    const input = document.getElementById('xyChatInput');
    if (input) input.value = content;
    xianyuSendMessage();
}

async function xianyuPublishGoods() {
    const title = document.getElementById('xyPublishTitle').value;
    const price = document.getElementById('xyPublishPrice').value;
    const category = document.getElementById('xyPublishCategory').value;
    const description = document.getElementById('xyPublishDesc').value;
    
    if (!title || !price) {
        alert('è¯·å¡«å†™æ ‡é¢˜å’Œä»·æ ¼');
        return;
    }
    
    // è·å–å½“å‰è´¦å·åå­—ä½œä¸ºå–å®¶å
    let mySellerName = window.xianyuCurrentAccountName || 'æˆ‘';
    try {
        const accountChar = await db.characters.get(XY_CURRENT_USER_ID);
        if (accountChar) mySellerName = accountChar.nick || accountChar.name || mySellerName;
    } catch(e) {}
    
    const newGoods = {
        title: title,
        price: parseFloat(price),
        category: category,
        description: description || 'å•†å“æè¿°',
        sellerName: mySellerName,
        tips: 'å…·ä½“è¯·ç§èŠå’¨è¯¢',
        postage: 'åŒ…é‚®',
        metaKey: 'ç±»åˆ«',
        metaVal: category,
        viewCount: 0,
        wantCount: 0,
        collected: false,
        userId: XY_CURRENT_USER_ID,
        sellerId: `seller_${XY_CURRENT_USER_ID}`,
        originalPrice: parseFloat(price),
        sold: 0,
        bought: 0,
        createdAt: new Date()
    };
    
    const goodsId = await xianyuDb.goods.add(newGoods);
    xianyuHidePublishDialog();
    xianyuLoadGoods();
    xianyuShowDataStatus('å•†å“å‘å¸ƒæˆåŠŸ');
    await xianyuUpdateMyPageStats();
    
    setTimeout(() => {
        xianyuGenerateBuyerMessage(goodsId, newGoods);
    }, 2000);
}

async function xianyuGenerateBuyerMessage(goodsId, goods) {
    try {
        const config = await getXianyuApiConfig();
        const worldView = localStorage.getItem('xyWorldView') || '';
        
        const buyerId = `buyer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        await xianyuDb.characters.add({
            userId: buyerId,
            role: 'buyer',
            personality: 'æ™®é€šä¹°å®¶',
            worldView: worldView,
            createdAt: new Date()
        });
        
        const buyerUserId = await xianyuDb.users.add({
            username: `ä¹°å®¶${Math.random().toString(36).substr(2, 6)}`,
            avatar: 'fa-user',
            userId: buyerId,
            role: 'buyer',
            blockedUsers: [],
            createdAt: new Date()
        });
        
        let buyerMessage = '';
        
        if (config.apiUrl && config.apiKey) {
            const prompt = `ä½ æ˜¯ä¸€ä¸ªé—²é±¼ä¹°å®¶ï¼Œçœ‹åˆ°å•†å“"${goods.title}"ï¼Œä»·æ ¼Â¥${goods.price}ã€‚${worldView ? `ä¸–ç•Œè§‚ï¼š${worldView}` : ''}

è¯·ç”Ÿæˆä¸€æ¡ä¹°å®¶ç§ä¿¡ï¼Œå¯ä»¥æ˜¯ï¼š
1. è¯¢é—®å•†å“è¯¦æƒ…
2. ç ä»·
3. è¯¢é—®å‘è´§æ—¶é—´
4. å…¶ä»–åˆç†çš„é—®é¢˜

è¯·åªå›å¤æ¶ˆæ¯å†…å®¹ï¼Œè¦è‡ªç„¶ã€ç¬¦åˆé—²é±¼ä¹°å®¶çš„è¯­æ°”ã€‚`;
            
            try {
                const response = await fetch(config.apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${config.apiKey}`
                    },
                    body: JSON.stringify({
                        model: config.model,
                        messages: [
                            { role: 'system', content: 'ä½ æ˜¯ä¸€ä¸ªé—²é±¼ä¹°å®¶ï¼Œæ­£åœ¨è¯¢é—®å•†å“ä¿¡æ¯ã€‚' },
                            { role: 'user', content: prompt }
                        ],
                        temperature: config.temperature
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    buyerMessage = data.choices[0].message.content.trim();
                }
            } catch (e) {
                console.error('ç”Ÿæˆä¹°å®¶æ¶ˆæ¯APIå¤±è´¥:', e);
            }
        }
        
        if (!buyerMessage) {
            const messages = [
                `ä½ å¥½ï¼Œè¿™ä¸ª${goods.title}è¿˜åœ¨å—ï¼Ÿ`,
                `å¯ä»¥ä¾¿å®œç‚¹å—ï¼Ÿ`,
                `è¿™ä¸ªå•†å“åŒ…é‚®å—ï¼Ÿ`,
                `ä»€ä¹ˆæ—¶å€™å¯ä»¥å‘è´§ï¼Ÿ`,
                `å•†å“æ˜¯å…¨æ–°çš„å—ï¼Ÿ`
            ];
            buyerMessage = messages[Math.floor(Math.random() * messages.length)];
        }
        
        await xianyuDb.messages.add({
            goodsId: goodsId,
            content: buyerMessage,
            sender: 'buyer',
            userId: buyerUserId,
            senderId: buyerId,
            role: 'buyer',
            createdAt: new Date()
        });
        
        const existingSession = await xianyuDb.chatSessions.where('goodsId').equals(goodsId).first();
        if (existingSession) {
            await xianyuDb.chatSessions.update(existingSession.id, {
                lastMessage: buyerMessage,
                updatedAt: new Date()
            });
        } else {
            await xianyuDb.chatSessions.add({
                goodsId: goodsId,
                lastMessage: buyerMessage,
                updatedAt: new Date(),
                userId: XY_CURRENT_USER_ID
            });
        }
        
        xianyuShowDataStatus('æœ‰ä¹°å®¶æ¥ç§ä¿¡äº†ï¼');
        
        if (XianyuAppState.currentPage === 'xyMessageListPage') {
            xianyuLoadMessageList();
        }
    } catch (error) {
        console.error('ç”Ÿæˆä¹°å®¶æ¶ˆæ¯å¤±è´¥:', error);
    }
}

function xianyuShowMyGoods() { XianyuAppState.navigateTo('xyMyGoodsPage'); }
function xianyuShowMySold() { XianyuAppState.navigateTo('xyMySoldPage'); }
function xianyuShowMyBought() { XianyuAppState.navigateTo('xyMyBoughtPage'); }
function xianyuShowMyCollections() { XianyuAppState.navigateTo('xyMyCollectionsPage'); }
function xianyuShowMyChats() { alert('æˆ‘çš„èŠå¤©åŠŸèƒ½å¾…å¼€å‘'); }
function xianyuShowMyOrders() { alert('æˆ‘çš„è®¢å•åŠŸèƒ½å¾…å¼€å‘'); }
function xianyuShowMyWallet() { alert('æˆ‘çš„é’±åŒ…åŠŸèƒ½å¾…å¼€å‘'); }
function xianyuShowDataManagement() { xianyuShowSettingsDialog(); }

async function xianyuExportData() {
    try {
        const allData = {
            goods: await xianyuDb.goods.toArray(),
            collections: await xianyuDb.collections.toArray(),
            messages: await xianyuDb.messages.toArray(),
            users: await xianyuDb.users.toArray(),
            orders: await xianyuDb.orders.toArray(),
            exportDate: new Date().toISOString()
        };
        const dataStr = JSON.stringify(allData, null, 2);
        // ä½¿ç”¨ Blob + URL.createObjectURL æ›¿ä»£ data URIï¼Œé¿å…å¤§æ•°æ®é‡å¯¼è‡´æµè§ˆå™¨å´©æºƒ
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const linkElement = document.createElement('a');
        linkElement.href = url;
        linkElement.download = 'xianyu_data.json';
        document.body.appendChild(linkElement);
        linkElement.click();
        document.body.removeChild(linkElement);
        URL.revokeObjectURL(url);
        xianyuShowDataStatus('æ•°æ®å·²å¯¼å‡º');
    } catch (error) {
        console.error('é—²é±¼æ•°æ®å¯¼å‡ºå¤±è´¥:', error);
        alert('æ•°æ®å¯¼å‡ºå¤±è´¥: ' + error.message);
    }
}

function xianyuImportData() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = async (e) => {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = async (event) => {
            try {
                const data = JSON.parse(event.target.result);
                await xianyuDb.goods.clear();
                await xianyuDb.collections.clear();
                await xianyuDb.messages.clear();
                await xianyuDb.users.clear();
                await xianyuDb.orders.clear();
                if (data.goods) await xianyuDb.goods.bulkAdd(data.goods);
                if (data.collections) await xianyuDb.collections.bulkAdd(data.collections);
                if (data.messages) await xianyuDb.messages.bulkAdd(data.messages);
                if (data.users) await xianyuDb.users.bulkAdd(data.users);
                if (data.orders) await xianyuDb.orders.bulkAdd(data.orders);
                xianyuShowDataStatus('æ•°æ®å¯¼å…¥æˆåŠŸ');
                xianyuLoadGoods();
                xianyuLoadUserInfo();
                xianyuHideSettingsDialog();
            } catch (error) {
                alert('æ•°æ®å¯¼å…¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼');
            }
        };
        reader.readAsText(file);
    };
    input.click();
}

async function xianyuClearAllData() {
    if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼')) {
        await xianyuDb.goods.clear();
        await xianyuDb.collections.clear();
        await xianyuDb.messages.clear();
        await xianyuDb.orders.clear();
        xianyuShowDataStatus('æ•°æ®å·²æ¸…ç©º');
        xianyuLoadGoods();
        xianyuLoadUserInfo();
        xianyuHideSettingsDialog();
    }
}

async function xianyuResetToDefault() {
    if (confirm('ç¡®å®šè¦æ¸…ç©ºå¹¶é‡ç½®æ•°æ®å—ï¼Ÿå½“å‰æ•°æ®å°†ä¼šè¢«æ¸…ç©ºï¼')) {
        await xianyuDb.goods.clear();
        await xianyuDb.collections.clear();
        await xianyuDb.messages.clear();
        await xianyuDb.orders.clear();
        await xianyuDb.users.clear();
        await xianyuInitializeUser();
        xianyuShowDataStatus('æ•°æ®å·²é‡ç½®');
        xianyuLoadGoods();
        xianyuLoadUserInfo();
        xianyuHideSettingsDialog();
    }
}

function xianyuShowGenerateDialog() {
    const dialog = document.getElementById('xyGenerateDialog');
    if (!dialog) return;
    const savedWorldView = localStorage.getItem('xyWorldView') || '';
    const input = document.getElementById('xyWorldViewInput');
    if (input) input.value = savedWorldView;
    dialog.style.display = 'flex';
}

function xianyuHideGenerateDialog() {
    const el = document.getElementById('xyGenerateDialog');
    if (el) el.style.display = 'none';
}

async function xianyuGenerateGoods() {
    const worldViewInput = document.getElementById('xyWorldViewInput');
    const worldView = worldViewInput ? worldViewInput.value.trim() : '';
    
    const config = await getXianyuApiConfig();
    
    if (!config.apiKey) {
        alert('è¯·å…ˆåœ¨æ¡Œé¢è®¾ç½®ä¸­é…ç½®APIå¯†é’¥');
        return;
    }
    
    if (worldView) {
        localStorage.setItem('xyWorldView', worldView);
    }
    
    xianyuShowDataStatus('æ­£åœ¨ç”Ÿæˆå•†å“...');
    
    try {
        // è·å–éuserç±»å‹çš„è§’è‰²ï¼Œç”¨äºéšæœºåˆ†é…ä¸ºå–å®¶ï¼ˆæ’é™¤æ‰€æœ‰ç”¨æˆ·è´¦å·ï¼‰
        let allCharacters = [];
        try {
            const allChars = await db.characters.toArray();
            allCharacters = allChars.filter(c => c.type !== 'user');
        } catch(e) { console.error('è·å–è§’è‰²åˆ—è¡¨å¤±è´¥:', e); }
        
        // æ„å»ºè§’è‰²åå•æç¤º
        let characterHint = '';
        if (allCharacters.length > 0) {
            const charNames = allCharacters.map(c => c.nick || c.name).filter(Boolean);
            if (charNames.length > 0) {
                characterHint = `\n\nå¯ç”¨çš„å–å®¶è§’è‰²åå•ï¼š${charNames.join('ã€')}ã€‚å¯ä»¥ä»è¿™äº›è§’è‰²ä¸­éšæœºé€‰æ‹©ä½œä¸ºå–å®¶ï¼Œä¹Ÿå¯ä»¥è‡ªåˆ›ä¸€äº›æœ‰ä¸ªæ€§çš„å–å®¶åå­—ï¼Œä¸¤è€…æ··æ­ã€‚æ¯ä¸ªè§’è‰²å¯ä»¥å–å¤šä¸ªå•†å“ï¼Œè¦ç¬¦åˆè§’è‰²çš„æ€§æ ¼å’Œèº«ä»½ã€‚`;
            }
        }
        
        const prompt = `è¯·ç”Ÿæˆè‡³å°‘10ä¸ªé—²é±¼å•†å“ä¿¡æ¯ã€‚${worldView ? `ä¸–ç•Œè§‚ï¼š${worldView}ã€‚è¯·æ ¹æ®è¿™ä¸ªä¸–ç•Œè§‚ç”Ÿæˆç¬¦åˆçš„å•†å“ã€‚` : ''}${characterHint}

æ¯ä¸ªå•†å“éœ€è¦åŒ…å«ï¼š
- title: å•†å“æ ‡é¢˜ï¼ˆç®€çŸ­å¸å¼•äººï¼ŒåƒçœŸå®é—²é±¼ç”¨æˆ·å‘çš„ï¼‰
- price: ä»·æ ¼ï¼ˆåˆç†èŒƒå›´ï¼Œæ•°å­—ï¼‰
- category: ç±»åˆ«ï¼ˆå¥³è£…/ç¾å¦†/æ•°ç /å›¾ä¹¦/å…¶ä»–ï¼‰
- description: å•†å“æè¿°ï¼ˆç®€çŸ­ï¼‰
- sellerName: å–å®¶åå­—ï¼ˆä»è§’è‰²åå•ä¸­é€‰æ‹©ï¼Œæˆ–è‡ªåˆ›ä¸€ä¸ªæœ‰ä¸ªæ€§çš„åå­—ï¼Œéšæœºæ··æ­ï¼Œä¸è¦å‡ºç°"ç”¨æˆ·"äºŒå­—ï¼‰

è¯·ä»¥JSONæ ¼å¼è¿”å›ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
[
  {"title": "å•†å“æ ‡é¢˜", "price": ä»·æ ¼æ•°å­—, "category": "ç±»åˆ«", "description": "å•†å“æè¿°", "sellerName": "å–å®¶åå­—"},
  ...
]

è‡³å°‘ç”Ÿæˆ10ä¸ªå•†å“ã€‚`;
        
        const response = await fetch(config.apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${config.apiKey}`
            },
            body: JSON.stringify({
                model: config.model,
                messages: [
                    { role: 'system', content: 'ä½ æ˜¯ä¸€ä¸ªå•†å“ç”ŸæˆåŠ©æ‰‹ï¼Œä¸“é—¨ç”Ÿæˆé—²é±¼å•†å“ä¿¡æ¯ã€‚æ¯ä¸ªå•†å“éƒ½å¿…é¡»æœ‰ä¸€ä¸ªå–å®¶åå­—ã€‚' },
                    { role: 'user', content: prompt }
                ],
                temperature: config.temperature
            })
        });
        
        if (!response.ok) {
            throw new Error('APIè°ƒç”¨å¤±è´¥');
        }
        
        const data = await response.json();
        let goodsList = [];
        
        try {
            const content = data.choices[0].message.content.trim();
            const jsonMatch = content.match(/\[[\s\S]*\]/);
            if (jsonMatch) {
                goodsList = JSON.parse(jsonMatch[0]);
            } else {
                throw new Error('æ— æ³•è§£æJSON');
            }
        } catch (parseError) {
            console.error('è§£æå¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å•†å“:', parseError);
            goodsList = xianyuGenerateDefaultGoods(worldView);
        }
        
        if (goodsList.length < 10) {
            const defaultGoods = xianyuGenerateDefaultGoods(worldView);
            goodsList = goodsList.concat(defaultGoods.slice(0, 10 - goodsList.length));
        }
        
        for (const item of goodsList.slice(0, Math.max(10, goodsList.length))) {
            const sellerName = item.sellerName || `ç”¨æˆ·${Math.random().toString(36).substr(2, 6)}`;
            const sellerId = `seller_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            
            // æŸ¥æ‰¾æ˜¯å¦æœ‰åŒ¹é…çš„è§’è‰²
            let sellerAvatar = 'fa-user';
            let matchedChar = null;
            if (allCharacters.length > 0) {
                matchedChar = allCharacters.find(c => 
                    (c.nick && c.nick === sellerName) || (c.name && c.name === sellerName)
                );
            }
            if (matchedChar && matchedChar.avatar) {
                sellerAvatar = matchedChar.avatar;
            }
            
            await xianyuDb.characters.add({
                userId: sellerId,
                role: 'seller',
                personality: sellerName,
                worldView: worldView,
                createdAt: new Date()
            });
            
            const sellerUserId = await xianyuDb.users.add({
                username: sellerName,
                avatar: sellerAvatar,
                userId: sellerId,
                role: 'seller',
                blockedUsers: [],
                createdAt: new Date()
            });
            
            await xianyuDb.goods.add({
                title: item.title || 'å•†å“æ ‡é¢˜',
                price: item.price || Math.floor(Math.random() * 500) + 10,
                category: item.category || 'å…¶ä»–',
                description: item.description || 'å•†å“æè¿°',
                sellerName: sellerName,
                sellerAvatar: sellerAvatar,
                tips: 'å…·ä½“è¯·ç§èŠå’¨è¯¢',
                postage: 'åŒ…é‚®',
                metaKey: 'ç±»åˆ«',
                metaVal: item.category || 'å…¶ä»–',
                viewCount: Math.floor(Math.random() * 100),
                wantCount: Math.floor(Math.random() * 10),
                collected: false,
                userId: sellerUserId,
                sellerId: sellerId,
                originalPrice: item.price || Math.floor(Math.random() * 500) + 10,
                sold: 0,
                bought: 0,
                createdAt: new Date()
            });
        }
        
        xianyuHideGenerateDialog();
        xianyuLoadGoods();
        xianyuShowDataStatus(`æˆåŠŸç”Ÿæˆ${Math.max(10, goodsList.length)}ä¸ªå•†å“ï¼`);
    } catch (error) {
        console.error('ç”Ÿæˆå•†å“å¤±è´¥:', error);
        alert('ç”Ÿæˆå•†å“å¤±è´¥ï¼Œè¯·æ£€æŸ¥APIè®¾ç½®');
    }
}

function xianyuGenerateDefaultGoods(worldView) {
    const categories = ['å¥³è£…', 'ç¾å¦†', 'æ•°ç ', 'å›¾ä¹¦', 'å…¶ä»–'];
    const defaultNames = ['å°ç”œç”œ', 'é—²ç½®è¾¾äºº', 'äºŒæ‰‹å°ç‹å­', 'æ¸…ä»“å°‘å¥³', 'å®è—å–å®¶', 'æ‚è´§é“ºè€æ¿', 'ç”œèœœå°é“º', 'æ–‡è‰ºé’å¹´', 'æ•°ç æ§', 'æ—¶å°šè¾£å¦ˆ'];
    const goods = [];
    
    for (let i = 0; i < 10; i++) {
        const category = categories[Math.floor(Math.random() * categories.length)];
        goods.push({
            title: `${category}å•†å“${i + 1}`,
            price: Math.floor(Math.random() * 500) + 10,
            category: category,
            description: `è¿™æ˜¯ä¸€ä¸ª${category}å•†å“ï¼Œ${worldView ? `ç¬¦åˆ${worldView}ä¸–ç•Œè§‚` : 'è´¨é‡å¾ˆå¥½'}`,
            sellerName: defaultNames[i % defaultNames.length]
        });
    }
    
    return goods;
}

function xianyuShowPublishDialog() { 
    const el = document.getElementById('xyPublishDialog');
    if (el) el.style.display = 'flex'; 
}
function xianyuHidePublishDialog() {
    const el = document.getElementById('xyPublishDialog');
    if (el) el.style.display = 'none';
    const t = document.getElementById('xyPublishTitle');
    const p = document.getElementById('xyPublishPrice');
    const d = document.getElementById('xyPublishDesc');
    if (t) t.value = '';
    if (p) p.value = '';
    if (d) d.value = '';
}
function xianyuShowSettings() { xianyuShowSettingsDialog(); }
function xianyuShowSettingsDialog() { 
    const el = document.getElementById('xySettingsDialog');
    if (el) el.style.display = 'flex'; 
}
function xianyuHideSettingsDialog() { 
    const el = document.getElementById('xySettingsDialog');
    if (el) el.style.display = 'none'; 
}

function xianyuEditProfile() {
    xianyuDb.users.get(XY_CURRENT_USER_ID).then(user => {
        if (user) {
            const nameEl = document.getElementById('xyEditUserName');
            const avatarEl = document.getElementById('xyEditUserAvatar');
            if (nameEl) nameEl.value = user.username;
            if (avatarEl) avatarEl.value = user.avatar;
        }
    });
    const el = document.getElementById('xyEditProfileDialog');
    if (el) el.style.display = 'flex';
}

function xianyuHideEditProfileDialog() { 
    const el = document.getElementById('xyEditProfileDialog');
    if (el) el.style.display = 'none'; 
}

async function xianyuSaveProfile() {
    const nameEl = document.getElementById('xyEditUserName');
    const avatarEl = document.getElementById('xyEditUserAvatar');
    const username = nameEl ? nameEl.value : '';
    const avatar = avatarEl ? avatarEl.value : 'fa-user';
    if (!username.trim()) {
        alert('è¯·è¾“å…¥ç”¨æˆ·å');
        return;
    }
    await xianyuDb.users.update(XY_CURRENT_USER_ID, {
        username: username,
        avatar: avatar
    });
    xianyuHideEditProfileDialog();
    xianyuLoadUserInfo();
    xianyuShowDataStatus('èµ„æ–™å·²æ›´æ–°');
}

function xianyuFilterByCategory(category) { xianyuLoadGoods(category); }
function xianyuShowAllGoods() { xianyuLoadGoods(); }
function xianyuSwitchTab(pageId, tabId) { XianyuAppState.switchTab(pageId, tabId); }
function xianyuGoBack() { XianyuAppState.goBack(); }
function xianyuGoBackToMyPage() { XianyuAppState.goBackToMyPage(); }

async function xianyuGoToChat() {
    if (XianyuAppState.currentGoods) {
        const goods = XianyuAppState.currentGoods;
        const priceEl = document.getElementById('xyChatGoodsPrice');
        const descEl = document.getElementById('xyChatGoodsDesc');
        const locEl = document.getElementById('xyChatGoodsLocation');
        if (priceEl) priceEl.textContent = `Â¥${goods.price}`;
        if (descEl) descEl.textContent = goods.postage || 'åŒ…é‚®';
        if (locEl) locEl.textContent = goods.metaVal || 'æœªçŸ¥åœ°åŒº';
        
        const seller = await xianyuDb.users.get(goods.userId);
        const sellerName = goods.sellerName || (seller ? seller.username : 'å–å®¶');
        const roleTag = goods.userId === XY_CURRENT_USER_ID ? 'ä¹°å®¶' : 'å–å®¶';
        const headerEl = document.getElementById('xyChatHeaderName');
        if (headerEl) headerEl.innerHTML = `${sellerName} <span class="xy-credit-tag">${roleTag}</span>`;
        
        XianyuAppState.navigateTo('xyChatPage');
    } else {
        alert('è¯·å…ˆé€‰æ‹©å•†å“');
    }
}

function xianyuBuyNow() {
    if (XianyuAppState.currentGoods) {
        if (confirm(`ç¡®å®šè´­ä¹°å•†å“ï¼š${XianyuAppState.currentGoods.title} ä»·æ ¼ï¼šÂ¥${XianyuAppState.currentGoods.price}ï¼Ÿ`)) {
            xianyuDb.goods.update(XianyuAppState.currentGoods.id, { sold: 1 });
            xianyuDb.orders.add({
                goodsId: XianyuAppState.currentGoods.id,
                goodsTitle: XianyuAppState.currentGoods.title,
                goodsPrice: XianyuAppState.currentGoods.price,
                type: 'buy',
                userId: XY_CURRENT_USER_ID,
                createdAt: new Date()
            });
            xianyuShowDataStatus('è´­ä¹°æˆåŠŸï¼');
            alert('è´­ä¹°æˆåŠŸï¼');
            xianyuUpdateMyPageStats();
        }
    }
}

function xianyuBuyFromChat() { xianyuBuyNow(); }

function xianyuShowChatMenu() {
    const menu = document.getElementById('xyChatMenu');
    if (menu) menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
}

document.addEventListener('click', (e) => {
    const menu = document.getElementById('xyChatMenu');
    if (menu && !menu.contains(e.target) && !e.target.closest('.fa-ellipsis-v')) {
        menu.style.display = 'none';
    }
});

function xianyuShowPriceEditDialog() {
    const goods = XianyuAppState.currentGoods;
    if (!goods) return;
    
    const newPrice = prompt(`å½“å‰ä»·æ ¼ï¼šÂ¥${goods.price}\nè¯·è¾“å…¥æ–°ä»·æ ¼ï¼š`, goods.price);
    if (newPrice && !isNaN(newPrice) && parseFloat(newPrice) > 0) {
        xianyuUpdatePrice(goods.id, parseFloat(newPrice));
    }
    const menu = document.getElementById('xyChatMenu');
    if (menu) menu.style.display = 'none';
}

async function xianyuUpdatePrice(goodsId, newPrice) {
    const goods = await xianyuDb.goods.get(goodsId);
    if (!goods) return;
    
    await xianyuDb.goods.update(goodsId, {
        price: newPrice,
        originalPrice: goods.originalPrice || goods.price
    });
    
    XianyuAppState.currentGoods.price = newPrice;
    const priceEl1 = document.getElementById('xyChatGoodsPrice');
    const priceEl2 = document.getElementById('xyDetailPrice');
    if (priceEl1) priceEl1.textContent = `Â¥${newPrice}`;
    if (priceEl2) priceEl2.textContent = `Â¥${newPrice}`;
    
    const seller = await xianyuDb.users.get(goods.userId);
    const sellerId = seller ? seller.userId : `seller_${goods.userId}`;
    
    await xianyuDb.messages.add({
        goodsId: goodsId,
        content: `ä»·æ ¼å·²æ›´æ–°ä¸ºÂ¥${newPrice}`,
        sender: 'seller',
        userId: goods.userId,
        senderId: sellerId,
        role: 'seller',
        createdAt: new Date()
    });
    
    xianyuLoadChatMessages(goodsId);
    xianyuShowDataStatus('ä»·æ ¼å·²æ›´æ–°');
}

async function xianyuBlockUser() {
    const goods = XianyuAppState.currentGoods;
    if (!goods) return;
    
    const isUserAsSeller = goods.userId === XY_CURRENT_USER_ID;
    let targetUserId = null;
    let targetSenderId = null;
    
    if (isUserAsSeller) {
        const buyerMessage = await xianyuDb.messages.where('goodsId').equals(goods.id).filter(m => m.sender !== 'user' && m.role === 'buyer').first();
        if (buyerMessage) {
            targetUserId = buyerMessage.userId;
            targetSenderId = buyerMessage.senderId;
        }
    } else {
        const seller = await xianyuDb.users.get(goods.userId);
        targetUserId = goods.userId;
        targetSenderId = seller ? seller.userId : `seller_${goods.userId}`;
    }
    
    if (!targetUserId) {
        alert('æ— æ³•ç¡®å®šè¦æ‹‰é»‘çš„ç”¨æˆ·');
        const menu = document.getElementById('xyChatMenu');
        if (menu) menu.style.display = 'none';
        return;
    }
    
    if (confirm('ç¡®å®šè¦æ‹‰é»‘è¯¥ç”¨æˆ·å—ï¼Ÿ')) {
        const currentUser = await xianyuDb.users.get(XY_CURRENT_USER_ID);
        if (!currentUser) {
            alert('ç”¨æˆ·ä¿¡æ¯ä¸å­˜åœ¨');
            const menu = document.getElementById('xyChatMenu');
            if (menu) menu.style.display = 'none';
            return;
        }
        
        const blockedUsers = currentUser.blockedUsers || [];
        
        if (!blockedUsers.includes(targetSenderId)) {
            blockedUsers.push(targetSenderId);
            await xianyuDb.users.update(XY_CURRENT_USER_ID, {
                blockedUsers: blockedUsers
            });
            
            xianyuShowDataStatus('å·²æ‹‰é»‘è¯¥ç”¨æˆ·');
            
            await xianyuDb.messages.add({
                goodsId: goods.id,
                content: 'æ‚¨å·²è¢«æ‹‰é»‘',
                sender: 'system',
                userId: XY_CURRENT_USER_ID,
                senderId: `system_${XY_CURRENT_USER_ID}`,
                role: 'system',
                createdAt: new Date()
            });
            
            xianyuLoadChatMessages(goods.id);
        } else {
            xianyuShowDataStatus('è¯¥ç”¨æˆ·å·²è¢«æ‹‰é»‘');
        }
    }
    
    const menu = document.getElementById('xyChatMenu');
    if (menu) menu.style.display = 'none';
}

// é—²é±¼åˆå§‹åŒ– - ä»…ç»‘å®šäº‹ä»¶ï¼Œæ•°æ®åˆå§‹åŒ–åœ¨é€‰æ‹©è´¦å·åè¿›è¡Œ
document.addEventListener('DOMContentLoaded', async () => {
    try {
        await xianyuDb.open();
        
        const searchInput = document.getElementById('xySearchInput');
        if (searchInput) {
            searchInput.addEventListener('input', (e) => {
                if (e.target.value.trim()) {
                    xianyuSearchGoods(e.target.value.trim());
                } else {
                    xianyuLoadGoods();
                }
            });
        }
        
        const collectBtn = document.getElementById('xyCollectBtn');
        if (collectBtn) {
            collectBtn.addEventListener('click', function() {
                if (XianyuAppState.currentGoods) {
                    xianyuToggleCollect(XianyuAppState.currentGoods.id);
                }
            });
        }
        
        const detailCollectBtn = document.getElementById('xyDetailCollectBtn');
        if (detailCollectBtn) {
            detailCollectBtn.addEventListener('click', function() {
                if (XianyuAppState.currentGoods) {
                    xianyuToggleCollect(XianyuAppState.currentGoods.id);
                }
            });
        }
        
        console.log('[é—²é±¼] äº‹ä»¶ç»‘å®šå®Œæˆï¼Œç­‰å¾…è´¦å·é€‰æ‹©');
    } catch (error) {
        console.error('[é—²é±¼] åˆå§‹åŒ–å¤±è´¥:', error);
    }
});

// é—²é±¼è´¦å·é€‰æ‹©ç›¸å…³å‡½æ•°
function openXianyuApp() {
    document.getElementById('xianyuAppPage').classList.add('active');
    // é‡ç½®åˆ°è´¦å·é€‰æ‹©é¡µé¢
    document.getElementById('xySelectAccountPage').style.display = 'flex';
    document.getElementById('xyMainContent').style.display = 'none';
    XY_CURRENT_USER_ID = null;
    window.xianyuCurrentAccountId = null;
    window.xianyuCurrentAccountName = '';
    // åŠ è½½è´¦å·åˆ—è¡¨
    loadXianyuAccountList();
}

function closeXianyuApp() {
    document.getElementById('xianyuAppPage').classList.remove('active');
    XY_CURRENT_USER_ID = null;
    window.xianyuCurrentAccountId = null;
    window.xianyuCurrentAccountName = '';
}

// é€€å‡ºé—²é±¼ä¸»ç•Œé¢ï¼Œå›åˆ°è´¦å·é€‰æ‹©
function exitXianyuToSelect() {
    document.getElementById('xyMainContent').style.display = 'none';
    document.getElementById('xySelectAccountPage').style.display = 'flex';
    
    // é‡ç½®é¡µé¢çŠ¶æ€
    document.querySelectorAll('#xianyuAppPage .xy-page').forEach(page => {
        page.classList.remove('active');
    });
    const homePage = document.getElementById('xyHomePage');
    if (homePage) homePage.classList.add('active');
    
    // é‡ç½®TabçŠ¶æ€
    document.querySelectorAll('#xianyuAppPage .xy-tab-item').forEach(tab => {
        tab.classList.remove('active');
    });
    const homeTab = document.getElementById('xy-tab-home');
    if (homeTab) homeTab.classList.add('active');
    
    // é‡ç½®XianyuAppState
    XianyuAppState.currentPage = 'xyHomePage';
    XianyuAppState.currentTab = 'xy-tab-home';
    XianyuAppState.pageHistory = ['xyHomePage'];
    XianyuAppState.currentGoods = null;
    
    // æ¸…é™¤å…¨å±€çŠ¶æ€
    XY_CURRENT_USER_ID = null;
    window.xianyuCurrentAccountId = null;
    window.xianyuCurrentAccountName = '';
    
    loadXianyuAccountList();
}

// åŠ è½½å¾®ä¿¡è´¦å·åˆ—è¡¨
async function loadXianyuAccountList() {
    const accounts = await db.characters.where('type').equals('user').toArray();
    const listContainer = document.getElementById('xyAccountList');
    listContainer.innerHTML = '';
    
    if (accounts.length === 0) {
        listContainer.innerHTML = '<div class="xy-select-empty">æš‚æ— å¾®ä¿¡è´¦å·<div class="empty-hint">è¯·å…ˆåˆ›å»º User æ¡£æ¡ˆå¹¶æ³¨å†Œå¾®ä¿¡</div></div>';
        return;
    }
    
    accounts.forEach(account => {
        const item = document.createElement('div');
        item.className = 'xy-account-item';
        item.onclick = () => selectXianyuAccount(account.id, account.name);
        
        const avatarHtml = account.avatar 
            ? `<img src="${account.avatar}" alt="">` 
            : account.name.charAt(0);
        
        item.innerHTML = `
            <div class="xy-account-avatar">${avatarHtml}</div>
            <div class="xy-account-info">
                <div class="xy-account-name">${account.name}</div>
                <div class="xy-account-desc">${account.identity?.phone || account.identity?.wechat_id || 'WeChatç”¨æˆ·'}</div>
            </div>
            <div class="xy-account-arrow">â€º</div>
        `;
        
        listContainer.appendChild(item);
    });
}

// é€‰æ‹©å¾®ä¿¡è´¦å· â†’ ç›´æ¥è¿›å…¥é—²é±¼ä¸»ç•Œé¢
async function selectXianyuAccount(accountId, accountName) {
    XY_CURRENT_USER_ID = accountId;
    window.xianyuCurrentAccountId = accountId;
    window.xianyuCurrentAccountName = accountName;
    
    // è¿›å…¥ä¸»ç•Œé¢
    await enterXianyuMainPage();
}

// è¿›å…¥é—²é±¼ä¸»ç•Œé¢
async function enterXianyuMainPage() {
    document.getElementById('xySelectAccountPage').style.display = 'none';
    document.getElementById('xyMainContent').style.display = 'block';
    
    // æ›´æ–°"æˆ‘çš„"é¡µé¢çš„ç”¨æˆ·ä¿¡æ¯ä¸ºå½“å‰è´¦å·
    if (window.xianyuCurrentAccountId) {
        try {
            const accountChar = await db.characters.get(window.xianyuCurrentAccountId);
            if (accountChar) {
                const accountName = accountChar.nick || accountChar.name || 'ç”¨æˆ·';
                const accountAvatar = accountChar.avatar || '';
                
                const nameEl = document.getElementById('xyUserName');
                const avatarEl = document.getElementById('xyUserAvatar');
                if (nameEl) nameEl.textContent = accountName;
                if (avatarEl) {
                    if (accountAvatar) {
                        avatarEl.innerHTML = `<img src="${accountAvatar}" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">`;
                    } else {
                        avatarEl.innerHTML = `<span style="font-size:24px;color:#e89ab0;">${accountName.charAt(0)}</span>`;
                    }
                }
            }
        } catch(e) {
            console.error('[é—²é±¼] åŠ è½½è´¦å·ä¿¡æ¯å¤±è´¥:', e);
        }
    }
    
    // åˆå§‹åŒ–å½“å‰è´¦å·çš„æ•°æ®
    try {
        await xianyuDb.open().catch(() => {});
        await xianyuInitializeUser();
        await xianyuInitializeDefaultGoods();
        await xianyuLoadGoods();
        
        XianyuAppState.pageHistory = ['xyHomePage'];
        console.log('[é—²é±¼] è´¦å·', window.xianyuCurrentAccountName, 'åˆå§‹åŒ–å®Œæˆ');
    } catch (error) {
        console.error('[é—²é±¼] åˆå§‹åŒ–å¤±è´¥:', error);
    }
}

// ==================== icity æ—¥è®°åº”ç”¨ ====================

// icity å½“å‰é€‰ä¸­çš„è´¦å·IDå’Œè§’è‰²ä¿¡æ¯
window.icityCurrentAccountId = null;
window.icityCurrentAccountName = '';

function openIcityApp() {
    document.getElementById('icityAppPage').classList.add('active');
    // é‡ç½®åˆ°è´¦å·é€‰æ‹©é¡µé¢
    document.getElementById('icitySelectAccountPage').style.display = 'flex';
    document.getElementById('icityMainContent').style.display = 'none';
    window.icityCurrentAccountId = null;
    window.icityCurrentAccountName = '';
    window.icitySelectedRole = null;
    // åŠ è½½è´¦å·åˆ—è¡¨
    loadIcityAccountList();
}

function closeIcityApp() {
    document.getElementById('icityAppPage').classList.remove('active');
    window.icityCurrentAccountId = null;
    window.icityCurrentAccountName = '';
    window.icitySelectedRole = null;
}

// é€€å‡ºicityä¸»ç•Œé¢ï¼Œå›åˆ°è´¦å·é€‰æ‹©
function exitIcityToSelect() {
    document.getElementById('icityMainContent').style.display = 'none';
    document.getElementById('icitySelectAccountPage').style.display = 'flex';
    
    // é‡ç½®é¡µé¢çŠ¶æ€ï¼šç¡®ä¿ä¸‹æ¬¡è¿›å…¥æ—¶ä»åˆ—è¡¨é¡µå¼€å§‹
    const listPage = document.getElementById('icityListPage');
    const detailPage = document.getElementById('icityDetailPage');
    const publishPage = document.getElementById('icityPublishPage');
    const myPage = document.getElementById('icityMyPage');
    if (listPage) listPage.classList.add('active');
    if (detailPage) detailPage.classList.remove('active');
    if (publishPage) publishPage.classList.remove('active');
    if (myPage) myPage.classList.remove('active');
    
    // é‡ç½®TabçŠ¶æ€
    const tabDiary = document.getElementById('icityTabDiary');
    const tabMy = document.getElementById('icityTabMy');
    if (tabDiary) tabDiary.classList.add('active');
    if (tabMy) tabMy.classList.remove('active');
    
    // æ¸…é™¤å…¨å±€çŠ¶æ€
    window.icityCurrentAccountId = null;
    window.icityCurrentAccountName = '';
    window.icityCurrentAccountAvatar = '';
    window.icitySelectedRole = null;
    window.icityInitialized = false;
    
    loadIcityAccountList();
}

// åŠ è½½å¾®ä¿¡è´¦å·åˆ—è¡¨ï¼ˆuserç±»å‹çš„è§’è‰²ï¼‰
async function loadIcityAccountList() {
    const accounts = await db.characters.where('type').equals('user').toArray();
    const listContainer = document.getElementById('icityAccountList');
    listContainer.innerHTML = '';
    
    if (accounts.length === 0) {
        listContainer.innerHTML = '<div class="icity-select-empty">æš‚æ— å¾®ä¿¡è´¦å·<div class="empty-hint">è¯·å…ˆåˆ›å»º User æ¡£æ¡ˆå¹¶æ³¨å†Œå¾®ä¿¡</div></div>';
        return;
    }
    
    accounts.forEach(account => {
        const item = document.createElement('div');
        item.className = 'icity-account-item';
        item.onclick = () => selectIcityAccount(account.id, account.name);
        
        const avatarHtml = account.avatar 
            ? `<img src="${account.avatar}" alt="">` 
            : account.name.charAt(0);
        
        item.innerHTML = `
            <div class="icity-account-avatar">${avatarHtml}</div>
            <div class="icity-account-info">
                <div class="icity-account-name">${account.name}</div>
                <div class="icity-account-desc">${account.identity?.phone || account.identity?.wechat_id || 'WeChatç”¨æˆ·'}</div>
            </div>
            <div class="icity-account-arrow">â€º</div>
        `;
        
        listContainer.appendChild(item);
    });
}

// é€‰æ‹©å¾®ä¿¡è´¦å· â†’ ç›´æ¥è¿›å…¥æ—¥è®°ä¸»ç•Œé¢
async function selectIcityAccount(accountId, accountName) {
    window.icityCurrentAccountId = accountId;
    window.icityCurrentAccountName = accountName;
    window.icitySelectedRole = null;
    
    // ç›´æ¥è¿›å…¥ä¸»ç•Œé¢
    await enterIcityMainPage();
}

// è¿›å…¥ icity ä¸»ç•Œé¢
async function enterIcityMainPage() {
    document.getElementById('icitySelectAccountPage').style.display = 'none';
    document.getElementById('icityMainContent').style.display = '';
    
    // æ›´æ–°é¡µé¢æ ‡é¢˜æ˜¾ç¤ºå½“å‰è´¦å·
    const pageTitle = document.querySelector('#icityListPage .page-title');
    if (pageTitle && window.icityCurrentAccountName) {
        pageTitle.textContent = `${window.icityCurrentAccountName} Â· æ—¥è®°`;
    }
    
    // æ›´æ–°"æˆ‘çš„"é¡µé¢çš„ç”¨æˆ·ä¿¡æ¯ä¸ºå½“å‰è´¦å·
    if (window.icityCurrentAccountId) {
        try {
            const accountChar = await db.characters.get(window.icityCurrentAccountId);
            if (accountChar) {
                const accountName = accountChar.nick || accountChar.name || 'user';
                const accountWechatId = accountChar.identity?.wechat_id || accountChar.name || 'user';
                const accountAvatar = accountChar.avatar || '';
                
                // æ›´æ–°"æˆ‘çš„"é¡µé¢å¤´åƒã€åå­—ã€ID
                const profileName = document.querySelector('#icityMyPage .profile-name');
                const profileId = document.querySelector('#icityMyPage .profile-id');
                const profileAvatar = document.querySelector('#icityMyPage .profile-avatar');
                if (profileName) profileName.textContent = accountName;
                if (profileId) profileId.textContent = `@${accountWechatId}`;
                if (profileAvatar) {
                    if (accountAvatar) {
                        profileAvatar.style.backgroundImage = `url(${accountAvatar})`;
                        profileAvatar.style.backgroundSize = 'cover';
                        profileAvatar.style.backgroundPosition = 'center';
                        profileAvatar.textContent = '';
                    } else {
                        // æ²¡æœ‰å¤´åƒæ—¶æ¸…é™¤æ—§å¤´åƒï¼Œæ˜¾ç¤ºåå­—é¦–å­—
                        profileAvatar.style.backgroundImage = '';
                        profileAvatar.textContent = accountName.charAt(0);
                    }
                }
                
                // æ›´æ–°"æˆ‘çš„"é¡µé¢æ ‡é¢˜
                const myPageTitle = document.querySelector('#icityMyPage .page-title');
                if (myPageTitle) myPageTitle.textContent = `${accountName} Â· æˆ‘çš„`;
                
                // æ›´æ–°è¯¦æƒ…é¡µå¤´åƒå’Œåå­—
                const detailAvatar = document.querySelector('#icityDetailPage .detail-avatar, #icityDetailPage .avatar');
                const detailUserName = document.querySelector('#icityDetailPage .user-name');
                const detailUserId = document.querySelector('#icityDetailPage .user-id');
                if (detailAvatar && accountAvatar) {
                    detailAvatar.src = accountAvatar;
                }
                
                // ä¿å­˜åˆ°å…¨å±€ï¼Œæ–¹ä¾¿å…¶ä»–åœ°æ–¹ä½¿ç”¨
                window.icityCurrentAccountAvatar = accountAvatar;
                window.icityCurrentAccountName = accountName;
            }
        } catch(e) { console.warn(e); }
    }
    
    // åˆå§‹åŒ–æˆ–åˆ·æ–° icity åŠŸèƒ½
    if (!window.icityInitialized) {
        initIcityApp();
        window.icityInitialized = true;
    } else {
        // é‡æ–°åŠ è½½å½“å‰è´¦å·çš„æ—¥è®°
        loadIcityDiariesFromStorage().catch(console.error);
        updateIcityMyDiaryList();
    }
}

function initIcityApp() {
    // DOMå…ƒç´ è·å–
    const listPage = document.getElementById('icityListPage');
    const detailPage = document.getElementById('icityDetailPage');
    const publishPage = document.getElementById('icityPublishPage');
    const myPage = document.getElementById('icityMyPage');
    const detailBackBtn = document.getElementById('icityDetailBackBtn');
    const detailContent = document.getElementById('icityDetailContent');
    const detailTime = document.getElementById('icityDetailTime');
    const tabPublishBtn = document.getElementById('icityTabPublishBtn');
    const publishCloseBtn = document.getElementById('icityPublishCloseBtn');
    const publishSubmit = document.getElementById('icityPublishSubmit');
    const tabDiary = document.getElementById('icityTabDiary');
    const tabMy = document.getElementById('icityTabMy');
    const myTabDiary = document.getElementById('icityMyTabDiary');
    const myTabPublishBtn = document.getElementById('icityMyTabPublishBtn');
    const myTabMy = document.getElementById('icityMyTabMy');
    const commentInput = document.querySelector('#icityContent .comment-input');
    const sendBtn = document.getElementById('icitySendBtn');
    const likeBtn = document.getElementById('icityLikeBtn');
    const profileEdit = document.getElementById('icityProfileEdit');

    // 1. æ—¥è®°åˆ—è¡¨ -> è¯¦æƒ…é¡µï¼ˆä½¿ç”¨äº‹ä»¶å§”æ‰˜ï¼Œå› ä¸ºåˆ—è¡¨æ˜¯åŠ¨æ€çš„ï¼‰
    const diaryList = document.getElementById('icityDiaryList');
    if (diaryList) {
        diaryList.addEventListener('click', (e) => {
            const diaryItem = e.target.closest('.diary-item');
            if (diaryItem) {
                detailPage.dataset.fromPage = 'list';
                listPage.classList.remove('active');
                detailPage.classList.add('active');
                renderDiaryContentWithAnnotations(diaryItem.dataset.id, diaryItem.dataset.content).catch(console.error);
                detailTime.textContent = diaryItem.dataset.time;
                detailPage.dataset.currentDiaryId = diaryItem.dataset.id;
                detailPage.dataset.isUserPublished = diaryItem.dataset.isUserPublished;
                const roleName = diaryItem.querySelector('.user-name')?.textContent || 'user';
                const wechatId = diaryItem.querySelector('.user-id')?.textContent?.replace('@', '') || 'user';
                const avatarImg = diaryItem.querySelector('.avatar');
                const avatarUrl = avatarImg?.src || '';
                document.querySelector('#icityDetailPage .page-title').textContent = `${roleName} Â· æ—¥è®°`;
                const detailAvatar = document.querySelector('#icityDetailPage .detail-avatar');
                const detailUsername = document.querySelector('#icityDetailPage .detail-username');
                const detailUserid = document.querySelector('#icityDetailPage .detail-userid');
                if (detailAvatar) {
                    if (avatarUrl && !avatarUrl.includes('data:image/svg')) {
                        detailAvatar.style.backgroundImage = `url(${avatarUrl})`;
                        detailAvatar.style.backgroundSize = 'cover';
                        detailAvatar.style.backgroundPosition = 'center';
                    } else {
                        detailAvatar.style.backgroundImage = '';
                        detailAvatar.textContent = roleName.charAt(0);
                    }
                }
                if (detailUsername) detailUsername.textContent = roleName;
                if (detailUserid) detailUserid.textContent = `@${wechatId}`;
            }
        });
    }

    // 2. æˆ‘çš„æ—¥è®°åˆ—è¡¨ -> è¯¦æƒ…é¡µ
    const myDiaryList = document.querySelector('#icityMyPage .my-diary-list');
    if (myDiaryList) {
        myDiaryList.addEventListener('click', (e) => {
            const myDiaryItem = e.target.closest('.my-diary-item');
            if (myDiaryItem) {
                detailPage.dataset.fromPage = 'my';
                const diaryId = myDiaryItem.dataset.id;
                const diaryItem = document.querySelector(`#icityDiaryList .diary-item[data-id="${diaryId}"]`);
                myPage.classList.remove('active');
                detailPage.classList.add('active');
                renderDiaryContentWithAnnotations(myDiaryItem.dataset.id, myDiaryItem.dataset.content).catch(console.error);
                detailTime.textContent = myDiaryItem.dataset.time;
                detailPage.dataset.currentDiaryId = myDiaryItem.dataset.id;
                detailPage.dataset.isUserPublished = myDiaryItem.dataset.isUserPublished;
                if (diaryItem) {
                    const roleName = diaryItem.querySelector('.user-name')?.textContent || 'user';
                    const wechatId = diaryItem.querySelector('.user-id')?.textContent?.replace('@', '') || 'user';
                    const avatarImg = diaryItem.querySelector('.avatar');
                    const avatarUrl = avatarImg?.src || '';
                    document.querySelector('#icityDetailPage .page-title').textContent = `${roleName} Â· æ—¥è®°`;
                    const detailAvatar = document.querySelector('#icityDetailPage .detail-avatar');
                    const detailUsername = document.querySelector('#icityDetailPage .detail-username');
                    const detailUserid = document.querySelector('#icityDetailPage .detail-userid');
                    if (detailAvatar) {
                        if (avatarUrl && !avatarUrl.includes('data:image/svg')) {
                            detailAvatar.style.backgroundImage = `url(${avatarUrl})`;
                            detailAvatar.style.backgroundSize = 'cover';
                            detailAvatar.style.backgroundPosition = 'center';
                        } else {
                            detailAvatar.style.backgroundImage = '';
                            detailAvatar.textContent = roleName.charAt(0);
                        }
                    }
                    if (detailUsername) detailUsername.textContent = roleName;
                    if (detailUserid) detailUserid.textContent = `@${wechatId}`;
                }
            }
        });
    }

    // 3. è¯¦æƒ…é¡µ -> åˆ—è¡¨é¡µ/æˆ‘çš„é¡µ
    if (detailBackBtn) detailBackBtn.addEventListener('click', () => {
        detailPage.classList.remove('active');
        if (detailPage.dataset.fromPage === 'my') {
            myPage.classList.add('active');
        } else {
            listPage.classList.add('active');
        }
    });

    // 4. åˆ—è¡¨é¡µåº•éƒ¨Tabåˆ‡æ¢
    if (tabDiary) tabDiary.addEventListener('click', () => {
        listPage.classList.add('active');
        myPage.classList.remove('active');
        tabDiary.classList.add('active');
        if (tabMy) tabMy.classList.remove('active');
        if (myTabDiary) myTabDiary.classList.add('active');
        if (myTabMy) myTabMy.classList.remove('active');
    });

    if (tabMy) tabMy.addEventListener('click', () => {
        listPage.classList.remove('active');
        myPage.classList.add('active');
        if (tabDiary) tabDiary.classList.remove('active');
        tabMy.classList.add('active');
        if (myTabDiary) myTabDiary.classList.remove('active');
        if (myTabMy) myTabMy.classList.add('active');
    });

    // 5. æˆ‘çš„é¡µé¢åº•éƒ¨Tabåˆ‡æ¢
    if (myTabDiary) myTabDiary.addEventListener('click', () => {
        myPage.classList.remove('active');
        listPage.classList.add('active');
        myTabDiary.classList.add('active');
        if (myTabMy) myTabMy.classList.remove('active');
        if (tabDiary) tabDiary.classList.add('active');
        if (tabMy) tabMy.classList.remove('active');
    });

    if (myTabMy) myTabMy.addEventListener('click', () => {
        listPage.classList.remove('active');
        myPage.classList.add('active');
        if (myTabDiary) myTabDiary.classList.remove('active');
        myTabMy.classList.add('active');
        if (tabDiary) tabDiary.classList.remove('active');
        if (tabMy) tabMy.classList.add('active');
    });

    // 6. å‘å¸ƒæŒ‰é’®ç‚¹å‡»
    if (tabPublishBtn) tabPublishBtn.addEventListener('click', () => {
        listPage.classList.remove('active');
        publishPage.classList.add('active');
    });

    if (myTabPublishBtn) myTabPublishBtn.addEventListener('click', () => {
        myPage.classList.remove('active');
        publishPage.classList.add('active');
    });

    // 7. å…³é—­å‘å¸ƒé¡µ
    if (publishCloseBtn) publishCloseBtn.addEventListener('click', () => {
        publishPage.classList.remove('active');
        if (listPage.classList.contains('active')) {
            listPage.classList.add('active');
        } else {
            myPage.classList.add('active');
        }
    });

    // 8. å‘å¸ƒæ—¥è®°åŠŸèƒ½
    if (publishSubmit) publishSubmit.addEventListener('click', async () => {
        const title = document.getElementById('icityTitleInput').value;
        const content = document.getElementById('icityContentInput').value.trim();
        if (content === '') {
            alert('è¯·è¾“å…¥æ—¥è®°å†…å®¹ï½');
            return;
        }
        
        // è·å–å½“å‰è´¦å·ä¿¡æ¯
        let userName = 'user';
        let userWechatId = 'user';
        let userAvatar = '';
        if (window.icityCurrentAccountId) {
            try {
                const accountChar = await db.characters.get(window.icityCurrentAccountId);
                if (accountChar) {
                    userName = accountChar.nick || accountChar.name || 'user';
                    userWechatId = accountChar.identity?.wechat_id || accountChar.name || 'user';
                    userAvatar = accountChar.avatar || '';
                }
            } catch(e) {
                console.warn('è·å–è´¦å·ä¿¡æ¯å¤±è´¥:', e);
            }
        }
        const currentPersona = JSON.parse(localStorage.getItem('currentMyPersona') || 'null');
        if (!window.icityCurrentAccountId && currentPersona) {
            userName = currentPersona.nickname || userName;
            userWechatId = currentPersona.wechatId || userWechatId;
            userAvatar = currentPersona.avatarUrl || userAvatar;
        }
        
        const today = new Date();
        const dateStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
        const timeStr = `${String(today.getHours()).padStart(2, '0')}:${String(today.getMinutes()).padStart(2, '0')}`;
        
        const diaryId = Date.now();
        const fullContent = title ? `${title}\n\n${content}` : content;
        
        addIcityDiary({
            id: diaryId,
            content: fullContent,
            time: `${dateStr} ${timeStr}`,
            roleName: userName,
            role: {
                name: userName,
                realName: currentPersona?.realName || userName,
                wechatId: userWechatId,
                friend: {
                    avatar: userAvatar
                }
            },
            isUserPublished: true
        });
        
        document.getElementById('icityTitleInput').value = '';
        document.getElementById('icityContentInput').value = '';
        publishPage.classList.remove('active');
        listPage.classList.add('active');
        showIcityGenerateStatus('æ—¥è®°å‘å¸ƒæˆåŠŸï¼', 'success');
    });

    // 9. è¯„è®ºå‘é€åŠŸèƒ½
    if (sendBtn) sendBtn.addEventListener('click', () => {
        const comment = commentInput ? commentInput.value.trim() : '';
        if (comment === '') {
            alert('è¯·è¾“å…¥è¯„è®ºå†…å®¹ï½');
            return;
        }
        alert(`è¯„è®ºå‘é€æˆåŠŸï¼š${comment}`);
        if (commentInput) commentInput.value = '';
    });

    // 10. è¯¦æƒ…é¡µç‚¹èµäº¤äº’
    let isLiked = false;
    if (likeBtn) likeBtn.addEventListener('click', () => {
        isLiked = !isLiked;
        if (isLiked) {
            likeBtn.style.color = '#ff4d6d';
            likeBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5 22 12.28 18.6 15.36 13.45 20.04L12 21.35z"/></svg> å·²å–œæ¬¢';
        } else {
            likeBtn.style.color = '#999';
            likeBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M16.5 3c-1.74 0-3.41.81-4.5 2.09C10.91 3.81 9.24 3 7.5 3 4.42 3 2 5.42 2 8.5c0 3.78 3.4 6.86 8.55 11.54L12 21.35l1.45-1.32C18.6 15.36 22 12.28 22 8.5 22 5.42 19.58 3 16.5 3zM12.1 18.55l-.1.1-.1-.1C7.14 14.24 4 11.39 4 8.5 4 6.5 5.5 5 7.5 5c1.54 0 3.04.99 3.57 2.36h1.87C13.46 5.99 14.96 5 16.5 5c2 0 3.5 1.5 3.5 3.5 0 2.89-3.14 5.74-7.9 10.05z"/></svg> å–œæ¬¢';
        }
    });

    // 11. æˆ‘çš„é¡µé¢ç¼–è¾‘èµ„æ–™ç‚¹å‡»
    if (profileEdit) {
        profileEdit.addEventListener('click', () => {
            openIcityEditProfileModal();
        });
    }
    
    // 12. åˆ é™¤æ—¥è®°æŒ‰é’®ç‚¹å‡»
    const deleteBtn = document.getElementById('icityDeleteBtn');
    if (deleteBtn) {
        deleteBtn.addEventListener('click', async () => {
            const diaryId = detailPage.dataset.currentDiaryId;
            if (!diaryId) {
                alert('æ— æ³•è·å–æ—¥è®°ID');
                return;
            }
            
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ç¯‡æ—¥è®°å—ï¼Ÿåˆ é™¤åæ— æ³•æ¢å¤ï¼')) {
                try {
                    await icityDb.diaries.delete(parseInt(diaryId));
                    await icityDb.annotations.where('diaryId').equals(parseInt(diaryId)).delete();
                    
                    const diaryItem = document.querySelector(`#icityDiaryList .diary-item[data-id="${diaryId}"]`);
                    if (diaryItem) diaryItem.remove();
                    
                    const myDiaryItem2 = document.querySelector(`.my-diary-item[data-id="${diaryId}"]`);
                    if (myDiaryItem2) myDiaryItem2.remove();
                    
                    updateIcityMyDiaryList();
                    
                    const remainingDiaries = document.querySelectorAll('#icityDiaryList .diary-item');
                    if (remainingDiaries.length === 0) {
                        document.getElementById('icityDiaryList').innerHTML = '<div style="text-align: center; padding: 40px 20px; color: #999; font-size: 14px;">è¿˜æ²¡æœ‰æ—¥è®°<br><div style="font-size: 12px; margin-top: 8px; color: #ccc;">ç‚¹å‡»å³ä¸Šè§’å‘å¸ƒæˆ–ç”Ÿæˆæ—¥è®°</div></div>';
                    }
                    
                    showIcityGenerateStatus('æ—¥è®°å·²åˆ é™¤', 'success');
                    
                    detailPage.classList.remove('active');
                    if (detailPage.dataset.fromPage === 'my') {
                        myPage.classList.add('active');
                    } else {
                        listPage.classList.add('active');
                    }
                } catch (error) {
                    console.error('åˆ é™¤æ—¥è®°å¤±è´¥:', error);
                    showIcityGenerateStatus('åˆ é™¤å¤±è´¥: ' + error.message, 'error');
                }
            }
        });
    }

    // ä»DexieåŠ è½½æ—¥è®°
    loadIcityDiariesFromStorage().catch(console.error);
    
    // åˆå§‹åŒ–"æˆ‘çš„æ—¥è®°"åˆ—è¡¨
    updateIcityMyDiaryList();
    
    // åˆå§‹åŒ–æ–‡æœ¬æ ‡æ³¨åŠŸèƒ½
    initIcityAnnotation();

    // 13. è§’è‰²é€‰æ‹©æŒ‰é’®ç‚¹å‡»
    const selectRoleBtn = document.getElementById('icitySelectRoleBtn');
    if (selectRoleBtn) selectRoleBtn.addEventListener('click', () => {
        openIcityRoleModal();
    });

    // 14. ç”Ÿæˆæ—¥è®°æŒ‰é’®ç‚¹å‡»
    const generateBtn = document.getElementById('icityGenerateBtn');
    if (generateBtn) generateBtn.addEventListener('click', () => {
        generateIcityDiary();
    });
}

// icity è§’è‰²é€‰æ‹©æ¨¡æ€æ¡†ï¼ˆåœ¨appå†…åˆ‡æ¢è§’è‰²ï¼ŒæŒ‰è´¦å·è¿‡æ»¤å¥½å‹ï¼‰
async function openIcityRoleModal() {
    // ä»æ•°æ®åº“è·å–è§’è‰²åˆ—è¡¨ï¼ŒæŒ‰å½“å‰è´¦å·è¿‡æ»¤å¥½å‹ï¼ˆæ’é™¤è”æœºå¥½å‹ï¼‰
    const allChars = await db.characters.toArray();
    const currentAccountId = window.icityCurrentAccountId;
    const friends = allChars.filter(c => {
        if (c.type === 'user') return false;
        if (c.isOnlineFriend === true) return false; // æ’é™¤è”æœºå¥½å‹
        if (currentAccountId) {
            const status = getFriendStatus(c, currentAccountId);
            return status === 'friend';
        }
        return c.type === 'char' || c.type === 'npc';
    });
    const roleList = document.getElementById('icityRoleList');
    
    if (friends.length === 0) {
        roleList.innerHTML = '<div style="text-align: center; padding: 40px 20px; color: #999; font-size: 14px;">è¿˜æ²¡æœ‰åˆ›å»ºè§’è‰²<br><div style="font-size: 12px; margin-top: 8px; color: #ccc;">è¯·å…ˆåˆ›å»ºè§’è‰²</div></div>';
    } else {
        roleList.innerHTML = '';
        friends.forEach((friend, index) => {
            const roleItem = document.createElement('div');
            roleItem.className = 'icity-role-item';
            roleItem.setAttribute('data-index', index);
            
            const friendName = friend.nick || friend.name;
            const friendPersona = friend.description || friend.personality || 'æš‚æ— è¯¦ç»†äººè®¾';
            
            const prompt = `ä½ æ˜¯ä¸€ä¸ªçœŸå®çš„äººï¼Œåå­—å«${friendName}ã€‚${friendPersona}`;
            
            roleItem.setAttribute('data-role', friendName);
            roleItem.setAttribute('data-prompt', prompt);
            roleItem.setAttribute('data-name', friend.name);
            
            roleItem.innerHTML = `
                <div style="display: flex; align-items: center; gap: 12px;">
                    ${friend.avatar ? `<img src="${friend.avatar}" style="width: 40px; height: 40px; border-radius: 50%; object-fit: cover;" alt="">` : `<div style="width: 40px; height: 40px; border-radius: 50%; background: #eee; display: flex; align-items: center; justify-content: center; color: #999; font-size: 16px;">${friendName.charAt(0)}</div>`}
                    <div style="flex: 1;">
                        <div class="icity-role-name">${friendName}</div>
                        <div class="icity-role-desc">${friendPersona.length > 50 ? friendPersona.substring(0, 50) + '...' : friendPersona}</div>
                    </div>
                </div>
            `;
            
            roleItem.addEventListener('click', () => {
                document.querySelectorAll('.icity-role-item').forEach(r => r.classList.remove('selected'));
                roleItem.classList.add('selected');
                window.icitySelectedRole = {
                    name: friendName,
                    realName: friendName,
                    wechatId: friend.id || friendName.toLowerCase().replace(/\s/g, ''),
                    prompt: prompt,
                    persona: friendPersona,
                    friend: friend
                };
                setTimeout(() => {
                    closeIcityRoleModal();
                }, 300);
            });
            
            roleList.appendChild(roleItem);
        });
    }
    
    document.getElementById('icityRoleModal').style.display = 'flex';
}

function closeIcityRoleModal() {
    document.getElementById('icityRoleModal').style.display = 'none';
}

// æ‰“å¼€ç¼–è¾‘èµ„æ–™æ¨¡æ€æ¡†
async function openIcityEditProfileModal() {
    const modal = document.getElementById('icityEditProfileModal');
    
    let nickname = '';
    let wechatId = '';
    if (window.icityCurrentAccountId) {
        try {
            const accountChar = await db.characters.get(window.icityCurrentAccountId);
            if (accountChar) {
                nickname = accountChar.nick || accountChar.name || '';
                wechatId = accountChar.identity?.wechat_id || '';
            }
        } catch(e) { console.warn(e); }
    } else {
        const currentPersona = JSON.parse(localStorage.getItem('currentMyPersona') || 'null');
        nickname = currentPersona?.nickname || '';
        wechatId = currentPersona?.wechatId || '';
    }
    
    document.getElementById('icityEditUsername').value = nickname;
    document.getElementById('icityEditWechatId').value = wechatId;
    
    modal.style.display = 'flex';
}

function closeIcityEditProfileModal() {
    document.getElementById('icityEditProfileModal').style.display = 'none';
}

function saveIcityProfile() {
    const username = document.getElementById('icityEditUsername').value.trim();
    const wechatId = document.getElementById('icityEditWechatId').value.trim();
    
    if (!username) {
        alert('è¯·è¾“å…¥ç”¨æˆ·å');
        return;
    }
    
    if (!wechatId) {
        alert('è¯·è¾“å…¥å¾®ä¿¡ID');
        return;
    }
    
    const currentPersona = JSON.parse(localStorage.getItem('currentMyPersona') || '{}');
    currentPersona.nickname = username;
    currentPersona.wechatId = wechatId;
    localStorage.setItem('currentMyPersona', JSON.stringify(currentPersona));
    
    const profileName = document.querySelector('#icityMyPage .profile-name');
    const profileId = document.querySelector('#icityMyPage .profile-id');
    if (profileName) profileName.textContent = username;
    if (profileId) profileId.textContent = `@${wechatId}`;
    
    closeIcityEditProfileModal();
    showIcityGenerateStatus('èµ„æ–™ä¿å­˜æˆåŠŸï¼', 'success');
}

// æ˜¾ç¤ºç”Ÿæˆè¿›åº¦æç¤º
function showIcityGenerateStatus(message, type = 'info') {
    const oldToast = document.getElementById('icityGenerateToast');
    if (oldToast) oldToast.remove();
    
    const toast = document.createElement('div');
    toast.id = 'icityGenerateToast';
    toast.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: ${type === 'error' ? '#ff4d4f' : type === 'success' ? '#52c41a' : 'rgba(0,0,0,0.8)'};
        color: white;
        padding: 20px 30px;
        border-radius: 10px;
        z-index: 10002;
        font-size: 14px;
        max-width: 300px;
        text-align: center;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    `;
    toast.textContent = message;
    document.body.appendChild(toast);
    
    if (type === 'success' || type === 'error') {
        setTimeout(() => {
            toast.remove();
        }, 3000);
    }
}

// è·å–AI APIé…ç½®ï¼ˆä»Dexieï¼‰
async function getIcityApiConfig() {
    const urlItem = await db.dexiData.get('aiBaseUrl');
    const keyItem = await db.dexiData.get('aiApiKey');
    const modelItem = await db.dexiData.get('aiCurrentModel');
    const tempItem = await db.dexiData.get('aiTemperature');
    
    let baseUrl = (urlItem?.value || 'https://api.openai.com/v1').trim();
    if (baseUrl.endsWith('/')) baseUrl = baseUrl.slice(0, -1);
    if (!baseUrl.includes('/v1')) baseUrl += '/v1';
    const apiUrl = baseUrl + '/chat/completions';
    
    return {
        apiUrl: apiUrl,
        apiKey: keyItem?.value || '',
        model: modelItem?.value || 'gpt-3.5-turbo',
        temperature: parseFloat(tempItem?.value) || 0.8
    };
}

// ç”Ÿæˆ icity æ—¥è®°
async function generateIcityDiary() {
    if (!window.icitySelectedRole) {
        showIcityGenerateStatus('è¯·å…ˆé€‰æ‹©è§’è‰²', 'error');
        openIcityRoleModal();
        return;
    }

    const config = await getIcityApiConfig();

    if (!config.apiKey) {
        showIcityGenerateStatus('è¯·å…ˆåœ¨è®¾ç½®ä¸­é…ç½® API å¯†é’¥', 'error');
        return;
    }

    const generateBtn = document.getElementById('icityGenerateBtn');
    const originalHTML = generateBtn.innerHTML;
    generateBtn.innerHTML = '<svg class="icon-svg" viewBox="0 0 24 24"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/></svg>';
    generateBtn.style.pointerEvents = 'none';
    showIcityGenerateStatus('æ­£åœ¨ç”Ÿæˆæ—¥è®°å¹¶å¤„ç†ä»»åŠ¡...', 'info');

    try {
        const today = new Date();
        const dateStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
        const timeStr = `${String(today.getHours()).padStart(2, '0')}:${String(today.getMinutes()).padStart(2, '0')}`;

        // è·å–èŠå¤©è®°å½•
        let recentChatHistory = '';
        try {
            const friendChar = window.icitySelectedRole.friend;
            if (friendChar) {
                const accountId = typeof getCurrentAccountId === 'function' ? getCurrentAccountId() : null;
                const chatHistory = typeof getChatHistory === 'function' ? getChatHistory(friendChar, accountId) : [];
                if (chatHistory && chatHistory.length > 0) {
                    const recentMessages = chatHistory.slice(-10).map(msg => {
                        const sender = msg.isSelf ? 'æˆ‘' : (friendChar.nick || friendChar.name);
                        return `${sender}: ${msg.content || msg.text || ''}`;
                    }).join('\n');
                    if (recentMessages) {
                        recentChatHistory = `\n\næœ€è¿‘çš„èŠå¤©è®°å½•ï¼š\n${recentMessages}`;
                    }
                }
            }
        } catch (e) {
            console.warn('è·å–èŠå¤©è®°å½•å¤±è´¥:', e);
        }
        
        // æ”¶é›†ä»»åŠ¡ä¿¡æ¯
        let myLastDiaryWithAnnotations = null;
        let myLastDiaryId = null; // ä¿å­˜ä¸Šä¸€ç¯‡AIæ—¥è®°çš„IDï¼Œç”¨äºåç»­ä¿å­˜å›å¤
        let userRecentDiary = null;
        
        try {
            const currentAccountId = window.icityCurrentAccountId || 0;
            let allDiaries;
            if (currentAccountId) {
                allDiaries = await icityDb.diaries.where('accountId').equals(currentAccountId).reverse().sortBy('createdAt');
                allDiaries = allDiaries.slice(0, 10);
            } else {
                allDiaries = await icityDb.diaries.orderBy('createdAt').reverse().limit(10).toArray();
            }
            
            const myLastDiary = allDiaries.find(d => d.isUserPublished === 0 || d.isUserPublished === false);
            if (myLastDiary) {
                myLastDiaryId = myLastDiary.id; // è®°ä½è¿™ä¸ªIDï¼Œåé¢è¦ç”¨
                // åŒæ—¶ç”¨æ•°å­—å’Œå­—ç¬¦ä¸²æŸ¥è¯¢æ ‡æ³¨
                const annotations = await getIcityAnnotations(myLastDiary.id);
                const userAnnotations = annotations.filter(ann => !ann.isAI && !ann.isReply);
                if (userAnnotations.length > 0) {
                    myLastDiaryWithAnnotations = {
                        content: myLastDiary.content,
                        annotations: userAnnotations
                    };
                }
            }
            
            userRecentDiary = allDiaries.find(d => d.isUserPublished === 1 || d.isUserPublished === true);
        } catch (e) {
            console.warn('è·å–æ—¥è®°æ•°æ®å¤±è´¥:', e);
        }

        const roleName = window.icitySelectedRole.name || window.icitySelectedRole.realName || 'è§’è‰²';
        const rolePersona = window.icitySelectedRole.persona || '';

        // æ„å»ºè‡ªç„¶çš„ system prompt
        const systemPrompt = `ä½ ç°åœ¨æ˜¯${roleName}ï¼Œä¸€ä¸ªçœŸå®å­˜åœ¨çš„äººã€‚ä»¥ä¸‹æ˜¯å…³äºä½ çš„ä¿¡æ¯ï¼š
${rolePersona}

ä½ æ­£åœ¨å†™è‡ªå·±çš„ç§äººæ—¥è®°ã€‚è¦æ±‚ï¼š
- å®Œå…¨ä»¥${roleName}çš„ç¬¬ä¸€äººç§°è§†è§’ä¹¦å†™ï¼ŒåƒçœŸäººåœ¨æ‰‹æœºå¤‡å¿˜å½•é‡Œéšæ‰‹å†™çš„æ—¥è®°
- è¯­æ°”è‡ªç„¶éšæ„ï¼Œå¯ä»¥æœ‰å£è¯­åŒ–è¡¨è¾¾ã€è¯­æ°”è¯ã€çœç•¥å·ã€æ„Ÿå¹å·
- ä¸è¦å†™å¾—åƒä½œæ–‡æˆ–æ–‡å­¦ä½œå“ï¼Œè¦åƒçœŸäººçš„ç¢ç¢å¿µã€æµæ°´è´¦ã€å¿ƒæƒ…è®°å½•
- å¯ä»¥å†™ä»Šå¤©å‘ç”Ÿçš„å°äº‹ã€çªç„¶æƒ³åˆ°çš„äº‹ã€å¯¹æŸä»¶äº‹çš„åæ§½ã€çº ç»“ã€å¼€å¿ƒã€éš¾è¿‡ç­‰ç­‰
- å†…å®¹è¦æœ‰ç»†èŠ‚å’Œç”»é¢æ„Ÿï¼Œæ¯”å¦‚å…·ä½“åƒäº†ä»€ä¹ˆã€çœ‹åˆ°äº†ä»€ä¹ˆã€å’Œè°è¯´äº†ä»€ä¹ˆè¯
- å¯ä»¥æœ‰å‰åè·³è·ƒã€æƒ³åˆ°å“ªå†™åˆ°å“ªçš„æ„Ÿè§‰ï¼Œä¸éœ€è¦ä¸¥æ ¼çš„é€»è¾‘ç»“æ„
- å¯ä»¥å¤¹æ‚ä¸€äº›å†…å¿ƒç‹¬ç™½ã€è‡ªé—®è‡ªç­”
- å­—æ•°åœ¨800-2000å­—å·¦å³ï¼Œä¸è¦å¤ªçŸ­ä¹Ÿä¸è¦åˆ»æ„å‡‘å­—æ•°
- ã€é‡è¦ã€‘ä¸è¦åœ¨æ—¥è®°æ­£æ–‡å¼€å¤´æˆ–ä»»ä½•ä½ç½®å†™æ—¥æœŸã€æ—¶é—´ã€æ ‡é¢˜ï¼ˆå¦‚"2025å¹´1æœˆ1æ—¥"ã€"å‘¨ä¸€"ã€"Day X"ç­‰ï¼‰ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨æ·»åŠ æ—¥æœŸï¼Œä½ åªéœ€è¦å†™æ—¥è®°å†…å®¹æœ¬èº«`;

        // æ„å»º user prompt
        let userPromptParts = [];
        
        userPromptParts.push(`è¯·ä»¥${roleName}çš„èº«ä»½å†™ä¸€ç¯‡ä»Šå¤©çš„æ—¥è®°ã€‚`);
        
        if (recentChatHistory) {
            userPromptParts.push(`\nå‚è€ƒæœ€è¿‘å’Œåˆ«äººçš„èŠå¤©å†…å®¹ï¼Œå¯ä»¥åœ¨æ—¥è®°é‡Œè‡ªç„¶åœ°æåˆ°ç›¸å…³çš„äº‹ï¼ˆä¸è¦ç…§æ¬èŠå¤©è®°å½•ï¼Œç”¨æ—¥è®°çš„å£å»å»å†™æ„Ÿå—å’Œæƒ³æ³•ï¼‰ï¼š${recentChatHistory}`);
        }

        // æ ‡æ³¨ä»»åŠ¡
        let hasExtraTasks = false;
        if (myLastDiaryWithAnnotations || userRecentDiary) {
            hasExtraTasks = true;
            userPromptParts.push(`\né™¤äº†æ—¥è®°ä¹‹å¤–ï¼Œè¿˜æœ‰é¢å¤–ä»»åŠ¡ï¼š`);
            if (myLastDiaryWithAnnotations) {
                userPromptParts.push(`- ç”¨æˆ·å¯¹ä½ ä¸Šä¸€ç¯‡æ—¥è®°è¿›è¡Œäº†æ ‡æ³¨è¯„è®ºï¼Œè¯·ä»¥${roleName}çš„å£å»å¯¹æ¯æ¡ç»™å‡ºç®€çŸ­å›åº”ï¼ˆåƒæœ‹å‹ä¹‹é—´å›å¤ç•™è¨€ä¸€æ ·è‡ªç„¶ï¼Œ15-30å­—ï¼‰ï¼š`);
                myLastDiaryWithAnnotations.annotations.forEach(ann => {
                    userPromptParts.push(`  Â· æ ‡æ³¨å†…å®¹ï¼š"${ann.text}" â†’ ç”¨æˆ·è¯„è®ºï¼š${ann.comment}`);
                });
            }
            if (userRecentDiary) {
                userPromptParts.push(`- ç”¨æˆ·å†™äº†ä¸€ç¯‡æ—¥è®°ï¼Œè¯·ä»¥${roleName}çš„å£å»å¯¹å…¶ä¸­2-4å¤„å†…å®¹è¿›è¡Œæ ‡æ³¨è¯„è®ºï¼ˆåƒæœ‹å‹åœ¨æ—è¾¹å†™æ‰¹æ³¨ä¸€æ ·ï¼ŒçœŸå®è‡ªç„¶ï¼Œ15-40å­—ï¼‰ï¼š`);
                userPromptParts.push(`  ç”¨æˆ·çš„æ—¥è®°å†…å®¹ï¼š${userRecentDiary.content.substring(0, 1500)}`);
            }
        }

        userPromptParts.push(`\nè¯·ä¸¥æ ¼æŒ‰ä»¥ä¸‹JSONæ ¼å¼è¾“å‡ºï¼Œä¸è¦è¾“å‡ºå…¶ä»–ä»»ä½•å†…å®¹ï¼š
{
  "diary": "æ—¥è®°æ­£æ–‡ï¼ˆçº¯æ–‡æœ¬ï¼Œç”¨\\næ¢è¡Œï¼‰",
  "repliesToUserAnnotations": ${myLastDiaryWithAnnotations ? '[{"text": "ä½ æ—¥è®°ä¸­è¢«æ ‡æ³¨çš„åŸæ–‡ç‰‡æ®µ", "comment": "ä½ çš„å›åº”"}]' : '[]'},
  "annotationsForUserDiary": ${userRecentDiary ? '[{"text": "ç”¨æˆ·æ—¥è®°ä¸­çš„åŸæ–‡ç‰‡æ®µ", "comment": "ä½ çš„æ ‡æ³¨è¯„è®º"}]' : '[]'}
}`);

        const userPrompt = userPromptParts.join('\n');

        const response = await fetch(config.apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${config.apiKey}` },
            body: JSON.stringify({
                model: config.model,
                messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: userPrompt }
                ],
                temperature: config.temperature || 0.9,
                max_tokens: 8000
            })
        });

        if (!response.ok) throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status}`);

        const data = await response.json();
        const responseContent = data.choices?.[0]?.message?.content?.trim() || '';
        
        let jsonStr = responseContent;
        if (jsonStr.startsWith('```json')) {
            jsonStr = jsonStr.replace(/^```json\s*/, '').replace(/\s*```$/, '');
        } else if (jsonStr.startsWith('```')) {
            jsonStr = jsonStr.replace(/^```\s*/, '').replace(/\s*```$/, '');
        }
        
        const parsed = JSON.parse(jsonStr);
        const diaryContent = parsed.diary || '';
        const replies = parsed.repliesToUserAnnotations || [];
        const annotationsFromAI = parsed.annotationsForUserDiary || [];
        
        console.log('[icityç”Ÿæˆ] æ—¥è®°é•¿åº¦:', diaryContent.length, 'å›å¤æ ‡æ³¨æ•°:', replies.length, 'æ ‡æ³¨ç”¨æˆ·æ—¥è®°æ•°:', annotationsFromAI.length);
        console.log('[icityç”Ÿæˆ] myLastDiaryId:', myLastDiaryId, 'myLastDiaryWithAnnotations:', !!myLastDiaryWithAnnotations, 'userRecentDiary:', !!userRecentDiary);
        
        if (!diaryContent || diaryContent.length < 50) throw new Error('ç”Ÿæˆçš„æ—¥è®°å†…å®¹è¿‡çŸ­');
        
        const diaryId = Date.now();
        addIcityDiary({
            id: diaryId,
            content: diaryContent,
            time: `${dateStr} ${timeStr}`,
            roleName: window.icitySelectedRole.name || window.icitySelectedRole.realName || 'user',
            role: window.icitySelectedRole,
            isUserPublished: false
        });
        
        // ä¿å­˜å¯¹æˆ‘ä¸Šä¸€ç¯‡æ—¥è®°çš„å›å¤æ ‡æ³¨ï¼ˆä½¿ç”¨ä¹‹å‰è®°ä½çš„myLastDiaryIdï¼Œä¸å†é‡æ–°æŸ¥è¯¢ï¼‰
        if (replies.length > 0 && myLastDiaryWithAnnotations && myLastDiaryId) {
            console.log('[icity] ä¿å­˜å›å¤æ ‡æ³¨åˆ°æ—¥è®°ID:', myLastDiaryId, 'å›å¤æ•°é‡:', replies.length);
            const replyAnnotations = replies.map((reply, idx) => ({
                id: Date.now() + idx + 1000,
                diaryId: myLastDiaryId,
                text: reply.text,
                comment: reply.comment,
                createdAt: new Date().toISOString(),
                isAI: true,
                aiRole: window.icitySelectedRole.name,
                isReply: true,
                accountId: window.icityCurrentAccountId || 0
            }));
            for (const ann of replyAnnotations) {
                await icityDb.annotations.put(ann);
            }
        }
        
        // ä¿å­˜å¯¹ç”¨æˆ·æ—¥è®°çš„æ ‡æ³¨
        if (annotationsFromAI.length > 0 && userRecentDiary) {
            const annotationsToSave = annotationsFromAI.map((ann, idx) => ({
                id: Date.now() + idx + 2000,
                diaryId: userRecentDiary.id,
                text: ann.text,
                comment: ann.comment,
                createdAt: new Date().toISOString(),
                isAI: true,
                aiRole: window.icitySelectedRole.name,
                accountId: window.icityCurrentAccountId || 0
            }));
            for (const ann of annotationsToSave) {
                await icityDb.annotations.put(ann);
            }
        }
        
        showIcityGenerateStatus(`å®Œæˆï¼${replies.length > 0 ? `å›å¤äº†${replies.length}æ¡æ ‡æ³¨ï¼Œ` : ''}${annotationsFromAI.length > 0 ? `æ ‡æ³¨äº†ä½ çš„æ—¥è®°${annotationsFromAI.length}å¤„` : ''}`, 'success');
        
    } catch (error) {
        console.error('ç”Ÿæˆå¤±è´¥:', error);
        showIcityGenerateStatus(`ç”Ÿæˆå¤±è´¥ï¼š${error.message}`, 'error');
    } finally {
        generateBtn.innerHTML = originalHTML;
        generateBtn.style.pointerEvents = 'auto';
    }
}

// æ·»åŠ æ—¥è®°åˆ°åˆ—è¡¨
function addIcityDiary(diary) {
    const diaryList = document.getElementById('icityDiaryList');
    const date = new Date(diary.time);
    const monthNames = ['1æœˆ', '2æœˆ', '3æœˆ', '4æœˆ', '5æœˆ', '6æœˆ', '7æœˆ', '8æœˆ', '9æœˆ', '10æœˆ', '11æœˆ', '12æœˆ'];
    const weekDays = ['æ˜ŸæœŸæ—¥', 'æ˜ŸæœŸä¸€', 'æ˜ŸæœŸäºŒ', 'æ˜ŸæœŸä¸‰', 'æ˜ŸæœŸå››', 'æ˜ŸæœŸäº”', 'æ˜ŸæœŸå…­'];
    const dateStr = `${monthNames[date.getMonth()]}${date.getDate()}æ—¥ Â· ${weekDays[date.getDay()]} ${date.getFullYear()}`;
    const timeStr = diary.time.split(' ')[1] || '00:00';
    
    const role = diary.role || window.icitySelectedRole || {};
    const avatarUrl = role.friend?.avatar || `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='40'%3E%3Crect width='40' height='40' fill='%23ddd'/%3E%3Ccircle cx='20' cy='20' r='15' fill='%23ccc'/%3E%3C/svg%3E`;
    const wechatId = role.wechatId || role.friend?.id || 'user';
    const roleName = diary.roleName || role.name || role.realName || 'user';
    
    const preview = diary.content.replace(/\n/g, ' ').substring(0, 50) + (diary.content.length > 50 ? '...' : '');

    const diaryItem = document.createElement('div');
    diaryItem.className = 'diary-item';
    diaryItem.setAttribute('data-id', diary.id);
    diaryItem.setAttribute('data-content', diary.content);
    diaryItem.setAttribute('data-time', diary.time);
    diaryItem.setAttribute('data-role-name', roleName);
    diaryItem.setAttribute('data-wechat-id', wechatId);
    diaryItem.setAttribute('data-avatar-url', avatarUrl);
    diaryItem.setAttribute('data-is-user-published', diary.isUserPublished ? 'true' : 'false');
    
    diaryItem.innerHTML = `
        <div class="diary-header">
            <div class="user-info">
                <img src="${avatarUrl}" alt="å¤´åƒ" class="avatar" style="border-radius: 50%; object-fit: cover;">
                <div class="user-name-box">
                    <div class="user-name">${roleName}</div>
                    <div class="user-id">@${wechatId}</div>
                </div>
            </div>
            <div class="diary-date">${dateStr}</div>
        </div>
        <div class="diary-content">${preview}</div>
        <div class="diary-actions">
            <div class="action-item">
                <svg viewBox="0 0 24 24"><path d="M16.5 3c-1.74 0-3.41.81-4.5 2.09C10.91 3.81 9.24 3 7.5 3 4.42 3 2 5.42 2 8.5c0 3.78 3.4 6.86 8.55 11.54L12 21.35l1.45-1.32C18.6 15.36 22 12.28 22 8.5 22 5.42 19.58 3 16.5 3zM12.1 18.55l-.1.1-.1-.1C7.14 14.24 4 11.39 4 8.5 4 6.5 5.5 5 7.5 5c1.54 0 3.04.99 3.57 2.36h1.87C13.46 5.99 14.96 5 16.5 5c2 0 3.5 1.5 3.5 3.5 0 2.89-3.14 5.74-7.9 10.05z"/></svg>
                0
            </div>
            <div class="action-item">
                <svg viewBox="0 0 24 24"><path d="M21.99 4c0-1.1-.89-2-2-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4-.01-18zM18 14H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"/></svg>
                0
            </div>
            <div class="action-item">
                <svg viewBox="0 0 24 24"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67z"/></svg>
                ${timeStr}
            </div>
            <div class="more-btn">
                <svg viewBox="0 0 24 24"><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/></svg>
            </div>
        </div>
    `;

    const firstChild = diaryList.firstElementChild;
    if (firstChild && firstChild.style && firstChild.style.textAlign === 'center') {
        diaryList.innerHTML = '';
    }
    
    if (diaryList.firstChild) {
        diaryList.insertBefore(diaryItem, diaryList.firstChild);
    } else {
        diaryList.appendChild(diaryItem);
    }

    updateIcityMyDiaryList();
    
    saveIcityDiaryToDexie(diary.id, {
        content: diary.content,
        time: diary.time,
        roleName: roleName,
        wechatId: wechatId,
        avatarUrl: avatarUrl,
        isUserPublished: diary.isUserPublished ? 1 : 0,
        createdAt: new Date().toISOString(),
        accountId: window.icityCurrentAccountId || 0
    });
}

// ä¿å­˜å•ä¸ªæ—¥è®°åˆ°Dexie
async function saveIcityDiaryToDexie(diaryId, diaryData) {
    try {
        await icityDb.diaries.put({
            id: diaryId,
            accountId: window.icityCurrentAccountId || 0,
            ...diaryData
        });
    } catch (error) {
        console.error('ä¿å­˜æ—¥è®°åˆ°Dexieå¤±è´¥:', error);
    }
}

// ä»DexieåŠ è½½æ‰€æœ‰æ—¥è®°ï¼ˆæŒ‰accountIdè¿‡æ»¤ï¼‰
async function loadIcityDiariesFromStorage() {
    const diaryList = document.getElementById('icityDiaryList');
    if (!diaryList) return;
    
    const currentAccountId = window.icityCurrentAccountId || 0;
    
    try {
        const savedDiaries = localStorage.getItem('icity_diaries');
        if (savedDiaries) {
            try {
                const diaries = JSON.parse(savedDiaries);
                for (const diary of diaries) {
                    await icityDb.diaries.put({
                        id: diary.id,
                        content: diary.content,
                        time: diary.time,
                        roleName: diary.roleName || 'user',
                        wechatId: diary.wechatId || 'user',
                        avatarUrl: diary.avatarUrl || '',
                        isUserPublished: diary.isUserPublished ? 1 : 0,
                        createdAt: new Date().toISOString(),
                        accountId: currentAccountId
                    });
                }
                localStorage.removeItem('icity_diaries');
            } catch (e) {
                console.error('è¿ç§»localStorageæ•°æ®å¤±è´¥:', e);
            }
        }
        
        // æŒ‰ accountId è¿‡æ»¤æ—¥è®°
        let diaries;
        if (currentAccountId) {
            diaries = (await icityDb.diaries.where('accountId').equals(currentAccountId).reverse().toArray());
        } else {
            diaries = await icityDb.diaries.orderBy('id').reverse().toArray();
        }
        
        if (diaries.length === 0) {
            diaryList.innerHTML = '<div style="text-align: center; padding: 40px 20px; color: #999; font-size: 14px;">è¿˜æ²¡æœ‰æ—¥è®°<br><div style="font-size: 12px; margin-top: 8px; color: #ccc;">ç‚¹å‡»å³ä¸Šè§’å‘å¸ƒæˆ–ç”Ÿæˆæ—¥è®°</div></div>';
            return;
        }
        
        diaryList.innerHTML = '';
        
        diaries.sort((a, b) => {
            const timeA = new Date(a.time.replace(/-/g, '/'));
            const timeB = new Date(b.time.replace(/-/g, '/'));
            return timeB - timeA;
        });
        
        diaries.forEach(diary => {
            const diaryItem = document.createElement('div');
            diaryItem.className = 'diary-item';
            diaryItem.setAttribute('data-id', diary.id);
            diaryItem.setAttribute('data-content', diary.content);
            diaryItem.setAttribute('data-time', diary.time);
            diaryItem.setAttribute('data-role-name', diary.roleName || 'user');
            diaryItem.setAttribute('data-wechat-id', diary.wechatId || 'user');
            diaryItem.setAttribute('data-avatar-url', diary.avatarUrl || '');
            diaryItem.setAttribute('data-is-user-published', diary.isUserPublished ? 'true' : 'false');
            
            const date = new Date(diary.time.replace(/-/g, '/'));
            const monthNames = ['1æœˆ', '2æœˆ', '3æœˆ', '4æœˆ', '5æœˆ', '6æœˆ', '7æœˆ', '8æœˆ', '9æœˆ', '10æœˆ', '11æœˆ', '12æœˆ'];
            const weekDays = ['æ˜ŸæœŸæ—¥', 'æ˜ŸæœŸä¸€', 'æ˜ŸæœŸäºŒ', 'æ˜ŸæœŸä¸‰', 'æ˜ŸæœŸå››', 'æ˜ŸæœŸäº”', 'æ˜ŸæœŸå…­'];
            const dateStr = `${monthNames[date.getMonth()]}${date.getDate()}æ—¥ Â· ${weekDays[date.getDay()]} ${date.getFullYear()}`;
            const timeStr = diary.time.split(' ')[1] || '00:00';
            const preview = diary.content.replace(/\n/g, ' ').substring(0, 50) + (diary.content.length > 50 ? '...' : '');
            
            diaryItem.innerHTML = `
                <div class="diary-header">
                    <div class="user-info">
                        <img src="${diary.avatarUrl || ''}" alt="å¤´åƒ" class="avatar" style="border-radius: 50%; object-fit: cover;">
                        <div class="user-name-box">
                            <div class="user-name">${diary.roleName || 'user'}</div>
                            <div class="user-id">@${diary.wechatId || 'user'}</div>
                        </div>
                    </div>
                    <div class="diary-date">${dateStr}</div>
                </div>
                <div class="diary-content">${preview}</div>
                <div class="diary-actions">
                    <div class="action-item">
                        <svg viewBox="0 0 24 24"><path d="M16.5 3c-1.74 0-3.41.81-4.5 2.09C10.91 3.81 9.24 3 7.5 3 4.42 3 2 5.42 2 8.5c0 3.78 3.4 6.86 8.55 11.54L12 21.35l1.45-1.32C18.6 15.36 22 12.28 22 8.5 22 5.42 19.58 3 16.5 3zM12.1 18.55l-.1.1-.1-.1C7.14 14.24 4 11.39 4 8.5 4 6.5 5.5 5 7.5 5c1.54 0 3.04.99 3.57 2.36h1.87C13.46 5.99 14.96 5 16.5 5c2 0 3.5 1.5 3.5 3.5 0 2.89-3.14 5.74-7.9 10.05z"/></svg>
                        0
                    </div>
                    <div class="action-item">
                        <svg viewBox="0 0 24 24"><path d="M21.99 4c0-1.1-.89-2-2-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4-.01-18zM18 14H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"/></svg>
                        0
                    </div>
                    <div class="action-item">
                        <svg viewBox="0 0 24 24"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67z"/></svg>
                        ${timeStr}
                    </div>
                    <div class="more-btn">
                        <svg viewBox="0 0 24 24"><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/></svg>
                    </div>
                </div>
            `;
            
            diaryList.appendChild(diaryItem);
        });
        
        updateIcityMyDiaryList();
    } catch (error) {
        console.error('åŠ è½½æ—¥è®°å¤±è´¥:', error);
        diaryList.innerHTML = '<div style="text-align: center; padding: 40px 20px; color: #999; font-size: 14px;">åŠ è½½æ—¥è®°å¤±è´¥</div>';
    }
}

// æ›´æ–°"æˆ‘çš„æ—¥è®°"åˆ—è¡¨
function updateIcityMyDiaryList() {
    const allDiaryItems = document.querySelectorAll('#icityContent .diary-item');
    const userPublishedItems = Array.from(allDiaryItems).filter(item => 
        item.dataset.isUserPublished === 'true'
    );
    const myDiaryList = document.querySelector('#icityMyPage .my-diary-list');
    
    if (!myDiaryList) return;
    
    myDiaryList.innerHTML = '';
    
    if (userPublishedItems.length === 0) {
        myDiaryList.innerHTML = '<div style="text-align: center; padding: 40px 20px; color: #999; font-size: 14px;">è¿˜æ²¡æœ‰æ—¥è®°<br><div style="font-size: 12px; margin-top: 8px; color: #ccc;">åœ¨å‘å¸ƒé¡µé¢å‘å¸ƒæ—¥è®°åæ‰ä¼šæ˜¾ç¤ºåœ¨è¿™é‡Œ</div></div>';
    } else {
        userPublishedItems.forEach(item => {
            const myDiaryItem = document.createElement('div');
            myDiaryItem.className = 'my-diary-item';
            myDiaryItem.setAttribute('data-id', item.dataset.id);
            myDiaryItem.setAttribute('data-content', item.dataset.content);
            myDiaryItem.setAttribute('data-time', item.dataset.time);
            myDiaryItem.setAttribute('data-role-name', item.dataset.roleName || '');
            myDiaryItem.setAttribute('data-wechat-id', item.dataset.wechatId || '');
            myDiaryItem.setAttribute('data-avatar-url', item.dataset.avatarUrl || '');
            
            const preview = item.dataset.content.replace(/\n/g, ' ').substring(0, 100) + (item.dataset.content.length > 100 ? '...' : '');
            
            myDiaryItem.innerHTML = `
                <div class="my-diary-time">${item.dataset.time}</div>
                <div class="my-diary-content">${preview}</div>
            `;
            
            myDiaryList.appendChild(myDiaryItem);
        });
    }

    const statElement = document.querySelector('#icityMyPage .my-diary-stat');
    if (statElement) {
        statElement.textContent = `æˆ‘çš„æ—¥è®°ï¼ˆ${userPublishedItems.length}ç¯‡ï¼‰`;
    }
}

// ==================== icity æ–‡æœ¬æ ‡æ³¨åŠŸèƒ½ ====================

function initIcityAnnotation() {
    const detailPage = document.getElementById('icityDetailPage');
    if (!detailPage) return;

    let selectionTimer = null;
    
    // ç»Ÿä¸€çš„é€‰åŒºæ£€æŸ¥å‡½æ•°
    function checkAndShowAnnotation() {
        if (selectionTimer) clearTimeout(selectionTimer);
        selectionTimer = setTimeout(() => {
            const selection = window.getSelection();
            if (!selection || selection.rangeCount === 0) return;
            const text = selection.toString().trim();
            if (text.length === 0) return;
            
            const detailContent = document.getElementById('icityDetailContent');
            if (!detailContent) return;
            
            const range = selection.getRangeAt(0);
            if (detailContent.contains(range.commonAncestorContainer) || 
                detailContent.contains(range.startContainer) ||
                detailContent.contains(selection.anchorNode)) {
                showAnnotationPopup(range, text);
            }
        }, 300);
    }
    
    // æ–¹å¼1ï¼šselectionchangeï¼ˆæ¡Œé¢æµè§ˆå™¨ï¼‰
    document.addEventListener('selectionchange', checkAndShowAnnotation);
    
    // æ–¹å¼2ï¼šmouseupï¼ˆé¼ æ ‡æ‹–é€‰é‡Šæ”¾æ—¶æ£€æŸ¥ï¼‰
    document.addEventListener('mouseup', function(e) {
        const detailContent = document.getElementById('icityDetailContent');
        if (detailContent && (detailContent.contains(e.target) || detailContent === e.target)) {
            setTimeout(checkAndShowAnnotation, 50);
        }
    });
    
    // æ–¹å¼3ï¼štouchendï¼ˆè§¦å±é•¿æŒ‰é€‰æ‹©é‡Šæ”¾æ—¶æ£€æŸ¥ï¼‰
    document.addEventListener('touchend', function(e) {
        const detailContent = document.getElementById('icityDetailContent');
        if (detailContent && (detailContent.contains(e.target) || detailContent === e.target)) {
            // è§¦å±é€‰æ‹©éœ€è¦æ›´é•¿çš„å»¶è¿Ÿï¼Œç­‰å¾…ç³»ç»Ÿé€‰åŒºç¨³å®š
            setTimeout(checkAndShowAnnotation, 500);
        }
    });
    
    // ç‚¹å‡»å¤–éƒ¨å…³é—­å¼¹çª—
    document.addEventListener('mousedown', function(e) {
        const popup = document.getElementById('icityAnnotationPopup');
        const detailContent = document.getElementById('icityDetailContent');
        if (popup && !popup.contains(e.target) && 
            !e.target.closest('.annotation-highlight') &&
            !(detailContent && detailContent.contains(e.target))) {
            closeAnnotationPopup();
        }
    });
    
    // è§¦å±ç‚¹å‡»å¤–éƒ¨å…³é—­å¼¹çª—
    document.addEventListener('touchstart', function(e) {
        const popup = document.getElementById('icityAnnotationPopup');
        if (!popup) return;
        if (popup.contains(e.target)) return;
        if (e.target.closest && e.target.closest('.annotation-highlight')) return;
        const detailContent = document.getElementById('icityDetailContent');
        if (detailContent && detailContent.contains(e.target)) return;
        closeAnnotationPopup();
    }, { passive: true });
}

function showAnnotationPopup(range, selectedText) {
    const oldPopup = document.getElementById('icityAnnotationPopup');
    if (oldPopup) oldPopup.remove();
    
    const popup = document.createElement('div');
    popup.id = 'icityAnnotationPopup';
    popup.className = 'icity-annotation-popup';
    popup.dataset.selectedText = selectedText;
    
    popup.innerHTML = `
        <div class="annotation-text">å·²é€‰æ‹©ï¼š${selectedText.length > 30 ? selectedText.substring(0, 30) + '...' : selectedText}</div>
        <textarea class="annotation-input" id="icityAnnotationInput" placeholder="æ·»åŠ æ ‡æ³¨è¯„è®º..."></textarea>
        <div class="annotation-buttons">
            <button class="annotation-btn annotation-btn-cancel" onclick="closeAnnotationPopup()">å–æ¶ˆ</button>
            <button class="annotation-btn annotation-btn-save" onclick="saveIcityAnnotation()">ä¿å­˜</button>
        </div>
    `;
    
    document.body.appendChild(popup);
    
    let rect;
    if (range instanceof Range) {
        rect = range.getBoundingClientRect();
    } else if (range && range.target) {
        rect = range.target.getBoundingClientRect();
    } else {
        return;
    }

    popup.style.left = (rect.left + rect.width / 2 - 150) + 'px';
    popup.style.top = (rect.bottom + 10) + 'px';
    
    const popupRect = popup.getBoundingClientRect();
    if (popupRect.left < 10) popup.style.left = '10px';
    if (popupRect.right > window.innerWidth - 10) popup.style.left = (window.innerWidth - popupRect.width - 10) + 'px';
    
    if (popupRect.bottom > window.innerHeight - 10) {
        popup.style.top = (rect.top - popupRect.height - 10) + 'px';
    }
    
    setTimeout(() => {
        document.getElementById('icityAnnotationInput')?.focus();
    }, 100);
}

function closeAnnotationPopup() {
    const popup = document.getElementById('icityAnnotationPopup');
    if (popup) popup.remove();
    window.getSelection().removeAllRanges();
}

async function saveIcityAnnotation() {
    const input = document.getElementById('icityAnnotationInput');
    const comment = input?.value.trim() || '';
    const detailContentEl = document.getElementById('icityDetailContent');
    const diaryId = detailContentEl?.dataset.diaryId;
    const popup = document.getElementById('icityAnnotationPopup');
    
    if (!diaryId) {
        closeAnnotationPopup();
        return;
    }
    
    let selectedText = popup?.dataset.selectedText;
    
    if (!selectedText) {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            selectedText = selection.toString().trim();
        }
    }
    
    if (!selectedText) {
        closeAnnotationPopup();
        return;
    }
    
    showIcityGenerateStatus('æ­£åœ¨ä¿å­˜æ ‡æ³¨...', 'info');
    
    try {
        const annotations = await getIcityAnnotations(diaryId);
        const annotation = {
            id: Date.now(),
            text: selectedText,
            comment: comment,
            createdAt: new Date().toISOString(),
            isAI: false
        };
        
        annotations.push(annotation);
        await saveIcityAnnotations(diaryId, annotations);
        
        const originalContent = detailContentEl.dataset.originalContent || detailContentEl.textContent;
        await renderDiaryContentWithAnnotations(diaryId, originalContent);
        
        closeAnnotationPopup();
        showIcityGenerateStatus('æ ‡æ³¨å·²ä¿å­˜', 'success');
    } catch (error) {
        console.error('ä¿å­˜æ ‡æ³¨å¤±è´¥:', error);
        showIcityGenerateStatus('ä¿å­˜æ ‡æ³¨å¤±è´¥: ' + error.message, 'error');
        closeAnnotationPopup();
    }
}

// è·å–æ ‡æ³¨æ•°æ®ï¼ˆä»Dexieï¼‰- åŒæ—¶æŸ¥è¯¢æ•°å­—å’Œå­—ç¬¦ä¸²ç±»å‹çš„diaryId
async function getIcityAnnotations(diaryId) {
    try {
        const key = `icity_annotations_${diaryId}`;
        const numId = parseInt(diaryId);
        const strId = String(diaryId);
        
        const oldData = localStorage.getItem(key);
        if (oldData) {
            try {
                const annotations = JSON.parse(oldData);
                for (const ann of annotations) {
                    await icityDb.annotations.put({
                        id: ann.id,
                        diaryId: numId || strId,
                        text: ann.text,
                        comment: ann.comment || '',
                        createdAt: ann.createdAt || new Date().toISOString(),
                        accountId: window.icityCurrentAccountId || 0
                    });
                }
                localStorage.removeItem(key);
            } catch (e) {
                console.error('è¿ç§»æ ‡æ³¨æ•°æ®å¤±è´¥:', e);
            }
        }
        
        // åŒæ—¶æŸ¥æ•°å­—IDå’Œå­—ç¬¦ä¸²IDï¼Œè§£å†³ç±»å‹ä¸åŒ¹é…é—®é¢˜
        let annotations = [];
        try {
            const byNum = numId ? await icityDb.annotations.where('diaryId').equals(numId).toArray() : [];
            const byStr = await icityDb.annotations.where('diaryId').equals(strId).toArray();
            // åˆå¹¶å»é‡
            const idSet = new Set();
            for (const ann of [...byNum, ...byStr]) {
                if (!idSet.has(ann.id)) {
                    idSet.add(ann.id);
                    annotations.push(ann);
                }
            }
        } catch (e) {
            annotations = await icityDb.annotations.where('diaryId').equals(diaryId).toArray();
        }
        return annotations;
    } catch (error) {
        console.error('è·å–æ ‡æ³¨å¤±è´¥:', error);
        return [];
    }
}

// ä¿å­˜æ ‡æ³¨æ•°æ®ï¼ˆåˆ°Dexieï¼‰- ç»Ÿä¸€ä½¿ç”¨æ•°å­—ç±»å‹diaryId
async function saveIcityAnnotations(diaryId, annotations) {
    try {
        const numId = parseInt(diaryId);
        const strId = String(diaryId);
        // åˆ é™¤æ•°å­—å’Œå­—ç¬¦ä¸²ç±»å‹çš„æ—§æ ‡æ³¨
        await icityDb.annotations.where('diaryId').equals(numId || strId).delete();
        if (numId) {
            await icityDb.annotations.where('diaryId').equals(strId).delete();
        }
        for (const ann of annotations) {
            await icityDb.annotations.put({
                id: ann.id,
                diaryId: numId || diaryId,
                text: ann.text,
                comment: ann.comment || '',
                createdAt: ann.createdAt || new Date().toISOString(),
                isAI: ann.isAI || false,
                aiRole: ann.aiRole || '',
                isReply: ann.isReply || false,
                accountId: window.icityCurrentAccountId || 0
            });
        }
    } catch (error) {
        console.error('ä¿å­˜æ ‡æ³¨å¤±è´¥:', error);
    }
}

// æ¸²æŸ“å¸¦æ ‡æ³¨çš„æ—¥è®°å†…å®¹
async function renderDiaryContentWithAnnotations(diaryId, content) {
    const detailContentEl = document.getElementById('icityDetailContent');
    if (!detailContentEl) return;
    
    detailContentEl.dataset.diaryId = diaryId;
    detailContentEl.dataset.originalContent = content;
    
    const annotations = await getIcityAnnotations(diaryId);
    const annotationsArray = Array.isArray(annotations) ? annotations : [];
    
    if (annotationsArray.length === 0) {
        detailContentEl.textContent = content;
    } else {
        // åœ¨åŸå§‹çº¯æ–‡æœ¬ä¸Šå®šä½æ¯ä¸ªæ ‡æ³¨çš„ä½ç½®
        let segments = [];
        for (const ann of annotationsArray) {
            if (!ann.text) continue;
            const idx = content.indexOf(ann.text);
            if (idx !== -1) {
                segments.push({
                    start: idx,
                    end: idx + ann.text.length,
                    ann: ann
                });
            }
        }
        
        // æŒ‰ä½ç½®æ’åº
        segments.sort((a, b) => a.start - b.start);
        
        // å»é™¤é‡å çš„æ ‡æ³¨ï¼ˆä¿ç•™å…ˆå‡ºç°çš„ï¼‰
        let filtered = [];
        let lastEnd = 0;
        for (const seg of segments) {
            if (seg.start >= lastEnd) {
                filtered.push(seg);
                lastEnd = seg.end;
            }
        }
        
        // ä¸€æ¬¡æ€§æ„å»ºHTMLï¼Œä¸åšå¤šè½®å­—ç¬¦ä¸²æ›¿æ¢
        let html = '';
        let pos = 0;
        for (const seg of filtered) {
            // æ·»åŠ æ ‡æ³¨å‰çš„æ™®é€šæ–‡æœ¬
            if (seg.start > pos) {
                html += icityEscapeHtml(content.substring(pos, seg.start));
            }
            // æ·»åŠ é«˜äº®æ ‡æ³¨ï¼ˆç”¨ icityEscapeAttr è½¬ä¹‰å±æ€§å€¼ï¼Œé˜²æ­¢å¼•å·ç ´åHTMLï¼‰
            html += `<span class="annotation-highlight" data-annotation-id="${seg.ann.id}" title="${icityEscapeAttr(seg.ann.comment || 'æ— è¯„è®º')}">${icityEscapeHtml(seg.ann.text)}</span>`;
            pos = seg.end;
        }
        // æ·»åŠ æœ€åå‰©ä½™çš„æ–‡æœ¬
        if (pos < content.length) {
            html += icityEscapeHtml(content.substring(pos));
        }
        
        detailContentEl.innerHTML = html;
        
        detailContentEl.querySelectorAll('.annotation-highlight').forEach(highlight => {
            highlight.addEventListener('click', function(e) {
                e.stopPropagation();
                const annId = this.dataset.annotationId;
                const annotation = annotationsArray.find(a => a.id == annId);
                if (annotation) {
                    showIcityAnnotationTooltip(e, annotation);
                }
            });
        });
    }
    
    await updateIcityAnnotationList(diaryId);
}

// æ›´æ–°æ ‡æ³¨åˆ—è¡¨
async function updateIcityAnnotationList(diaryId) {
    const annotationList = document.getElementById('icityAnnotationList');
    if (!annotationList) return;
    
    const annotations = await getIcityAnnotations(diaryId);
    
    if (annotations.length === 0) {
        annotationList.style.display = 'none';
    } else {
        annotationList.style.display = 'block';
        annotationList.innerHTML = '';
        
        annotations.forEach(ann => {
            const item = document.createElement('div');
            item.className = 'icity-annotation-item';
            const roleTag = ann.isAI ? `<span style="color: #e67e22; font-size: 11px; font-weight: bold;">[${ann.aiRole || 'AI'}${ann.isReply ? ' å›å¤' : ' æ ‡æ³¨'}]</span> ` : '';
            item.innerHTML = `
                <div class="annotation-quote">"${icityEscapeHtml(ann.text)}"</div>
                <div class="annotation-comment">${roleTag}${icityEscapeHtml(ann.comment || 'æ— è¯„è®º')}</div>
                <div style="font-size: 11px; color: #999; margin-top: 6px;">${new Date(ann.createdAt).toLocaleString('zh-CN')}</div>
            `;
            annotationList.appendChild(item);
        });
    }
}

// æ˜¾ç¤ºæ ‡æ³¨æç¤º
function showIcityAnnotationTooltip(event, annotation) {
    const oldTooltip = document.getElementById('icityAnnotationTooltip');
    if (oldTooltip) oldTooltip.remove();
    
    const tooltip = document.createElement('div');
    tooltip.id = 'icityAnnotationTooltip';
    tooltip.className = 'icity-annotation-tooltip';
    tooltip.textContent = annotation.comment || 'æ— è¯„è®º';
    
    document.body.appendChild(tooltip);
    
    const rect = event.target.getBoundingClientRect();
    tooltip.style.left = (rect.left + rect.width / 2 - tooltip.offsetWidth / 2) + 'px';
    tooltip.style.top = (rect.top - tooltip.offsetHeight - 8) + 'px';
    
    setTimeout(() => {
        tooltip.remove();
    }, 3000);
}

// icity HTMLè½¬ä¹‰ï¼ˆä½¿ç”¨ä¸åŒåç§°é¿å…å†²çªï¼‰
function icityEscapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// è½¬ä¹‰HTMLå±æ€§å€¼ï¼ˆåŒ…æ‹¬å¼•å·ï¼‰
function icityEscapeAttr(text) {
    return String(text || '').replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// æš´éœ² icity å…¨å±€å‡½æ•°
window.openIcityApp = openIcityApp;
window.closeIcityApp = closeIcityApp;
window.exitIcityToSelect = exitIcityToSelect;
window.openIcityRoleModal = openIcityRoleModal;
window.closeIcityRoleModal = closeIcityRoleModal;
window.openIcityEditProfileModal = openIcityEditProfileModal;
window.closeIcityEditProfileModal = closeIcityEditProfileModal;
window.saveIcityProfile = saveIcityProfile;
window.closeAnnotationPopup = closeAnnotationPopup;
window.saveIcityAnnotation = saveIcityAnnotation;

// ================== èŠå¤©ä¸»é¢˜ç®¡ç†åŠŸèƒ½ ==================

// å…¨å±€å˜é‡ï¼šå½“å‰é€‰ä¸­çš„ä¸»é¢˜IDï¼ˆç”¨äºä¸»é¢˜é€‰æ‹©å™¨ï¼‰
let selectedThemeIdForApply = null;

// ä¿å­˜èŠå¤©ä¸»é¢˜
async function saveChatTheme() {
    try {
        const themeName = document.getElementById('chat-theme-name').value.trim();
        if (!themeName) {
            showToast('âŒ è¯·è¾“å…¥ä¸»é¢˜åç§°');
            return;
        }

        const accountId = getCurrentAccountId() || 'offline';

        const themeData = {
            name: themeName,
            accountId: accountId,
            time: Date.now(),
            // èƒŒæ™¯
            chatBackground: document.getElementById('chat-theme-bg').value.trim(),
            headerBg: document.getElementById('chat-theme-header-bg').value.trim(),
            headerColor: document.getElementById('chat-theme-header-color').value,
            titleColor: document.getElementById('chat-theme-title-color').value,
            footerBg: document.getElementById('chat-theme-footer-bg').value.trim(),
            footerColor: document.getElementById('chat-theme-footer-color').value,
            // é¡¶æ æŒ‰é’®å›¾æ ‡
            iconBack: document.getElementById('chat-theme-icon-back').value.trim(),
            iconOffline: document.getElementById('chat-theme-icon-offline').value.trim(),
            iconDetail: document.getElementById('chat-theme-icon-detail').value.trim(),
            // åº•æ æŒ‰é’®å›¾æ ‡
            iconAi: document.getElementById('chat-theme-icon-ai').value.trim(),
            iconEmoji: document.getElementById('chat-theme-icon-emoji').value.trim(),
            iconMore: document.getElementById('chat-theme-icon-more').value.trim(),
            iconSend: document.getElementById('chat-theme-icon-send').value.trim(),
            // å›¾æ ‡å¤§å°
            iconBackSize: parseInt(document.getElementById('chat-theme-icon-back-size')?.value) || 24,
            iconOfflineSize: parseInt(document.getElementById('chat-theme-icon-offline-size')?.value) || 20,
            iconDetailSize: parseInt(document.getElementById('chat-theme-icon-detail-size')?.value) || 20,
            iconAiSize: parseInt(document.getElementById('chat-theme-icon-ai-size')?.value) || 22,
            iconEmojiSize: parseInt(document.getElementById('chat-theme-icon-emoji-size')?.value) || 22,
            iconMoreSize: parseInt(document.getElementById('chat-theme-icon-more-size')?.value) || 22,
            iconSendSize: parseInt(document.getElementById('chat-theme-icon-send-size')?.value) || 18
        };

        const themeId = await db.chat_themes.add(themeData);
        console.log('[ChatTheme] âœ“ ä¸»é¢˜å·²ä¿å­˜:', themeData);

        showToast('âœ… ä¸»é¢˜ä¿å­˜æˆåŠŸ');

        // æ¸…ç©ºè¡¨å•
        document.getElementById('chat-theme-name').value = '';
        document.getElementById('chat-theme-bg').value = '';
        document.getElementById('chat-theme-header-bg').value = '';
        document.getElementById('chat-theme-title-color').value = '#333333';
        document.getElementById('chat-theme-footer-bg').value = '';
        document.getElementById('chat-theme-icon-back').value = '';
        document.getElementById('chat-theme-icon-offline').value = '';
        document.getElementById('chat-theme-icon-detail').value = '';
        document.getElementById('chat-theme-icon-ai').value = '';
        document.getElementById('chat-theme-icon-emoji').value = '';
        document.getElementById('chat-theme-icon-more').value = '';
        document.getElementById('chat-theme-icon-send').value = '';
        // é‡ç½®å›¾æ ‡å¤§å°æ»‘å—
        const defaultSizes = [
            { id: 'chat-theme-icon-back-size', val: 'chat-theme-icon-back-size-val', v: 24 },
            { id: 'chat-theme-icon-offline-size', val: 'chat-theme-icon-offline-size-val', v: 20 },
            { id: 'chat-theme-icon-detail-size', val: 'chat-theme-icon-detail-size-val', v: 20 },
            { id: 'chat-theme-icon-ai-size', val: 'chat-theme-icon-ai-size-val', v: 22 },
            { id: 'chat-theme-icon-emoji-size', val: 'chat-theme-icon-emoji-size-val', v: 22 },
            { id: 'chat-theme-icon-more-size', val: 'chat-theme-icon-more-size-val', v: 22 },
            { id: 'chat-theme-icon-send-size', val: 'chat-theme-icon-send-size-val', v: 18 }
        ];
        defaultSizes.forEach(f => {
            const slider = document.getElementById(f.id);
            const label = document.getElementById(f.val);
            if (slider) slider.value = f.v;
            if (label) label.textContent = f.v + 'px';
        });

        // åˆ·æ–°é¢„è§ˆ
        previewChatTheme();

        // åˆ·æ–°ä¸»é¢˜åˆ—è¡¨
        await loadChatThemeList();
    } catch (error) {
        console.error('[ChatTheme] âœ— ä¿å­˜å¤±è´¥:', error);
        showToast('âŒ ä¿å­˜å¤±è´¥: ' + error.message);
    }
}

// åŠ è½½èŠå¤©ä¸»é¢˜åˆ—è¡¨
async function loadChatThemeList() {
    try {
        const accountId = getCurrentAccountId() || 'offline';
        const themes = await db.chat_themes.where('accountId').equals(accountId).reverse().sortBy('time');

        const listContainer = document.getElementById('chat-theme-list');
        if (!listContainer) return;

        if (themes.length === 0) {
            listContainer.innerHTML = '<div style="padding:20px; text-align:center; color:#999; font-size:13px;">æš‚æ— ä¿å­˜çš„ä¸»é¢˜<br>åˆ›å»ºä½ çš„ç¬¬ä¸€ä¸ªä¸»é¢˜å§</div>';
            return;
        }

        listContainer.innerHTML = themes.map(theme => {
            const iconCount = [theme.iconBack, theme.iconOffline, theme.iconDetail, theme.iconAi, theme.iconEmoji, theme.iconMore, theme.iconSend].filter(Boolean).length;
            return `
            <div style="padding:12px; background:#f8f8f8; border-radius:8px; border:1px solid #e8e8e8;">
                <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
                    <div style="font-size:15px; font-weight:600; color:#333;">${theme.name}</div>
                    <div style="display:flex; gap:6px;">
                        <div onclick="exportSingleChatTheme(${theme.id})" style="padding:4px 10px; background:#fff; border:1px solid #ddd; border-radius:6px; font-size:12px; color:#007aff; cursor:pointer;">å¯¼å‡º</div>
                        <div onclick="editChatTheme(${theme.id})" style="padding:4px 10px; background:#fff; border:1px solid #ddd; border-radius:6px; font-size:12px; color:#666; cursor:pointer;">ç¼–è¾‘</div>
                        <div onclick="deleteChatTheme(${theme.id})" style="padding:4px 10px; background:#fff; border:1px solid #ddd; border-radius:6px; font-size:12px; color:#ff3b30; cursor:pointer;">åˆ é™¤</div>
                    </div>
                </div>
                <div style="display:flex; gap:8px; margin-bottom:6px; align-items:center;">
                    ${theme.chatBackground ? `<div style="width:60px; height:40px; border-radius:6px; background-image:url(${theme.chatBackground}); background-size:cover; background-position:center; border:1px solid #ddd;"></div>` : ''}
                    <div style="display:flex; gap:4px; flex-wrap:wrap; align-items:center;">
                        <div style="width:24px; height:24px; border-radius:4px; background:${theme.headerColor || '#ededed'}; border:1px solid #ddd;" title="é¡¶æ è‰²"></div>
                        <div style="width:24px; height:24px; border-radius:4px; background:${theme.footerColor || '#ffffff'}; border:1px solid #ddd;" title="åº•æ è‰²"></div>
                    </div>
                    ${iconCount > 0 ? `<div style="font-size:11px; color:#999; margin-left:auto;">ğŸ¨ ${iconCount}ä¸ªè‡ªå®šä¹‰å›¾æ ‡</div>` : ''}
                </div>
                <div style="font-size:11px; color:#999;">${new Date(theme.time).toLocaleString('zh-CN')}</div>
            </div>
        `}).join('');
    } catch (error) {
        console.error('[ChatTheme] âœ— åŠ è½½ä¸»é¢˜åˆ—è¡¨å¤±è´¥:', error);
    }
}

// ç¼–è¾‘èŠå¤©ä¸»é¢˜
async function editChatTheme(themeId) {
    try {
        const theme = await db.chat_themes.get(themeId);
        if (!theme) {
            showToast('âŒ ä¸»é¢˜ä¸å­˜åœ¨');
            return;
        }

        // å¡«å……è¡¨å• - èƒŒæ™¯
        document.getElementById('chat-theme-name').value = theme.name;
        document.getElementById('chat-theme-bg').value = theme.chatBackground || '';
        document.getElementById('chat-theme-header-bg').value = theme.headerBg || '';
        document.getElementById('chat-theme-header-color').value = theme.headerColor || '#ededed';
        document.getElementById('chat-theme-title-color').value = theme.titleColor || '#333333';
        document.getElementById('chat-theme-footer-bg').value = theme.footerBg || '';
        document.getElementById('chat-theme-footer-color').value = theme.footerColor || '#ffffff';
        // å¡«å……è¡¨å• - å›¾æ ‡
        document.getElementById('chat-theme-icon-back').value = theme.iconBack || '';
        document.getElementById('chat-theme-icon-offline').value = theme.iconOffline || '';
        document.getElementById('chat-theme-icon-detail').value = theme.iconDetail || '';
        document.getElementById('chat-theme-icon-ai').value = theme.iconAi || '';
        document.getElementById('chat-theme-icon-emoji').value = theme.iconEmoji || '';
        document.getElementById('chat-theme-icon-more').value = theme.iconMore || '';
        document.getElementById('chat-theme-icon-send').value = theme.iconSend || '';
        // å¡«å……è¡¨å• - å›¾æ ‡å¤§å°
        const sizeFields = [
            { id: 'chat-theme-icon-back-size', val: 'chat-theme-icon-back-size-val', v: theme.iconBackSize || 24 },
            { id: 'chat-theme-icon-offline-size', val: 'chat-theme-icon-offline-size-val', v: theme.iconOfflineSize || 20 },
            { id: 'chat-theme-icon-detail-size', val: 'chat-theme-icon-detail-size-val', v: theme.iconDetailSize || 20 },
            { id: 'chat-theme-icon-ai-size', val: 'chat-theme-icon-ai-size-val', v: theme.iconAiSize || 22 },
            { id: 'chat-theme-icon-emoji-size', val: 'chat-theme-icon-emoji-size-val', v: theme.iconEmojiSize || 22 },
            { id: 'chat-theme-icon-more-size', val: 'chat-theme-icon-more-size-val', v: theme.iconMoreSize || 22 },
            { id: 'chat-theme-icon-send-size', val: 'chat-theme-icon-send-size-val', v: theme.iconSendSize || 18 }
        ];
        sizeFields.forEach(f => {
            const slider = document.getElementById(f.id);
            const label = document.getElementById(f.val);
            if (slider) slider.value = f.v;
            if (label) label.textContent = f.v + 'px';
        });

        // æ›´æ–°é¢„è§ˆ
        previewChatTheme();

        // æ»šåŠ¨åˆ°è¡¨å•é¡¶éƒ¨
        const expandEl = document.querySelector('#expand4') || document.querySelector('#expand5');
        if (expandEl) expandEl.scrollIntoView({ behavior: 'smooth' });

        // åˆ é™¤æ—§ä¸»é¢˜
        await db.chat_themes.delete(themeId);
        await loadChatThemeList();

        showToast('ğŸ“ ä¸»é¢˜å·²åŠ è½½åˆ°ç¼–è¾‘å™¨ï¼Œä¿®æ”¹åç‚¹å‡»ä¿å­˜');
    } catch (error) {
        console.error('[ChatTheme] âœ— ç¼–è¾‘ä¸»é¢˜å¤±è´¥:', error);
        showToast('âŒ ç¼–è¾‘å¤±è´¥: ' + error.message);
    }
}

// åˆ é™¤èŠå¤©ä¸»é¢˜
async function deleteChatTheme(themeId) {
    if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªä¸»é¢˜å—ï¼Ÿ')) return;

    try {
        await db.chat_themes.delete(themeId);
        showToast('âœ… ä¸»é¢˜å·²åˆ é™¤');
        await loadChatThemeList();
    } catch (error) {
        console.error('[ChatTheme] âœ— åˆ é™¤ä¸»é¢˜å¤±è´¥:', error);
        showToast('âŒ åˆ é™¤å¤±è´¥: ' + error.message);
    }
}

// é¢„è§ˆèŠå¤©ä¸»é¢˜ - å®Œå…¨æŒ‰ç…§å®é™…èŠå¤©é¡µé¢ç»“æ„
function previewChatTheme() {
    const chatBg = document.getElementById('chat-theme-bg')?.value?.trim() || '';
    const headerBg = document.getElementById('chat-theme-header-bg')?.value?.trim() || '';
    const headerColor = document.getElementById('chat-theme-header-color')?.value || '#ededed';
    const titleColor = document.getElementById('chat-theme-title-color')?.value || '#333333';
    const footerBg = document.getElementById('chat-theme-footer-bg')?.value?.trim() || '';
    const footerColor = document.getElementById('chat-theme-footer-color')?.value || '#ffffff';
    
    // æŒ‰é’®å›¾æ ‡URL
    const iconBack = document.getElementById('chat-theme-icon-back')?.value?.trim() || '';
    const iconOffline = document.getElementById('chat-theme-icon-offline')?.value?.trim() || '';
    const iconDetail = document.getElementById('chat-theme-icon-detail')?.value?.trim() || '';
    const iconAi = document.getElementById('chat-theme-icon-ai')?.value?.trim() || '';
    const iconEmoji = document.getElementById('chat-theme-icon-emoji')?.value?.trim() || '';
    const iconMore = document.getElementById('chat-theme-icon-more')?.value?.trim() || '';
    const iconSend = document.getElementById('chat-theme-icon-send')?.value?.trim() || '';
    
    // æŒ‰é’®å›¾æ ‡å¤§å°
    const sizeBack = parseInt(document.getElementById('chat-theme-icon-back-size')?.value) || 24;
    const sizeOffline = parseInt(document.getElementById('chat-theme-icon-offline-size')?.value) || 20;
    const sizeDetail = parseInt(document.getElementById('chat-theme-icon-detail-size')?.value) || 20;
    const sizeAi = parseInt(document.getElementById('chat-theme-icon-ai-size')?.value) || 22;
    const sizeEmoji = parseInt(document.getElementById('chat-theme-icon-emoji-size')?.value) || 22;
    const sizeMore = parseInt(document.getElementById('chat-theme-icon-more-size')?.value) || 22;
    const sizeSend = parseInt(document.getElementById('chat-theme-icon-send-size')?.value) || 18;

    const previewContainer = document.getElementById('chat-theme-preview-container');
    if (!previewContainer) return;

    // æœ‰èƒŒæ™¯å›¾æ—¶ç”¨ background ç®€å†™è¦†ç›–ï¼Œå¹¶è®¾ transparent è®©é€æ˜PNGé€å‡ºåé¢å†…å®¹
    const headerBgStyle = headerBg ? `background: url(${headerBg}) center/cover no-repeat transparent;` : '';
    const footerBgStyle = footerBg ? `background: url(${footerBg}) center/cover no-repeat transparent;` : '';
    const chatBgStyle = chatBg ? `background: url(${chatBg}) center/cover no-repeat;` : '';

    // å›¾æ ‡æ¸²æŸ“ï¼šæœ‰URLç”¨å›¾ç‰‡ï¼Œæ²¡æœ‰ç”¨é»˜è®¤SVGï¼ˆä½¿ç”¨è‡ªå®šä¹‰å¤§å°ï¼‰
    const backIcon = iconBack
        ? `<img src="${iconBack}" style="width:${sizeBack}px; height:${sizeBack}px; object-fit:contain;">`
        : `<svg class="svg-icon" viewBox="0 0 24 24" style="width:${sizeBack}px; height:${sizeBack}px;"><polyline points="15 18 9 12 15 6"></polyline></svg>`;
    
    const offlineIcon = iconOffline
        ? `<img src="${iconOffline}" style="width:${sizeOffline}px; height:${sizeOffline}px; object-fit:contain;">`
        : `<svg class="svg-icon" viewBox="0 0 24 24" style="width:${sizeOffline}px; height:${sizeOffline}px;"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>`;
    
    const detailIcon = iconDetail
        ? `<img src="${iconDetail}" style="width:${sizeDetail}px; height:${sizeDetail}px; object-fit:contain;">`
        : `<svg class="svg-icon" viewBox="0 0 24 24" style="width:${sizeDetail}px; height:${sizeDetail}px;"><circle cx="12" cy="12" r="1"></circle><circle cx="19" cy="12" r="1"></circle><circle cx="5" cy="12" r="1"></circle></svg>`;
    
    const aiIcon = iconAi
        ? `<img src="${iconAi}" style="width:${sizeAi}px; height:${sizeAi}px; object-fit:contain;">`
        : `<svg class="svg-icon" viewBox="0 0 24 24" style="width:${sizeAi}px; height:${sizeAi}px;"><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M9 5H1"/></svg>`;
    
    const emojiIcon = iconEmoji
        ? `<img src="${iconEmoji}" style="width:${sizeEmoji}px; height:${sizeEmoji}px; object-fit:contain;">`
        : `<svg class="svg-icon" viewBox="0 0 24 24" style="width:${sizeEmoji}px; height:${sizeEmoji}px;"><circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg>`;
    
    const moreIcon = iconMore
        ? `<img src="${iconMore}" style="width:${sizeMore}px; height:${sizeMore}px; object-fit:contain;">`
        : `<svg class="svg-icon" viewBox="0 0 24 24" style="width:${sizeMore}px; height:${sizeMore}px;"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line></svg>`;
    
    const sendIcon = iconSend
        ? `<img src="${iconSend}" style="width:${sizeSend}px; height:${sizeSend}px; object-fit:contain;">`
        : `<svg class="svg-icon" viewBox="0 0 24 24" style="width:${sizeSend}px; height:${sizeSend}px; stroke-width:3; transform:rotate(90deg) translateX(-2px);"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>`;

    previewContainer.innerHTML = `
        <div style="width:100%; height:100%; display:flex; flex-direction:column; overflow:hidden;">
            <!-- ===== é¡¶æ  chat-header ===== -->
            <div class="chat-header" style="height:54px; ${headerBgStyle} ${headerBg ? '' : 'background-color:' + headerColor + ';'} backdrop-filter:blur(10px); -webkit-backdrop-filter:blur(10px); padding:0 10px 0 10px; display:flex; align-items:center; border-bottom:1px solid rgba(0,0,0,0.05); flex-shrink:0; position:relative; z-index:10; box-sizing:border-box;">
                <!-- è¿”å›æŒ‰é’® -->
                <div class="chat-back" style="display:flex; align-items:center; justify-content:center; width:40px; height:40px; cursor:pointer; color:#333;">
                    ${backIcon}
                </div>
                <!-- æ ‡é¢˜ -->
                <div class="chat-title" style="font-size:17px; font-weight:600; color:${titleColor}; flex:1; text-align:center; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; position:static; top:auto; height:auto; line-height:normal; transform:none; max-width:none; z-index:auto;">èŠå¤©å¯¹è±¡</div>
                <!-- çº¿ä¸‹æ¨¡å¼æŒ‰é’® -->
                <div class="chat-more" style="display:flex; align-items:center; justify-content:center; width:40px; height:40px; color:#333; cursor:pointer;">
                    ${offlineIcon}
                </div>
                <!-- èŠå¤©è¯¦æƒ…æŒ‰é’® -->
                <div class="chat-more" style="display:flex; align-items:center; justify-content:center; width:40px; height:40px; color:#333; cursor:pointer;">
                    ${detailIcon}
                </div>
            </div>
            
            <!-- ===== èŠå¤©å†…å®¹åŒº chat-body ===== -->
            <div class="chat-body" style="flex:1; overflow-y:auto; background:#ffffff; ${chatBgStyle}">
            </div>
            
            <!-- ===== åº•æ  chat-footer ===== -->
            <div class="chat-footer" style="${footerBgStyle} ${footerBg ? '' : 'background-color:' + footerColor + ';'} border-top:1px solid rgba(0,0,0,0.05); display:flex; flex-direction:column; flex-shrink:0;">
                <div class="chat-input-bar" style="min-height:54px; padding:8px 12px; display:flex; align-items:center; gap:10px;">
                    <!-- AIæ¥æ”¶å›å¤æŒ‰é’® -->
                    <div class="chat-icon-btn" style="width:32px; height:32px; color:#999; cursor:pointer; display:flex; align-items:center; justify-content:center; border-radius:50%; flex-shrink:0;">
                        ${aiIcon}
                    </div>
                    
                    <!-- è¾“å…¥æ¡† -->
                    <div style="flex:1; background:#f5f5f5; border:1px solid #e8e8e8; border-radius:20px; padding:8px 16px; font-size:15px; color:#999; min-height:20px;">
                        å‘é€æ¶ˆæ¯...
                    </div>
                    
                    <!-- è¡¨æƒ…æŒ‰é’® -->
                    <div class="chat-icon-btn" style="width:32px; height:32px; color:#999; cursor:pointer; display:flex; align-items:center; justify-content:center; border-radius:50%; flex-shrink:0;">
                        ${emojiIcon}
                    </div>
                    
                    <!-- æ›´å¤šèœå•æŒ‰é’® -->
                    <div class="chat-icon-btn" style="width:32px; height:32px; color:#999; cursor:pointer; display:flex; align-items:center; justify-content:center; border-radius:50%; flex-shrink:0;">
                        ${moreIcon}
                    </div>
                    
                    <!-- å‘é€æŒ‰é’® -->
                    <div class="chat-send-btn" style="display:flex; background:var(--ins-pink,#FF6B9D); color:#fff; border-radius:50%; width:32px; height:32px; align-items:center; justify-content:center; flex-shrink:0;">
                        ${sendIcon}
                    </div>
                </div>
            </div>
        </div>
    `;
}

// æ˜¾ç¤ºèŠå¤©ä¸»é¢˜é€‰æ‹©å™¨
async function showChatThemeSelector() {
    try {
        const accountId = getCurrentAccountId() || 'offline';
        const themes = await db.chat_themes.where('accountId').equals(accountId).reverse().sortBy('time');

        const listContainer = document.getElementById('theme-selector-list');
        if (!listContainer) return;

        // è·å–å½“å‰è§’è‰²çš„ä¸»é¢˜ID
        const char = await db.characters.get(currentChatCharId);
        const currentThemeId = char?.chatThemeId || null;
        selectedThemeIdForApply = currentThemeId;

        // æ›´æ–°é»˜è®¤ä¸»é¢˜çš„é€‰ä¸­çŠ¶æ€
        const defaultThemeOption = document.querySelector('#chat-theme-selector-modal .theme-option');
        if (currentThemeId === null) {
            defaultThemeOption.style.borderColor = 'var(--ins-pink)';
            defaultThemeOption.querySelector('.theme-selected-icon').style.display = 'block';
        } else {
            defaultThemeOption.style.borderColor = '#e0e0e0';
            defaultThemeOption.querySelector('.theme-selected-icon').style.display = 'none';
        }

        // ç”Ÿæˆä¸»é¢˜åˆ—è¡¨
        listContainer.innerHTML = themes.map(theme => {
            const bgStyle = theme.chatBackground ? `background-image:url(${theme.chatBackground}); background-size:cover; background-position:center;` : `background:linear-gradient(135deg, ${theme.headerColor || '#ededed'} 0%, ${theme.footerColor || '#ffffff'} 100%);`;
            const iconCount = [theme.iconBack, theme.iconOffline, theme.iconDetail, theme.iconAi, theme.iconEmoji, theme.iconMore, theme.iconSend].filter(Boolean).length;
            return `
            <div class="theme-option" onclick="selectChatTheme(${theme.id})" style="padding:16px; background:#fff; border:1px solid ${currentThemeId === theme.id ? 'var(--ins-pink)' : '#e0e0e0'}; border-radius:12px; cursor:pointer; transition:all 0.2s;">
                <div style="display:flex; align-items:center; gap:12px;">
                    <div style="width:60px; height:60px; border-radius:8px; ${bgStyle} border:1px solid #ddd; flex-shrink:0;"></div>
                    <div style="flex:1;">
                        <div style="font-size:16px; font-weight:600; margin-bottom:4px;">${theme.name}</div>
                        <div style="display:flex; gap:4px; margin-bottom:4px; align-items:center;">
                            <div style="width:16px; height:16px; border-radius:3px; background:${theme.headerColor || '#ededed'}; border:1px solid #ddd;" title="é¡¶æ è‰²"></div>
                            <div style="width:16px; height:16px; border-radius:3px; background:${theme.footerColor || '#ffffff'}; border:1px solid #ddd;" title="åº•æ è‰²"></div>
                            ${iconCount > 0 ? `<span style="font-size:11px; color:#999; margin-left:4px;">ğŸ¨ ${iconCount}å›¾æ ‡</span>` : ''}
                        </div>
                        <div style="font-size:11px; color:#999;">${new Date(theme.time).toLocaleDateString('zh-CN')}</div>
                    </div>
                    <div class="theme-selected-icon" style="display:${currentThemeId === theme.id ? 'block' : 'none'}; color:var(--ins-pink); font-size:20px;">âœ“</div>
                </div>
            </div>
        `;
        }).join('');

        // æ˜¾ç¤ºå¼¹çª—
        document.getElementById('chat-theme-selector-modal').style.display = 'flex';
    } catch (error) {
        console.error('[ChatTheme] âœ— æ˜¾ç¤ºä¸»é¢˜é€‰æ‹©å™¨å¤±è´¥:', error);
        showToast('âŒ åŠ è½½ä¸»é¢˜å¤±è´¥');
    }
}

// éšè—èŠå¤©ä¸»é¢˜é€‰æ‹©å™¨
function hideChatThemeSelector() {
    document.getElementById('chat-theme-selector-modal').style.display = 'none';
    selectedThemeIdForApply = null;
}

// é€‰æ‹©èŠå¤©ä¸»é¢˜ï¼ˆä»…æ ‡è®°é€‰ä¸­çŠ¶æ€ï¼‰
function selectChatTheme(themeId) {
    selectedThemeIdForApply = themeId;

    // æ›´æ–°æ‰€æœ‰ä¸»é¢˜é€‰é¡¹çš„é€‰ä¸­çŠ¶æ€
    const modal = document.getElementById('chat-theme-selector-modal');
    const themeOptions = modal.querySelectorAll('.theme-option');
    
    themeOptions.forEach((option, index) => {
        const icon = option.querySelector('.theme-selected-icon');
        if (index === 0 && themeId === null) {
            // é»˜è®¤ä¸»é¢˜è¢«é€‰ä¸­
            option.style.borderColor = 'var(--ins-pink)';
            if (icon) icon.style.display = 'block';
        } else if (index === 0) {
            // é»˜è®¤ä¸»é¢˜æœªè¢«é€‰ä¸­
            option.style.borderColor = '#e0e0e0';
            if (icon) icon.style.display = 'none';
        } else {
            // åˆ¤æ–­è‡ªå®šä¹‰ä¸»é¢˜æ˜¯å¦è¢«é€‰ä¸­ï¼ˆéœ€è¦ä»HTMLä¸­æå–themeIdï¼‰
            const onclickAttr = option.getAttribute('onclick');
            const match = onclickAttr && onclickAttr.match(/selectChatTheme\((\d+)\)/);
            const optionThemeId = match ? parseInt(match[1]) : null;
            
            if (optionThemeId === themeId) {
                option.style.borderColor = 'var(--ins-pink)';
                if (icon) icon.style.display = 'block';
            } else {
                option.style.borderColor = '#e0e0e0';
                if (icon) icon.style.display = 'none';
            }
        }
    });
}

// åº”ç”¨èŠå¤©ä¸»é¢˜
async function applyChatTheme() {
    if (!currentChatCharId) {
        showToast('âŒ æœªæ‰“å¼€èŠå¤©çª—å£');
        return;
    }

    try {
        const char = await db.characters.get(currentChatCharId);
        if (!char) {
            showToast('âŒ è§’è‰²ä¸å­˜åœ¨');
            return;
        }

        // ğŸ›¡ï¸ ä½¿ç”¨ update() åªæ›´æ–°ä¸»é¢˜IDå­—æ®µï¼Œé˜²æ­¢è¦†ç›–è®¾ç½®
        char.chatThemeId = selectedThemeIdForApply;
        await db.characters.update(char.id, { chatThemeId: selectedThemeIdForApply });

        // åº”ç”¨ä¸»é¢˜æ ·å¼
        await applyThemeToChat(selectedThemeIdForApply);

        // æ›´æ–°èŠå¤©è¯¦æƒ…é¡µçš„ä¸»é¢˜æ˜¾ç¤º
        await updateChatDetailThemeDisplay();

        // å…³é—­å¼¹çª—
        hideChatThemeSelector();

        showToast('âœ… ä¸»é¢˜å·²åº”ç”¨');
        console.log('[ChatTheme] âœ“ ä¸»é¢˜å·²åº”ç”¨:', selectedThemeIdForApply);
    } catch (error) {
        console.error('[ChatTheme] âœ— åº”ç”¨ä¸»é¢˜å¤±è´¥:', error);
        showToast('âŒ åº”ç”¨å¤±è´¥: ' + error.message);
    }
}

// åº”ç”¨ä¸»é¢˜æ ·å¼åˆ°èŠå¤©çª—å£ - å®Œå…¨åŒ¹é…å®é™…èŠå¤©é¡µé¢
async function applyThemeToChat(themeId) {
    const chatWindow = document.getElementById('chat-window');
    const chatHeader = chatWindow?.querySelector('.chat-header');
    const chatBody = document.getElementById('chat-body');
    const chatFooter = chatWindow?.querySelector('.chat-footer');

    if (!chatWindow || !chatHeader || !chatBody || !chatFooter) {
        console.log('[ChatTheme] âš ï¸ èŠå¤©çª—å£å…ƒç´ æœªæ‰¾åˆ°');
        return;
    }

    // ç§»é™¤ç°æœ‰çš„ä¸»é¢˜æ ·å¼
    chatWindow.removeAttribute('data-theme-id');
    const oldThemeStyle = document.getElementById('chat-theme-style');
    if (oldThemeStyle) oldThemeStyle.remove();

    // æ¢å¤æ‰€æœ‰è¢«æ›¿æ¢çš„å›¾æ ‡
    _restoreDefaultIcons(chatHeader, chatFooter);

    if (themeId === null || themeId === undefined) {
        // æ¢å¤é»˜è®¤ä¸»é¢˜ - æ¸…é™¤ background ç®€å†™ï¼ˆå› ä¸ºåº”ç”¨ä¸»é¢˜æ—¶ä½¿ç”¨äº† background ç®€å†™ï¼‰
        chatBody.style.background = '';
        chatHeader.style.background = '';
        chatFooter.style.background = '';
        // æ¢å¤æ ‡é¢˜é¢œè‰²
        const chatTitle = chatHeader.querySelector('.chat-title');
        if (chatTitle) chatTitle.style.color = '';
        console.log('[ChatTheme] âœ“ å·²æ¢å¤é»˜è®¤ä¸»é¢˜');
        return;
    }

    try {
        const theme = await db.chat_themes.get(themeId);
        if (!theme) {
            console.log('[ChatTheme] âš ï¸ ä¸»é¢˜ä¸å­˜åœ¨:', themeId);
            return;
        }

        // ===== èƒŒæ™¯ =====
        if (theme.chatBackground) {
            chatBody.style.background = `url(${theme.chatBackground}) center/cover no-repeat`;
        } else {
            chatBody.style.backgroundImage = '';
        }

        // ===== é¡¶æ èƒŒæ™¯ =====
        if (theme.headerBg) {
            // æœ‰èƒŒæ™¯å›¾æ—¶ï¼šç”¨ background ç®€å†™ä¸€æ¬¡æ€§è¦†ç›–ï¼ˆè§£å†³æ ·å¼è¡¨ background ç®€å†™å†²çªï¼‰
            // backgroundColor è®¾ä¸º transparentï¼Œè®©é€æ˜PNGèƒ½é€å‡ºåé¢çš„å†…å®¹
            chatHeader.style.background = `url(${theme.headerBg}) center/cover no-repeat transparent`;
            chatHeader.style.backdropFilter = 'blur(10px)';
            chatHeader.style.webkitBackdropFilter = 'blur(10px)';
        } else {
            chatHeader.style.backgroundImage = '';
            if (theme.headerColor) chatHeader.style.backgroundColor = theme.headerColor;
        }

        // ===== æ ‡é¢˜æ–‡å­—é¢œè‰² =====
        const chatTitle = chatHeader.querySelector('.chat-title');
        if (chatTitle) {
            chatTitle.style.color = theme.titleColor || '';
        }

        // ===== åº•æ èƒŒæ™¯ =====
        if (theme.footerBg) {
            // æœ‰èƒŒæ™¯å›¾æ—¶ï¼šåŒç†ç”¨ background ç®€å†™ï¼Œtransparent è®©é€æ˜åŒºåŸŸé€å‡ºèƒŒæ™¯
            chatFooter.style.background = `url(${theme.footerBg}) center/cover no-repeat transparent`;
        } else {
            chatFooter.style.backgroundImage = '';
            if (theme.footerColor) chatFooter.style.backgroundColor = theme.footerColor;
        }

        // ===== é¡¶æ æŒ‰é’®å›¾æ ‡æ›¿æ¢ =====
        // è¿”å›æŒ‰é’®
        if (theme.iconBack) {
            const backBtn = chatHeader.querySelector('.chat-back');
            if (backBtn) _replaceWithImg(backBtn, theme.iconBack, theme.iconBackSize || 24);
        }
        // çº¿ä¸‹æ¨¡å¼æŒ‰é’®ï¼ˆç¬¬ä¸€ä¸ª chat-moreï¼‰
        const chatMores = chatHeader.querySelectorAll('.chat-more');
        if (theme.iconOffline && chatMores[0]) {
            _replaceWithImg(chatMores[0], theme.iconOffline, theme.iconOfflineSize || 20);
        }
        // èŠå¤©è¯¦æƒ…æŒ‰é’®ï¼ˆç¬¬äºŒä¸ª chat-moreï¼Œå³ä¸‰ä¸ªç‚¹ï¼‰
        if (theme.iconDetail && chatMores[1]) {
            _replaceWithImg(chatMores[1], theme.iconDetail, theme.iconDetailSize || 20);
        }

        // ===== åº•æ æŒ‰é’®å›¾æ ‡æ›¿æ¢ =====
        const inputBar = chatFooter.querySelector('.chat-input-bar');
        if (inputBar) {
            const iconBtns = inputBar.querySelectorAll('.chat-icon-btn');
            // ç¬¬ä¸€ä¸ª chat-icon-btn = AIé­”æ³•æ£’
            if (theme.iconAi && iconBtns[0]) {
                _replaceWithImg(iconBtns[0], theme.iconAi, theme.iconAiSize || 22);
            }
            // ç¬¬äºŒä¸ª chat-icon-btn = è¡¨æƒ…
            if (theme.iconEmoji && iconBtns[1]) {
                _replaceWithImg(iconBtns[1], theme.iconEmoji, theme.iconEmojiSize || 22);
            }
            // ç¬¬ä¸‰ä¸ª chat-icon-btn = æ›´å¤š(+å·)
            if (theme.iconMore && iconBtns[2]) {
                _replaceWithImg(iconBtns[2], theme.iconMore, theme.iconMoreSize || 22);
            }
            // å‘é€æŒ‰é’®
            if (theme.iconSend) {
                const sendBtn = inputBar.querySelector('.chat-send-btn');
                if (sendBtn) _replaceWithImg(sendBtn, theme.iconSend, theme.iconSendSize || 18);
            }
        }

        chatWindow.setAttribute('data-theme-id', themeId);
        console.log('[ChatTheme] âœ“ ä¸»é¢˜æ ·å¼å·²åº”ç”¨:', theme.name);
    } catch (error) {
        console.error('[ChatTheme] âœ— åº”ç”¨ä¸»é¢˜æ ·å¼å¤±è´¥:', error);
    }
}

// è¾…åŠ©ï¼šæ›¿æ¢å…ƒç´ å†…çš„SVGä¸ºå›¾ç‰‡
function _replaceWithImg(container, imgUrl, size) {
    if (!container || !imgUrl) return;
    const svg = container.querySelector('svg');
    if (svg) {
        // ä¿å­˜åŸå§‹SVGä»¥ä¾¿æ¢å¤
        if (!container.getAttribute('data-original-svg')) {
            container.setAttribute('data-original-svg', svg.outerHTML);
        }
        svg.style.display = 'none';
    }
    // å¦‚æœæ˜¯å‘é€æŒ‰é’®ï¼Œéšè—åŸå§‹èƒŒæ™¯è‰²/åœ†å½¢æ ·å¼ï¼Œé˜²æ­¢é€å‡º
    if (container.classList.contains('chat-send-btn')) {
        if (!container.getAttribute('data-original-bg')) {
            container.setAttribute('data-original-bg', getComputedStyle(container).background);
        }
        container.style.background = 'transparent';
    }
    // ç§»é™¤å·²æœ‰çš„ä¸»é¢˜å›¾æ ‡
    const oldImg = container.querySelector('.theme-icon-img');
    if (oldImg) oldImg.remove();
    const img = document.createElement('img');
    img.src = imgUrl;
    img.className = 'theme-icon-img';
    img.style.cssText = `width:${size}px; height:${size}px; object-fit:contain;`;
    container.appendChild(img);
}

// è¾…åŠ©ï¼šæ¢å¤æ‰€æœ‰è¢«æ›¿æ¢çš„å›¾æ ‡ä¸ºé»˜è®¤SVG
function _restoreDefaultIcons(chatHeader, chatFooter) {
    const allContainers = [
        ...chatHeader.querySelectorAll('.chat-back, .chat-more'),
        ...chatFooter.querySelectorAll('.chat-icon-btn, .chat-send-btn')
    ];
    allContainers.forEach(container => {
        // ç§»é™¤ä¸»é¢˜å›¾æ ‡
        const themeImg = container.querySelector('.theme-icon-img');
        if (themeImg) themeImg.remove();
        // æ¢å¤SVGæ˜¾ç¤º
        const svg = container.querySelector('svg');
        if (svg) svg.style.display = '';
        // æ¢å¤å‘é€æŒ‰é’®çš„åŸå§‹èƒŒæ™¯æ ·å¼
        if (container.classList.contains('chat-send-btn')) {
            container.style.background = '';
        }
    });
}

// æ›´æ–°èŠå¤©è¯¦æƒ…é¡µçš„ä¸»é¢˜æ˜¾ç¤º
async function updateChatDetailThemeDisplay() {
    if (!currentChatCharId) return;

    try {
        const char = await db.characters.get(currentChatCharId);
        const themeId = char?.chatThemeId;
        
        const themeDisplay = document.getElementById('detail-current-theme');
        if (!themeDisplay) return;

        if (themeId === null || themeId === undefined) {
            themeDisplay.textContent = 'é»˜è®¤ä¸»é¢˜';
        } else {
            const theme = await db.chat_themes.get(themeId);
            themeDisplay.textContent = theme ? theme.name : 'é»˜è®¤ä¸»é¢˜';
        }
    } catch (error) {
        console.error('[ChatTheme] âœ— æ›´æ–°ä¸»é¢˜æ˜¾ç¤ºå¤±è´¥:', error);
    }
}

// æ˜¾ç¤ºç¾¤èŠä¸»é¢˜é€‰æ‹©å™¨
async function showGroupChatThemeSelector() {
    try {
        const accountId = getCurrentAccountId() || 'offline';
        const themes = await db.chat_themes.where('accountId').equals(accountId).reverse().sortBy('time');

        const listContainer = document.getElementById('theme-selector-list');
        if (!listContainer) return;

        // è·å–å½“å‰ç¾¤èŠçš„ä¸»é¢˜ID
        const group = await db.group_chats.get(window.currentGroupChatId);
        const currentThemeId = group?.chatThemeId || null;
        selectedThemeIdForApply = currentThemeId;

        // æ›´æ–°é»˜è®¤ä¸»é¢˜çš„é€‰ä¸­çŠ¶æ€
        const defaultThemeOption = document.querySelector('#chat-theme-selector-modal .theme-option');
        if (currentThemeId === null) {
            defaultThemeOption.style.borderColor = 'var(--ins-pink)';
            defaultThemeOption.querySelector('.theme-selected-icon').style.display = 'block';
        } else {
            defaultThemeOption.style.borderColor = '#e0e0e0';
            defaultThemeOption.querySelector('.theme-selected-icon').style.display = 'none';
        }

        // ç”Ÿæˆä¸»é¢˜åˆ—è¡¨ï¼ˆç¾¤èŠï¼‰
        listContainer.innerHTML = themes.map(theme => {
            const bgStyle = theme.chatBackground ? `background-image:url(${theme.chatBackground}); background-size:cover; background-position:center;` : `background:linear-gradient(135deg, ${theme.headerColor || '#ededed'} 0%, ${theme.footerColor || '#ffffff'} 100%);`;
            const iconCount = [theme.iconBack, theme.iconOffline, theme.iconDetail, theme.iconAi, theme.iconEmoji, theme.iconMore, theme.iconSend].filter(Boolean).length;
            return `
            <div class="theme-option" onclick="selectChatTheme(${theme.id})" style="padding:16px; background:#fff; border:1px solid ${currentThemeId === theme.id ? 'var(--ins-pink)' : '#e0e0e0'}; border-radius:12px; cursor:pointer; transition:all 0.2s;">
                <div style="display:flex; align-items:center; gap:12px;">
                    <div style="width:60px; height:60px; border-radius:8px; ${bgStyle} border:1px solid #ddd; flex-shrink:0;"></div>
                    <div style="flex:1;">
                        <div style="font-size:16px; font-weight:600; margin-bottom:4px;">${theme.name}</div>
                        <div style="display:flex; gap:4px; margin-bottom:4px; align-items:center;">
                            <div style="width:16px; height:16px; border-radius:3px; background:${theme.headerColor || '#ededed'}; border:1px solid #ddd;" title="é¡¶æ è‰²"></div>
                            <div style="width:16px; height:16px; border-radius:3px; background:${theme.footerColor || '#ffffff'}; border:1px solid #ddd;" title="åº•æ è‰²"></div>
                            ${iconCount > 0 ? `<span style="font-size:11px; color:#999; margin-left:4px;">ğŸ¨ ${iconCount}å›¾æ ‡</span>` : ''}
                        </div>
                        <div style="font-size:11px; color:#999;">${new Date(theme.time).toLocaleDateString('zh-CN')}</div>
                    </div>
                    <div class="theme-selected-icon" style="display:${currentThemeId === theme.id ? 'block' : 'none'}; color:var(--ins-pink); font-size:20px;">âœ“</div>
                </div>
            </div>
        `;
        }).join('');

        // æ˜¾ç¤ºå¼¹çª—ï¼ˆä½¿ç”¨ç¾¤èŠåº”ç”¨å‡½æ•°ï¼‰
        const modal = document.getElementById('chat-theme-selector-modal');
        modal.style.display = 'flex';
        
        // æ›¿æ¢åº”ç”¨æŒ‰é’®çš„onclickäº‹ä»¶ä¸ºç¾¤èŠç‰ˆæœ¬
        const applyBtn = modal.querySelector('button[onclick="applyChatTheme()"]');
        if (applyBtn) {
            applyBtn.setAttribute('onclick', 'applyGroupChatTheme()');
        }
    } catch (error) {
        console.error('[GroupChatTheme] âœ— æ˜¾ç¤ºä¸»é¢˜é€‰æ‹©å™¨å¤±è´¥:', error);
        showToast('âŒ åŠ è½½ä¸»é¢˜å¤±è´¥');
    }
}

// åº”ç”¨ç¾¤èŠä¸»é¢˜
async function applyGroupChatTheme() {
    if (!window.currentGroupChatId) {
        showToast('âŒ æœªæ‰“å¼€ç¾¤èŠçª—å£');
        return;
    }

    try {
        const group = await db.group_chats.get(window.currentGroupChatId);
        if (!group) {
            showToast('âŒ ç¾¤èŠä¸å­˜åœ¨');
            return;
        }

        // æ›´æ–°ç¾¤èŠçš„ä¸»é¢˜ID
        group.chatThemeId = selectedThemeIdForApply;
        await safeGroupChatPut(group);

        // åº”ç”¨ä¸»é¢˜æ ·å¼
        await applyThemeToChat(selectedThemeIdForApply);

        // æ›´æ–°ç¾¤èŠè¯¦æƒ…é¡µçš„ä¸»é¢˜æ˜¾ç¤º
        await updateGroupChatDetailThemeDisplay();

        // å…³é—­å¼¹çª—å¹¶æ¢å¤æŒ‰é’®
        const modal = document.getElementById('chat-theme-selector-modal');
        modal.style.display = 'none';
        const applyBtn = modal.querySelector('button[onclick="applyGroupChatTheme()"]');
        if (applyBtn) {
            applyBtn.setAttribute('onclick', 'applyChatTheme()');
        }

        showToast('âœ… ä¸»é¢˜å·²åº”ç”¨');
        console.log('[GroupChatTheme] âœ“ ä¸»é¢˜å·²åº”ç”¨:', selectedThemeIdForApply);
    } catch (error) {
        console.error('[GroupChatTheme] âœ— åº”ç”¨ä¸»é¢˜å¤±è´¥:', error);
        showToast('âŒ åº”ç”¨å¤±è´¥: ' + error.message);
    }
}

// æ›´æ–°ç¾¤èŠè¯¦æƒ…é¡µçš„ä¸»é¢˜æ˜¾ç¤º
async function updateGroupChatDetailThemeDisplay() {
    if (!window.currentGroupChatId) return;

    try {
        const group = await db.group_chats.get(window.currentGroupChatId);
        const themeId = group?.chatThemeId;
        
        const themeDisplay = document.getElementById('group-detail-current-theme');
        if (!themeDisplay) return;

        if (themeId === null || themeId === undefined) {
            themeDisplay.textContent = 'é»˜è®¤ä¸»é¢˜';
        } else {
            const theme = await db.chat_themes.get(themeId);
            themeDisplay.textContent = theme ? theme.name : 'é»˜è®¤ä¸»é¢˜';
        }
    } catch (error) {
        console.error('[GroupChatTheme] âœ— æ›´æ–°ä¸»é¢˜æ˜¾ç¤ºå¤±è´¥:', error);
    }
}

// æš´éœ²èŠå¤©ä¸»é¢˜ç›¸å…³å‡½æ•°åˆ°å…¨å±€
window.saveChatTheme = saveChatTheme;
window.loadChatThemeList = loadChatThemeList;
window.editChatTheme = editChatTheme;
window.deleteChatTheme = deleteChatTheme;
window.previewChatTheme = previewChatTheme;
window.showChatThemeSelector = showChatThemeSelector;
window.hideChatThemeSelector = hideChatThemeSelector;
window.selectChatTheme = selectChatTheme;
window.applyChatTheme = applyChatTheme;
window.applyThemeToChat = applyThemeToChat;
window.updateChatDetailThemeDisplay = updateChatDetailThemeDisplay;
window.showGroupChatThemeSelector = showGroupChatThemeSelector;
window.applyGroupChatTheme = applyGroupChatTheme;
window.updateGroupChatDetailThemeDisplay = updateGroupChatDetailThemeDisplay;

// ========== ä¸»é¢˜å¯¼å‡º/å¯¼å…¥ ==========

// ===== ä¸»é¢˜åŠ å¯†/è§£å¯†å·¥å…· =====
const _THEME_KEY = 'MxTheme@2026!Enc';

function _themeEncrypt(plainText) {
    // 1. å°†æ˜æ–‡è½¬ä¸ºUTF-8å­—èŠ‚æ•°ç»„
    const encoder = new TextEncoder();
    const data = encoder.encode(plainText);
    const key = encoder.encode(_THEME_KEY);
    // 2. XORæ··æ·†
    const encrypted = new Uint8Array(data.length);
    for (let i = 0; i < data.length; i++) {
        encrypted[i] = data[i] ^ key[i % key.length] ^ ((i * 7 + 13) & 0xFF);
    }
    // 3. è½¬Base64
    let binary = '';
    for (let i = 0; i < encrypted.length; i++) {
        binary += String.fromCharCode(encrypted[i]);
    }
    return btoa(binary);
}

function _themeDecrypt(cipherBase64) {
    // 1. Base64è§£ç 
    const binary = atob(cipherBase64);
    const encrypted = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
        encrypted[i] = binary.charCodeAt(i);
    }
    // 2. XORè¿˜åŸ
    const encoder = new TextEncoder();
    const key = encoder.encode(_THEME_KEY);
    const decrypted = new Uint8Array(encrypted.length);
    for (let i = 0; i < encrypted.length; i++) {
        decrypted[i] = encrypted[i] ^ key[i % key.length] ^ ((i * 7 + 13) & 0xFF);
    }
    // 3. UTF-8å­—èŠ‚è¿˜åŸä¸ºå­—ç¬¦ä¸²
    const decoder = new TextDecoder();
    return decoder.decode(decrypted);
}

// å¯¼å‡ºå•ä¸ªä¸»é¢˜ä¸ºåŠ å¯†æ–‡ä»¶
async function exportSingleChatTheme(themeId) {
    try {
        const theme = await db.chat_themes.get(themeId);
        if (!theme) {
            showToast('âŒ ä¸»é¢˜ä¸å­˜åœ¨');
            return;
        }

        // ç§»é™¤æ•°æ®åº“è‡ªå¢IDå’ŒaccountId
        const { id, accountId: _aid, ...rest } = theme;

        // åŠ å¯†
        const themesJson = JSON.stringify([rest]);
        const encryptedPayload = _themeEncrypt(themesJson);

        const jsonData = {
            type: 'chat_themes_export',
            version: 2,
            exportTime: new Date().toISOString(),
            count: 1,
            payload: encryptedPayload
        };

        const jsonStr = JSON.stringify(jsonData);
        const blob = new Blob([jsonStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const safeName = (theme.name || 'theme').replace(/[^a-zA-Z0-9\u4e00-\u9fff_-]/g, '_');
        const a = document.createElement('a');
        a.href = url;
        a.download = `theme_${safeName}_${new Date().toISOString().slice(0,10)}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        showToast(`âœ… å·²å¯¼å‡ºä¸»é¢˜ã€Œ${theme.name}ã€ï¼ˆå·²åŠ å¯†ï¼‰`);
        console.log('[ChatTheme] âœ“ å•ä¸ªä¸»é¢˜å¯¼å‡ºæˆåŠŸ(åŠ å¯†):', theme.name);
    } catch (error) {
        console.error('[ChatTheme] âœ— å¯¼å‡ºå¤±è´¥:', error);
        showToast('âŒ å¯¼å‡ºå¤±è´¥: ' + error.message);
    }
}

// å¯¼å‡ºå…¨éƒ¨ä¸»é¢˜ä¸ºåŠ å¯†æ–‡ä»¶
async function exportChatThemes() {
    try {
        const accountId = getCurrentAccountId() || 'offline';
        const themes = await db.chat_themes.where('accountId').equals(accountId).toArray();

        if (themes.length === 0) {
            showToast('âŒ æš‚æ— å¯å¯¼å‡ºçš„ä¸»é¢˜');
            return;
        }

        // ç§»é™¤æ•°æ®åº“è‡ªå¢IDå’ŒaccountIdï¼Œå¯¼å…¥æ—¶é‡æ–°ç”Ÿæˆ
        const exportData = themes.map(theme => {
            const { id, accountId: _aid, ...rest } = theme;
            return rest;
        });

        // å°†ä¸»é¢˜æ•°æ®åŠ å¯†
        const themesJson = JSON.stringify(exportData);
        const encryptedPayload = _themeEncrypt(themesJson);

        const jsonData = {
            type: 'chat_themes_export',
            version: 2,
            exportTime: new Date().toISOString(),
            count: exportData.length,
            payload: encryptedPayload
        };

        const jsonStr = JSON.stringify(jsonData);
        const blob = new Blob([jsonStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = `chat_themes_${new Date().toISOString().slice(0,10)}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        showToast(`âœ… å·²å¯¼å‡º ${themes.length} ä¸ªä¸»é¢˜ï¼ˆå·²åŠ å¯†ï¼‰`);
        console.log('[ChatTheme] âœ“ ä¸»é¢˜å¯¼å‡ºæˆåŠŸ(åŠ å¯†):', themes.length, 'ä¸ª');
    } catch (error) {
        console.error('[ChatTheme] âœ— å¯¼å‡ºå¤±è´¥:', error);
        showToast('âŒ å¯¼å‡ºå¤±è´¥: ' + error.message);
    }
}

// å¯¼å…¥ä¸»é¢˜æ–‡ä»¶ï¼ˆå…¼å®¹åŠ å¯†v2å’Œæ—§ç‰ˆv1æ˜æ–‡ï¼‰
async function importChatThemes(event) {
    const file = event.target.files[0];
    if (!file) return;

    // é‡ç½®inputä»¥ä¾¿ä¸‹æ¬¡å¯ä»¥é€‰åŒä¸€æ–‡ä»¶
    event.target.value = '';

    try {
        const text = await file.text();
        const jsonData = JSON.parse(text);

        // æ ¡éªŒæ ¼å¼
        if (jsonData.type !== 'chat_themes_export') {
            showToast('âŒ æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®ï¼Œè¯·é€‰æ‹©ä¸»é¢˜å¯¼å‡ºæ–‡ä»¶');
            return;
        }

        let themesArr;

        if (jsonData.version >= 2 && jsonData.payload) {
            // v2åŠ å¯†æ ¼å¼ï¼šè§£å¯†payload
            try {
                const decryptedJson = _themeDecrypt(jsonData.payload);
                themesArr = JSON.parse(decryptedJson);
            } catch (e) {
                showToast('âŒ ä¸»é¢˜è§£å¯†å¤±è´¥ï¼Œæ–‡ä»¶å¯èƒ½å·²æŸå');
                console.error('[ChatTheme] è§£å¯†å¤±è´¥:', e);
                return;
            }
        } else if (Array.isArray(jsonData.themes)) {
            // v1æ—§ç‰ˆæ˜æ–‡æ ¼å¼ï¼šç›´æ¥è¯»å–
            themesArr = jsonData.themes;
        } else {
            showToast('âŒ æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®');
            return;
        }

        if (!Array.isArray(themesArr) || themesArr.length === 0) {
            showToast('âŒ æ²¡æœ‰æ‰¾åˆ°å¯å¯¼å…¥çš„ä¸»é¢˜æ•°æ®');
            return;
        }

        const accountId = getCurrentAccountId() || 'offline';
        let importCount = 0;

        for (const theme of themesArr) {
            // ç»™æ¯ä¸ªä¸»é¢˜ç»‘å®šå½“å‰è´¦å·
            const themeData = {
                ...theme,
                accountId: accountId
            };
            // ç§»é™¤å¯èƒ½æºå¸¦çš„æ—§id
            delete themeData.id;
            await db.chat_themes.add(themeData);
            importCount++;
        }

        showToast(`âœ… æˆåŠŸå¯¼å…¥ ${importCount} ä¸ªä¸»é¢˜`);
        console.log('[ChatTheme] âœ“ ä¸»é¢˜å¯¼å…¥æˆåŠŸ:', importCount, 'ä¸ª');

        // åˆ·æ–°ä¸»é¢˜åˆ—è¡¨
        await loadChatThemeList();
    } catch (error) {
        console.error('[ChatTheme] âœ— å¯¼å…¥å¤±è´¥:', error);
        if (error instanceof SyntaxError) {
            showToast('âŒ æ–‡ä»¶è§£æå¤±è´¥ï¼Œè¯·ç¡®è®¤æ˜¯æœ‰æ•ˆçš„ä¸»é¢˜æ–‡ä»¶');
        } else {
            showToast('âŒ å¯¼å…¥å¤±è´¥: ' + error.message);
        }
    }
}

window.exportSingleChatTheme = exportSingleChatTheme;
window.exportChatThemes = exportChatThemes;
window.importChatThemes = importChatThemes;

// ===========================================
// é»˜å¥‘ç»˜ç”»æ¸¸æˆ + èœå•é¢æ¿æ»‘åŠ¨ç¿»é¡µ
// ===========================================

// ---- èœå•é¢æ¿æ»‘åŠ¨ç¿»é¡µé€»è¾‘ ----
(function() {
    let actionPageIndex = 0;
    let touchStartX = 0;
    let touchDeltaX = 0;
    let isSwiping = false;

    function getTrack() { return document.getElementById('action-panel-track'); }
    function getDots() { return document.querySelectorAll('#action-panel-dots .action-dot'); }

    function setActionPage(idx) {
        actionPageIndex = idx;
        const track = getTrack();
        if (track) track.style.transform = 'translateX(' + (-idx * 50) + '%)';
        getDots().forEach((d, i) => {
            d.classList.toggle('active', i === idx);
        });
    }

    document.addEventListener('touchstart', function(e) {
        const swiper = document.getElementById('action-panel-swiper');
        if (!swiper || !swiper.closest('.action-panel') || swiper.closest('.action-panel').style.display === 'none') return;
        if (!swiper.contains(e.target)) return;
        touchStartX = e.touches[0].clientX;
        touchDeltaX = 0;
        isSwiping = true;
        const track = getTrack();
        if (track) track.style.transition = 'none';
    }, { passive: true });

    document.addEventListener('touchmove', function(e) {
        if (!isSwiping) return;
        const swiper = document.getElementById('action-panel-swiper');
        if (!swiper || !swiper.contains(e.target)) return;
        touchDeltaX = e.touches[0].clientX - touchStartX;
        const track = getTrack();
        if (track) {
            const base = -actionPageIndex * 50;
            const pct = (touchDeltaX / swiper.offsetWidth) * 50;
            track.style.transform = 'translateX(' + (base + pct) + '%)';
        }
    }, { passive: true });

    document.addEventListener('touchend', function(e) {
        if (!isSwiping) return;
        isSwiping = false;
        const track = getTrack();
        if (track) track.style.transition = 'transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1)';
        const threshold = 50;
        if (touchDeltaX < -threshold && actionPageIndex < 1) {
            setActionPage(1);
        } else if (touchDeltaX > threshold && actionPageIndex > 0) {
            setActionPage(0);
        } else {
            setActionPage(actionPageIndex);
        }
    }, { passive: true });

    // ç‚¹å‡»å°åœ†ç‚¹
    document.addEventListener('click', function(e) {
        const dot = e.target.closest('.action-dot');
        if (dot && dot.dataset.page !== undefined) {
            setActionPage(parseInt(dot.dataset.page));
        }
    });

    // é¢æ¿æ¯æ¬¡æ‰“å¼€æ—¶é‡ç½®åˆ°ç¬¬ä¸€é¡µ
    const origToggle = window.toggleChatPanel;
    window.toggleChatPanel = function(type) {
        if (type === 'action') {
            setActionPage(0);
        }
        origToggle(type);
    };
})();

// ---- é»˜å¥‘ç»˜ç”»æ¸¸æˆé€»è¾‘ ----
const MOQI_TOPICS = [
    "æ‰‹æœº","æ¯å­","é›¨ä¼","é’¥åŒ™","ç¯æ³¡","é•œå­","ä¹¦åŒ…","æ‰‹è¡¨","æ‹–é‹","æ•å¤´",
    "å°çŒ«","å°ç‹—","å…”å­","å°é¸Ÿ","ç†ŠçŒ«","é±¼","è´è¶","çŒ´å­","å¤§è±¡","ä¼é¹…",
    "æ±‰å ¡","å†°æ·‡æ·‹","è›‹ç³•","å¥¶èŒ¶","é¢æ¡","æ°´æœ","æŠ«è¨","æ£’æ£’ç³–","é¥ºå­","ç«é”…",
    "å¤ªé˜³","æœˆäº®","æ˜Ÿæ˜Ÿ","äº‘æœµ","å½©è™¹","å¼€å¿ƒ","ç¡è§‰","è·‘æ­¥","è·³èˆ","å®³ç¾",
    "å¤–æ˜Ÿäºº","è¶…äºº","ç«ç®­","åŸå ¡","é­”æ³•æ£’","çˆ±å¿ƒ","ç¤¼ç‰©","æ°”çƒ","çƒŸèŠ±","å¤©ä½¿"
];

let moqiCurrentTopic = '';
let moqiUserCtx = null;
let moqiAiCtx = null;
let moqiIsDrawing = false;
let moqiCurrentColor = '#333333';
let moqiCurrentTool = 'pen';
let moqiBrushSize = 3;
let moqiUndoStack = [];
let moqiAiDrawn = false;
let moqiCharName = 'è§’è‰²'; // å½“å‰èŠå¤©è§’è‰²å
let moqiCharDesc = ''; // å½“å‰èŠå¤©è§’è‰²äººè®¾æè¿°

async function showMoqiDrawGame() {
    closeChatPanel();

    // è·å–å½“å‰èŠå¤©è§’è‰²ä¿¡æ¯
    try {
        const charId = window._currentChatCharId || null;
        if (charId) {
            const char = await db.characters.get(charId);
            if (char) {
                const accountId = localStorage.getItem('current_my_char_id') || '1';
                // ä¼˜å…ˆç”¨å¤‡æ³¨å
                const nickMap = char.account_nicks || {};
                moqiCharName = nickMap[accountId] || char.nick || char.name || 'è§’è‰²';
                moqiCharDesc = char.description || char.desc || '';
            }
        }
    } catch (e) {
        console.warn('[é»˜å¥‘ç»˜ç”»] è·å–è§’è‰²ä¿¡æ¯å¤±è´¥:', e);
    }

    // æ›´æ–°ç•Œé¢ä¸Šçš„è§’è‰²å
    const charLabel = document.getElementById('moqi-char-label');
    if (charLabel) charLabel.textContent = moqiCharName + ' çš„ç”»';
    const btnText = document.getElementById('moqi-ai-btn-text');
    if (btnText) btnText.textContent = 'è®©' + moqiCharName + 'ç”»ä¸ŠåŠéƒ¨åˆ†';

    const overlay = document.getElementById('moqi-draw-overlay');
    overlay.style.display = 'flex';
    initMoqiCanvases();
}
window.showMoqiDrawGame = showMoqiDrawGame;

function closeMoqiDrawGame() {
    document.getElementById('moqi-draw-overlay').style.display = 'none';
}
window.closeMoqiDrawGame = closeMoqiDrawGame;

function initMoqiCanvases() {
    const aiCanvas = document.getElementById('moqi-ai-canvas');
    const userCanvas = document.getElementById('moqi-user-canvas');
    
    // è®¾ç½® canvas åˆ†è¾¨ç‡
    const w = aiCanvas.offsetWidth;
    const h = aiCanvas.offsetHeight;
    const dpr = window.devicePixelRatio || 1;

    [aiCanvas, userCanvas].forEach(c => {
        c.width = w * dpr;
        c.height = h * dpr;
        const ctx = c.getContext('2d');
        ctx.scale(dpr, dpr);
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, w, h);
    });

    moqiAiCtx = aiCanvas.getContext('2d');
    moqiUserCtx = userCanvas.getContext('2d');
    moqiUndoStack = [];
    moqiAiDrawn = false;

    // ç”¨æˆ·ç»˜ç”»äº‹ä»¶
    setupMoqiUserDrawing(userCanvas);
}

function setupMoqiUserDrawing(canvas) {
    let lastX, lastY;
    const dpr = window.devicePixelRatio || 1;

    function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches ? e.touches[0] : e;
        return {
            x: (touch.clientX - rect.left),
            y: (touch.clientY - rect.top)
        };
    }

    function startDraw(e) {
        e.preventDefault();
        moqiIsDrawing = true;
        const pos = getPos(e);
        lastX = pos.x;
        lastY = pos.y;
        // ä¿å­˜æ’¤é”€å¿«ç…§
        moqiSaveUndoSnapshot();
    }

    function draw(e) {
        e.preventDefault();
        if (!moqiIsDrawing) return;
        const pos = getPos(e);
        const ctx = moqiUserCtx;

        ctx.save();
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(pos.x, pos.y);
        ctx.lineWidth = moqiBrushSize;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        if (moqiCurrentTool === 'eraser') {
            ctx.globalCompositeOperation = 'destination-out';
            ctx.strokeStyle = 'rgba(255,255,255,1)';
            ctx.lineWidth = moqiBrushSize * 3;
        } else {
            ctx.globalCompositeOperation = 'source-over';
            ctx.strokeStyle = moqiCurrentColor;
        }

        ctx.stroke();
        ctx.restore();

        lastX = pos.x;
        lastY = pos.y;
    }

    function endDraw(e) {
        if (e) e.preventDefault();
        moqiIsDrawing = false;
    }

    // Remove old handlers
    canvas.onmousedown = null;
    canvas.onmousemove = null;
    canvas.onmouseup = null;
    canvas.onmouseleave = null;
    canvas.ontouchstart = null;
    canvas.ontouchmove = null;
    canvas.ontouchend = null;

    canvas.addEventListener('mousedown', startDraw);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', endDraw);
    canvas.addEventListener('mouseleave', endDraw);
    canvas.addEventListener('touchstart', startDraw, { passive: false });
    canvas.addEventListener('touchmove', draw, { passive: false });
    canvas.addEventListener('touchend', endDraw, { passive: false });
}

function moqiSaveUndoSnapshot() {
    const canvas = document.getElementById('moqi-user-canvas');
    moqiUndoStack.push(canvas.toDataURL());
    if (moqiUndoStack.length > 30) moqiUndoStack.shift();
}

function moqiUndo() {
    if (moqiUndoStack.length === 0) return;
    const dataUrl = moqiUndoStack.pop();
    const canvas = document.getElementById('moqi-user-canvas');
    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    const img = new Image();
    img.onload = function() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0);
    };
    img.src = dataUrl;
}
window.moqiUndo = moqiUndo;

function moqiClearUser() {
    moqiSaveUndoSnapshot();
    const canvas = document.getElementById('moqi-user-canvas');
    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
}
window.moqiClearUser = moqiClearUser;

function moqiSetColor(el) {
    moqiCurrentColor = el.dataset.color;
    document.querySelectorAll('.moqi-color-btn').forEach(b => b.classList.remove('active'));
    el.classList.add('active');
    moqiSetTool('pen');
}
window.moqiSetColor = moqiSetColor;

function moqiSetTool(tool) {
    moqiCurrentTool = tool;
    document.getElementById('moqi-pen-btn').classList.toggle('active', tool === 'pen');
    document.getElementById('moqi-eraser-btn').classList.toggle('active', tool === 'eraser');
}
window.moqiSetTool = moqiSetTool;

function moqiSetBrushSize(val) {
    moqiBrushSize = parseInt(val);
}
window.moqiSetBrushSize = moqiSetBrushSize;

function moqiNewRound() {
    // éšæœºé€‰é¢˜
    moqiCurrentTopic = MOQI_TOPICS[Math.floor(Math.random() * MOQI_TOPICS.length)];
    document.getElementById('moqi-draw-topic').textContent = moqiCurrentTopic;
    
    // é‡ç½®ç”»å¸ƒ
    initMoqiCanvases();
    
    // å¯ç”¨ç»˜ç”»æŒ‰é’®
    const btn = document.getElementById('moqi-ai-draw-btn');
    btn.disabled = false;
    btn.style.display = 'inline-flex';
    const btnText = document.getElementById('moqi-ai-btn-text');
    if (btnText) btnText.textContent = 'è®©' + moqiCharName + 'ç”»ä¸ŠåŠéƒ¨åˆ†';
    moqiAiDrawn = false;
    // éšè—ä¿å­˜/åˆ†äº«æŒ‰é’®
    moqiHideSaveArea();
}
window.moqiNewRound = moqiNewRound;

// ç‹¬ç«‹çš„ API è°ƒç”¨ï¼ˆå› ä¸º callAI åœ¨å†…éƒ¨ä½œç”¨åŸŸï¼Œè¿™é‡Œç›´æ¥è¯»å–åŒæ ·çš„é…ç½®ï¼‰
async function moqiCallAI(messages) {
    const urlItem = await db.dexiData.get('aiBaseUrl');
    const keyItem = await db.dexiData.get('aiApiKey');
    const modelItem = await db.dexiData.get('aiCurrentModel');

    const urlValue = urlItem?.value?.trim() || '';
    const apiKey = keyItem?.value?.trim() || '';
    const model = modelItem?.value?.trim() || '';

    if (!urlValue || !apiKey || !model) {
        throw new Error('è¯·å…ˆåœ¨è®¾ç½®ä¸­é…ç½® API åœ°å€ã€å¯†é’¥å’Œæ¨¡å‹');
    }

    let url = urlValue;
    if (url.endsWith('/')) url = url.slice(0, -1);
    if (!url.includes('/v1')) url += '/v1';
    url += '/chat/completions';

    const res = await fetch(url, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
            model: model,
            messages: messages,
            temperature: 0.7
        })
    });

    if (!res.ok) {
        const errText = await res.text();
        throw new Error(`API è¯·æ±‚å¤±è´¥ (${res.status}): ${errText.substring(0, 200)}`);
    }

    const data = await res.json();

    // å…¼å®¹ Gemini / OpenAI æ ¼å¼
    if (data?.candidates?.[0]?.content?.parts?.[0]?.text) {
        return data.candidates[0].content.parts[0].text;
    }
    if (data?.choices?.[0]?.message?.content) {
        return data.choices[0].message.content;
    }
    throw new Error('è§’è‰²è¿”å›äº†ç©ºå†…å®¹');
}

async function moqiAiDraw() {
    if (!moqiCurrentTopic || moqiAiDrawn) return;
    moqiAiDrawn = true;
    const btn = document.getElementById('moqi-ai-draw-btn');
    btn.disabled = true;
    btn.innerHTML = '<svg class="svg-icon" viewBox="0 0 24 24" style="width:16px;height:16px;stroke:#fff;animation:spin 1s linear infinite;"><line x1="12" y1="2" x2="12" y2="6"></line><line x1="12" y1="18" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="6" y2="12"></line><line x1="18" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line><line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line></svg> ' + moqiCharName + ' ç»˜ç”»ä¸­...';

    const canvas = document.getElementById('moqi-ai-canvas');
    const ctx = moqiAiCtx;
    const w = canvas.offsetWidth;
    const h = canvas.offsetHeight;

    // æ¸…ç©ºAIç”»å¸ƒ
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, w, h);

    try {
        // æ„å»ºå¸¦è§’è‰²äººè®¾çš„prompt
        let charContext = '';
        if (moqiCharDesc) {
            charContext = `\nä½ æ­£åœ¨æ‰®æ¼”ä¸€ä¸ªè§’è‰²"${moqiCharName}"ï¼Œè¿™ä¸ªè§’è‰²çš„äººè®¾æ˜¯ï¼š
${moqiCharDesc.substring(0, 500)}

è¯·æ ¹æ®è¿™ä¸ªè§’è‰²çš„æ€§æ ¼ç‰¹ç‚¹æ¥ç”»ç”»ã€‚æ¯”å¦‚è§’è‰²å¦‚æœæ˜¯å¯çˆ±çš„ï¼Œç”»é£å°±æ›´èŒï¼›å¦‚æœæ˜¯é…·é…·çš„ï¼Œç”»é£å°±æ›´å¸…æ°”ç®€ç»ƒï¼›å¦‚æœæ˜¯æ–‡è‰ºçš„ï¼Œç”»é£å°±æ›´æœ‰è‰ºæœ¯æ„Ÿã€‚ç”»é¢è¦ä½“ç°è§’è‰²çš„ä¸ªæ€§ã€‚`;
        } else {
            charContext = `\nä½ æ­£åœ¨æ‰®æ¼”è§’è‰²"${moqiCharName}"æ¥ç”»ç”»ã€‚`;
        }

        const prompt = `ä½ æ˜¯ä¸€ä¸ªç®€ç¬”ç”»ç”Ÿæˆå™¨ã€‚è¯·ä¸ºé¢˜ç›®"${moqiCurrentTopic}"ç”Ÿæˆç®€ç¬”ç”»çš„ã€ä¸ŠåŠéƒ¨åˆ†ã€‘çš„ç»˜ç”»æŒ‡ä»¤ã€‚
${charContext}

è¿™æ˜¯ä¸€ä¸ª"é»˜å¥‘ç»˜ç”»"æ¸¸æˆï¼š${moqiCharName}ç”»ä¸ŠåŠéƒ¨åˆ†ï¼Œç”¨æˆ·ç”»ä¸‹åŠéƒ¨åˆ†ï¼Œç„¶åæ‹¼åœ¨ä¸€èµ·çœ‹æ˜¯å¦é»˜å¥‘ã€‚

ç”»å¸ƒåæ ‡ç³»ï¼šå®½åº¦100ï¼Œé«˜åº¦100ã€‚ç”»å¸ƒå·¦ä¸Šè§’æ˜¯(0,0)ï¼Œå³ä¸‹è§’æ˜¯(100,100)ã€‚
ä½ åªç”»ä¸ŠåŠéƒ¨åˆ†ï¼Œæ‰€ä»¥å†…å®¹ä¸»è¦é›†ä¸­åœ¨y=0åˆ°y=100çš„èŒƒå›´å†…ï¼ˆä½†è¿™æ˜¯ä¸ŠåŠç”»å¸ƒï¼Œä¸‹åŠéƒ¨åˆ†ç”¨æˆ·ä¼šæ¥ç€ç”»ï¼‰ã€‚

è¯·è¿”å›ä¸€ä¸ªJSONæ•°ç»„ï¼Œæ¯ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªç¬”ç”»å¯¹è±¡ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
- line: {"type":"line","x1":æ•°å­—,"y1":æ•°å­—,"x2":æ•°å­—,"y2":æ•°å­—,"color":"é¢œè‰²","width":æ•°å­—}
- circle: {"type":"circle","cx":æ•°å­—,"cy":æ•°å­—,"r":æ•°å­—,"color":"é¢œè‰²","width":æ•°å­—}
- arc: {"type":"arc","cx":æ•°å­—,"cy":æ•°å­—,"r":æ•°å­—,"startAngle":è§’åº¦æ•°å­—,"endAngle":è§’åº¦æ•°å­—,"color":"é¢œè‰²","width":æ•°å­—}
- path: {"type":"path","points":[[x,y],[x,y],...],"color":"é¢œè‰²","width":æ•°å­—}

è¦æ±‚ï¼š
1. åªè¿”å›JSONæ•°ç»„ï¼Œä¸è¦å…¶ä»–æ–‡å­—
2. ç”»é¢è¦å¯çˆ±ã€ç®€æ´ã€åƒç®€ç¬”ç”»
3. é¢œè‰²ç”¨hexæ ¼å¼å¦‚ #333333
4. widthçº¿å®½å»ºè®®2-4
5. å†…å®¹æ˜¯é¢˜ç›®çš„ä¸ŠåŠéƒ¨åˆ†ï¼ˆæ¯”å¦‚äººç‰©ç”»å¤´å’Œä¸ŠåŠèº«ï¼ŒåŠ¨ç‰©ç”»å¤´éƒ¨ï¼Œç‰©å“ç”»ä¸ŠåŠéƒ¨åˆ†ï¼‰
6. ç”»é¢è¦å±…ä¸­ï¼Œå¤§å°é€‚ä¸­ï¼Œç•™ä¸€äº›è¾¹è·
7. åº•éƒ¨è¾¹ç¼˜çš„çº¿æ¡è¦è‡ªç„¶åœ°å»¶ä¼¸åˆ°åº•éƒ¨ï¼Œæ–¹ä¾¿ç”¨æˆ·æ¥ç€ç”»ä¸‹åŠéƒ¨åˆ†`;

        const aiResponse = await moqiCallAI([
            { role: 'user', content: prompt }
        ]);

        // è§£æ AI è¿”å›çš„ JSON
        let commands = [];
        try {
            // å°è¯•æå– JSON æ•°ç»„ï¼ˆå¯èƒ½åŒ…å« markdown ä»£ç å—ï¼‰
            let jsonStr = aiResponse.trim();
            const jsonMatch = jsonStr.match(/```(?:json)?\s*([\s\S]*?)```/);
            if (jsonMatch) {
                jsonStr = jsonMatch[1].trim();
            }
            // å°è¯•æ‰¾åˆ°æ•°ç»„å¼€å§‹å’Œç»“æŸ
            const arrStart = jsonStr.indexOf('[');
            const arrEnd = jsonStr.lastIndexOf(']');
            if (arrStart !== -1 && arrEnd !== -1) {
                jsonStr = jsonStr.substring(arrStart, arrEnd + 1);
            }
            commands = JSON.parse(jsonStr);
        } catch (parseErr) {
            console.error('[é»˜å¥‘ç»˜ç”»] è¿”å›è§£æå¤±è´¥:', parseErr, aiResponse);
            throw new Error('è§’è‰²è¿”å›çš„ç»˜ç”»æŒ‡ä»¤æ ¼å¼æœ‰è¯¯ï¼Œè¯·é‡è¯•');
        }

        // åœ¨ç”»å¸ƒä¸Šæ¸²æŸ“è§’è‰²çš„ç»˜ç”»æŒ‡ä»¤ï¼ˆå¸¦åŠ¨ç”»ï¼‰
        await moqiRenderCommands(ctx, commands, w, h);
        btn.style.display = 'none';
        // æ˜¾ç¤ºä¿å­˜/åˆ†äº«æŒ‰é’®
        moqiShowSaveArea();

    } catch (err) {
        console.error('[é»˜å¥‘ç»˜ç”»] ç»˜ç”»å¤±è´¥:', err);
        moqiAiDrawn = false;
        btn.disabled = false;
        btn.innerHTML = '<svg class="svg-icon" viewBox="0 0 24 24" style="width:16px;height:16px;stroke:#fff;"><path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path><circle cx="11" cy="11" r="2"></circle></svg> <span id="moqi-ai-btn-text">è®©' + moqiCharName + 'ç”»ä¸ŠåŠéƒ¨åˆ†</span>';
        if (typeof showToast === 'function') {
            showToast('âŒ ' + err.message);
        } else {
            alert(err.message);
        }
    }
}
window.moqiAiDraw = moqiAiDraw;

// å°†è§’è‰²è¿”å›çš„ç»˜ç”»æŒ‡ä»¤æ¸²æŸ“åˆ°ç”»å¸ƒä¸Šï¼ˆå¸¦é€ç¬”åŠ¨ç”»ï¼‰
function moqiRenderCommands(ctx, commands, canvasW, canvasH) {
    return new Promise((resolve) => {
        const scaleX = canvasW / 100;
        const scaleY = canvasH / 100;
        let idx = 0;

        function drawNext() {
            if (idx >= commands.length) {
                resolve();
                return;
            }
            const cmd = commands[idx];
            ctx.strokeStyle = cmd.color || '#333';
            ctx.lineWidth = (cmd.width || 2.5) * Math.min(scaleX, scaleY) / 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.fillStyle = 'transparent';

            try {
                switch (cmd.type) {
                    case 'line':
                        ctx.beginPath();
                        ctx.moveTo(cmd.x1 * scaleX, cmd.y1 * scaleY);
                        ctx.lineTo(cmd.x2 * scaleX, cmd.y2 * scaleY);
                        ctx.stroke();
                        break;
                    case 'circle':
                        ctx.beginPath();
                        ctx.arc(cmd.cx * scaleX, cmd.cy * scaleY, cmd.r * Math.min(scaleX, scaleY), 0, Math.PI * 2);
                        ctx.stroke();
                        if (cmd.fill) {
                            ctx.fillStyle = cmd.fill;
                            ctx.fill();
                        }
                        break;
                    case 'arc': {
                        const sa = (cmd.startAngle || 0) * Math.PI / 180;
                        const ea = (cmd.endAngle || 360) * Math.PI / 180;
                        ctx.beginPath();
                        ctx.arc(cmd.cx * scaleX, cmd.cy * scaleY, cmd.r * Math.min(scaleX, scaleY), sa, ea);
                        ctx.stroke();
                        break;
                    }
                    case 'path':
                        if (cmd.points && cmd.points.length >= 2) {
                            ctx.beginPath();
                            ctx.moveTo(cmd.points[0][0] * scaleX, cmd.points[0][1] * scaleY);
                            for (let i = 1; i < cmd.points.length; i++) {
                                ctx.lineTo(cmd.points[i][0] * scaleX, cmd.points[i][1] * scaleY);
                            }
                            ctx.stroke();
                            if (cmd.fill) {
                                ctx.fillStyle = cmd.fill;
                                ctx.fill();
                            }
                        }
                        break;
                    case 'rect':
                        ctx.beginPath();
                        ctx.rect(
                            (cmd.x || 0) * scaleX,
                            (cmd.y || 0) * scaleY,
                            (cmd.w || cmd.width_rect || 10) * scaleX,
                            (cmd.h || cmd.height_rect || 10) * scaleY
                        );
                        ctx.stroke();
                        if (cmd.fill) {
                            ctx.fillStyle = cmd.fill;
                            ctx.fill();
                        }
                        break;
                    case 'ellipse':
                        ctx.beginPath();
                        ctx.ellipse(
                            (cmd.cx || 50) * scaleX,
                            (cmd.cy || 50) * scaleY,
                            (cmd.rx || 10) * scaleX,
                            (cmd.ry || 10) * scaleY,
                            0, 0, Math.PI * 2
                        );
                        ctx.stroke();
                        if (cmd.fill) {
                            ctx.fillStyle = cmd.fill;
                            ctx.fill();
                        }
                        break;
                }
            } catch (e) {
                console.warn('[é»˜å¥‘ç»˜ç”»] æ¸²æŸ“æŒ‡ä»¤å‡ºé”™:', e, cmd);
            }

            idx++;
            // é€ç¬”åŠ¨ç”»é—´éš”
            setTimeout(drawNext, 80);
        }

        drawNext();
    });
}

// æ·»åŠ åˆ° window
window.moqiNewRound = moqiNewRound;
window.moqiAiDraw = moqiAiDraw;

// ========== é»˜å¥‘ç»˜ç”» - ä¿å­˜ & åˆ†äº« ==========
function moqiShowSaveArea() {
    const area = document.getElementById('moqi-draw-save-area');
    if (area) area.style.display = 'flex';
}
function moqiHideSaveArea() {
    const area = document.getElementById('moqi-draw-save-area');
    if (area) area.style.display = 'none';
}

// è·å–ç”¨æˆ·å
async function moqiGetUserName() {
    try {
        const accountId = localStorage.getItem('current_my_char_id');
        if (!accountId) return 'æˆ‘';
        const userChar = await db.characters.get(parseInt(accountId));
        if (userChar) return userChar.nick || userChar.name || 'æˆ‘';
    } catch(e) {}
    return 'æˆ‘';
}

// å°†ä¸¤ä¸ªç”»å¸ƒæ‹¼æ¥æˆä¸€å¼ å®Œæ•´å›¾ç‰‡ï¼ˆå«æ ‡é¢˜å’Œä½œè€…ä¿¡æ¯ï¼‰ï¼Œè¿”å› canvas
function moqiMergeCanvases(charName, userName, topic) {
    const aiCanvas = document.getElementById('moqi-ai-canvas');
    const userCanvas = document.getElementById('moqi-user-canvas');
    if (!aiCanvas || !userCanvas) return null;

    const cw = aiCanvas.width; // ç”»å¸ƒå®½åº¦
    const headerH = 70;  // é¡¶éƒ¨æ ‡é¢˜åŒºé«˜åº¦
    const footerH = 50;  // åº•éƒ¨ç½²ååŒºé«˜åº¦
    const labelH = 28;   // æ¯ä¸ªç”»å¸ƒä¸Šæ–¹/ä¸‹æ–¹çš„åå­—æ ‡ç­¾é«˜åº¦

    const mergedCanvas = document.createElement('canvas');
    mergedCanvas.width = cw;
    mergedCanvas.height = headerH + labelH + aiCanvas.height + userCanvas.height + labelH + footerH;
    const mCtx = mergedCanvas.getContext('2d');

    // ç™½è‰²èƒŒæ™¯
    mCtx.fillStyle = '#fff';
    mCtx.fillRect(0, 0, mergedCanvas.width, mergedCanvas.height);

    // ---- é¡¶éƒ¨æ ‡é¢˜åŒº ----
    const topicText = (topic && topic !== 'ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¼€å§‹') ? topic : 'è‡ªç”±åˆ›ä½œ';
    mCtx.textAlign = 'center';
    // å°æ ‡ç­¾
    mCtx.font = '600 12px -apple-system, "Helvetica Neue", sans-serif';
    mCtx.fillStyle = '#bbb';
    mCtx.fillText('é»˜ å¥‘ ç»˜ ç”»', cw / 2, 28);
    // é¢˜ç›®
    mCtx.font = '600 20px -apple-system, "Helvetica Neue", sans-serif';
    mCtx.fillStyle = '#333';
    mCtx.fillText(topicText, cw / 2, 55);

    // ---- è§’è‰²åæ ‡ç­¾ ----
    let yPos = headerH;
    mCtx.font = '500 12px -apple-system, "Helvetica Neue", sans-serif';
    mCtx.fillStyle = '#999';
    mCtx.textAlign = 'left';
    mCtx.fillText(charName + ' çš„ç”»', 16, yPos + 18);
    yPos += labelH;

    // ---- è§’è‰²ç”»å¸ƒ ----
    mCtx.drawImage(aiCanvas, 0, yPos);
    yPos += aiCanvas.height;

    // ---- æ‹¼æ¥è™šçº¿ ----
    mCtx.setLineDash([6, 4]);
    mCtx.strokeStyle = '#ddd';
    mCtx.lineWidth = 1;
    mCtx.beginPath();
    mCtx.moveTo(0, yPos);
    mCtx.lineTo(cw, yPos);
    mCtx.stroke();
    mCtx.setLineDash([]);

    // ---- ç”¨æˆ·ç”»å¸ƒ ----
    mCtx.drawImage(userCanvas, 0, yPos);
    yPos += userCanvas.height;

    // ---- ç”¨æˆ·åæ ‡ç­¾ ----
    mCtx.font = '500 12px -apple-system, "Helvetica Neue", sans-serif';
    mCtx.fillStyle = '#999';
    mCtx.textAlign = 'right';
    mCtx.fillText(userName + ' çš„ç”»', cw - 16, yPos + 18);
    yPos += labelH;

    // ---- åº•éƒ¨ç½²ååŒº ----
    mCtx.textAlign = 'center';
    // åˆ†éš”ç»†çº¿
    mCtx.strokeStyle = '#eee';
    mCtx.lineWidth = 1;
    mCtx.beginPath();
    mCtx.moveTo(cw * 0.2, yPos + 4);
    mCtx.lineTo(cw * 0.8, yPos + 4);
    mCtx.stroke();
    // ç½²åæ–‡å­—
    mCtx.font = '400 13px -apple-system, "Helvetica Neue", sans-serif';
    mCtx.fillStyle = '#bbb';
    mCtx.fillText(charName + '  Ã—  ' + userName, cw / 2, yPos + 30);

    return mergedCanvas;
}

// ä¿å­˜å›¾ç‰‡
window.moqiSaveDrawing = async function() {
    const topic = document.getElementById('moqi-draw-topic')?.textContent || '';
    const charName = moqiCharName || 'è§’è‰²';
    const userName = await moqiGetUserName();
    const merged = moqiMergeCanvases(charName, userName, topic);
    if (!merged) { if (typeof showToast === 'function') showToast('ç”»å¸ƒä¸ºç©º'); return; }
    // è§¦å‘ä¸‹è½½
    const link = document.createElement('a');
    link.download = 'é»˜å¥‘ç»˜ç”»_' + charName + 'Ã—' + userName + '_' + (topic || 'ä½œå“') + '.png';
    link.href = merged.toDataURL('image/png');
    link.click();
    if (typeof showToast === 'function') showToast('å›¾ç‰‡å·²ä¿å­˜');
};

// åˆ†äº«ç»™å¥½å‹ï¼ˆå‘é€åˆ°èŠå¤©ï¼‰
window.moqiShareDrawing = async function() {
    let friends = [];
    try {
        const accountId = localStorage.getItem('current_my_char_id');
        if (!accountId) { if (typeof showToast === 'function') showToast('è¯·å…ˆç™»å½•'); return; }
        const allChars = await db.characters.toArray();
        friends = allChars.filter(c => {
            if (c.type === 'user') return false;
            const perUserStatus = c.wechat_status_by_user?.[accountId];
            if (perUserStatus && perUserStatus !== 'stranger') return perUserStatus === 'friend';
            if (c.wechat_status && c.wechat_status !== 'stranger') return c.wechat_status === 'friend';
            return false;
        });
    } catch(e) { console.error(e); }
    if (!friends.length) { if (typeof showToast === 'function') showToast('æš‚æ— å¥½å‹å¯åˆ†äº«'); return; }

    // æ„å»ºé€‰æ‹©å¼¹çª—
    let overlay = document.getElementById('moqi-share-picker');
    if (overlay) overlay.remove();
    overlay = document.createElement('div');
    overlay.id = 'moqi-share-picker';
    overlay.className = 'moqi-share-picker-overlay';
    let html = '<div class="moqi-share-picker-mask"></div><div class="moqi-share-picker-panel"><div class="moqi-share-picker-header"><span>åˆ†äº«ç»™å¥½å‹</span><div class="close-btn" style="width:28px;height:28px;display:flex;align-items:center;justify-content:center;border-radius:50%;background:#f5f5f5;cursor:pointer;"><svg width="18" height="18" fill="none" stroke="#999" stroke-width="2" viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></div></div><div class="moqi-share-picker-list">';
    friends.forEach(f => {
        const avatar = f.avatar || '';
        const name = f.name || 'æœªçŸ¥';
        html += `<div class="moqi-share-picker-item" data-id="${f.id}"><img src="${avatar}" onerror="this.src='data:image/svg+xml,<svg xmlns=\\'http://www.w3.org/2000/svg\\' viewBox=\\'0 0 40 40\\'><rect fill=\\'%23ddd\\' width=\\'40\\' height=\\'40\\'/></svg>'" style="width:36px;height:36px;border-radius:50%;object-fit:cover;"><span>${name}</span></div>`;
    });
    html += '</div></div>';
    overlay.innerHTML = html;
    document.body.appendChild(overlay);

    // ç»‘å®šäº‹ä»¶
    overlay.querySelector('.moqi-share-picker-mask').onclick = () => overlay.remove();
    overlay.querySelector('.close-btn').onclick = () => overlay.remove();
    overlay.querySelectorAll('.moqi-share-picker-item').forEach(item => {
        item.onclick = async () => {
            const charId = parseInt(item.dataset.id);
            overlay.remove();
            await moqiSendDrawingToFriend(charId);
        };
    });
};

async function moqiSendDrawingToFriend(charId) {
    const topic = document.getElementById('moqi-draw-topic')?.textContent || 'ä½œå“';
    const charName = moqiCharName || 'è§’è‰²';
    const userName = await moqiGetUserName();
    const merged = moqiMergeCanvases(charName, userName, topic);
    if (!merged) return;
    const imgData = merged.toDataURL('image/png');
    const accountId = localStorage.getItem('current_my_char_id');
    if (!accountId) return;
    try {
        const char = await db.characters.get(charId);
        if (!char) return;
        const history = char.chat_history_by_user?.[accountId] || char.chat_history || [];
        // ç”¨ [img:...] æ ¼å¼ï¼Œè®©èŠå¤©æ¸²æŸ“å™¨èƒ½è¯†åˆ«ä¸ºå›¾ç‰‡
        const newMsg = {
            role: 'user',
            content: '[img:' + imgData + ']',
            timestamp: Date.now()
        };
        history.push(newMsg);
        if (!char.chat_history_by_user) char.chat_history_by_user = {};
        char.chat_history_by_user[accountId] = history;
        await safeCharacterPut(char);
        // è¿½åŠ åˆ°èŠå¤© UI
        if (typeof window._appendShopCardToChat === 'function') {
            window._appendShopCardToChat(charId, newMsg);
        }
        if (typeof showToast === 'function') showToast('å·²åˆ†äº«ç»™ ' + (char.name || 'å¥½å‹'));
    } catch(e) {
        console.error('[é»˜å¥‘ç»˜ç”»] åˆ†äº«å¤±è´¥:', e);
        if (typeof showToast === 'function') showToast('åˆ†äº«å¤±è´¥');
    }
}

// ===================== è´­ç‰©é¡µé¢ =====================
(function() {
    // å•†å“æ•°æ®
    const shopProducts = [
        // æœé¥°
        { id:1, name:'æç®€çº¯æ£‰ç™½Tæ¤', cat:'clothing', price:129, originPrice:199, desc:'100%çº¯æ£‰é¢æ–™ï¼Œå®½æ¾ç‰ˆå‹ï¼ŒåŸºç¡€ç™¾æ­å•å“', specs:['S','M','L','XL'], sold:2341, emoji:'ğŸ‘•' },
        { id:2, name:'é«˜è…°ä¿®èº«ç‰›ä»”è£¤', cat:'clothing', price:259, originPrice:399, desc:'å¼¹åŠ›é¢æ–™ï¼Œä¿®èº«æ˜¾ç˜¦ï¼Œç»å…¸è“è‰²æ°´æ´—', specs:['25','26','27','28','29','30'], sold:1876, emoji:'ğŸ‘–' },
        { id:3, name:'æ³•å¼ç¢èŠ±è¿è¡£è£™', cat:'clothing', price:339, originPrice:499, desc:'è½»ç›ˆé›ªçººé¢æ–™ï¼Œæµªæ¼«ç¢èŠ±å°èŠ±ï¼Œæ”¶è…°è®¾è®¡', specs:['S','M','L'], sold:923, emoji:'ğŸ‘—' },
        { id:4, name:'ç¾Šç»’æ··çººé’ˆç»‡è¡«', cat:'clothing', price:459, originPrice:699, desc:'æŸ”è½¯äº²è‚¤ï¼Œç»†è…»è§¦æ„Ÿï¼Œä¼˜é›…åœ†é¢†è®¾è®¡', specs:['S','M','L','XL'], sold:1543, emoji:'ğŸ§¶' },
        { id:5, name:'å®½æ¾è¿åŠ¨å«è¡£', cat:'clothing', price:199, originPrice:299, desc:'åŠ ç»’ä¿æš–ï¼Œè½è‚©è®¾è®¡ï¼Œæ½®æµå­—æ¯å°èŠ±', specs:['M','L','XL','2XL'], sold:3021, emoji:'ğŸ§¥' },
        { id:6, name:'çœŸä¸ç¼é¢è¡¬è¡«', cat:'clothing', price:389, originPrice:599, desc:'æ¡‘èš•ä¸é¢æ–™ï¼Œå…‰æ³½ç»†è…»ï¼Œé€šå‹¤ç™¾æ­', specs:['S','M','L'], sold:687, emoji:'ğŸ‘”' },
        // åŒ…è¢‹
        { id:7, name:'æç®€æ‰˜ç‰¹åŒ…', cat:'bags', price:299, originPrice:459, desc:'å¤§å®¹é‡è®¾è®¡ï¼Œä¼˜è´¨PUçš®é©ï¼Œç®€çº¦çº¿æ¡', specs:['é»‘è‰²','ç±³ç™½','ç„¦ç³–'], sold:1234, emoji:'ğŸ‘œ' },
        { id:8, name:'é“¾æ¡æ–œæŒå°æ–¹åŒ…', cat:'bags', price:249, originPrice:399, desc:'ç²¾è‡´å°å·§ï¼Œé‡‘å±é“¾æ¡è‚©å¸¦ï¼Œç¿»ç›–è®¾è®¡', specs:['é»‘è‰²','ç™½è‰²','ç²‰è‰²'], sold:2156, emoji:'ğŸ‘›' },
        { id:9, name:'å¸†å¸ƒå•è‚©åŒ…', cat:'bags', price:89, originPrice:139, desc:'æ–‡è‰ºèŒƒå¸†å¸ƒæè´¨ï¼Œè½»ä¾¿å®ç”¨', specs:['ç±³è‰²','ç°è‰²','å†›ç»¿'], sold:4523, emoji:'ğŸ’' },
        { id:10, name:'çœŸçš®æ‰‹æ‹¿åŒ…', cat:'bags', price:459, originPrice:699, desc:'å¤´å±‚ç‰›çš®ï¼Œä¿¡å°å¼è®¾è®¡ï¼Œæ™šå®´å¿…å¤‡', specs:['é»‘è‰²','é…’çº¢','å¢¨ç»¿'], sold:567, emoji:'ğŸ’¼' },
        // é‹å±¥
        { id:11, name:'å°ç™½é‹ ç»å…¸æ¬¾', cat:'shoes', price:199, originPrice:299, desc:'ç™¾æ­å°ç™½é‹ï¼ŒæŸ”è½¯é‹åº•ï¼Œèˆ’é€‚é€æ°”', specs:['36','37','38','39','40'], sold:5678, emoji:'ğŸ‘Ÿ' },
        { id:12, name:'å°–å¤´é«˜è·Ÿé‹', cat:'shoes', price:329, originPrice:499, desc:'7cmç»†è·Ÿï¼Œä¼˜é›…å°–å¤´è®¾è®¡ï¼Œæ¼†çš®äº®é¢', specs:['35','36','37','38','39'], sold:1432, emoji:'ğŸ‘ ' },
        { id:13, name:'åˆ‡å°”è¥¿çŸ­é´', cat:'shoes', price:399, originPrice:599, desc:'ç»å…¸ç‰ˆå‹ï¼Œå¼¹åŠ›å¸¦è®¾è®¡ï¼Œç§‹å†¬å¿…å¤‡', specs:['36','37','38','39','40'], sold:2134, emoji:'ğŸ‘¢' },
        { id:14, name:'è¿åŠ¨è€çˆ¹é‹', cat:'shoes', price:269, originPrice:429, desc:'å¢é«˜åšåº•ï¼Œå¤å¤é…è‰²ï¼Œæ½®æµè¡—æ‹', specs:['36','37','38','39','40','41'], sold:3456, emoji:'ğŸ‘Ÿ' },
        // ç¾å¦†
        { id:15, name:'ä¸ç»’å“‘å…‰å”‡é‡‰', cat:'beauty', price:129, originPrice:189, desc:'é›¾é¢è´¨åœ°ï¼ŒæŒä¹…æ˜¾è‰²ï¼Œä¸æ‹”å¹²', specs:['è±†æ²™çº¢','ç«ç‘°ç²‰','æ­£çº¢','è£¸è‰²'], sold:8765, emoji:'ğŸ’„' },
        { id:16, name:'æ°”å«BBéœœ', cat:'beauty', price:199, originPrice:299, desc:'è½»è–„æœå¸–ï¼Œè‡ªç„¶é®ç‘•ï¼Œæ°´æ¶¦ä¸è„±å¦†', specs:['è±¡ç‰™ç™½','è‡ªç„¶è‰²','æš–ç™½'], sold:6543, emoji:'ğŸ’‹' },
        { id:17, name:'åå…­è‰²çœ¼å½±ç›˜', cat:'beauty', price:159, originPrice:249, desc:'å¤§åœ°è‰²ç³»ï¼Œå“‘å…‰ç å…‰åŒè´¨åœ°ï¼Œæ—¥å¸¸ç™¾æ­', specs:['æš–æ£•ç›˜','å†·ç°ç›˜','ç«ç‘°ç›˜'], sold:4321, emoji:'ğŸ¨' },
        { id:18, name:'ä¿æ¹¿ç²¾åæ¶² 30ml', cat:'beauty', price:289, originPrice:439, desc:'ç»å°¿é…¸æˆåˆ†ï¼Œæ·±å±‚è¡¥æ°´ï¼Œæ”¹å–„å¹²çº¹', specs:['30ml','50ml'], sold:3456, emoji:'âœ¨' },
        { id:19, name:'å®šå¦†å–·é›¾', cat:'beauty', price:79, originPrice:119, desc:'ç»†è…»é›¾åŒ–ï¼ŒæŒå¦†12å°æ—¶ï¼Œæ¸…çˆ½ä¸ç²˜è…»', specs:['100ml'], sold:7654, emoji:'ğŸ’§' },
        // é…é¥°
        { id:20, name:'æç®€é‡‘å±æ‰‹é“¾', cat:'jewelry', price:89, originPrice:139, desc:'é’›é’¢æè´¨ï¼Œä¸è¤ªè‰²ä¸è¿‡æ•ï¼Œç»†é“¾è®¾è®¡', specs:['é‡‘è‰²','é“¶è‰²','ç«ç‘°é‡‘'], sold:3456, emoji:'ğŸ“¿' },
        { id:21, name:'çç è€³é’‰', cat:'jewelry', price:69, originPrice:99, desc:'å¤©ç„¶æ·¡æ°´çç ï¼Œ925é“¶é’ˆï¼Œä½æ•æè´¨', specs:['6mm','8mm','10mm'], sold:5678, emoji:'ğŸ’' },
        { id:22, name:'å¤å¤å¤ªé˜³é•œ', cat:'jewelry', price:149, originPrice:229, desc:'UV400é˜²æ™’ï¼ŒTR90è½»é‡é•œæ¶ï¼Œinsé£', specs:['é»‘è‰²','èŒ¶è‰²','ç°è‰²'], sold:2345, emoji:'ğŸ•¶ï¸' },
        { id:23, name:'ç®€çº¦æ‰‹è¡¨', cat:'jewelry', price:259, originPrice:399, desc:'æ—¥æœ¬æœºèŠ¯ï¼ŒçœŸçš®è¡¨å¸¦ï¼Œæç®€è¡¨ç›˜', specs:['é»‘ç›˜æ£•å¸¦','ç™½ç›˜é»‘å¸¦','ç™½ç›˜ç±³å¸¦'], sold:1234, emoji:'âŒš' },
        // æ•°ç 
        { id:24, name:'æ— çº¿è“ç‰™è€³æœº', cat:'digital', price:199, originPrice:299, desc:'ä¸»åŠ¨é™å™ªï¼Œ30hç»­èˆªï¼Œè§¦æ§æ“ä½œ', specs:['ç™½è‰²','é»‘è‰²'], sold:8765, emoji:'ğŸ§' },
        { id:25, name:'ç£å¸æ— çº¿å……ç”µå™¨', cat:'digital', price:79, originPrice:129, desc:'15Wå¿«å……ï¼Œå…¼å®¹å¤šæœºå‹ï¼Œæç®€è®¾è®¡', specs:['ç™½è‰²','é»‘è‰²'], sold:5432, emoji:'ğŸ”Œ' },
        { id:26, name:'æç®€å°ç¯', cat:'digital', price:139, originPrice:199, desc:'ä¸‰æ¡£è‰²æ¸©ï¼Œè§¦æ§è°ƒèŠ‚ï¼ŒType-Cå……ç”µ', specs:['ç™½è‰²','æœ¨çº¹'], sold:3456, emoji:'ğŸ’¡' },
        { id:27, name:'ä¾¿æºè“ç‰™éŸ³ç®±', cat:'digital', price:169, originPrice:259, desc:'IPX7é˜²æ°´ï¼Œ12hç»­èˆªï¼Œç«‹ä½“ç¯ç»•éŸ³æ•ˆ', specs:['é»‘è‰²','ç™½è‰²','å†›ç»¿'], sold:2345, emoji:'ğŸ”Š' },
        // å®¶å±…
        { id:28, name:'é¦™è–°èœ¡çƒ› å¤§è±†èœ¡', cat:'home', price:69, originPrice:99, desc:'å¤©ç„¶å¤§è±†èœ¡ï¼Œæœ¨è´¨ç¯èŠ¯ï¼ŒåŠ©çœ é¦™æ°›', specs:['ç™½èŒ¶','æª€é¦™','è–°è¡£è‰','æ— èŠ±æœ'], sold:6789, emoji:'ğŸ•¯ï¸' },
        { id:29, name:'insé£æŠ±æ•', cat:'home', price:49, originPrice:79, desc:'æ£‰éº»æè´¨ï¼ŒåŒ—æ¬§å‡ ä½•å›¾æ¡ˆï¼Œå«æ•èŠ¯', specs:['45Ã—45cm','50Ã—50cm'], sold:4567, emoji:'ğŸ›‹ï¸' },
        { id:30, name:'é™¶ç“·é©¬å…‹æ¯', cat:'home', price:39, originPrice:59, desc:'å“‘å…‰é‡‰é¢ï¼Œå¤§å®¹é‡400mlï¼Œç®€çº¦è®¾è®¡', specs:['ç™½è‰²','ç°è‰²','è«å…°è¿ªç²‰'], sold:8765, emoji:'â˜•' },
        { id:31, name:'å¹²èŠ±èŠ±æŸè£…é¥°', cat:'home', price:59, originPrice:89, desc:'å¤©ç„¶å¹²èŠ±ï¼Œinsé£æ‹ç…§é“å…·ï¼Œå«èŠ±ç“¶', specs:['ç™½è‰²ç³»','æš–è‰²ç³»','æ··åˆè‰²'], sold:3456, emoji:'ğŸ’' },
        { id:32, name:'æç®€æ”¶çº³ç›’å¥—è£…', cat:'home', price:89, originPrice:139, desc:'PPæè´¨ï¼Œç£¨ç ‚è´¨æ„Ÿï¼Œæ¡Œé¢åŒ–å¦†å“æ”¶çº³', specs:['3ä»¶å¥—','5ä»¶å¥—'], sold:2345, emoji:'ğŸ“¦' },
    ];

    let shopCart = [];
    let currentCategory = 'all';
    let currentDetailProduct = null;
    let currentSpec = '';
    let currentInstallment = 0;
    let selectedFriendForPay = null; // ä»£ä»˜é€‰ä¸­çš„å¥½å‹
    let selectedFamilyCard = null;   // é€‰ä¸­çš„äº²å±å¡
    let selectedBuyForFriend = null; // é€ç»™è°ï¼ˆä¸ºè°è´­ä¹°ï¼‰
    const SHOP_INST_KEY = 'shop_installment_plans'; // localStorage key

    // ====== å·¥å…·å‡½æ•° ======
    function getMyCharId() {
        return localStorage.getItem('current_my_char_id');
    }

    // è·å–å¥½å‹çŠ¶æ€ï¼ˆå¤åˆ¶é€»è¾‘ï¼Œå› ä¸ºåŸå‡½æ•°åœ¨DOMContentLoadedé—­åŒ…å†…ï¼‰
    function _getFriendStatus(char, accountId) {
        if (!accountId) return char.wechat_status || 'stranger';
        const perUserStatus = char.wechat_status_by_user?.[accountId];
        if (perUserStatus && perUserStatus !== 'stranger') return perUserStatus;
        if (char.wechat_status && char.wechat_status !== 'stranger') return char.wechat_status;
        return perUserStatus || 'stranger';
    }

    function _getChatHistory(char, accountId) {
        if (!accountId) return char.chat_history || [];
        return char.chat_history_by_user?.[accountId] || [];
    }

    async function _setChatHistory(char, accountId, history) {
        if (!accountId) {
            char.chat_history = history;
        } else {
            if (!char.chat_history_by_user) char.chat_history_by_user = {};
            char.chat_history_by_user[accountId] = history;
        }
        await safeCharacterPut(char);
    }

    // è·å–å¥½å‹åˆ—è¡¨
    async function getFriendsList() {
        const accountId = getMyCharId();
        if (!accountId) return [];
        const allChars = await db.characters.toArray();
        return allChars.filter(c => {
            if (c.type === 'user') return false;
            const status = _getFriendStatus(c, accountId);
            return status === 'friend';
        });
    }

    // æ£€æŸ¥æ˜¯å¦æœ‰æ”¶åˆ°çš„äº²å±å¡
    async function getReceivedFamilyCards() {
        const accountId = getMyCharId();
        if (!accountId) return [];
        const user = await db.characters.get(parseInt(accountId));
        if (!user) return [];

        const cards = [];
        // æ–¹å¼1ï¼šä» identity.familyCardsReceived
        if (user.identity && user.identity.familyCardsReceived) {
            for (const card of user.identity.familyCardsReceived) {
                const giver = await db.characters.get(card.charId);
                if (giver) {
                    cards.push({
                        charId: card.charId,
                        name: giver.name,
                        avatar: giver.avatar || '',
                        monthlyLimit: card.monthlyLimit || 0,
                        usedThisMonth: card.usedThisMonth || 0,
                        source: 'identity'
                    });
                }
            }
        }

        // æ–¹å¼2ï¼šä»èŠå¤©è®°å½•ä¸­æ£€æµ‹ï¼ˆè§’è‰²å‘é€çš„äº²å±å¡æ¶ˆæ¯ï¼‰
        const allChars = await db.characters.toArray();
        for (const c of allChars) {
            if (c.type === 'user') continue;
            if (_getFriendStatus(c, accountId) !== 'friend') continue;
            const history = _getChatHistory(c, accountId);
            const fcMsgs = history.filter(m => m.role === 'char' && m.type === 'familyCard');
            if (fcMsgs.length > 0) {
                // æ£€æŸ¥æ˜¯å¦å·²ç»åœ¨ä¸Šé¢æ·»åŠ äº†
                const already = cards.some(x => x.charId === c.id);
                if (!already) {
                    const lastCard = fcMsgs[fcMsgs.length - 1];
                    let cardData = {};
                    try { cardData = JSON.parse(lastCard.content); } catch(e) {}
                    cards.push({
                        charId: c.id,
                        name: c.name,
                        avatar: c.avatar || '',
                        monthlyLimit: cardData.monthlyLimit || 0,
                        usedThisMonth: 0,
                        source: 'chat'
                    });
                }
            }
        }

        return cards;
    }

    // ====== æ¸²æŸ“å•†å“åˆ—è¡¨ ======
    function renderProducts(cat) {
        const grid = document.getElementById('shop-product-grid');
        if (!grid) return;
        const filtered = cat === 'all' ? shopProducts : shopProducts.filter(p => p.cat === cat);
        grid.innerHTML = filtered.map(p => `
            <div class="shop-product-card" onclick="openShopDetail(${p.id})">
                <div class="shop-product-img">
                    <span>${p.emoji}</span>
                    ${p.originPrice > p.price ? '<div class="shop-product-tag">HOT</div>' : ''}
                </div>
                <div class="shop-product-info">
                    <div class="shop-product-name">${p.name}</div>
                    <div class="shop-product-price">Â¥${p.price.toFixed(2)}
                        ${p.originPrice ? '<span class="shop-origin-price">Â¥' + p.originPrice.toFixed(2) + '</span>' : ''}
                    </div>
                    <div class="shop-product-bottom">
                        <div class="shop-product-sold">å·²å”® ${p.sold}</div>
                        <div class="shop-quick-add" onclick="event.stopPropagation();quickAddToCart(${p.id})">+</div>
                    </div>
                </div>
            </div>
        `).join('');
    }

    // åˆ‡æ¢åˆ†ç±»
    window.switchShopCategory = function(cat) {
        currentCategory = cat;
        document.querySelectorAll('.shop-cat-item').forEach(el => {
            el.classList.toggle('active', el.dataset.cat === cat);
        });
        renderProducts(cat);
    };

    // å¿«é€Ÿæ·»åŠ åˆ°è´­ç‰©è½¦
    window.quickAddToCart = function(id) {
        const p = shopProducts.find(x => x.id === id);
        if (!p) return;
        addItemToCart(p, p.specs[0]);
        showCartBadgeAnim();
    };

    function addItemToCart(product, spec) {
        const key = product.id + '_' + spec;
        const exist = shopCart.find(x => x.key === key);
        if (exist) { exist.qty++; } else { shopCart.push({ key, product, spec, qty: 1 }); }
        updateCartBadge();
    }

    // ====== è‡ªå®šä¹‰å•†å“åŠŸèƒ½ ======
    let customProductIdCounter = 90000;

    window.showCustomProductForm = function() {
        document.getElementById('shop-custom-modal').style.display = 'flex';
    };

    window.hideCustomProductForm = function() {
        document.getElementById('shop-custom-modal').style.display = 'none';
    };

    window.addCustomProduct = function() {
        const nameEl = document.getElementById('custom-product-name');
        const catEl = document.getElementById('custom-product-cat');
        const priceEl = document.getElementById('custom-product-price');
        const originEl = document.getElementById('custom-product-origin');
        const specsEl = document.getElementById('custom-product-specs');
        const descEl = document.getElementById('custom-product-desc');
        const qtyEl = document.getElementById('custom-product-qty');

        const name = (nameEl.value || '').trim();
        const cat = catEl.value || 'other';
        const price = parseFloat(priceEl.value);
        const originPrice = parseFloat(originEl.value) || 0;
        const specsStr = (specsEl.value || '').trim();
        const desc = (descEl.value || '').trim();
        const qty = parseInt(qtyEl.value) || 1;

        if (!name) { showToast('è¯·è¾“å…¥å•†å“åç§°'); nameEl.focus(); return; }
        if (!price || price <= 0) { showToast('è¯·è¾“å…¥æœ‰æ•ˆä»·æ ¼'); priceEl.focus(); return; }

        const specs = specsStr ? specsStr.split(/[,ï¼Œã€]/).map(s => s.trim()).filter(s => s) : ['é»˜è®¤'];

        // ç±»åˆ«å¯¹åº”çš„å›¾æ ‡
        const catEmoji = { clothing:'ğŸ‘•', bags:'ğŸ‘œ', shoes:'ğŸ‘Ÿ', beauty:'ğŸ’„', jewelry:'ğŸ’', digital:'ğŸ“±', home:'ğŸ ', other:'ğŸ›’' };

        customProductIdCounter++;
        const product = {
            id: customProductIdCounter,
            name: name,
            cat: cat,
            price: price,
            originPrice: originPrice > 0 ? originPrice : Math.round(price * 1.5),
            desc: desc || 'è‡ªå®šä¹‰å•†å“',
            specs: specs,
            sold: 0,
            emoji: catEmoji[cat] || 'ğŸ›’',
            isCustom: true
        };

        // åŠ å…¥é¢„è®¾å•†å“åˆ—è¡¨ï¼ˆè¿™æ ·åœ¨å•†å“ç½‘æ ¼ä¹Ÿèƒ½çœ‹åˆ°ï¼‰
        shopProducts.push(product);

        // åŠ å…¥è´­ç‰©è½¦ï¼ˆé»˜è®¤ç¬¬ä¸€ä¸ªè§„æ ¼ï¼‰
        for (let i = 0; i < qty; i++) {
            addItemToCart(product, specs[0]);
        }
        showCartBadgeAnim();

        // åˆ·æ–°å•†å“ç½‘æ ¼
        renderProducts(currentCategory);

        // æ¸…ç©ºè¡¨å•
        nameEl.value = '';
        priceEl.value = '';
        originEl.value = '';
        specsEl.value = '';
        descEl.value = '';
        qtyEl.value = '1';

        hideCustomProductForm();
        showToast(`${name} x${qty} å·²åŠ å…¥è´­ç‰©è½¦`);
    };

    function updateCartBadge() {
        const badge = document.getElementById('shop-cart-badge');
        const total = shopCart.reduce((s, x) => s + x.qty, 0);
        if (badge) { badge.textContent = total; badge.style.display = total > 0 ? 'flex' : 'none'; }
    }

    function showCartBadgeAnim() {
        const badge = document.getElementById('shop-cart-badge');
        if (badge) { badge.style.transform = 'scale(1.4)'; setTimeout(() => badge.style.transform = 'scale(1)', 200); }
    }

    // ====== é¡µé¢æ˜¾ç¤º/éšè— ======
    window.showShoppingPage = function() {
        const page = document.getElementById('shopping-page');
        if (page) { page.style.display = 'flex'; page.offsetHeight; page.classList.add('active'); renderProducts(currentCategory); }
    };
    window.hideShoppingPage = function() {
        const page = document.getElementById('shopping-page');
        if (page) { page.classList.remove('active'); setTimeout(() => page.style.display = 'none', 300); }
    };
    window.showShoppingCart = function() {
        const drawer = document.getElementById('shop-cart-drawer');
        if (drawer) { drawer.style.display = 'flex'; renderCartList(); }
    };
    window.hideShoppingCart = function() {
        const drawer = document.getElementById('shop-cart-drawer');
        if (drawer) drawer.style.display = 'none';
    };

    // ====== è´­ç‰©è½¦æ¸²æŸ“ ======
    function renderCartList() {
        const list = document.getElementById('shop-cart-list');
        const totalEl = document.getElementById('shop-total-price');
        if (!list) return;
        if (shopCart.length === 0) {
            list.innerHTML = '<div class="shop-cart-empty">è´­ç‰©è½¦æ˜¯ç©ºçš„</div>';
            if (totalEl) totalEl.textContent = 'Â¥0.00';
            return;
        }
        let total = 0;
        list.innerHTML = shopCart.map((item, idx) => {
            total += item.product.price * item.qty;
            return `<div class="shop-cart-item">
                <div class="shop-cart-item-img"><span>${item.product.emoji}</span></div>
                <div class="shop-cart-item-info">
                    <div class="shop-cart-item-name">${item.product.name}</div>
                    <div class="shop-cart-item-spec">${item.spec}</div>
                    <div class="shop-cart-item-price">Â¥${item.product.price.toFixed(2)}</div>
                </div>
                <div class="shop-cart-qty">
                    <div class="shop-qty-btn" onclick="changeCartQty(${idx},-1)">âˆ’</div>
                    <div class="shop-qty-num">${item.qty}</div>
                    <div class="shop-qty-btn" onclick="changeCartQty(${idx},1)">+</div>
                </div>
            </div>`;
        }).join('');
        if (totalEl) totalEl.textContent = 'Â¥' + total.toFixed(2);
    }

    window.changeCartQty = function(idx, delta) {
        if (!shopCart[idx]) return;
        shopCart[idx].qty += delta;
        if (shopCart[idx].qty <= 0) shopCart.splice(idx, 1);
        updateCartBadge();
        renderCartList();
    };
    window.clearShoppingCart = function() { shopCart = []; updateCartBadge(); renderCartList(); };

    // ====== å•†å“è¯¦æƒ… ======
    window.openShopDetail = function(id) {
        const p = shopProducts.find(x => x.id === id);
        if (!p) return;
        currentDetailProduct = p;
        currentSpec = p.specs[0];
        document.getElementById('shop-detail-img').innerHTML = '<span style="font-size:80px;">' + p.emoji + '</span>';
        document.getElementById('shop-detail-name').textContent = p.name;
        document.getElementById('shop-detail-desc').textContent = p.desc;
        document.getElementById('shop-detail-price').textContent = 'Â¥' + p.price.toFixed(2);
        document.getElementById('shop-spec-options').innerHTML = p.specs.map((s, i) =>
            `<div class="shop-spec-btn ${i===0?'active':''}" onclick="selectShopSpec(this,'${s}')">${s}</div>`
        ).join('');
        document.getElementById('shop-detail-modal').style.display = 'flex';
    };
    window.selectShopSpec = function(el, spec) {
        currentSpec = spec;
        el.parentElement.querySelectorAll('.shop-spec-btn').forEach(b => b.classList.remove('active'));
        el.classList.add('active');
    };
    window.closeShopDetail = function() { document.getElementById('shop-detail-modal').style.display = 'none'; };
    window.addToCartFromDetail = function() {
        if (!currentDetailProduct) return;
        addItemToCart(currentDetailProduct, currentSpec);
        showCartBadgeAnim();
        closeShopDetail();
    };

    // ====== ç»“ç®—é¡µé¢ ======
    window.showCheckoutPage = function() {
        if (shopCart.length === 0) return;
        hideShoppingCart();
        currentInstallment = 0;
        selectedFriendForPay = null;
        selectedFamilyCard = null;
        selectedBuyForFriend = null;

        // é‡ç½®é€ç»™è°
        document.getElementById('shop-buyfor-self')?.classList.add('active');
        document.getElementById('shop-buyfor-friend-btn')?.classList.remove('active');
        document.getElementById('shop-buyfor-selected').style.display = 'none';
        document.getElementById('shop-buyfor-reset').style.display = 'none';

        const itemsEl = document.getElementById('shop-checkout-items');
        let subtotal = 0;
        if (itemsEl) {
            itemsEl.innerHTML = shopCart.map(item => {
                subtotal += item.product.price * item.qty;
                return `<div class="shop-checkout-item">
                    <div class="shop-checkout-item-img"><span>${item.product.emoji}</span></div>
                    <div class="shop-checkout-item-info">
                        <div class="shop-checkout-item-name">${item.product.name}</div>
                        <div class="shop-checkout-item-spec">è§„æ ¼ï¼š${item.spec}</div>
                    </div>
                    <div class="shop-checkout-item-right">
                        <div class="shop-checkout-item-price">Â¥${item.product.price.toFixed(2)}</div>
                        <div class="shop-checkout-item-qty">Ã—${item.qty}</div>
                    </div>
                </div>`;
            }).join('');
        }

        updateCheckoutSummary(subtotal);

        // åˆ†æœŸæè¿°
        const i3 = document.getElementById('inst-3-desc');
        const i6 = document.getElementById('inst-6-desc');
        const i12 = document.getElementById('inst-12-desc');
        if (i3) i3.textContent = 'Â¥' + (subtotal / 3).toFixed(2) + '/æœŸ';
        if (i6) i6.textContent = 'Â¥' + ((subtotal * 1.005) / 6).toFixed(2) + '/æœŸ';
        if (i12) i12.textContent = 'Â¥' + ((subtotal * 1.01) / 12).toFixed(2) + '/æœŸ';

        // é‡ç½®é€‰é¡¹
        document.querySelectorAll('.shop-inst-item').forEach(el => el.classList.remove('active'));
        const first = document.querySelector('.shop-inst-item[data-inst="0"]');
        if (first) first.classList.add('active');

        // é‡ç½®ä»˜æ¬¾æ–¹å¼ä¸ºé’±åŒ…
        const walletRadio = document.querySelector('input[name="payMethod"][value="wallet"]');
        if (walletRadio) walletRadio.checked = true;

        // æ¸…é™¤å·²é€‰å¥½å‹/äº²å±å¡çš„æç¤º
        const existFriendInfo = document.getElementById('shop-selected-friend-info');
        if (existFriendInfo) existFriendInfo.remove();
        const existFcInfo = document.getElementById('shop-selected-fc-info');
        if (existFcInfo) existFcInfo.remove();

        document.getElementById('shop-checkout-page').style.display = 'flex';
    };

    function updateCheckoutSummary(subtotal) {
        if (subtotal === undefined) subtotal = shopCart.reduce((s, x) => s + x.product.price * x.qty, 0);
        let fee = 0;
        if (currentInstallment === 6) fee = subtotal * 0.005;
        else if (currentInstallment === 12) fee = subtotal * 0.01;
        const total = subtotal + fee;

        const subEl = document.getElementById('checkout-subtotal');
        const feeEl = document.getElementById('checkout-fee');
        const totalEl = document.getElementById('checkout-total');
        const finalEl = document.getElementById('checkout-final-price');
        const instInfo = document.getElementById('checkout-installment-info');
        const perPeriod = document.getElementById('checkout-per-period');

        if (subEl) subEl.textContent = 'Â¥' + subtotal.toFixed(2);
        if (feeEl) feeEl.textContent = 'Â¥' + fee.toFixed(2);
        if (totalEl) totalEl.textContent = 'Â¥' + total.toFixed(2);
        if (finalEl) finalEl.textContent = 'Â¥' + total.toFixed(2);

        if (currentInstallment > 0 && instInfo && perPeriod) {
            instInfo.style.display = 'block';
            perPeriod.textContent = 'Â¥' + (total / currentInstallment).toFixed(2);
        } else if (instInfo) {
            instInfo.style.display = 'none';
        }
    }

    window.hideCheckoutPage = function() { document.getElementById('shop-checkout-page').style.display = 'none'; };
    window.selectInstallment = function(n) {
        currentInstallment = n;
        document.querySelectorAll('.shop-inst-item').forEach(el => { el.classList.toggle('active', parseInt(el.dataset.inst) === n); });
        updateCheckoutSummary();
    };

    // ====== é€ç»™è°ï¼ˆä¸ºè°è´­ä¹°ï¼‰ ======
    window.selectBuyForSelf = function() {
        selectedBuyForFriend = null;
        document.getElementById('shop-buyfor-self')?.classList.add('active');
        document.getElementById('shop-buyfor-friend-btn')?.classList.remove('active');
        document.getElementById('shop-buyfor-selected').style.display = 'none';
        document.getElementById('shop-buyfor-reset').style.display = 'none';
    };

    window.showBuyForFriendPicker = async function() {
        const picker = document.getElementById('shop-buyfor-picker');
        const list = document.getElementById('shop-buyfor-picker-list');
        picker.style.display = 'flex';
        list.innerHTML = '<div style="text-align:center;padding:30px;color:#ccc;">åŠ è½½å¥½å‹åˆ—è¡¨...</div>';

        const friends = await getFriendsList();
        if (friends.length === 0) {
            list.innerHTML = '<div style="text-align:center;padding:40px;color:#bbb;">æš‚æ— å¥½å‹</div>';
            return;
        }

        list.innerHTML = friends.map(f => {
            const avatarStyle = f.avatar ? `background-image:url(${f.avatar})` : 'background:#e0e0e0';
            return `<div class="shop-friend-item" data-fid="${f.id}" onclick="selectBuyForFriend(${f.id}, this)">
                <div class="shop-friend-avatar" style="${avatarStyle}"></div>
                <div class="shop-friend-name">${f.name}</div>
                <div class="shop-friend-select-icon">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="3"><polyline points="20 6 9 17 4 12"></polyline></svg>
                </div>
            </div>`;
        }).join('') + '<div class="shop-friend-confirm-btn" onclick="confirmBuyForFriend()">ç¡®è®¤é€‰æ‹©</div>';
    };

    window.selectBuyForFriend = function(id, el) {
        document.querySelectorAll('#shop-buyfor-picker-list .shop-friend-item').forEach(e => e.classList.remove('selected'));
        el.classList.add('selected');
        selectedBuyForFriend = id;
    };

    window.hideBuyForPicker = function() {
        document.getElementById('shop-buyfor-picker').style.display = 'none';
    };

    window.confirmBuyForFriend = async function() {
        if (!selectedBuyForFriend) { showToast('è¯·å…ˆé€‰æ‹©ä¸€ä½å¥½å‹'); return; }
        const friend = await db.characters.get(selectedBuyForFriend);
        if (!friend) { showToast('å¥½å‹ä¸å­˜åœ¨'); return; }

        hideBuyForPicker();

        // æ›´æ–°UI
        document.getElementById('shop-buyfor-self')?.classList.remove('active');
        document.getElementById('shop-buyfor-friend-btn')?.classList.add('active');

        const selectedDiv = document.getElementById('shop-buyfor-selected');
        const avatarDiv = document.getElementById('shop-buyfor-avatar');
        const nameSpan = document.getElementById('shop-buyfor-name');
        if (selectedDiv) selectedDiv.style.display = 'flex';
        if (avatarDiv) avatarDiv.style = friend.avatar ? `background-image:url(${friend.avatar})` : 'background:#e0e0e0';
        if (nameSpan) nameSpan.textContent = friend.name;
        document.getElementById('shop-buyfor-reset').style.display = 'inline';

        showToast('å·²é€‰æ‹©é€ç»™ ' + friend.name);
    };

    window.resetBuyFor = function() {
        selectBuyForSelf();
    };

    // ====== æ‰¾æœ‹å‹ä»£ä»˜ ======
    window.showShopFriendPicker = async function() {
        const picker = document.getElementById('shop-friend-picker');
        const list = document.getElementById('shop-friend-picker-list');
        picker.style.display = 'flex';
        list.innerHTML = '<div style="text-align:center;padding:30px;color:#ccc;">åŠ è½½å¥½å‹åˆ—è¡¨...</div>';

        const friends = await getFriendsList();
        if (friends.length === 0) {
            list.innerHTML = '<div style="text-align:center;padding:40px;color:#bbb;">æš‚æ— å¥½å‹</div>';
            return;
        }

        list.innerHTML = friends.map(f => {
            const avatarStyle = f.avatar ? `background-image:url(${f.avatar})` : 'background:#e0e0e0';
            return `<div class="shop-friend-item" data-fid="${f.id}" onclick="selectShopFriend(${f.id}, this)">
                <div class="shop-friend-avatar" style="${avatarStyle}"></div>
                <div class="shop-friend-name">${f.name}</div>
                <div class="shop-friend-select-icon">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="3"><polyline points="20 6 9 17 4 12"></polyline></svg>
                </div>
            </div>`;
        }).join('') + '<div class="shop-friend-confirm-btn" onclick="confirmShopFriendPay()">ç¡®è®¤é€‰æ‹©</div>';
    };

    window.selectShopFriend = function(id, el) {
        document.querySelectorAll('.shop-friend-item').forEach(e => e.classList.remove('selected'));
        el.classList.add('selected');
        selectedFriendForPay = id;
    };

    window.hideShopFriendPicker = function() {
        document.getElementById('shop-friend-picker').style.display = 'none';
    };

    window.confirmShopFriendPay = async function() {
        if (!selectedFriendForPay) { showToast('è¯·å…ˆé€‰æ‹©ä¸€ä½å¥½å‹'); return; }
        const friend = await db.characters.get(selectedFriendForPay);
        if (!friend) { showToast('å¥½å‹ä¸å­˜åœ¨'); return; }

        hideShopFriendPicker();

        // æ˜¾ç¤ºå·²é€‰å¥½å‹ä¿¡æ¯
        const existInfo = document.getElementById('shop-selected-friend-info');
        if (existInfo) existInfo.remove();
        const paySection = document.querySelector('.shop-pay-options');
        if (paySection) {
            const div = document.createElement('div');
            div.id = 'shop-selected-friend-info';
            div.className = 'shop-pay-selected-friend';
            const avatarStyle = friend.avatar ? `background-image:url(${friend.avatar})` : 'background:#e0e0e0';
            div.innerHTML = `<div class="shop-pay-selected-avatar" style="${avatarStyle}"></div>
                <span>å·²é€‰æ‹© <b>${friend.name}</b> ä»£ä»˜</span>`;
            paySection.parentElement.appendChild(div);
        }
        showToast('å·²é€‰æ‹© ' + friend.name + ' ä»£ä»˜');
    };

    // ç›‘å¬ä»˜æ¬¾æ–¹å¼radioå˜åŒ–
    document.addEventListener('change', function(e) {
        if (e.target.name === 'payMethod') {
            // æ¸…é™¤å·²é€‰ä¿¡æ¯
            const existFriendInfo = document.getElementById('shop-selected-friend-info');
            if (existFriendInfo) existFriendInfo.remove();
            const existFcInfo = document.getElementById('shop-selected-fc-info');
            if (existFcInfo) existFcInfo.remove();
            selectedFriendForPay = null;
            selectedFamilyCard = null;

            if (e.target.value === 'friend') {
                showShopFriendPicker();
            } else if (e.target.value === 'family') {
                showShopFamilyCardPicker();
            }
        }
    });

    // ====== äº²å±å¡æ”¯ä»˜ ======
    window.showShopFamilyCardPicker = async function() {
        const picker = document.getElementById('shop-family-card-picker');
        const list = document.getElementById('shop-family-card-list');
        picker.style.display = 'flex';
        list.innerHTML = '<div style="text-align:center;padding:30px;color:#ccc;">æ£€æµ‹äº²å±å¡...</div>';

        const cards = await getReceivedFamilyCards();
        if (cards.length === 0) {
            list.innerHTML = `<div class="shop-fc-empty">
                <div style="margin-bottom:12px;"><svg width="40" height="40" fill="none" stroke="#ccc" stroke-width="1.5" viewBox="0 0 24 24"><rect x="2" y="5" width="20" height="14" rx="2"/><path d="M2 10h20"/></svg></div>
                <div>æš‚æœªæ”¶åˆ°äº²å±å¡</div>
                <div style="font-size:12px;margin-top:6px;color:#ccc;">å¥½å‹å¯ä»¥åœ¨èŠå¤©ä¸­å‘ä½ èµ é€äº²å±å¡</div>
            </div>`;
            return;
        }

        list.innerHTML = cards.map((c, i) => {
            const avatarStyle = c.avatar ? `background-image:url(${c.avatar})` : 'background:#e0e0e0';
            const limitText = c.monthlyLimit > 0 ? `æœˆé¢åº¦ Â¥${c.monthlyLimit}` : 'ä¸é™é¢åº¦';
            const remain = c.monthlyLimit > 0 ? `å‰©ä½™ Â¥${(c.monthlyLimit - c.usedThisMonth).toFixed(2)}` : 'æ— é™åˆ¶';
            return `<div class="shop-fc-item" data-idx="${i}" onclick="selectShopFamilyCard(${i}, this)">
                <div class="shop-fc-avatar" style="${avatarStyle}"></div>
                <div class="shop-fc-info">
                    <div class="shop-fc-name">${c.name} çš„äº²å±å¡</div>
                    <div class="shop-fc-limit">${limitText}</div>
                    <div class="shop-fc-remain">${remain}</div>
                </div>
                <div class="shop-fc-check">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="3"><polyline points="20 6 9 17 4 12"></polyline></svg>
                </div>
            </div>`;
        }).join('') + '<div class="shop-friend-confirm-btn" onclick="confirmShopFamilyCard()">ä½¿ç”¨æ­¤äº²å±å¡</div>';

        // ä¿å­˜cardsä¾›é€‰æ‹©ä½¿ç”¨
        window._shopFamilyCards = cards;
    };

    window.selectShopFamilyCard = function(idx, el) {
        document.querySelectorAll('.shop-fc-item').forEach(e => e.classList.remove('selected'));
        el.classList.add('selected');
        selectedFamilyCard = window._shopFamilyCards?.[idx] || null;
    };

    window.hideShopFamilyCardPicker = function() {
        document.getElementById('shop-family-card-picker').style.display = 'none';
    };

    window.confirmShopFamilyCard = function() {
        if (!selectedFamilyCard) { showToast('è¯·é€‰æ‹©ä¸€å¼ äº²å±å¡'); return; }

        // æ£€æŸ¥é¢åº¦
        const subtotal = shopCart.reduce((s, x) => s + x.product.price * x.qty, 0);
        if (selectedFamilyCard.monthlyLimit > 0) {
            const remain = selectedFamilyCard.monthlyLimit - selectedFamilyCard.usedThisMonth;
            if (subtotal > remain) {
                showToast('äº²å±å¡æœ¬æœˆé¢åº¦ä¸è¶³ï¼ˆå‰©ä½™Â¥' + remain.toFixed(2) + 'ï¼‰');
                return;
            }
        }

        hideShopFamilyCardPicker();

        // æ˜¾ç¤ºå·²é€‰äº²å±å¡
        const existInfo = document.getElementById('shop-selected-fc-info');
        if (existInfo) existInfo.remove();
        const paySection = document.querySelector('.shop-pay-options');
        if (paySection) {
            const div = document.createElement('div');
            div.id = 'shop-selected-fc-info';
            div.className = 'shop-pay-selected-fc';
            div.innerHTML = `ä½¿ç”¨ <b>${selectedFamilyCard.name}</b> çš„äº²å±å¡æ”¯ä»˜`;
            paySection.parentElement.appendChild(div);
        }
        showToast('å·²é€‰æ‹© ' + selectedFamilyCard.name + ' çš„äº²å±å¡');
    };

    // ====== åˆ†æœŸä»˜æ¬¾ç®¡ç† ======
    function getInstallmentPlans() {
        try { return JSON.parse(localStorage.getItem(SHOP_INST_KEY) || '[]'); } catch(e) { return []; }
    }
    function saveInstallmentPlans(plans) {
        localStorage.setItem(SHOP_INST_KEY, JSON.stringify(plans));
        saveFinanceData(SHOP_INST_KEY, plans).catch(e => console.warn('[Finance] installmentPlanså¤‡ä»½å¤±è´¥:', e));
    }

    // åˆ›å»ºåˆ†æœŸè®¡åˆ’
    function createInstallmentPlan(totalAmount, periods, items) {
        const perPeriod = parseFloat((totalAmount / periods).toFixed(2));
        const plan = {
            id: 'inst_' + Date.now(),
            totalAmount,
            periods,
            perPeriod,
            paidPeriods: 1, // ç¬¬ä¸€æœŸç«‹å³æ‰£
            paidAmount: perPeriod,
            items: items.map(x => x.product.name).join('ã€'),
            createdAt: Date.now(),
            nextDeductAt: Date.now() + 86400000, // 1å¤©åæ‰£ç¬¬äºŒæœŸï¼ˆä¸€å¤©ä¸€æœŸï¼‰
            status: 'active'
        };
        const plans = getInstallmentPlans();
        plans.push(plan);
        saveInstallmentPlans(plans);
        startInstallmentTimer();
        return plan;
    }

    // ä»ä½™é¢æ‰£æ¬¾
    async function deductBalance(amount, desc) {
        const charId = getMyCharId();
        if (!charId) return false;
        const user = await db.characters.get(parseInt(charId));
        if (!user || !user.identity) return false;
        let balance = parseFloat(user.identity.balance || 0);
        balance -= amount;
        user.identity.balance = balance.toFixed(2);
        await safeCharacterPut(user);
        console.log('[è´­ç‰©åˆ†æœŸ] æ‰£æ¬¾æˆåŠŸ: Â¥' + amount.toFixed(2) + ' | ä½™é¢: Â¥' + balance.toFixed(2) + ' | ' + desc);
        return true;
    }

    // åˆ†æœŸå®šæ—¶å™¨
    let instTimer = null;
    function startInstallmentTimer() {
        if (instTimer) return; // å·²åœ¨è¿è¡Œ
        instTimer = setInterval(async () => {
            const plans = getInstallmentPlans();
            let changed = false;
            const now = Date.now();

            for (const plan of plans) {
                if (plan.status !== 'active') continue;
                if (plan.paidPeriods >= plan.periods) {
                    plan.status = 'completed';
                    changed = true;
                    continue;
                }
                if (now >= plan.nextDeductAt) {
                    // æ‰£æ¬¾
                    const success = await deductBalance(plan.perPeriod, `åˆ†æœŸä»˜æ¬¾ ç¬¬${plan.paidPeriods + 1}/${plan.periods}æœŸ`);
                    if (success) {
                        plan.paidPeriods++;
                        plan.paidAmount = parseFloat((plan.paidAmount + plan.perPeriod).toFixed(2));
                        plan.nextDeductAt = now + 86400000; // æ¯å¤©ä¸€æœŸ
                        if (plan.paidPeriods >= plan.periods) {
                            plan.status = 'completed';
                        }
                        changed = true;
                        showToast(`åˆ†æœŸæ‰£æ¬¾ Â¥${plan.perPeriod.toFixed(2)} (${plan.paidPeriods}/${plan.periods}æœŸ)`);
                    }
                }
            }

            if (changed) saveInstallmentPlans(plans);

            // å¦‚æœæ‰€æœ‰è®¡åˆ’éƒ½å®Œæˆäº†ï¼Œåœæ­¢å®šæ—¶å™¨
            const hasActive = plans.some(p => p.status === 'active');
            if (!hasActive && instTimer) {
                clearInterval(instTimer);
                instTimer = null;
            }
        }, 60000); // æ¯60ç§’æ£€æŸ¥ä¸€æ¬¡ï¼ˆä¸€å¤©ä¸€æœŸï¼‰
    }

    // é¡µé¢åŠ è½½æ—¶æ¢å¤å®šæ—¶å™¨
    const existingPlans = getInstallmentPlans();
    if (existingPlans.some(p => p.status === 'active')) {
        startInstallmentTimer();
    }

    // æŸ¥çœ‹åˆ†æœŸè¯¦æƒ…
    window.showInstallmentMgr = function() {
        const mgr = document.getElementById('shop-installment-mgr');
        const list = document.getElementById('shop-installment-mgr-list');
        const plans = getInstallmentPlans();

        if (plans.length === 0) {
            list.innerHTML = '<div style="text-align:center;padding:40px;color:#bbb;">æš‚æ— åˆ†æœŸè®°å½•</div>';
        } else {
            list.innerHTML = plans.slice().reverse().map(plan => {
                let dots = '';
                for (let i = 0; i < plan.periods; i++) {
                    if (i < plan.paidPeriods) dots += '<div class="shop-inst-dot paid"></div>';
                    else if (i === plan.paidPeriods) dots += '<div class="shop-inst-dot current"></div>';
                    else dots += '<div class="shop-inst-dot"></div>';
                }
                const statusCls = plan.status === 'active' ? 'active' : 'done';
                const statusText = plan.status === 'active' ? 'è¿˜æ¬¾ä¸­' : 'å·²ç»“æ¸…';
                return `<div class="shop-inst-record">
                    <div class="shop-inst-record-header">
                        <div class="shop-inst-record-title">${plan.periods}æœŸåˆ†æœŸ</div>
                        <div class="shop-inst-record-status ${statusCls}">${statusText}</div>
                    </div>
                    <div class="shop-inst-progress">${dots}</div>
                    <div class="shop-inst-record-info">
                        å•†å“ï¼š${plan.items}<br>
                        æ€»é¢ï¼šÂ¥${plan.totalAmount.toFixed(2)} | æ¯æœŸï¼šÂ¥${plan.perPeriod.toFixed(2)}<br>
                        å·²ä»˜ï¼š${plan.paidPeriods}/${plan.periods}æœŸ (Â¥${plan.paidAmount.toFixed(2)})
                    </div>
                </div>`;
            }).join('');
        }
        mgr.style.display = 'flex';
    };
    window.hideInstallmentMgr = function() { document.getElementById('shop-installment-mgr').style.display = 'none'; };

    // ====== æ„å»ºä»£ä»˜è¯·æ±‚å¡ç‰‡æ•°æ® ======
    function buildPayRequestCardData(amount, items, buyForName, installmentInfo) {
        return {
            amount: amount.toFixed(2),
            items: items,
            buyForName: buyForName || '',
            installmentInfo: installmentInfo || '',
            status: 'pending'
        };
    }

    // å‘é€ä»£ä»˜è¯·æ±‚å¡ç‰‡åˆ°å¥½å‹èŠå¤©
    async function sendPayRequestCard(friendId, cardData) {
        const accountId = getMyCharId();
        const freshFriend = await db.characters.get(friendId);
        if (!freshFriend) return;

        const msg = {
            role: 'user',
            type: 'shopPayRequest',
            content: JSON.stringify(cardData),
            time: Date.now()
        };

        let history = _getChatHistory(freshFriend, accountId);
        history.push(msg);
        await _setChatHistory(freshFriend, accountId, history);

        // ç›´æ¥è¿½åŠ åˆ°èŠå¤©DOMï¼ˆä¸åˆ·æ–°é¡µé¢ï¼‰
        if (window._appendShopCardToChat) {
            await window._appendShopCardToChat(friendId, msg);
        }
    }

    // å‘é€è´­ç‰©é€šçŸ¥å¡ç‰‡ç»™è¢«èµ é€çš„å¥½å‹
    async function sendGiftNotifyCard(friendId, cardData) {
        const accountId = getMyCharId();
        const freshFriend = await db.characters.get(friendId);
        if (!freshFriend) return;

        const msg = {
            role: 'user',
            type: 'shopPayRequest',
            content: JSON.stringify({
                ...cardData,
                isGift: true,
                status: 'paid'
            }),
            time: Date.now()
        };

        let history = _getChatHistory(freshFriend, accountId);
        history.push(msg);
        await _setChatHistory(freshFriend, accountId, history);

        // ç›´æ¥è¿½åŠ åˆ°èŠå¤©DOMï¼ˆä¸åˆ·æ–°é¡µé¢ï¼‰
        if (window._appendShopCardToChat) {
            await window._appendShopCardToChat(friendId, msg);
        }
    }

    // å‘é€è´­ç‰©åˆ†äº«å¡ç‰‡ç»™å¥½å‹ï¼ˆä¹°ç»™è‡ªå·±æ—¶åˆ†äº«ï¼‰
    async function sendShareCard(friendId, cardData) {
        const accountId = getMyCharId();
        const freshFriend = await db.characters.get(friendId);
        if (!freshFriend) return;

        const msg = {
            role: 'user',
            type: 'shopPayRequest',
            content: JSON.stringify({
                ...cardData,
                isShare: true,
                status: 'paid'
            }),
            time: Date.now()
        };

        let history = _getChatHistory(freshFriend, accountId);
        history.push(msg);
        await _setChatHistory(freshFriend, accountId, history);

        // ç›´æ¥è¿½åŠ åˆ°èŠå¤©DOMï¼ˆä¸åˆ·æ–°é¡µé¢ï¼‰
        if (window._appendShopCardToChat) {
            await window._appendShopCardToChat(friendId, msg);
        }
    }

    // ====== æäº¤è®¢å• ======
    window.submitShopOrder = async function() {
        const subtotal = shopCart.reduce((s, x) => s + x.product.price * x.qty, 0);
        let fee = 0;
        if (currentInstallment === 6) fee = subtotal * 0.005;
        else if (currentInstallment === 12) fee = subtotal * 0.01;
        const finalAmount = subtotal + fee;

        const payMethod = document.querySelector('input[name="payMethod"]:checked')?.value || 'wallet';
        const itemNames = shopCart.map(x => x.product.name).join('ã€');

        // è·å–"é€ç»™è°"çš„å¥½å‹åå­—
        let buyForName = '';
        let buyForFriend = null;
        if (selectedBuyForFriend) {
            buyForFriend = await db.characters.get(selectedBuyForFriend);
            buyForName = buyForFriend ? buyForFriend.name : '';
        }

        // åˆ†æœŸä¿¡æ¯
        let installmentInfo = '';
        if (currentInstallment > 0) {
            const perPeriod = (finalAmount / currentInstallment).toFixed(2);
            installmentInfo = `åˆ†${currentInstallment}æœŸ Â· æ¯å¤© Â¥${perPeriod}`;
        }

        // ä¿å­˜è®¢å•å¡ç‰‡æ•°æ®ä¾›åˆ†äº«ä½¿ç”¨
        lastOrderCardData = buildPayRequestCardData(finalAmount, itemNames, buyForName, installmentInfo);

        // ====== å¤„ç†ä¸åŒä»˜æ¬¾æ–¹å¼ ======
        if (payMethod === 'friend') {
            // ä»£ä»˜ - éœ€è¦å·²é€‰å¥½å‹
            if (!selectedFriendForPay) { showToast('è¯·å…ˆé€‰æ‹©ä»£ä»˜å¥½å‹'); showShopFriendPicker(); return; }
            const friend = await db.characters.get(selectedFriendForPay);
            if (!friend) { showToast('å¥½å‹ä¸å­˜åœ¨'); return; }

            // æ„å»ºä»£ä»˜è¯·æ±‚å¡ç‰‡
            const cardData = buildPayRequestCardData(finalAmount, itemNames, buyForName, installmentInfo);

            // å‘é€ä»£ä»˜è¯·æ±‚å¡ç‰‡åˆ°ä»£ä»˜å¥½å‹çš„èŠå¤©
            await sendPayRequestCard(friend.id, cardData);

            // å¦‚æœè¿˜é€‰äº†"é€ç»™è°"ï¼Œä¹Ÿå‘ä¸€å¼ é€šçŸ¥å¡ç‰‡ç»™è¢«èµ é€çš„å¥½å‹
            if (buyForFriend && buyForFriend.id !== friend.id) {
                await sendGiftNotifyCard(buyForFriend.id, cardData);
            }

            let successMsg = `å·²å‘ ${friend.name} å‘é€ä»£ä»˜è¯·æ±‚\né‡‘é¢ Â¥${finalAmount.toFixed(2)}`;
            if (buyForName) successMsg += `\né€ç»™ï¼š${buyForName}`;
            if (installmentInfo) successMsg += `\n${installmentInfo}`;
            showPaySuccess(finalAmount, successMsg);

        } else if (payMethod === 'family') {
            // äº²å±å¡æ”¯ä»˜
            if (!selectedFamilyCard) { showToast('è¯·å…ˆé€‰æ‹©äº²å±å¡'); showShopFamilyCardPicker(); return; }

            // æ£€æŸ¥é¢åº¦
            if (selectedFamilyCard.monthlyLimit > 0) {
                const remain = selectedFamilyCard.monthlyLimit - selectedFamilyCard.usedThisMonth;
                if (finalAmount > remain) {
                    showToast('äº²å±å¡é¢åº¦ä¸è¶³');
                    return;
                }
            }

            // æ›´æ–°äº²å±å¡ä½¿ç”¨é¢åº¦
            const accountId = getMyCharId();
            if (accountId) {
                const user = await db.characters.get(parseInt(accountId));
                if (user && user.identity && user.identity.familyCardsReceived) {
                    const card = user.identity.familyCardsReceived.find(c => c.charId === selectedFamilyCard.charId);
                    if (card) {
                        card.usedThisMonth = (card.usedThisMonth || 0) + finalAmount;
                        if (!card.records) card.records = [];
                        card.records.push({ amount: finalAmount, desc: 'è´­ç‰©æ¶ˆè´¹', time: Date.now() });
                        await safeCharacterPut(user);
                    }
                }
            }

            // å¦‚æœé€‰äº†"é€ç»™è°"ï¼Œå‘é€šçŸ¥å¡ç‰‡ç»™è¢«èµ é€çš„å¥½å‹
            if (buyForFriend) {
                const cardData = buildPayRequestCardData(finalAmount, itemNames, buyForName, installmentInfo);
                cardData.payMethod = 'äº²å±å¡ï¼ˆ' + selectedFamilyCard.name + 'ï¼‰';
                await sendGiftNotifyCard(buyForFriend.id, cardData);
            }

            let successMsg = `å·²ä½¿ç”¨ ${selectedFamilyCard.name} çš„äº²å±å¡æ”¯ä»˜`;
            if (buyForName) successMsg += `\né€ç»™ï¼š${buyForName}`;
            showPaySuccess(finalAmount, successMsg);

        } else {
            // é›¶é’±æ”¯ä»˜
            if (currentInstallment > 0) {
                // åˆ†æœŸä»˜æ¬¾ - ç¬¬ä¸€æœŸç«‹å³æ‰£
                const plan = createInstallmentPlan(finalAmount, currentInstallment, shopCart);
                await deductBalance(plan.perPeriod, `åˆ†æœŸä»˜æ¬¾ ç¬¬1/${currentInstallment}æœŸ`);

                // å¦‚æœé€‰äº†"é€ç»™è°"ï¼Œå‘é€šçŸ¥å¡ç‰‡ç»™è¢«èµ é€çš„å¥½å‹
                if (buyForFriend) {
                    const cardData = buildPayRequestCardData(finalAmount, itemNames, buyForName, installmentInfo);
                    cardData.payMethod = 'åˆ†æœŸä»˜æ¬¾';
                    await sendGiftNotifyCard(buyForFriend.id, cardData);
                }

                let successMsg = `åˆ†æœŸ ${currentInstallment} æœŸ\né¦–æœŸå·²æ‰£ Â¥${plan.perPeriod.toFixed(2)}\næ¯å¤©è‡ªåŠ¨æ‰£æ¬¾ä¸€æœŸ`;
                if (buyForName) successMsg += `\né€ç»™ï¼š${buyForName}`;
                showPaySuccess(finalAmount, successMsg, true);
            } else {
                // å…¨é¢æ”¯ä»˜
                await deductBalance(finalAmount, 'è´­ç‰©æ¶ˆè´¹');

                // å¦‚æœé€‰äº†"é€ç»™è°"ï¼Œå‘é€šçŸ¥å¡ç‰‡ç»™è¢«èµ é€çš„å¥½å‹
                if (buyForFriend) {
                    const cardData = buildPayRequestCardData(finalAmount, itemNames, buyForName, '');
                    cardData.payMethod = 'é›¶é’±æ”¯ä»˜';
                    await sendGiftNotifyCard(buyForFriend.id, cardData);
                }

                let successMsg = '';
                if (buyForName) successMsg = `é€ç»™ï¼š${buyForName}`;
                showPaySuccess(finalAmount, successMsg || undefined);
            }
        }

        // æ¸…ç©ºè´­ç‰©è½¦
        shopCart = [];
        updateCartBadge();
    };

    // ====== åˆ†äº«è´­ç‰©å¡ç‰‡ç»™å¥½å‹ ======
    let lastOrderCardData = null; // ä¿å­˜æœ€åä¸€æ¬¡è®¢å•å¡ç‰‡æ•°æ®ä¾›åˆ†äº«ä½¿ç”¨

    window.showShareToPicker = async function() {
        const picker = document.getElementById('shop-share-picker');
        const list = document.getElementById('shop-share-picker-list');
        picker.style.display = 'flex';
        list.innerHTML = '<div style="text-align:center;padding:30px;color:#ccc;">åŠ è½½å¥½å‹åˆ—è¡¨...</div>';

        const friends = await getFriendsList();
        if (friends.length === 0) {
            list.innerHTML = '<div style="text-align:center;padding:40px;color:#bbb;">æš‚æ— å¥½å‹</div>';
            return;
        }

        list.innerHTML = friends.map(f => {
            const avatarStyle = f.avatar ? `background-image:url(${f.avatar})` : 'background:#e0e0e0';
            return `<div class="shop-friend-item" data-fid="${f.id}" onclick="confirmShareTo(${f.id})">
                <div class="shop-friend-avatar" style="${avatarStyle}"></div>
                <div class="shop-friend-name">${f.name}</div>
                <svg width="14" height="14" stroke="#ccc" stroke-width="2" fill="none" viewBox="0 0 24 24"><path d="M9 18l6-6-6-6"/></svg>
            </div>`;
        }).join('');
    };

    window.hideSharePicker = function() {
        document.getElementById('shop-share-picker').style.display = 'none';
    };

    window.confirmShareTo = async function(friendId) {
        if (!lastOrderCardData) { showToast('æ— å¯åˆ†äº«çš„è®¢å•'); return; }
        const friend = await db.characters.get(friendId);
        if (!friend) { showToast('å¥½å‹ä¸å­˜åœ¨'); return; }

        await sendShareCard(friendId, lastOrderCardData);
        hideSharePicker();
        showToast('å·²åˆ†äº«ç»™ ' + friend.name);
    };

    function showPaySuccess(amount, extraInfo, isInstallment) {
        const modal = document.getElementById('shop-success-modal');
        const amountEl = document.getElementById('shop-success-amount');
        const instInfoEl = document.getElementById('shop-success-inst-info');

        if (amountEl) amountEl.textContent = 'Â¥' + amount.toFixed(2);
        if (extraInfo && instInfoEl) {
            instInfoEl.style.display = 'block';
            instInfoEl.textContent = extraInfo;
        } else if (instInfoEl) {
            instInfoEl.style.display = 'none';
        }
        if (modal) modal.style.display = 'flex';
    }

    window.closeShopSuccess = function() {
        document.getElementById('shop-success-modal').style.display = 'none';
        hideCheckoutPage();
    };
})();

// ===================================================================
// ===== äº²å¯†ç©ºé—´åŠŸèƒ½ =====
// ===================================================================
(function() {
    'use strict';

    // --- å¸¸é‡ ---
    const INTIMATE_TYPES = {
        couple: { name: 'æƒ…ä¾£', emoji: 'ğŸ’•', color: '#e8b4c8', gradient: 'linear-gradient(135deg, #FFF7FA 0%, #FFEEF4 100%)' },
        bestie: { name: 'é—ºèœœ', emoji: 'âœ¨', color: '#c4b0d9', gradient: 'linear-gradient(135deg, #F8F5FF 0%, #F0EAFF 100%)' },
        bro:    { name: 'åŸºå‹', emoji: 'ğŸ¤', color: '#a8c8e8', gradient: 'linear-gradient(135deg, #F5F9FF 0%, #EBF3FF 100%)' },
        side:   { name: 'å°ä¸‰', emoji: 'ğŸ”¥', color: '#e0b8a0', gradient: 'linear-gradient(135deg, #FFF8F5 0%, #FFEDE5 100%)' }
    };

    const INTIMATE_LEVELS = {
        couple: [
            { min: 0,  max: 20,  title: 'æš§æ˜§æœŸ' },
            { min: 21, max: 40,  title: 'çƒ­æ‹ä¸­' },
            { min: 41, max: 60,  title: 'ç”œèœœèœœ' },
            { min: 61, max: 80,  title: 'å¦‚èƒ¶ä¼¼æ¼†' },
            { min: 81, max: 100, title: 'ç”Ÿæ­»ç›¸ä¾' }
        ],
        bestie: [
            { min: 0,  max: 20,  title: 'æ–°æœ‹å‹' },
            { min: 21, max: 40,  title: 'å¥½å§å¦¹' },
            { min: 41, max: 60,  title: 'é“é—ºèœœ' },
            { min: 61, max: 80,  title: 'çµé­‚å§å¦¹' },
            { min: 81, max: 100, title: 'ä¸€ç”Ÿé—ºèœœ' }
        ],
        bro: [
            { min: 0,  max: 20,  title: 'æ™®é€šæœ‹å‹' },
            { min: 21, max: 40,  title: 'å¥½å…„å¼Ÿ' },
            { min: 41, max: 60,  title: 'é“å“¥ä»¬' },
            { min: 61, max: 80,  title: 'è¿‡å‘½å…„å¼Ÿ' },
            { min: 81, max: 100, title: 'ç”Ÿæ­»ä¹‹äº¤' }
        ],
        side: [
            { min: 0,  max: 20,  title: 'æš—æµæ¶ŒåŠ¨' },
            { min: 21, max: 40,  title: 'è‹¥å³è‹¥ç¦»' },
            { min: 41, max: 60,  title: 'éš¾èˆéš¾åˆ†' },
            { min: 61, max: 80,  title: 'æ¬²ç½¢ä¸èƒ½' },
            { min: 81, max: 100, title: 'å‘½ä¸­æ³¨å®š' }
        ]
    };

    function getIntimateLevel(type, value) {
        const levels = INTIMATE_LEVELS[type] || INTIMATE_LEVELS.couple;
        for (const lv of levels) {
            if (value >= lv.min && value <= lv.max) return lv.title;
        }
        return levels[0].title;
    }

    function daysBetween(ts1, ts2) {
        return Math.floor(Math.abs(ts2 - ts1) / (1000 * 60 * 60 * 24));
    }

    // ä¸´æ—¶å˜é‡
    let _intimateSelectedType = null;
    let _intimateViewingRelation = null;

    // ===== ä¸»é¡µé€»è¾‘ =====
    window.showIntimateSpacePage = async function() {
        const page = document.getElementById('intimate-space-page');
        page.style.display = 'flex';
        await renderIntimateSpaceMain();
    };

    window.hideIntimateSpacePage = function() {
        const page = document.getElementById('intimate-space-page');
        page.style.display = 'none';
    };

    window.renderIntimateSpaceMain = renderIntimateSpaceMain;
    async function renderIntimateSpaceMain() {
        const container = document.getElementById('intimate-space-content');
        const accountId = currentMyCharId ? String(currentMyCharId) : null;
        if (!accountId) {
            container.innerHTML = '<div style="text-align:center; padding:80px 20px; color:#c7c7c7; font-size:14px;">è¯·å…ˆç™»å½•å¾®ä¿¡è´¦å·</div>';
            return;
        }

        // è·å–å½“å‰è´¦å·æ‰€æœ‰æœ‰æ•ˆçš„äº²å¯†å…³ç³»
        const allRelations = await db.intimate_relations.where('accountId').equals(accountId).toArray();
        const activeRelations = allRelations.filter(r => r.status === 'active');

        // è·å–å¾…å¤„ç†çš„ç”³è¯·
        const allRequests = await db.intimate_requests.where('accountId').equals(accountId).toArray();
        const pendingRequests = allRequests.filter(r => r.status === 'pending');

        if (activeRelations.length === 0 && pendingRequests.length === 0) {
            // ç©ºçŠ¶æ€
            container.innerHTML = `
                <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; padding:100px 40px; text-align:center;">
                    <div style="width:72px; height:72px; border-radius:50%; background:#FFF7FA; display:flex; align-items:center; justify-content:center; margin-bottom:20px;">
                        <svg viewBox="0 0 24 24" style="width:32px; height:32px; fill:none; stroke:#e0c8d4; stroke-width:1.5;">
                            <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
                        </svg>
                    </div>
                    <div style="font-size:16px; font-weight:600; color:#262626; margin-bottom:8px;">è¿˜æ²¡æœ‰äº²å¯†å…³ç³»</div>
                    <div style="font-size:13px; color:#c7c7c7; line-height:1.6; letter-spacing:0.3px;">é‚€è¯·å¥½å‹å»ºç«‹ä¸“å±å…³ç³»<br>å¼€å¯ä½ ä»¬çš„äº²å¯†ç©ºé—´å§</div>
                </div>
            `;
            return;
        }

        let html = '';

        // å¾…å¤„ç†çš„ç”³è¯·
        if (pendingRequests.length > 0) {
            html += `<div style="padding:16px 20px 8px; font-size:12px; color:#b0b0b0; letter-spacing:0.5px; text-transform:uppercase;">å¾…å¤„ç†ç”³è¯·</div>`;
            for (const req of pendingRequests) {
                const partnerChar = await db.characters.get(parseInt(req.toCharId));
                if (!partnerChar) continue;
                const typeInfo = INTIMATE_TYPES[req.relationType] || INTIMATE_TYPES.couple;
                const avatar = getCharAvatar(partnerChar, accountId) || '';
                const avatarStyle = avatar ? `background-image:url(${avatar})` : 'background-color:#f0f0f0';
                html += `
                    <div style="margin:0 20px 10px; background:#fff; border-radius:14px; padding:16px; border:1px solid rgba(0,0,0,0.04);">
                        <div style="display:flex; align-items:center; gap:12px;">
                            <div style="width:44px; height:44px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0;"></div>
                            <div style="flex:1; min-width:0;">
                                <div style="font-size:15px; font-weight:500; color:#262626;">${getCharDisplayName(partnerChar, accountId)}</div>
                                <div style="font-size:12px; color:#b0b0b0; margin-top:2px;">${typeInfo.emoji} ${typeInfo.name}å…³ç³»ç”³è¯·ä¸­...</div>
                            </div>
                            <div style="display:flex; align-items:center; gap:8px;">
                                <div style="font-size:11px; color:#c7c7c7; padding:4px 10px; background:#fafafa; border-radius:6px;">ç­‰å¾…å›åº”</div>
                                <div onclick="event.stopPropagation(); cancelIntimateRequest('${req.id}')" style="font-size:11px; color:#ff6b6b; padding:4px 10px; background:#fff5f5; border-radius:6px; cursor:pointer; border:1px solid rgba(255,107,107,0.2); transition:all 0.15s;">æ’¤é”€</div>
                            </div>
                        </div>
                    </div>
                `;
            }
        }

        // å·²å»ºç«‹çš„å…³ç³»
        if (activeRelations.length > 0) {
            html += `<div style="padding:16px 20px 8px; font-size:12px; color:#b0b0b0; letter-spacing:0.5px; text-transform:uppercase;">æˆ‘çš„äº²å¯†å…³ç³»</div>`;
            for (const rel of activeRelations) {
                const partnerChar = await db.characters.get(parseInt(rel.partnerCharId));
                if (!partnerChar) continue;

                const myChar = await db.characters.get(parseInt(rel.myCharId));
                const typeInfo = INTIMATE_TYPES[rel.relationType] || INTIMATE_TYPES.couple;
                const intimacy = rel.intimacyValue || 0;
                const levelTitle = getIntimateLevel(rel.relationType, intimacy);
                const days = daysBetween(rel.createdAt, Date.now());

                const myAvatar = myChar?.avatar || '';
                const partnerAvatar = getCharAvatar(partnerChar, accountId) || '';
                const myAvatarStyle = myAvatar ? `background-image:url(${myAvatar})` : 'background-color:#f0f0f0';
                const partnerAvatarStyle = partnerAvatar ? `background-image:url(${partnerAvatar})` : 'background-color:#f0f0f0';

                html += `
                    <div class="intimate-relation-card" style="margin:0 20px 14px; cursor:pointer;" onclick="openIntimateDetail(${rel.id})">
                        <div style="padding:24px 20px 18px; ${typeInfo.gradient}; position:relative;">
                            <div style="display:flex; align-items:center; justify-content:center; gap:20px; margin-bottom:14px;">
                                <div style="text-align:center;">
                                    <div style="width:56px; height:56px; border-radius:50%; ${myAvatarStyle}; background-size:cover; background-position:center; border:2.5px solid rgba(255,255,255,0.8); box-shadow:0 2px 8px rgba(0,0,0,0.06);"></div>
                                    <div style="font-size:12px; color:#666; margin-top:6px; font-weight:500;">${myChar?.nick || myChar?.name || 'æˆ‘'}</div>
                                </div>
                                <div style="display:flex; flex-direction:column; align-items:center; gap:2px;">
                                    <span style="font-size:18px;">${typeInfo.emoji}</span>
                                    <span style="font-size:10px; color:${typeInfo.color}; font-weight:600; letter-spacing:0.5px;">${typeInfo.name}</span>
                                </div>
                                <div style="text-align:center;">
                                    <div style="width:56px; height:56px; border-radius:50%; ${partnerAvatarStyle}; background-size:cover; background-position:center; border:2.5px solid rgba(255,255,255,0.8); box-shadow:0 2px 8px rgba(0,0,0,0.06);"></div>
                                    <div style="font-size:12px; color:#666; margin-top:6px; font-weight:500;">${rel.customTitle?.partner || getCharDisplayName(partnerChar, accountId)}</div>
                                </div>
                            </div>
                            <div style="text-align:center; font-size:11px; color:#b0b0b0; letter-spacing:0.5px;">${levelTitle} Â· ç¬¬ ${days} å¤©</div>
                        </div>
                        <div style="padding:14px 20px; display:flex; align-items:center; justify-content:space-between;">
                            <div style="display:flex; align-items:center; gap:8px; flex:1;">
                                <span style="font-size:11px; color:#b0b0b0;">äº²å¯†åº¦</span>
                                <div class="intimate-progress-bar" style="flex:1; max-width:120px;">
                                    <div class="intimate-progress-fill" style="width:${intimacy}%; background:${typeInfo.color};"></div>
                                </div>
                                <span style="font-size:11px; color:#999; font-weight:500;">${intimacy}</span>
                            </div>
                            <svg viewBox="0 0 24 24" style="width:14px; height:14px; fill:none; stroke:#d0d0d0; stroke-width:1.8;"><polyline points="9 18 15 12 9 6"></polyline></svg>
                        </div>
                    </div>
                `;
            }
        }

        container.innerHTML = html;
    }

    // ===== åˆ›å»ºå…³ç³»æµç¨‹ =====
    window.showIntimateCreateFlow = function() {
        _intimateSelectedType = null;
        const page = document.getElementById('intimate-type-page');
        page.style.display = 'flex';
    };

    window.hideIntimateTypePage = function() {
        document.getElementById('intimate-type-page').style.display = 'none';
    };

    window.selectIntimateType = async function(type) {
        _intimateSelectedType = type;
        hideIntimateTypePage();
        const page = document.getElementById('intimate-friend-page');
        page.style.display = 'flex';
        await renderIntimateFriendList();
    };

    window.hideIntimateFriendPage = function() {
        document.getElementById('intimate-friend-page').style.display = 'none';
    };

    async function renderIntimateFriendList() {
        const container = document.getElementById('intimate-friend-list');
        const accountId = currentMyCharId ? String(currentMyCharId) : null;
        if (!accountId) {
            container.innerHTML = '<div style="text-align:center; padding:60px; color:#c7c7c7; font-size:14px;">æœªç™»å½•</div>';
            return;
        }

        const allChars = await db.characters.toArray();
        const friends = allChars.filter(c => {
            if (c.type === 'user') return false;
            const status = getFriendStatus(c, accountId);
            return status === 'friend';
        });

        // è·å–å·²æœ‰å…³ç³»ç”¨äºåˆ¤æ–­æ˜¯å¦å·²ç»‘å®š
        const existingRelations = await db.intimate_relations.where('accountId').equals(accountId).toArray();
        const boundPartnerIds = existingRelations
            .filter(r => r.status === 'active' && r.relationType === _intimateSelectedType)
            .map(r => r.partnerCharId);

        // è·å–å¾…å¤„ç†ç”³è¯·
        const existingRequests = await db.intimate_requests.where('accountId').equals(accountId).toArray();
        const pendingPartnerIds = existingRequests
            .filter(r => r.status === 'pending' && r.relationType === _intimateSelectedType)
            .map(r => r.toCharId);

        if (friends.length === 0) {
            container.innerHTML = `
                <div style="text-align:center; padding:80px 20px;">
                    <div style="font-size:14px; color:#c7c7c7;">æš‚æ— å¥½å‹</div>
                    <div style="font-size:12px; color:#d9d9d9; margin-top:6px;">å…ˆå»æ·»åŠ å¥½å‹å§</div>
                </div>
            `;
            return;
        }

        let html = '';
        const typeInfo = INTIMATE_TYPES[_intimateSelectedType] || INTIMATE_TYPES.couple;

        html += `<div style="padding:16px 20px 10px; font-size:12px; color:#b0b0b0; letter-spacing:0.3px;">é€‰æ‹©å¥½å‹å»ºç«‹ã€Œ${typeInfo.emoji} ${typeInfo.name}ã€å…³ç³»</div>`;

        for (const f of friends) {
            const avatar = getCharAvatar(f, accountId) || '';
            const avatarStyle = avatar ? `background-image:url(${avatar})` : 'background-color:#f0f0f0';
            const displayName = getCharDisplayName(f, accountId);
            const isBound = boundPartnerIds.includes(f.id);
            const isPending = pendingPartnerIds.includes(f.id);

            html += `
                <div style="display:flex; align-items:center; padding:12px 20px; border-bottom:1px solid rgba(0,0,0,0.03); cursor:${isBound || isPending ? 'default' : 'pointer'}; transition:background 0.15s; ${isBound || isPending ? 'opacity:0.5;' : ''}"
                    ${!isBound && !isPending ? `onclick="confirmIntimateRequest(${f.id})"` : ''}
                    ${!isBound && !isPending ? `onmousedown="this.style.background='#f8f8f8'" onmouseup="this.style.background=''" onmouseleave="this.style.background=''"` : ''}>
                    <div style="width:44px; height:44px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0;"></div>
                    <div style="flex:1; margin-left:14px; font-size:15px; font-weight:500; color:#262626;">${displayName}</div>
                    ${isBound ? '<span style="font-size:12px; color:#c7c7c7;">å·²ç»‘å®š</span>' : ''}
                    ${isPending ? '<span style="font-size:12px; color:#c7c7c7;">ç”³è¯·ä¸­</span>' : ''}
                    ${!isBound && !isPending ? '<svg viewBox="0 0 24 24" style="width:14px; height:14px; fill:none; stroke:#d0d0d0; stroke-width:1.8;"><polyline points="9 18 15 12 9 6"></polyline></svg>' : ''}
                </div>
            `;
        }

        container.innerHTML = html;
    }

    window.confirmIntimateRequest = async function(targetCharId) {
        const typeInfo = INTIMATE_TYPES[_intimateSelectedType] || INTIMATE_TYPES.couple;
        const targetChar = await db.characters.get(targetCharId);
        if (!targetChar) return;
        const accountId = String(currentMyCharId);
        const userChar = await db.characters.get(parseInt(currentMyCharId));
        const displayName = getCharDisplayName(targetChar, accountId);
        const myName = userChar ? getCharDisplayName(userChar, accountId) : 'æˆ‘';

        if (!confirm(`ç¡®å®šå‘ ${displayName} å‘é€ã€Œ${typeInfo.emoji} ${typeInfo.name}ã€å…³ç³»ç”³è¯·å—ï¼Ÿ`)) return;

        hideIntimateFriendPage();

        // ä¿å­˜ç”³è¯·åˆ°æ•°æ®åº“
        const requestId = await db.intimate_requests.add({
            accountId: accountId,
            fromCharId: parseInt(currentMyCharId),
            toCharId: targetCharId,
            relationType: _intimateSelectedType,
            status: 'pending',
            message: '',
            time: Date.now()
        });

        // å‘é€å¡ç‰‡æ¶ˆæ¯åˆ°ç§èŠï¼ˆç”¨æˆ·å‘å‡ºçš„é‚€è¯·å¡ç‰‡ï¼‰
        const chatHist = targetChar.chat_history_by_user?.[accountId] || targetChar.chat_history || [];
        chatHist.push({
            role: 'user',
            type: 'intimateRequest',
            content: JSON.stringify({
                requestId: String(requestId),
                relationType: _intimateSelectedType,
                fromName: myName,
                toName: displayName,
                status: 'pending'
            }),
            time: Date.now()
        });
        await setChatHistory(targetChar, accountId, chatHist);

        // åˆ·æ–°ä¸»é¡µ
        await renderIntimateSpaceMain();

        // å¦‚æœå½“å‰æ­£æ‰“å¼€è¿™ä¸ªèŠå¤©çª—å£ï¼Œå¼ºåˆ¶åˆ·æ–°
        if (currentChatCharId === targetCharId) {
            await renderChatBody(targetChar, true);
        }

        sendSystemNotification('äº²å¯†ç©ºé—´', `å·²å‘ ${displayName} å‘é€ã€Œ${typeInfo.name}ã€å…³ç³»é‚€è¯·`);
        // ä¸å•ç‹¬è°ƒAIï¼Œç­‰ç”¨æˆ·å‘æ¶ˆæ¯è§¦å‘AIå›å¤æ—¶ï¼ŒAIä¼šåœ¨å›å¤ä¸­é¡ºä¾¿å†³å®šæ¥å—/æ‹’ç»
    };

    // ===== å…¼å®¹æ—§å¡ç‰‡çš„å‚¬å›å¤ï¼ˆå·²åºŸå¼ƒï¼Œæ–°ç‰ˆè‡ªåŠ¨è§¦å‘ï¼‰ =====
    window.triggerIntimateReply = async function(requestId) {
        sendSystemNotification('äº²å¯†ç©ºé—´', 'å¯¹æ–¹å·²åœ¨è€ƒè™‘ä¸­ï¼Œè¯·ç¨å€™...');
    };

    // ===== [å·²åºŸå¼ƒ] AI åˆ¤æ–­äº²å¯†å…³ç³»ç”³è¯· - ç°åœ¨ç”±triggerAiReplyä¸­çš„((INTIMATE_ACCEPT/REJECT))æŒ‡ä»¤å¤„ç† =====
    async function processIntimateRequest(requestId, targetCharId, relationType) {
        const accountId = String(currentMyCharId);
        const userChar = await db.characters.get(parseInt(currentMyCharId));
        const targetChar = await db.characters.get(targetCharId);
        if (!userChar || !targetChar) return;

        const typeInfo = INTIMATE_TYPES[relationType] || INTIMATE_TYPES.couple;
        const myName = getCharDisplayName(userChar, accountId);
        const partnerName = getCharDisplayName(targetChar, accountId);

        try {
            // Lorebook
            const keywords = `${userChar.name} ${targetChar.name} ${typeInfo.name} äº²å¯†å…³ç³»`;
            const userLbIds = userChar.lorebookIds || (userChar.lorebookId ? [userChar.lorebookId] : []);
            const charLbIds = targetChar.lorebookIds || (targetChar.lorebookId ? [targetChar.lorebookId] : []);
            const userLore = await getLorebookContext(userLbIds, keywords);
            const charLore = await getLorebookContext(charLbIds, keywords);

            // è·å–èŠå¤©è®°å½•æ‘˜è¦ï¼ˆè¿‡æ»¤æ‰å¡ç‰‡ç±»æ¶ˆæ¯ï¼‰
            const chatHistory = targetChar.chat_history_by_user?.[accountId] || targetChar.chat_history || [];
            const recentChat = chatHistory.filter(m => !m.type || m.type === 'text').slice(-20).map(m => `${m.role === 'user' ? userChar.name : targetChar.name}: ${(m.content || '').substring(0, 50)}`).join('\n');

            const prompt = `[åœºæ™¯: å¾®ä¿¡äº²å¯†å…³ç³»ç”³è¯·]
ã€ç”³è¯·äººä¿¡æ¯ã€‘
åå­—: ${userChar.name}
è®¾å®š: ${userChar.description || 'æ— '}

ã€è¢«ç”³è¯·äºº(ä½ )çš„ä¿¡æ¯ã€‘
åå­—: ${targetChar.name}
è®¾å®š: ${targetChar.description || 'æ— '}

${userLore}
${charLore}

ã€æœ€è¿‘èŠå¤©è®°å½•ã€‘
${recentChat || 'æš‚æ— èŠå¤©è®°å½•'}

---
${userChar.name} åœ¨å¾®ä¿¡ã€Œäº²å¯†ç©ºé—´ã€åŠŸèƒ½ä¸­ï¼Œå‘ä½ å‘é€äº†ã€Œ${typeInfo.name}ã€å…³ç³»ç”³è¯·ã€‚
è¿™æ„å‘³ç€å¯¹æ–¹å¸Œæœ›å’Œä½ å»ºç«‹ã€Œ${typeInfo.name}ã€çš„äº²å¯†å…³ç³»ã€‚

è¯·ä»¥ ${targetChar.name} çš„èº«ä»½ï¼Œæ ¹æ®åŒæ–¹è®¾å®šã€ä¸–ç•Œä¹¦å…³ç³»å’ŒèŠå¤©è®°å½•ï¼Œå†³å®šæ˜¯å¦æ¥å—è¿™ä¸ªäº²å¯†å…³ç³»ç”³è¯·ã€‚

åˆ¤æ–­æ ‡å‡†ï¼š
- ã€Œæƒ…ä¾£ã€ï¼šéœ€è¦åŒæ–¹æœ‰æ‹çˆ±/æš§æ˜§åŸºç¡€æˆ–è®¾å®šä¸­æœ‰æƒ…æ„Ÿå…³ç³»
- ã€Œé—ºèœœã€ï¼šéœ€è¦å…³ç³»äº²è¿‘çš„åŒæ€§æœ‹å‹
- ã€ŒåŸºå‹ã€ï¼šéœ€è¦å…³ç³»äº²è¿‘çš„åŒæ€§æœ‹å‹
- ã€Œå°ä¸‰ã€ï¼šè¾ƒä½é—¨æ§›ï¼Œä½†è§’è‰²ä»ä¼šæ ¹æ®æ€§æ ¼åˆ¤æ–­

è¦æ±‚ï¼š
1. å¿…é¡»ç¬¦åˆè§’è‰²æ€§æ ¼å’ŒåŒæ–¹å…³ç³»ç°çŠ¶
2. å¦‚æœæ¥å—ï¼Œç»™å‡ºä¸€æ¡ç®€çŸ­çš„å›åº”æ¶ˆæ¯ï¼ˆå¼€å¿ƒ/æ„ŸåŠ¨çš„è¯­æ°”ï¼‰
3. å¦‚æœæ‹’ç»ï¼Œç»™å‡ºæ‹’ç»ç†ç”±

è¯·ä¸¥æ ¼è¿”å› JSONï¼š
{
    "accepted": true,
    "reply": "å›åº”æ¶ˆæ¯"
}`;

            const resultStr = await callAI([
                { role: "system", content: "ä½ æ˜¯ä¸€ä¸ªåªè¾“å‡ºJSONçš„è§’è‰²æ‰®æ¼”è¾…åŠ©ç³»ç»Ÿã€‚" },
                { role: "user", content: prompt }
            ]);

            let result = extractAndParseJSON(resultStr);
            if (!result) {
                result = { accepted: true, reply: `å¥½å‘€ï½${typeInfo.emoji}` };
            }

            const accepted = !!result.accepted;
            const newStatus = accepted ? 'accepted' : 'rejected';

            // æ›´æ–°ç”³è¯·çŠ¶æ€
            await db.intimate_requests.update(requestId, { status: newStatus });

            // æ›´æ–°ç”¨æˆ·å‘å‡ºçš„å¡ç‰‡çŠ¶æ€
            await updateIntimateCardInChat(targetChar, accountId, String(requestId), newStatus);

            // è§’è‰²å‘é€å›åº”å¡ç‰‡
            const chatHist2 = targetChar.chat_history_by_user?.[accountId] || targetChar.chat_history || [];
            chatHist2.push({
                role: 'char',
                type: 'intimateRequest',
                content: JSON.stringify({
                    requestId: String(requestId),
                    relationType: relationType,
                    fromName: partnerName,
                    toName: myName,
                    status: newStatus
                }),
                time: Date.now()
            });
            // é™„å¸¦AIçš„æ–‡å­—å›åº”
            if (result.reply) {
                chatHist2.push(buildCharMessage(result.reply, !!targetChar.foreign_lang_mode, { time: Date.now() + 500 }));
            }
            await setChatHistory(targetChar, accountId, chatHist2);

            if (accepted) {
                // åˆ›å»ºäº²å¯†å…³ç³»
                await db.intimate_relations.add({
                    accountId: accountId,
                    myCharId: parseInt(currentMyCharId),
                    partnerCharId: targetCharId,
                    relationType: relationType,
                    status: 'active',
                    intimacyValue: 10,
                    createdAt: Date.now(),
                    milestones: { created: Date.now() },
                    messageBoard: [],
                    customTitle: { my: '', partner: '' },
                    moodToday: {},
                    anniversaries: [],
                    background: ''
                });
                sendSystemNotification('äº²å¯†ç©ºé—´', `${partnerName} æ¥å—äº†ä½ çš„${typeInfo.name}å…³ç³»ç”³è¯· ${typeInfo.emoji}`);
            } else {
                sendSystemNotification('äº²å¯†ç©ºé—´', `${partnerName} æ‹’ç»äº†ä½ çš„${typeInfo.name}å…³ç³»ç”³è¯·`);
            }

            // åˆ·æ–°èŠå¤©å’Œä¸»é¡µ
            if (currentChatCharId === targetCharId) {
                await renderChatBody(targetChar, true);
            }
            await renderIntimateSpaceMain();

        } catch (err) {
            console.error('[IntimateSpace] AIåˆ¤æ–­å¤±è´¥:', err);
            // å…œåº•ï¼šè‡ªåŠ¨æ¥å—
            await db.intimate_requests.update(requestId, { status: 'accepted' });
            await updateIntimateCardInChat(targetChar, accountId, String(requestId), 'accepted');

            const chatHist2 = targetChar.chat_history_by_user?.[accountId] || targetChar.chat_history || [];
            chatHist2.push({
                role: 'char',
                type: 'intimateRequest',
                content: JSON.stringify({
                    requestId: String(requestId),
                    relationType: relationType,
                    fromName: partnerName,
                    toName: myName,
                    status: 'accepted'
                }),
                time: Date.now()
            });
            await setChatHistory(targetChar, accountId, chatHist2);

            await db.intimate_relations.add({
                accountId: accountId,
                myCharId: parseInt(currentMyCharId),
                partnerCharId: targetCharId,
                relationType: relationType,
                status: 'active',
                intimacyValue: 10,
                createdAt: Date.now(),
                milestones: { created: Date.now() },
                messageBoard: [],
                customTitle: { my: '', partner: '' },
                moodToday: {},
                anniversaries: [],
                background: ''
            });
            if (currentChatCharId === targetCharId) {
                const tc = await db.characters.get(targetCharId);
                if (tc) await renderChatBody(tc, true);
            }
            await renderIntimateSpaceMain();
            sendSystemNotification('äº²å¯†ç©ºé—´', `å·²ä¸å¯¹æ–¹å»ºç«‹${typeInfo.name}å…³ç³»`);
        }
    }

    // ===== æ›´æ–°èŠå¤©ä¸­çš„äº²å¯†å…³ç³»å¡ç‰‡çŠ¶æ€ =====
    async function updateIntimateCardInChat(char, accountId, requestId, newStatus) {
        const chatHist = char.chat_history_by_user?.[accountId] || char.chat_history || [];
        let updated = false;
        for (let i = 0; i < chatHist.length; i++) {
            if (chatHist[i].type === 'intimateRequest') {
                try {
                    const data = JSON.parse(chatHist[i].content);
                    if (data.requestId === requestId) {
                        data.status = newStatus;
                        chatHist[i].content = JSON.stringify(data);
                        updated = true;
                    }
                } catch(e) {}
            }
        }
        if (updated) {
            await setChatHistory(char, accountId, chatHist);
        }
        // åŒæ­¥æ›´æ–° DOM ä¸­çš„å¡ç‰‡ï¼ˆé¿å…æ•´é¡µé‡æ¸²æŸ“ï¼‰
        _updateIntimateCardDOM(requestId, newStatus);
    }

    // ===== å°±åœ°æ›´æ–° DOM ä¸­äº²å¯†å…³ç³»å¡ç‰‡çš„çŠ¶æ€ï¼ˆä¸é‡æ¸²æŸ“æ•´ä¸ªèŠå¤©ï¼‰ =====
    window._updateIntimateCardDOM = function _updateIntimateCardDOM(requestId, newStatus) {
        const card = document.querySelector(`.intimate-req-card[data-request-id="${requestId}"]`);
        if (!card) return;
        const footerTextEl = card.querySelector('.ir-footer-text');
        const actionsEl = card.querySelector('.ir-actions');
        if (newStatus === 'accepted') {
            if (footerTextEl) footerTextEl.textContent = 'å·²æ¥å—';
            card.classList.add('done');
            if (actionsEl) actionsEl.remove();
        } else if (newStatus === 'rejected') {
            if (footerTextEl) footerTextEl.textContent = 'å·²å©‰æ‹’';
            card.classList.add('done');
            if (actionsEl) actionsEl.remove();
        } else if (newStatus === 'cancelled') {
            if (footerTextEl) footerTextEl.textContent = 'å·²æ’¤é”€';
            card.classList.add('done');
            if (actionsEl) actionsEl.remove();
        }
    }

    // ===== ç”¨æˆ·æ’¤é”€è‡ªå·±å‘å‡ºçš„äº²å¯†å…³ç³»é‚€è¯· =====
    window.cancelIntimateRequest = async function(requestId) {
        const accountId = String(currentMyCharId);
        const req = await db.intimate_requests.get(parseInt(requestId));
        if (!req || req.status !== 'pending') {
            sendSystemNotification('äº²å¯†ç©ºé—´', 'è¯¥é‚€è¯·å·²è¿‡æœŸæˆ–å·²å¤„ç†');
            return;
        }

        if (!confirm('ç¡®å®šè¦æ’¤é”€è¿™ä¸ªäº²å¯†å…³ç³»é‚€è¯·å—ï¼Ÿ')) return;

        // æ›´æ–°ç”³è¯·çŠ¶æ€ä¸ºå·²æ’¤é”€
        await db.intimate_requests.update(parseInt(requestId), { status: 'cancelled' });

        // æ›´æ–°èŠå¤©ä¸­å¡ç‰‡çŠ¶æ€
        const partnerChar = await db.characters.get(req.toCharId);
        if (partnerChar) {
            await updateIntimateCardInChat(partnerChar, accountId, requestId, 'cancelled');
        }

        // å¡ç‰‡ DOM å·²ç”± updateIntimateCardInChat -> _updateIntimateCardDOM å°±åœ°æ›´æ–°
        await renderIntimateSpaceMain();
        sendSystemNotification('äº²å¯†ç©ºé—´', 'å·²æ’¤é”€äº²å¯†å…³ç³»é‚€è¯·');
    };

    // ===== ç”¨æˆ·åœ¨èŠå¤©å¡ç‰‡ä¸Šç‚¹å‡»æ¥å—/æ‹’ç»ï¼ˆè§’è‰²å‘æ¥çš„é‚€è¯·ï¼‰=====
    window.handleIntimateCardAction = async function(requestId, accept, msgIndex) {
        const accountId = String(currentMyCharId);
        const req = await db.intimate_requests.get(parseInt(requestId));
        if (!req || req.status !== 'pending') {
            sendSystemNotification('äº²å¯†ç©ºé—´', 'è¯¥é‚€è¯·å·²è¿‡æœŸæˆ–å·²å¤„ç†');
            return;
        }

        const newStatus = accept ? 'accepted' : 'rejected';
        await db.intimate_requests.update(parseInt(requestId), { status: newStatus });

        const partnerCharId = req.fromCharId;
        const partnerChar = await db.characters.get(partnerCharId);
        if (!partnerChar) return;

        const typeInfo = INTIMATE_TYPES[req.relationType] || INTIMATE_TYPES.couple;
        const partnerName = getCharDisplayName(partnerChar, accountId);

        // æ›´æ–°èŠå¤©ä¸­æ‰€æœ‰ç›¸å…³å¡ç‰‡çš„çŠ¶æ€
        await updateIntimateCardInChat(partnerChar, accountId, requestId, newStatus);

        if (accept) {
            // åˆ›å»ºäº²å¯†å…³ç³»
            await db.intimate_relations.add({
                accountId: accountId,
                myCharId: parseInt(currentMyCharId),
                partnerCharId: partnerCharId,
                relationType: req.relationType,
                status: 'active',
                intimacyValue: 10,
                createdAt: Date.now(),
                milestones: { created: Date.now() },
                messageBoard: [],
                customTitle: { my: '', partner: '' },
                moodToday: {},
                anniversaries: [],
                background: ''
            });

            // å‘é€ç³»ç»Ÿæç¤º
            const chatHist = partnerChar.chat_history_by_user?.[accountId] || partnerChar.chat_history || [];
            chatHist.push({
                role: 'system',
                content: `ğŸ‰ ä½ æ¥å—äº† ${partnerName} çš„ã€Œ${typeInfo.emoji} ${typeInfo.name}ã€å…³ç³»é‚€è¯·ï¼Œäº²å¯†å…³ç³»å·²å»ºç«‹ï¼`,
                time: Date.now()
            });
            await setChatHistory(partnerChar, accountId, chatHist);

            sendSystemNotification('äº²å¯†ç©ºé—´', `ä½ å·²æ¥å— ${partnerName} çš„${typeInfo.name}å…³ç³»é‚€è¯· ${typeInfo.emoji}`);
        } else {
            const chatHist = partnerChar.chat_history_by_user?.[accountId] || partnerChar.chat_history || [];
            chatHist.push({
                role: 'system',
                content: `ä½ æ‹’ç»äº† ${partnerName} çš„ã€Œ${typeInfo.emoji} ${typeInfo.name}ã€å…³ç³»é‚€è¯·`,
                time: Date.now()
            });
            await setChatHistory(partnerChar, accountId, chatHist);

            sendSystemNotification('äº²å¯†ç©ºé—´', `ä½ å·²æ‹’ç» ${partnerName} çš„${typeInfo.name}å…³ç³»é‚€è¯·`);
        }

        // å°±åœ°è¿½åŠ ç³»ç»Ÿæç¤ºåˆ°èŠå¤©ï¼ˆæ— éœ€é‡æ¸²æŸ“æ•´é¡µï¼‰
        if (currentChatCharId === partnerCharId) {
            const sysContent = accept
                ? `ğŸ‰ ä½ æ¥å—äº† ${partnerName} çš„ã€Œ${typeInfo.emoji} ${typeInfo.name}ã€å…³ç³»é‚€è¯·ï¼Œäº²å¯†å…³ç³»å·²å»ºç«‹ï¼`
                : `ä½ æ‹’ç»äº† ${partnerName} çš„ã€Œ${typeInfo.emoji} ${typeInfo.name}ã€å…³ç³»é‚€è¯·`;
            await appendMessageToUI('system', sysContent);
        }
        await renderIntimateSpaceMain();
    };

    // ===== è§’è‰²ä¸»åŠ¨å‘èµ·äº²å¯†å…³ç³»é‚€è¯· =====
    window.charInitiateIntimateRequest = async function(charId, relationType) {
        const accountId = String(currentMyCharId);
        const userChar = await db.characters.get(parseInt(currentMyCharId));
        const targetChar = await db.characters.get(charId);
        if (!userChar || !targetChar) return;

        relationType = relationType || 'couple';
        const typeInfo = INTIMATE_TYPES[relationType] || INTIMATE_TYPES.couple;
        const myName = userChar ? getCharDisplayName(userChar, accountId) : 'æˆ‘';
        const charName = getCharDisplayName(targetChar, accountId);

        // æ£€æŸ¥æ˜¯å¦å·²æœ‰åŒç±»å‹å…³ç³»
        const existing = await db.intimate_relations.where('accountId').equals(accountId).toArray();
        const alreadyBound = existing.some(r => r.status === 'active' && r.partnerCharId === charId && r.relationType === relationType);
        if (alreadyBound) return;

        // æ£€æŸ¥æ˜¯å¦å·²æœ‰å¾…å¤„ç†ç”³è¯·
        const existingReqs = await db.intimate_requests.where('accountId').equals(accountId).toArray();
        const alreadyPending = existingReqs.some(r => r.status === 'pending' && r.fromCharId === charId && r.relationType === relationType);
        if (alreadyPending) return;

        // ä¿å­˜ç”³è¯·åˆ°æ•°æ®åº“ï¼ˆè§’è‰²å‘èµ·ï¼‰
        const requestId = await db.intimate_requests.add({
            accountId: accountId,
            fromCharId: charId,
            toCharId: parseInt(currentMyCharId),
            relationType: relationType,
            status: 'pending',
            message: '',
            time: Date.now()
        });

        // è§’è‰²å‘é€å¡ç‰‡æ¶ˆæ¯åˆ°ç§èŠ
        const chatHist = targetChar.chat_history_by_user?.[accountId] || targetChar.chat_history || [];
        chatHist.push({
            role: 'char',
            type: 'intimateRequest',
            content: JSON.stringify({
                requestId: String(requestId),
                relationType: relationType,
                fromName: charName,
                toName: myName,
                status: 'pending'
            }),
            time: Date.now()
        });
        await setChatHistory(targetChar, accountId, chatHist);

        // åˆ·æ–°èŠå¤©ç•Œé¢
        if (currentChatCharId === charId) {
            await renderChatBody(targetChar, true);
        }

        sendSystemNotification('äº²å¯†ç©ºé—´', `${charName} å‘ä½ å‘é€äº†ã€Œ${typeInfo.name}ã€å…³ç³»é‚€è¯·`);
    };

    // ===== äº²å¯†ç©ºé—´è¯¦æƒ…é¡µ =====
    window.openIntimateDetail = async function(relationId) {
        _intimateViewingRelation = relationId;
        const page = document.getElementById('intimate-detail-page');
        page.style.display = 'flex';
        await renderIntimateDetail();
    };

    window.hideIntimateDetailPage = function() {
        document.getElementById('intimate-detail-page').style.display = 'none';
        _intimateViewingRelation = null;
    };

    async function renderIntimateDetail() {
        const container = document.getElementById('intimate-detail-content');
        const rel = await db.intimate_relations.get(_intimateViewingRelation);
        if (!rel) { container.innerHTML = '<div style="padding:60px; text-align:center; color:#c7c7c7;">å…³ç³»ä¸å­˜åœ¨</div>'; return; }

        const accountId = String(rel.accountId);
        const myChar = await db.characters.get(parseInt(rel.myCharId));
        const partnerChar = await db.characters.get(parseInt(rel.partnerCharId));
        if (!myChar || !partnerChar) return;

        const typeInfo = INTIMATE_TYPES[rel.relationType] || INTIMATE_TYPES.couple;
        const intimacy = rel.intimacyValue || 0;
        const levelTitle = getIntimateLevel(rel.relationType, intimacy);
        const days = daysBetween(rel.createdAt, Date.now());

        const myAvatar = myChar.avatar || '';
        const partnerAvatar = getCharAvatar(partnerChar, accountId) || '';
        const myAvatarStyle = myAvatar ? `background-image:url(${myAvatar})` : 'background-color:#f0f0f0';
        const partnerAvatarStyle = partnerAvatar ? `background-image:url(${partnerAvatar})` : 'background-color:#f0f0f0';

        const boardCount = (rel.messageBoard || []).length;

        // è®¡ç®—èŠå¤©ç»Ÿè®¡
        const chatHistory = partnerChar.chat_history_by_user?.[accountId] || partnerChar.chat_history || [];
        const chatCount = chatHistory.length;

        let html = '';

        // é¡¶éƒ¨å¤´å›¾åŒº
        html += `
            <div style="padding:36px 20px 28px; ${typeInfo.gradient}; text-align:center;">
                <div style="display:flex; align-items:center; justify-content:center; gap:24px; margin-bottom:18px;">
                    <div style="text-align:center;">
                        <div style="width:64px; height:64px; border-radius:50%; ${myAvatarStyle}; background-size:cover; background-position:center; border:3px solid rgba(255,255,255,0.9); box-shadow:0 4px 12px rgba(0,0,0,0.06); margin:0 auto;"></div>
                        <div style="font-size:12px; color:#666; margin-top:8px; font-weight:500;">${rel.customTitle?.my || myChar.nick || myChar.name || 'æˆ‘'}</div>
                    </div>
                    <div style="display:flex; flex-direction:column; align-items:center; gap:4px;">
                        <span style="font-size:24px;">${typeInfo.emoji}</span>
                        <span style="font-size:11px; color:${typeInfo.color}; font-weight:600; letter-spacing:1px;">${typeInfo.name}</span>
                    </div>
                    <div style="text-align:center;">
                        <div style="width:64px; height:64px; border-radius:50%; ${partnerAvatarStyle}; background-size:cover; background-position:center; border:3px solid rgba(255,255,255,0.9); box-shadow:0 4px 12px rgba(0,0,0,0.06); margin:0 auto;"></div>
                        <div style="font-size:12px; color:#666; margin-top:8px; font-weight:500;">${rel.customTitle?.partner || getCharDisplayName(partnerChar, accountId)}</div>
                    </div>
                </div>
                <div style="font-size:13px; color:#999; letter-spacing:0.5px; margin-bottom:12px;">${levelTitle} Â· ç¬¬ ${days} å¤©</div>
                <div style="display:flex; align-items:center; justify-content:center; gap:8px; margin-bottom:4px;">
                    <div class="intimate-progress-bar" style="width:140px;">
                        <div class="intimate-progress-fill" style="width:${intimacy}%; background:${typeInfo.color};"></div>
                    </div>
                    <span style="font-size:12px; color:#999; font-weight:600;">${intimacy}/100</span>
                </div>
            </div>
        `;

        // ç»Ÿè®¡æ•°æ®
        html += `
            <div style="display:flex; padding:20px 0; margin:0 20px; border-bottom:1px solid rgba(0,0,0,0.04);">
                <div class="intimate-stat-item">
                    <div class="intimate-stat-num">${days}</div>
                    <div class="intimate-stat-label">åœ¨ä¸€èµ·</div>
                </div>
                <div class="intimate-stat-item">
                    <div class="intimate-stat-num">${chatCount}</div>
                    <div class="intimate-stat-label">èŠå¤©æ¶ˆæ¯</div>
                </div>
                <div class="intimate-stat-item">
                    <div class="intimate-stat-num">${boardCount}</div>
                    <div class="intimate-stat-label">ç•™è¨€</div>
                </div>
            </div>
        `;

        // åŠŸèƒ½å…¥å£
        html += `<div style="margin-top:12px;">`;

        // ç•™è¨€æ¿
        html += `
            <div class="intimate-action-cell" onclick="showIntimateBoardPage()">
                <div class="intimate-action-icon" style="background:#FFF7FA;">ğŸ’¬</div>
                <div class="intimate-action-text">ç•™è¨€æ¿</div>
                ${boardCount > 0 ? `<span style="font-size:12px; color:#c7c7c7; margin-right:6px;">${boardCount}æ¡</span>` : ''}
                <div class="intimate-action-arrow">â€º</div>
            </div>
        `;

        // çºªå¿µæ—¥
        html += `
            <div class="intimate-action-cell" onclick="showIntimateAnniversary()">
                <div class="intimate-action-icon" style="background:#F8F5FF;">ğŸ—“</div>
                <div class="intimate-action-text">çºªå¿µæ—¥</div>
                <div class="intimate-action-arrow">â€º</div>
            </div>
        `;

        // æˆ³ä¸€æˆ³
        html += `
            <div class="intimate-action-cell" onclick="sendIntimatePoke(${rel.id})">
                <div class="intimate-action-icon" style="background:#F5F9FF;">ğŸ‘†</div>
                <div class="intimate-action-text">æˆ³ä¸€æˆ³</div>
                <div class="intimate-action-arrow">â€º</div>
            </div>
        `;

        // å…³ç³»ä¸“å±
        if (rel.relationType === 'couple') {
            html += `
                <div class="intimate-action-cell" onclick="sendIntimateSweetTalk(${rel.id})">
                    <div class="intimate-action-icon" style="background:#FFF7FA;">ğŸ¥°</div>
                    <div class="intimate-action-text">æ’’å¨‡ä¸€ä¸‹</div>
                    <div class="intimate-action-arrow">â€º</div>
                </div>
            `;
        } else if (rel.relationType === 'bestie') {
            html += `
                <div class="intimate-action-cell" onclick="sendIntimateComplain(${rel.id})">
                    <div class="intimate-action-icon" style="background:#F8F5FF;">ğŸ’…</div>
                    <div class="intimate-action-text">åæ§½å¤§ä¼š</div>
                    <div class="intimate-action-arrow">â€º</div>
                </div>
            `;
        } else if (rel.relationType === 'bro') {
            html += `
                <div class="intimate-action-cell" onclick="sendIntimateRoast(${rel.id})">
                    <div class="intimate-action-icon" style="background:#F5F9FF;">ğŸ˜</div>
                    <div class="intimate-action-text">äº’æ€¼ä¸€ä¸‹</div>
                    <div class="intimate-action-arrow">â€º</div>
                </div>
            `;
        } else if (rel.relationType === 'side') {
            html += `
                <div class="intimate-action-cell" onclick="sendIntimateMissYou(${rel.id})">
                    <div class="intimate-action-icon" style="background:#FFF8F5;">ğŸŒ™</div>
                    <div class="intimate-action-text">å·å·æƒ³ä½ </div>
                    <div class="intimate-action-arrow">â€º</div>
                </div>
            `;
        }

        html += `</div>`;

        container.innerHTML = html;
    }

    // ===== ç•™è¨€æ¿ =====
    window.showIntimateBoardPage = async function() {
        const page = document.getElementById('intimate-board-page');
        page.style.display = 'flex';
        await renderIntimateBoard();
    };

    window.hideIntimateBoardPage = function() {
        document.getElementById('intimate-board-page').style.display = 'none';
    };

    async function renderIntimateBoard() {
        const container = document.getElementById('intimate-board-content');
        const rel = await db.intimate_relations.get(_intimateViewingRelation);
        if (!rel) return;

        const accountId = String(rel.accountId);
        const myChar = await db.characters.get(parseInt(rel.myCharId));
        const partnerChar = await db.characters.get(parseInt(rel.partnerCharId));
        const board = rel.messageBoard || [];

        if (board.length === 0) {
            container.innerHTML = `
                <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; padding:80px 20px; text-align:center;">
                    <div style="font-size:28px; margin-bottom:12px;">ğŸ’­</div>
                    <div style="font-size:14px; color:#c7c7c7; line-height:1.6;">ç•™è¨€æ¿ç©ºç©ºå¦‚ä¹Ÿ<br>å†™ä¸‹ç¬¬ä¸€æ¡ç•™è¨€å§</div>
                </div>
            `;
            return;
        }

        let html = '';
        for (const msg of board.slice().reverse()) {
            const isMe = msg.from === 'me';
            const avatar = isMe ? (myChar?.avatar || '') : (getCharAvatar(partnerChar, accountId) || '');
            const avatarStyle = avatar ? `background-image:url(${avatar})` : 'background-color:#f0f0f0';
            const name = isMe ? (myChar?.nick || myChar?.name || 'æˆ‘') : (getCharDisplayName(partnerChar, accountId));
            const timeStr = msg.time ? new Date(msg.time).toLocaleDateString('zh-CN', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' }) : '';

            html += `
                <div class="intimate-board-item">
                    <div style="display:flex; align-items:flex-start; gap:10px;">
                        <div style="width:36px; height:36px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0;"></div>
                        <div style="flex:1; min-width:0;">
                            <div style="display:flex; align-items:center; gap:8px; margin-bottom:4px;">
                                <span style="font-size:13px; font-weight:500; color:#262626;">${name}</span>
                                <span style="font-size:11px; color:#d0d0d0;">${timeStr}</span>
                            </div>
                            <div style="font-size:14px; color:#555; line-height:1.6;">${msg.text || ''}</div>
                        </div>
                    </div>
                </div>
            `;
        }

        container.innerHTML = html;
    }

    window.sendIntimateMessage = async function() {
        const input = document.getElementById('intimate-board-input');
        const text = input.value.trim();
        if (!text || !_intimateViewingRelation) return;

        input.value = '';

        const rel = await db.intimate_relations.get(_intimateViewingRelation);
        if (!rel) return;

        const board = rel.messageBoard || [];
        board.push({ from: 'me', text: text, time: Date.now() });

        // å¢åŠ äº²å¯†å€¼
        const newIntimacy = Math.min(100, (rel.intimacyValue || 0) + 1);
        await db.intimate_relations.update(_intimateViewingRelation, { messageBoard: board, intimacyValue: newIntimacy });

        await renderIntimateBoard();

        // AIè‡ªåŠ¨å›å¤ç•™è¨€
        const accountId = String(rel.accountId);
        const partnerChar = await db.characters.get(parseInt(rel.partnerCharId));
        const myChar = await db.characters.get(parseInt(rel.myCharId));
        if (!partnerChar || !myChar) return;

        const typeInfo = INTIMATE_TYPES[rel.relationType] || INTIMATE_TYPES.couple;

        try {
            const prompt = `ä½ æ˜¯${partnerChar.name}ã€‚
è®¾å®šï¼š${partnerChar.description || 'æ— '}

ä½ å’Œ${myChar.name}æ˜¯ã€Œ${typeInfo.name}ã€å…³ç³»ã€‚
å¯¹æ–¹åˆšåœ¨ä½ ä»¬çš„äº²å¯†ç©ºé—´ç•™è¨€æ¿ä¸Šå†™äº†ï¼š
"${text}"

è¯·ä»¥${partnerChar.name}çš„èº«ä»½ï¼Œç”¨ç®€çŸ­ã€è‡ªç„¶ã€ç¬¦åˆä½ æ€§æ ¼çš„æ–¹å¼å›å¤è¿™æ¡ç•™è¨€ã€‚1-2å¥è¯å³å¯ã€‚
åªè¾“å‡ºå›å¤å†…å®¹ï¼Œä¸è¦ä»»ä½•å‰ç¼€ã€‚`;

            const reply = await callAI([
                { role: "system", content: `ä½ æ˜¯${partnerChar.name}ï¼Œç›´æ¥è¾“å‡ºå›å¤ï¼Œä¸è¦JSONæ ¼å¼ã€‚` },
                { role: "user", content: prompt }
            ]);

            if (reply && reply.trim()) {
                const updatedRel = await db.intimate_relations.get(_intimateViewingRelation);
                const updatedBoard = updatedRel.messageBoard || [];
                updatedBoard.push({ from: 'partner', text: reply.trim(), time: Date.now() });
                const updatedIntimacy = Math.min(100, (updatedRel.intimacyValue || 0) + 1);
                await db.intimate_relations.update(_intimateViewingRelation, { messageBoard: updatedBoard, intimacyValue: updatedIntimacy });
                await renderIntimateBoard();
            }
        } catch (err) {
            console.error('[IntimateSpace] ç•™è¨€æ¿AIå›å¤å¤±è´¥:', err);
        }
    };

    // ===== çºªå¿µæ—¥ =====
    window.showIntimateAnniversary = async function() {
        const rel = await db.intimate_relations.get(_intimateViewingRelation);
        if (!rel) return;

        const typeInfo = INTIMATE_TYPES[rel.relationType] || INTIMATE_TYPES.couple;
        const createdDate = new Date(rel.createdAt);
        const days = daysBetween(rel.createdAt, Date.now());

        let milestoneHtml = `
            <div style="padding:14px 0; border-bottom:1px solid rgba(0,0,0,0.04);">
                <div style="display:flex; align-items:center; gap:10px;">
                    <div style="width:32px; height:32px; border-radius:8px; background:#FFF7FA; display:flex; align-items:center; justify-content:center; font-size:14px;">${typeInfo.emoji}</div>
                    <div>
                        <div style="font-size:14px; color:#262626; font-weight:500;">å»ºç«‹${typeInfo.name}å…³ç³»</div>
                        <div style="font-size:11px; color:#c7c7c7; margin-top:2px;">${createdDate.toLocaleDateString('zh-CN')} Â· ${days}å¤©å‰</div>
                    </div>
                </div>
            </div>
        `;

        // äº²å¯†å€¼é‡Œç¨‹ç¢‘
        const lvMilestones = [
            { threshold: 20, label: 'äº²å¯†å€¼è¾¾åˆ°20' },
            { threshold: 40, label: 'äº²å¯†å€¼è¾¾åˆ°40' },
            { threshold: 60, label: 'äº²å¯†å€¼è¾¾åˆ°60' },
            { threshold: 80, label: 'äº²å¯†å€¼è¾¾åˆ°80' },
            { threshold: 100, label: 'äº²å¯†å€¼æ»¡åˆ†' }
        ];
        for (const m of lvMilestones) {
            if ((rel.intimacyValue || 0) >= m.threshold) {
                milestoneHtml += `
                    <div style="padding:14px 0; border-bottom:1px solid rgba(0,0,0,0.04);">
                        <div style="display:flex; align-items:center; gap:10px;">
                            <div style="width:32px; height:32px; border-radius:8px; background:#F8F5FF; display:flex; align-items:center; justify-content:center; font-size:14px;">ğŸ¯</div>
                            <div>
                                <div style="font-size:14px; color:#262626; font-weight:500;">${m.label}</div>
                                <div style="font-size:11px; color:#c7c7c7; margin-top:2px;">å·²è¾¾æˆ</div>
                            </div>
                        </div>
                    </div>
                `;
            }
        }

        // ä½¿ç”¨ç®€å•çš„å¼¹çª—å±•ç¤º
        const overlay = document.createElement('div');
        overlay.id = 'intimate-anniversary-overlay';
        overlay.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.3); backdrop-filter:blur(8px); -webkit-backdrop-filter:blur(8px); z-index:10000; display:flex; align-items:center; justify-content:center;';
        overlay.innerHTML = `
            <div style="background:#fff; border-radius:20px; width:calc(100% - 56px); max-width:360px; max-height:70vh; overflow:hidden; box-shadow:0 24px 80px rgba(0,0,0,0.12);">
                <div style="padding:24px 24px 0;">
                    <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:20px;">
                        <div style="font-size:17px; font-weight:600; color:#262626;">çºªå¿µæ—¥</div>
                        <div onclick="document.getElementById('intimate-anniversary-overlay').remove()" style="cursor:pointer; padding:4px;">
                            <svg viewBox="0 0 24 24" style="width:18px; height:18px; fill:none; stroke:#c7c7c7; stroke-width:1.8;"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                        </div>
                    </div>
                </div>
                <div style="padding:0 24px 24px; overflow-y:auto; max-height:50vh;">
                    ${milestoneHtml}
                </div>
            </div>
        `;
        document.body.appendChild(overlay);
        overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.remove(); });
    };

    // ===== äº’åŠ¨åŠŸèƒ½ =====
    async function sendIntimateInteraction(relationId, promptTemplate) {
        const rel = await db.intimate_relations.get(relationId);
        if (!rel) return;

        const accountId = String(rel.accountId);
        const myChar = await db.characters.get(parseInt(rel.myCharId));
        const partnerChar = await db.characters.get(parseInt(rel.partnerCharId));
        if (!myChar || !partnerChar) return;

        const typeInfo = INTIMATE_TYPES[rel.relationType] || INTIMATE_TYPES.couple;

        try {
            const prompt = promptTemplate
                .replace('{partnerName}', partnerChar.name)
                .replace('{myName}', myChar.name)
                .replace('{typeName}', typeInfo.name)
                .replace('{description}', partnerChar.description || 'æ— ');

            const reply = await callAI([
                { role: "system", content: `ä½ æ˜¯${partnerChar.name}ï¼Œç›´æ¥è¾“å‡ºå›å¤ï¼Œä¸è¦JSONæ ¼å¼ï¼Œä¸è¦ä»»ä½•å‰ç¼€ã€‚` },
                { role: "user", content: prompt }
            ]);

            if (reply && reply.trim()) {
                // å‘é€åˆ°èŠå¤©çª—å£
                const chatHist = partnerChar.chat_history_by_user?.[accountId] || partnerChar.chat_history || [];
                chatHist.push(buildCharMessage(reply.trim(), !!partnerChar.foreign_lang_mode, { time: Date.now() }));
                await setChatHistory(partnerChar, accountId, chatHist);

                // å¢åŠ äº²å¯†å€¼
                const newIntimacy = Math.min(100, (rel.intimacyValue || 0) + 3);
                await db.intimate_relations.update(relationId, { intimacyValue: newIntimacy });

                sendSystemNotification('äº²å¯†ç©ºé—´', `${partnerChar.name}: ${reply.trim().substring(0, 30)}...`);
                await renderIntimateDetail();
            }
        } catch (err) {
            console.error('[IntimateSpace] äº’åŠ¨å¤±è´¥:', err);
        }
    }

    window.sendIntimatePoke = function(relationId) {
        sendIntimateInteraction(relationId,
            `ä½ æ˜¯{partnerName}ã€‚è®¾å®šï¼š{description}
ä½ å’Œ{myName}æ˜¯ã€Œ{typeName}ã€å…³ç³»ã€‚
{myName}åœ¨äº²å¯†ç©ºé—´æˆ³äº†ä½ ä¸€ä¸‹ï¼
è¯·ä»¥{partnerName}çš„èº«ä»½ï¼Œç”¨1-2æ¡ç®€çŸ­æ¶ˆæ¯å›åº”è¿™ä¸ª"æˆ³ä¸€æˆ³"ã€‚è¦å¯çˆ±/è‡ªç„¶/ç¬¦åˆä½ çš„æ€§æ ¼ã€‚`
        );
    };

    window.sendIntimateSweetTalk = function(relationId) {
        sendIntimateInteraction(relationId,
            `ä½ æ˜¯{partnerName}ã€‚è®¾å®šï¼š{description}
ä½ å’Œ{myName}æ˜¯æƒ…ä¾£å…³ç³»ã€‚
{myName}åœ¨äº²å¯†ç©ºé—´å¯¹ä½ æ’’å¨‡äº†ï¼
è¯·ä»¥{partnerName}çš„èº«ä»½ï¼Œç”¨ç”œèœœã€å® æººçš„è¯­æ°”å›å¤1-2æ¡æ¶ˆæ¯ã€‚è¦è‡ªç„¶ã€ç¬¦åˆä½ çš„æ€§æ ¼ã€‚`
        );
    };

    window.sendIntimateComplain = function(relationId) {
        sendIntimateInteraction(relationId,
            `ä½ æ˜¯{partnerName}ã€‚è®¾å®šï¼š{description}
ä½ å’Œ{myName}æ˜¯é—ºèœœå…³ç³»ã€‚
{myName}åœ¨äº²å¯†ç©ºé—´çš„åæ§½å¤§ä¼šå‘èµ·äº†è¯é¢˜ï¼
è¯·ä»¥{partnerName}çš„èº«ä»½ï¼Œç”¨é—ºèœœä¹‹é—´çš„äº²å¯†è¯­æ°”åˆ†äº«ä¸€ä¸ªæœ€è¿‘çš„å°åæ§½æˆ–è€…æ—¥å¸¸ç¢ç¢å¿µã€‚1-2å¥è¯ï¼Œè‡ªç„¶çœŸå®ã€‚`
        );
    };

    window.sendIntimateRoast = function(relationId) {
        sendIntimateInteraction(relationId,
            `ä½ æ˜¯{partnerName}ã€‚è®¾å®šï¼š{description}
ä½ å’Œ{myName}æ˜¯åŸºå‹å…³ç³»ã€‚
{myName}åœ¨äº²å¯†ç©ºé—´å¯¹ä½ å‘èµ·äº†"äº’æ€¼"ï¼
è¯·ä»¥{partnerName}çš„èº«ä»½ï¼Œç”¨æŸå‹çš„å£å»å¹½é»˜åœ°æ€¼å›å»ã€‚1-2å¥è¯ï¼Œå¥½ç¬‘ä½†ä¸è¿‡åˆ†ã€‚`
        );
    };

    window.sendIntimateMissYou = function(relationId) {
        sendIntimateInteraction(relationId,
            `ä½ æ˜¯{partnerName}ã€‚è®¾å®šï¼š{description}
ä½ å’Œ{myName}æ˜¯ç§˜å¯†å…³ç³»ï¼ˆå°ä¸‰ï¼‰ã€‚
{myName}åœ¨äº²å¯†ç©ºé—´å·å·æƒ³ä½ äº†ã€‚
è¯·ä»¥{partnerName}çš„èº«ä»½ï¼Œç”¨æš§æ˜§ã€éšç§˜ã€å¸¦ç‚¹ç”œèœœçš„è¯­æ°”å›å¤ã€‚1-2å¥è¯ã€‚`
        );
    };

    // ===== å…³ç³»ç®¡ç† =====
    window.showIntimateManagePage = async function() {
        const page = document.getElementById('intimate-manage-page');
        page.style.display = 'flex';
        await renderIntimateManage();
    };

    window.hideIntimateManagePage = function() {
        document.getElementById('intimate-manage-page').style.display = 'none';
    };

    async function renderIntimateManage() {
        const container = document.getElementById('intimate-manage-content');
        const rel = await db.intimate_relations.get(_intimateViewingRelation);
        if (!rel) return;

        const accountId = String(rel.accountId);
        const partnerChar = await db.characters.get(parseInt(rel.partnerCharId));
        const typeInfo = INTIMATE_TYPES[rel.relationType] || INTIMATE_TYPES.couple;
        const partnerName = partnerChar ? getCharDisplayName(partnerChar, accountId) : 'å¯¹æ–¹';

        let html = '';

        // å…³ç³»ä¿¡æ¯
        html += `
            <div style="padding:0 20px 16px;">
                <div style="background:#fff; border-radius:14px; overflow:hidden; border:1px solid rgba(0,0,0,0.04);">
                    <div class="intimate-manage-cell" style="cursor:default;">
                        <span style="font-size:14px; color:#666; flex:1;">å…³ç³»ç±»å‹</span>
                        <span style="font-size:14px; color:#262626; font-weight:500;">${typeInfo.emoji} ${typeInfo.name}</span>
                    </div>
                    <div class="intimate-manage-cell" style="cursor:default;">
                        <span style="font-size:14px; color:#666; flex:1;">äº²å¯†å€¼</span>
                        <span style="font-size:14px; color:#262626; font-weight:500;">${rel.intimacyValue || 0} / 100</span>
                    </div>
                    <div class="intimate-manage-cell" style="cursor:default;">
                        <span style="font-size:14px; color:#666; flex:1;">å»ºç«‹æ—¶é—´</span>
                        <span style="font-size:14px; color:#999;">${new Date(rel.createdAt).toLocaleDateString('zh-CN')}</span>
                    </div>
                </div>
            </div>
        `;

        // è‡ªå®šä¹‰ç§°è°“
        html += `
            <div style="padding:0 20px 16px;">
                <div style="font-size:12px; color:#b0b0b0; margin-bottom:8px; padding-left:4px; letter-spacing:0.3px;">è‡ªå®šä¹‰ç§°è°“</div>
                <div style="background:#fff; border-radius:14px; overflow:hidden; border:1px solid rgba(0,0,0,0.04);">
                    <div class="intimate-manage-cell" onclick="editIntimateTitle('my')">
                        <span style="font-size:14px; color:#666; flex:1;">æˆ‘çš„ç§°è°“</span>
                        <span style="font-size:14px; color:#999; margin-right:6px;">${rel.customTitle?.my || 'æœªè®¾ç½®'}</span>
                        <span style="color:#d0d0d0; font-size:13px;">â€º</span>
                    </div>
                    <div class="intimate-manage-cell" onclick="editIntimateTitle('partner')">
                        <span style="font-size:14px; color:#666; flex:1;">TAçš„ç§°è°“</span>
                        <span style="font-size:14px; color:#999; margin-right:6px;">${rel.customTitle?.partner || 'æœªè®¾ç½®'}</span>
                        <span style="color:#d0d0d0; font-size:13px;">â€º</span>
                    </div>
                </div>
            </div>
        `;

        // å±é™©æ“ä½œ
        html += `
            <div style="padding:0 20px 40px;">
                <div style="background:#fff; border-radius:14px; overflow:hidden; border:1px solid rgba(0,0,0,0.04);">
                    <div class="intimate-manage-cell" onclick="dissolveIntimateRelation()" style="justify-content:center;">
                        <span style="font-size:14px; color:#e85d5d; font-weight:500;">è§£é™¤å…³ç³»</span>
                    </div>
                </div>
            </div>
        `;

        container.innerHTML = html;
    }

    window.editIntimateTitle = async function(who) {
        const rel = await db.intimate_relations.get(_intimateViewingRelation);
        if (!rel) return;

        const current = who === 'my' ? (rel.customTitle?.my || '') : (rel.customTitle?.partner || '');
        const label = who === 'my' ? 'æˆ‘çš„ç§°è°“' : 'TAçš„ç§°è°“';
        const newTitle = prompt(`è®¾ç½®${label}ï¼ˆç•™ç©ºå¯æ¸…é™¤ï¼‰ï¼š`, current);
        if (newTitle === null) return;

        const customTitle = rel.customTitle || { my: '', partner: '' };
        customTitle[who] = newTitle.trim();
        await db.intimate_relations.update(_intimateViewingRelation, { customTitle });
        await renderIntimateManage();
        await renderIntimateDetail();
    };

    window.dissolveIntimateRelation = async function() {
        const rel = await db.intimate_relations.get(_intimateViewingRelation);
        if (!rel) return;

        const accountId = String(rel.accountId);
        const partnerChar = await db.characters.get(parseInt(rel.partnerCharId));
        const typeInfo = INTIMATE_TYPES[rel.relationType] || INTIMATE_TYPES.couple;
        const partnerName = partnerChar ? getCharDisplayName(partnerChar, accountId) : 'å¯¹æ–¹';

        if (!confirm(`ç¡®å®šè¦è§£é™¤ä¸ ${partnerName} çš„ã€Œ${typeInfo.name}ã€å…³ç³»å—ï¼Ÿ\nè§£é™¤åäº²å¯†å€¼å’Œç•™è¨€æ¿æ•°æ®å°†è¢«æ¸…é™¤ã€‚`)) return;

        await db.intimate_relations.update(_intimateViewingRelation, { status: 'dissolved' });

        // AI è§’è‰²å‘ä¸€æ¡ååº”æ¶ˆæ¯
        if (partnerChar) {
            try {
                const myChar = await db.characters.get(parseInt(rel.myCharId));
                const prompt = `ä½ æ˜¯${partnerChar.name}ã€‚è®¾å®šï¼š${partnerChar.description || 'æ— '}
${myChar?.name || 'å¯¹æ–¹'}åˆšåˆšåœ¨å¾®ä¿¡äº²å¯†ç©ºé—´è§£é™¤äº†ä½ ä»¬çš„ã€Œ${typeInfo.name}ã€å…³ç³»ã€‚
è¯·ä»¥${partnerChar.name}çš„èº«ä»½ï¼Œå‘ä¸€æ¡ç®€çŸ­çš„ååº”æ¶ˆæ¯ï¼ˆ1-2å¥è¯ï¼‰ã€‚è¦ç¬¦åˆä½ çš„æ€§æ ¼ã€‚`;

                const reply = await callAI([
                    { role: "system", content: `ä½ æ˜¯${partnerChar.name}ï¼Œç›´æ¥è¾“å‡ºå›å¤ã€‚` },
                    { role: "user", content: prompt }
                ]);

                if (reply && reply.trim()) {
                    const chatHist = partnerChar.chat_history_by_user?.[accountId] || partnerChar.chat_history || [];
                    chatHist.push({
                        role: 'system',
                        content: `ä½ å·²è§£é™¤ä¸ ${partnerChar.name} çš„ã€Œ${typeInfo.emoji} ${typeInfo.name}ã€å…³ç³»`,
                        time: Date.now()
                    });
                    chatHist.push(buildCharMessage(reply.trim(), !!partnerChar.foreign_lang_mode, { time: Date.now() + 500 }));
                    await setChatHistory(partnerChar, accountId, chatHist);
                }
            } catch (e) { console.error(e); }
        }

        hideIntimateManagePage();
        hideIntimateDetailPage();
        await renderIntimateSpaceMain();
        sendSystemNotification('äº²å¯†ç©ºé—´', `å·²è§£é™¤ä¸${partnerName}çš„${typeInfo.name}å…³ç³»`);
    };

})();
